// Generated by Construct 3, the game and app creator :: https://www.construct.net
'use strict';
"use strict";
(function (e, a) {
    "object" === typeof exports && "undefined" !== typeof module ? a(exports) : "function" === typeof define && define.amd ? define(["exports"], a) : (e = "undefined" !== typeof globalThis ? globalThis : e || self, a(e.glMatrix = {}))
})(this, function (e) {
    function a(g, m, v) {
        var z = m[0],
            C = m[1],
            D = m[2];
        m = m[3];
        var H = v[0],
            K = v[1],
            M = v[2];
        v = v[3];
        g[0] = z * H + D * K;
        g[1] = C * H + m * K;
        g[2] = z * M + D * v;
        g[3] = C * M + m * v;
        return g
    }

    function b(g, m, v) {
        g[0] = m[0] - v[0];
        g[1] = m[1] - v[1];
        g[2] = m[2] - v[2];
        g[3] = m[3] - v[3];
        return g
    }

    function d(g, m, v) {
        var z = m[0],
            C = m[1],
            D =
            m[2],
            H = m[3],
            K = m[4];
        m = m[5];
        var M = v[0],
            O = v[1],
            R = v[2],
            T = v[3],
            Y = v[4];
        v = v[5];
        g[0] = z * M + D * O;
        g[1] = C * M + H * O;
        g[2] = z * R + D * T;
        g[3] = C * R + H * T;
        g[4] = z * Y + D * v + K;
        g[5] = C * Y + H * v + m;
        return g
    }

    function c(g, m, v) {
        g[0] = m[0] - v[0];
        g[1] = m[1] - v[1];
        g[2] = m[2] - v[2];
        g[3] = m[3] - v[3];
        g[4] = m[4] - v[4];
        g[5] = m[5] - v[5];
        return g
    }

    function f() {
        var g = new sa(9);
        sa != Float32Array && (g[1] = 0, g[2] = 0, g[3] = 0, g[5] = 0, g[6] = 0, g[7] = 0);
        g[0] = 1;
        g[4] = 1;
        g[8] = 1;
        return g
    }

    function k(g, m, v) {
        var z = m[0],
            C = m[1],
            D = m[2],
            H = m[3],
            K = m[4],
            M = m[5],
            O = m[6],
            R = m[7];
        m = m[8];
        var T = v[0],
            Y = v[1],
            X = v[2],
            fa = v[3],
            ha = v[4],
            ba = v[5],
            qa = v[6],
            ka = v[7];
        v = v[8];
        g[0] = T * z + Y * H + X * O;
        g[1] = T * C + Y * K + X * R;
        g[2] = T * D + Y * M + X * m;
        g[3] = fa * z + ha * H + ba * O;
        g[4] = fa * C + ha * K + ba * R;
        g[5] = fa * D + ha * M + ba * m;
        g[6] = qa * z + ka * H + v * O;
        g[7] = qa * C + ka * K + v * R;
        g[8] = qa * D + ka * M + v * m;
        return g
    }

    function h(g, m, v) {
        g[0] = m[0] - v[0];
        g[1] = m[1] - v[1];
        g[2] = m[2] - v[2];
        g[3] = m[3] - v[3];
        g[4] = m[4] - v[4];
        g[5] = m[5] - v[5];
        g[6] = m[6] - v[6];
        g[7] = m[7] - v[7];
        g[8] = m[8] - v[8];
        return g
    }

    function l(g) {
        g[0] = 1;
        g[1] = 0;
        g[2] = 0;
        g[3] = 0;
        g[4] = 0;
        g[5] = 1;
        g[6] = 0;
        g[7] = 0;
        g[8] = 0;
        g[9] = 0;
        g[10] = 1;
        g[11] = 0;
        g[12] = 0;
        g[13] = 0;
        g[14] = 0;
        g[15] = 1;
        return g
    }

    function n(g, m, v) {
        var z = m[0],
            C = m[1],
            D = m[2],
            H = m[3],
            K = m[4],
            M = m[5],
            O = m[6],
            R = m[7],
            T = m[8],
            Y = m[9],
            X = m[10],
            fa = m[11],
            ha = m[12],
            ba = m[13],
            qa = m[14];
        m = m[15];
        var ka = v[0],
            ta = v[1],
            ua = v[2],
            ra = v[3];
        g[0] = ka * z + ta * K + ua * T + ra * ha;
        g[1] = ka * C + ta * M + ua * Y + ra * ba;
        g[2] = ka * D + ta * O + ua * X + ra * qa;
        g[3] = ka * H + ta * R + ua * fa + ra * m;
        ka = v[4];
        ta = v[5];
        ua = v[6];
        ra = v[7];
        g[4] = ka * z + ta * K + ua * T + ra * ha;
        g[5] = ka * C + ta * M + ua * Y + ra * ba;
        g[6] = ka * D + ta * O + ua * X + ra * qa;
        g[7] = ka * H + ta * R + ua * fa + ra * m;
        ka = v[8];
        ta = v[9];
        ua = v[10];
        ra = v[11];
        g[8] = ka * z + ta * K +
            ua * T + ra * ha;
        g[9] = ka * C + ta * M + ua * Y + ra * ba;
        g[10] = ka * D + ta * O + ua * X + ra * qa;
        g[11] = ka * H + ta * R + ua * fa + ra * m;
        ka = v[12];
        ta = v[13];
        ua = v[14];
        ra = v[15];
        g[12] = ka * z + ta * K + ua * T + ra * ha;
        g[13] = ka * C + ta * M + ua * Y + ra * ba;
        g[14] = ka * D + ta * O + ua * X + ra * qa;
        g[15] = ka * H + ta * R + ua * fa + ra * m;
        return g
    }

    function u(g, m, v) {
        var z = m[0],
            C = m[1],
            D = m[2],
            H = m[3],
            K = z + z,
            M = C + C,
            O = D + D;
        m = z * K;
        var R = z * M;
        z *= O;
        var T = C * M;
        C *= O;
        D *= O;
        K *= H;
        M *= H;
        H *= O;
        g[0] = 1 - (T + D);
        g[1] = R + H;
        g[2] = z - M;
        g[3] = 0;
        g[4] = R - H;
        g[5] = 1 - (m + D);
        g[6] = C + K;
        g[7] = 0;
        g[8] = z + M;
        g[9] = C - K;
        g[10] = 1 - (m + T);
        g[11] = 0;
        g[12] = v[0];
        g[13] =
            v[1];
        g[14] = v[2];
        g[15] = 1;
        return g
    }

    function w(g, m) {
        g[0] = m[12];
        g[1] = m[13];
        g[2] = m[14];
        return g
    }

    function q(g, m) {
        var v = m[4],
            z = m[5],
            C = m[6],
            D = m[8],
            H = m[9],
            K = m[10];
        g[0] = Math.hypot(m[0], m[1], m[2]);
        g[1] = Math.hypot(v, z, C);
        g[2] = Math.hypot(D, H, K);
        return g
    }

    function t(g, m) {
        var v = new sa(3);
        q(v, m);
        var z = 1 / v[0],
            C = 1 / v[1],
            D = 1 / v[2],
            H = m[0] * z;
        v = m[1] * C;
        var K = m[2] * D,
            M = m[4] * z,
            O = m[5] * C,
            R = m[6] * D;
        z *= m[8];
        C *= m[9];
        m = m[10] * D;
        D = H + O + m;
        0 < D ? (H = 2 * Math.sqrt(D + 1), g[3] = .25 * H, g[0] = (R - C) / H, g[1] = (z - K) / H, g[2] = (v - M) / H) : H > O && H > m ? (H = 2 * Math.sqrt(1 +
            H - O - m), g[3] = (R - C) / H, g[0] = .25 * H, g[1] = (v + M) / H, g[2] = (z + K) / H) : O > m ? (H = 2 * Math.sqrt(1 + O - H - m), g[3] = (z - K) / H, g[0] = (v + M) / H, g[1] = .25 * H, g[2] = (R + C) / H) : (H = 2 * Math.sqrt(1 + m - H - O), g[3] = (v - M) / H, g[0] = (z + K) / H, g[1] = (R + C) / H, g[2] = .25 * H);
        return g
    }

    function p(g, m, v, z, C) {
        m = 1 / Math.tan(m / 2);
        g[0] = m / v;
        g[1] = 0;
        g[2] = 0;
        g[3] = 0;
        g[4] = 0;
        g[5] = m;
        g[6] = 0;
        g[7] = 0;
        g[8] = 0;
        g[9] = 0;
        g[11] = -1;
        g[12] = 0;
        g[13] = 0;
        g[15] = 0;
        null != C && Infinity !== C ? (v = 1 / (z - C), g[10] = (C + z) * v, g[14] = 2 * C * z * v) : (g[10] = -1, g[14] = -2 * z);
        return g
    }

    function r(g, m, v, z, C, D, H) {
        var K = 1 / (m - v),
            M =
            1 / (z - C),
            O = 1 / (D - H);
        g[0] = -2 * K;
        g[1] = 0;
        g[2] = 0;
        g[3] = 0;
        g[4] = 0;
        g[5] = -2 * M;
        g[6] = 0;
        g[7] = 0;
        g[8] = 0;
        g[9] = 0;
        g[10] = 2 * O;
        g[11] = 0;
        g[12] = (m + v) * K;
        g[13] = (C + z) * M;
        g[14] = (H + D) * O;
        g[15] = 1;
        return g
    }

    function x(g, m, v) {
        g[0] = m[0] - v[0];
        g[1] = m[1] - v[1];
        g[2] = m[2] - v[2];
        g[3] = m[3] - v[3];
        g[4] = m[4] - v[4];
        g[5] = m[5] - v[5];
        g[6] = m[6] - v[6];
        g[7] = m[7] - v[7];
        g[8] = m[8] - v[8];
        g[9] = m[9] - v[9];
        g[10] = m[10] - v[10];
        g[11] = m[11] - v[11];
        g[12] = m[12] - v[12];
        g[13] = m[13] - v[13];
        g[14] = m[14] - v[14];
        g[15] = m[15] - v[15];
        return g
    }

    function y() {
        var g = new sa(3);
        sa != Float32Array &&
            (g[0] = 0, g[1] = 0, g[2] = 0);
        return g
    }

    function E(g) {
        return Math.hypot(g[0], g[1], g[2])
    }

    function G(g, m, v) {
        var z = new sa(3);
        z[0] = g;
        z[1] = m;
        z[2] = v;
        return z
    }

    function A(g, m, v) {
        g[0] = m[0] - v[0];
        g[1] = m[1] - v[1];
        g[2] = m[2] - v[2];
        return g
    }

    function F(g, m, v) {
        g[0] = m[0] * v[0];
        g[1] = m[1] * v[1];
        g[2] = m[2] * v[2];
        return g
    }

    function J(g, m, v) {
        g[0] = m[0] / v[0];
        g[1] = m[1] / v[1];
        g[2] = m[2] / v[2];
        return g
    }

    function B(g, m) {
        return Math.hypot(m[0] - g[0], m[1] - g[1], m[2] - g[2])
    }

    function I(g, m) {
        var v = m[0] - g[0],
            z = m[1] - g[1];
        g = m[2] - g[2];
        return v * v + z * z + g * g
    }

    function L(g) {
        var m =
            g[0],
            v = g[1];
        g = g[2];
        return m * m + v * v + g * g
    }

    function P(g, m) {
        var v = m[0],
            z = m[1],
            C = m[2];
        v = v * v + z * z + C * C;
        0 < v && (v = 1 / Math.sqrt(v));
        g[0] = m[0] * v;
        g[1] = m[1] * v;
        g[2] = m[2] * v;
        return g
    }

    function S(g, m) {
        return g[0] * m[0] + g[1] * m[1] + g[2] * m[2]
    }

    function U(g, m, v) {
        var z = m[0],
            C = m[1];
        m = m[2];
        var D = v[0],
            H = v[1];
        v = v[2];
        g[0] = C * v - m * H;
        g[1] = m * D - z * v;
        g[2] = z * H - C * D;
        return g
    }

    function V() {
        var g = new sa(4);
        sa != Float32Array && (g[0] = 0, g[1] = 0, g[2] = 0, g[3] = 0);
        return g
    }

    function Z(g) {
        var m = new sa(4);
        m[0] = g[0];
        m[1] = g[1];
        m[2] = g[2];
        m[3] = g[3];
        return m
    }

    function ma(g,
        m, v, z) {
        var C = new sa(4);
        C[0] = g;
        C[1] = m;
        C[2] = v;
        C[3] = z;
        return C
    }

    function va(g, m) {
        g[0] = m[0];
        g[1] = m[1];
        g[2] = m[2];
        g[3] = m[3];
        return g
    }

    function Na(g, m, v, z, C) {
        g[0] = m;
        g[1] = v;
        g[2] = z;
        g[3] = C;
        return g
    }

    function Ea(g, m, v) {
        g[0] = m[0] + v[0];
        g[1] = m[1] + v[1];
        g[2] = m[2] + v[2];
        g[3] = m[3] + v[3];
        return g
    }

    function Ia(g, m, v) {
        g[0] = m[0] - v[0];
        g[1] = m[1] - v[1];
        g[2] = m[2] - v[2];
        g[3] = m[3] - v[3];
        return g
    }

    function Ma(g, m, v) {
        g[0] = m[0] * v[0];
        g[1] = m[1] * v[1];
        g[2] = m[2] * v[2];
        g[3] = m[3] * v[3];
        return g
    }

    function Fa(g, m, v) {
        g[0] = m[0] / v[0];
        g[1] = m[1] / v[1];
        g[2] =
            m[2] / v[2];
        g[3] = m[3] / v[3];
        return g
    }

    function ya(g, m, v) {
        g[0] = m[0] * v;
        g[1] = m[1] * v;
        g[2] = m[2] * v;
        g[3] = m[3] * v;
        return g
    }

    function na(g, m) {
        return Math.hypot(m[0] - g[0], m[1] - g[1], m[2] - g[2], m[3] - g[3])
    }

    function Va(g, m) {
        var v = m[0] - g[0],
            z = m[1] - g[1],
            C = m[2] - g[2];
        g = m[3] - g[3];
        return v * v + z * z + C * C + g * g
    }

    function xa(g) {
        return Math.hypot(g[0], g[1], g[2], g[3])
    }

    function Ga(g) {
        var m = g[0],
            v = g[1],
            z = g[2];
        g = g[3];
        return m * m + v * v + z * z + g * g
    }

    function bb(g, m) {
        var v = m[0],
            z = m[1],
            C = m[2];
        m = m[3];
        var D = v * v + z * z + C * C + m * m;
        0 < D && (D = 1 / Math.sqrt(D));
        g[0] =
            v * D;
        g[1] = z * D;
        g[2] = C * D;
        g[3] = m * D;
        return g
    }

    function Xa(g, m) {
        return g[0] * m[0] + g[1] * m[1] + g[2] * m[2] + g[3] * m[3]
    }

    function ob(g, m, v, z) {
        var C = m[0],
            D = m[1],
            H = m[2];
        m = m[3];
        g[0] = C + z * (v[0] - C);
        g[1] = D + z * (v[1] - D);
        g[2] = H + z * (v[2] - H);
        g[3] = m + z * (v[3] - m);
        return g
    }

    function pb(g, m) {
        return g[0] === m[0] && g[1] === m[1] && g[2] === m[2] && g[3] === m[3]
    }

    function cb() {
        var g = new sa(4);
        sa != Float32Array && (g[0] = 0, g[1] = 0, g[2] = 0);
        g[3] = 1;
        return g
    }

    function qb(g, m, v) {
        v *= .5;
        var z = Math.sin(v);
        g[0] = z * m[0];
        g[1] = z * m[1];
        g[2] = z * m[2];
        g[3] = Math.cos(v);
        return g
    }

    function rb(g, m, v) {
        var z = m[0],
            C = m[1],
            D = m[2];
        m = m[3];
        var H = v[0],
            K = v[1],
            M = v[2];
        v = v[3];
        g[0] = z * v + m * H + C * M - D * K;
        g[1] = C * v + m * K + D * H - z * M;
        g[2] = D * v + m * M + z * K - C * H;
        g[3] = m * v - z * H - C * K - D * M;
        return g
    }

    function sb(g, m, v) {
        v *= .5;
        var z = m[0],
            C = m[1],
            D = m[2];
        m = m[3];
        var H = Math.sin(v);
        v = Math.cos(v);
        g[0] = z * v + m * H;
        g[1] = C * v + D * H;
        g[2] = D * v - C * H;
        g[3] = m * v - z * H;
        return g
    }

    function tb(g, m, v) {
        v *= .5;
        var z = m[0],
            C = m[1],
            D = m[2];
        m = m[3];
        var H = Math.sin(v);
        v = Math.cos(v);
        g[0] = z * v - D * H;
        g[1] = C * v + m * H;
        g[2] = D * v + z * H;
        g[3] = m * v - C * H;
        return g
    }

    function ub(g, m, v) {
        v *= .5;
        var z = m[0],
            C = m[1],
            D = m[2];
        m = m[3];
        var H = Math.sin(v);
        v = Math.cos(v);
        g[0] = z * v + C * H;
        g[1] = C * v - z * H;
        g[2] = D * v + m * H;
        g[3] = m * v - D * H;
        return g
    }

    function vb(g, m) {
        var v = m[0],
            z = m[1],
            C = m[2],
            D = Math.sqrt(v * v + z * z + C * C);
        m = Math.exp(m[3]);
        var H = 0 < D ? m * Math.sin(D) / D : 0;
        g[0] = v * H;
        g[1] = z * H;
        g[2] = C * H;
        g[3] = m * Math.cos(D);
        return g
    }

    function wb(g, m) {
        var v = m[0],
            z = m[1],
            C = m[2];
        m = m[3];
        var D = Math.sqrt(v * v + z * z + C * C);
        D = 0 < D ? Math.atan2(D, m) / D : 0;
        g[0] = v * D;
        g[1] = z * D;
        g[2] = C * D;
        g[3] = .5 * Math.log(v * v + z * z + C * C + m * m);
        return g
    }

    function db(g, m, v, z) {
        var C = m[0],
            D = m[1],
            H = m[2];
        m = m[3];
        var K = v[0],
            M = v[1],
            O = v[2];
        v = v[3];
        var R = C * K + D * M + H * O + m * v;
        0 > R && (R = -R, K = -K, M = -M, O = -O, v = -v);
        if (1E-6 < 1 - R) {
            var T = Math.acos(R);
            var Y = Math.sin(T);
            R = Math.sin((1 - z) * T) / Y;
            z = Math.sin(z * T) / Y
        } else R = 1 - z;
        g[0] = R * C + z * K;
        g[1] = R * D + z * M;
        g[2] = R * H + z * O;
        g[3] = R * m + z * v;
        return g
    }

    function xb(g, m) {
        var v = m[0] + m[4] + m[8];
        if (0 < v) v = Math.sqrt(v + 1), g[3] = .5 * v, v = .5 / v, g[0] = (m[5] - m[7]) * v, g[1] = (m[6] - m[2]) * v, g[2] = (m[1] - m[3]) * v;
        else {
            var z = 0;
            m[4] > m[0] && (z = 1);
            m[8] > m[3 * z + z] && (z = 2);
            var C = (z + 1) % 3,
                D = (z + 2) % 3;
            v = Math.sqrt(m[3 * z + z] - m[3 * C + C] -
                m[3 * D + D] + 1);
            g[z] = .5 * v;
            v = .5 / v;
            g[3] = (m[3 * C + D] - m[3 * D + C]) * v;
            g[C] = (m[3 * C + z] + m[3 * z + C]) * v;
            g[D] = (m[3 * D + z] + m[3 * z + D]) * v
        }
        return g
    }

    function yb(g, m, v) {
        var z = .5 * v[0],
            C = .5 * v[1];
        v = .5 * v[2];
        var D = m[0],
            H = m[1],
            K = m[2];
        m = m[3];
        g[0] = D;
        g[1] = H;
        g[2] = K;
        g[3] = m;
        g[4] = z * m + C * K - v * H;
        g[5] = C * m + v * D - z * K;
        g[6] = v * m + z * H - C * D;
        g[7] = -z * D - C * H - v * K;
        return g
    }

    function zb(g, m) {
        g[0] = m[0];
        g[1] = m[1];
        g[2] = m[2];
        g[3] = m[3];
        g[4] = m[4];
        g[5] = m[5];
        g[6] = m[6];
        g[7] = m[7];
        return g
    }

    function eb(g, m, v) {
        var z = m[0],
            C = m[1],
            D = m[2],
            H = m[3],
            K = v[4],
            M = v[5],
            O = v[6],
            R = v[7],
            T = m[4],
            Y = m[5],
            X = m[6];
        m = m[7];
        var fa = v[0],
            ha = v[1],
            ba = v[2];
        v = v[3];
        g[0] = z * v + H * fa + C * ba - D * ha;
        g[1] = C * v + H * ha + D * fa - z * ba;
        g[2] = D * v + H * ba + z * ha - C * fa;
        g[3] = H * v - z * fa - C * ha - D * ba;
        g[4] = z * R + H * K + C * O - D * M + T * v + m * fa + Y * ba - X * ha;
        g[5] = C * R + H * M + D * K - z * O + Y * v + m * ha + X * fa - T * ba;
        g[6] = D * R + H * O + z * M - C * K + X * v + m * ba + T * ha - Y * fa;
        g[7] = H * R - z * K - C * M - D * O + m * v - T * fa - Y * ha - X * ba;
        return g
    }

    function Wa() {
        var g = new sa(2);
        sa != Float32Array && (g[0] = 0, g[1] = 0);
        return g
    }

    function fb(g, m, v) {
        g[0] = m[0] - v[0];
        g[1] = m[1] - v[1];
        return g
    }

    function gb(g, m, v) {
        g[0] = m[0] * v[0];
        g[1] = m[1] * v[1];
        return g
    }

    function Ya(g, m, v) {
        g[0] = m[0] / v[0];
        g[1] = m[1] / v[1];
        return g
    }

    function hb(g, m) {
        return Math.hypot(m[0] - g[0], m[1] - g[1])
    }

    function Ta(g, m) {
        var v = m[0] - g[0];
        g = m[1] - g[1];
        return v * v + g * g
    }

    function ib(g) {
        return Math.hypot(g[0], g[1])
    }

    function jb(g) {
        var m = g[0];
        g = g[1];
        return m * m + g * g
    }
    var sa = "undefined" !== typeof Float32Array ? Float32Array : Array,
        Sa = Math.random,
        Ab = Math.PI / 180;
    Math.hypot || (Math.hypot = function () {
        for (var g = 0, m = arguments.length; m--;) g += arguments[m] * arguments[m];
        return Math.sqrt(g)
    });
    var Db = Object.freeze({
            __proto__: null,
            EPSILON: 1E-6,
            get ARRAY_TYPE() {
                return sa
            },
            RANDOM: Sa,
            ANGLE_ORDER: "zyx",
            setMatrixArrayType: function (g) {
                sa = g
            },
            toRadian: function (g) {
                return g * Ab
            },
            equals: function (g, m) {
                return Math.abs(g - m) <= 1E-6 * Math.max(1, Math.abs(g), Math.abs(m))
            }
        }),
        Eb = Object.freeze({
            __proto__: null,
            create: function () {
                var g = new sa(4);
                sa != Float32Array && (g[1] = 0, g[2] = 0);
                g[0] = 1;
                g[3] = 1;
                return g
            },
            clone: function (g) {
                var m = new sa(4);
                m[0] = g[0];
                m[1] = g[1];
                m[2] = g[2];
                m[3] = g[3];
                return m
            },
            copy: function (g, m) {
                g[0] = m[0];
                g[1] = m[1];
                g[2] = m[2];
                g[3] = m[3];
                return g
            },
            identity: function (g) {
                g[0] = 1;
                g[1] = 0;
                g[2] = 0;
                g[3] = 1;
                return g
            },
            fromValues: function (g, m, v, z) {
                var C = new sa(4);
                C[0] = g;
                C[1] = m;
                C[2] = v;
                C[3] = z;
                return C
            },
            set: function (g, m, v, z, C) {
                g[0] = m;
                g[1] = v;
                g[2] = z;
                g[3] = C;
                return g
            },
            transpose: function (g, m) {
                if (g === m) {
                    var v = m[1];
                    g[1] = m[2];
                    g[2] = v
                } else g[0] = m[0], g[1] = m[2], g[2] = m[1], g[3] = m[3];
                return g
            },
            invert: function (g, m) {
                var v = m[0],
                    z = m[1],
                    C = m[2];
                m = m[3];
                var D = v * m - C * z;
                if (!D) return null;
                D = 1 / D;
                g[0] = m * D;
                g[1] = -z * D;
                g[2] = -C * D;
                g[3] = v * D;
                return g
            },
            adjoint: function (g, m) {
                var v = m[0];
                g[0] = m[3];
                g[1] = -m[1];
                g[2] = -m[2];
                g[3] = v;
                return g
            },
            determinant: function (g) {
                return g[0] * g[3] - g[2] * g[1]
            },
            multiply: a,
            rotate: function (g, m, v) {
                var z = m[0],
                    C = m[1],
                    D = m[2];
                m = m[3];
                var H = Math.sin(v);
                v = Math.cos(v);
                g[0] = z * v + D * H;
                g[1] = C * v + m * H;
                g[2] = z * -H + D * v;
                g[3] = C * -H + m * v;
                return g
            },
            scale: function (g, m, v) {
                var z = m[1],
                    C = m[2],
                    D = m[3],
                    H = v[0];
                v = v[1];
                g[0] = m[0] * H;
                g[1] = z * H;
                g[2] = C * v;
                g[3] = D * v;
                return g
            },
            fromRotation: function (g, m) {
                var v = Math.sin(m);
                m = Math.cos(m);
                g[0] = m;
                g[1] = v;
                g[2] = -v;
                g[3] = m;
                return g
            },
            fromScaling: function (g, m) {
                g[0] = m[0];
                g[1] =
                    0;
                g[2] = 0;
                g[3] = m[1];
                return g
            },
            str: function (g) {
                return "mat2(" + g[0] + ", " + g[1] + ", " + g[2] + ", " + g[3] + ")"
            },
            frob: function (g) {
                return Math.hypot(g[0], g[1], g[2], g[3])
            },
            LDU: function (g, m, v, z) {
                g[2] = z[2] / z[0];
                v[0] = z[0];
                v[1] = z[1];
                v[3] = z[3] - g[2] * v[1];
                return [g, m, v]
            },
            add: function (g, m, v) {
                g[0] = m[0] + v[0];
                g[1] = m[1] + v[1];
                g[2] = m[2] + v[2];
                g[3] = m[3] + v[3];
                return g
            },
            subtract: b,
            exactEquals: function (g, m) {
                return g[0] === m[0] && g[1] === m[1] && g[2] === m[2] && g[3] === m[3]
            },
            equals: function (g, m) {
                var v = g[0],
                    z = g[1],
                    C = g[2];
                g = g[3];
                var D = m[0],
                    H = m[1],
                    K = m[2];
                m = m[3];
                return Math.abs(v - D) <= 1E-6 * Math.max(1, Math.abs(v), Math.abs(D)) && Math.abs(z - H) <= 1E-6 * Math.max(1, Math.abs(z), Math.abs(H)) && Math.abs(C - K) <= 1E-6 * Math.max(1, Math.abs(C), Math.abs(K)) && Math.abs(g - m) <= 1E-6 * Math.max(1, Math.abs(g), Math.abs(m))
            },
            multiplyScalar: function (g, m, v) {
                g[0] = m[0] * v;
                g[1] = m[1] * v;
                g[2] = m[2] * v;
                g[3] = m[3] * v;
                return g
            },
            multiplyScalarAndAdd: function (g, m, v, z) {
                g[0] = m[0] + v[0] * z;
                g[1] = m[1] + v[1] * z;
                g[2] = m[2] + v[2] * z;
                g[3] = m[3] + v[3] * z;
                return g
            },
            mul: a,
            sub: b
        }),
        Fb = Object.freeze({
            __proto__: null,
            create: function () {
                var g = new sa(6);
                sa != Float32Array && (g[1] = 0, g[2] = 0, g[4] = 0, g[5] = 0);
                g[0] = 1;
                g[3] = 1;
                return g
            },
            clone: function (g) {
                var m = new sa(6);
                m[0] = g[0];
                m[1] = g[1];
                m[2] = g[2];
                m[3] = g[3];
                m[4] = g[4];
                m[5] = g[5];
                return m
            },
            copy: function (g, m) {
                g[0] = m[0];
                g[1] = m[1];
                g[2] = m[2];
                g[3] = m[3];
                g[4] = m[4];
                g[5] = m[5];
                return g
            },
            identity: function (g) {
                g[0] = 1;
                g[1] = 0;
                g[2] = 0;
                g[3] = 1;
                g[4] = 0;
                g[5] = 0;
                return g
            },
            fromValues: function (g, m, v, z, C, D) {
                var H = new sa(6);
                H[0] = g;
                H[1] = m;
                H[2] = v;
                H[3] = z;
                H[4] = C;
                H[5] = D;
                return H
            },
            set: function (g, m, v, z, C, D, H) {
                g[0] =
                    m;
                g[1] = v;
                g[2] = z;
                g[3] = C;
                g[4] = D;
                g[5] = H;
                return g
            },
            invert: function (g, m) {
                var v = m[0],
                    z = m[1],
                    C = m[2],
                    D = m[3],
                    H = m[4];
                m = m[5];
                var K = v * D - z * C;
                if (!K) return null;
                K = 1 / K;
                g[0] = D * K;
                g[1] = -z * K;
                g[2] = -C * K;
                g[3] = v * K;
                g[4] = (C * m - D * H) * K;
                g[5] = (z * H - v * m) * K;
                return g
            },
            determinant: function (g) {
                return g[0] * g[3] - g[1] * g[2]
            },
            multiply: d,
            rotate: function (g, m, v) {
                var z = m[0],
                    C = m[1],
                    D = m[2],
                    H = m[3],
                    K = m[4];
                m = m[5];
                var M = Math.sin(v);
                v = Math.cos(v);
                g[0] = z * v + D * M;
                g[1] = C * v + H * M;
                g[2] = z * -M + D * v;
                g[3] = C * -M + H * v;
                g[4] = K;
                g[5] = m;
                return g
            },
            scale: function (g, m, v) {
                var z =
                    m[1],
                    C = m[2],
                    D = m[3],
                    H = m[4],
                    K = m[5],
                    M = v[0];
                v = v[1];
                g[0] = m[0] * M;
                g[1] = z * M;
                g[2] = C * v;
                g[3] = D * v;
                g[4] = H;
                g[5] = K;
                return g
            },
            translate: function (g, m, v) {
                var z = m[0],
                    C = m[1],
                    D = m[2],
                    H = m[3],
                    K = m[4];
                m = m[5];
                var M = v[0];
                v = v[1];
                g[0] = z;
                g[1] = C;
                g[2] = D;
                g[3] = H;
                g[4] = z * M + D * v + K;
                g[5] = C * M + H * v + m;
                return g
            },
            fromRotation: function (g, m) {
                var v = Math.sin(m);
                m = Math.cos(m);
                g[0] = m;
                g[1] = v;
                g[2] = -v;
                g[3] = m;
                g[4] = 0;
                g[5] = 0;
                return g
            },
            fromScaling: function (g, m) {
                g[0] = m[0];
                g[1] = 0;
                g[2] = 0;
                g[3] = m[1];
                g[4] = 0;
                g[5] = 0;
                return g
            },
            fromTranslation: function (g, m) {
                g[0] = 1;
                g[1] = 0;
                g[2] = 0;
                g[3] = 1;
                g[4] = m[0];
                g[5] = m[1];
                return g
            },
            str: function (g) {
                return "mat2d(" + g[0] + ", " + g[1] + ", " + g[2] + ", " + g[3] + ", " + g[4] + ", " + g[5] + ")"
            },
            frob: function (g) {
                return Math.hypot(g[0], g[1], g[2], g[3], g[4], g[5], 1)
            },
            add: function (g, m, v) {
                g[0] = m[0] + v[0];
                g[1] = m[1] + v[1];
                g[2] = m[2] + v[2];
                g[3] = m[3] + v[3];
                g[4] = m[4] + v[4];
                g[5] = m[5] + v[5];
                return g
            },
            subtract: c,
            multiplyScalar: function (g, m, v) {
                g[0] = m[0] * v;
                g[1] = m[1] * v;
                g[2] = m[2] * v;
                g[3] = m[3] * v;
                g[4] = m[4] * v;
                g[5] = m[5] * v;
                return g
            },
            multiplyScalarAndAdd: function (g, m, v, z) {
                g[0] = m[0] +
                    v[0] * z;
                g[1] = m[1] + v[1] * z;
                g[2] = m[2] + v[2] * z;
                g[3] = m[3] + v[3] * z;
                g[4] = m[4] + v[4] * z;
                g[5] = m[5] + v[5] * z;
                return g
            },
            exactEquals: function (g, m) {
                return g[0] === m[0] && g[1] === m[1] && g[2] === m[2] && g[3] === m[3] && g[4] === m[4] && g[5] === m[5]
            },
            equals: function (g, m) {
                var v = g[0],
                    z = g[1],
                    C = g[2],
                    D = g[3],
                    H = g[4];
                g = g[5];
                var K = m[0],
                    M = m[1],
                    O = m[2],
                    R = m[3],
                    T = m[4];
                m = m[5];
                return Math.abs(v - K) <= 1E-6 * Math.max(1, Math.abs(v), Math.abs(K)) && Math.abs(z - M) <= 1E-6 * Math.max(1, Math.abs(z), Math.abs(M)) && Math.abs(C - O) <= 1E-6 * Math.max(1, Math.abs(C), Math.abs(O)) &&
                    Math.abs(D - R) <= 1E-6 * Math.max(1, Math.abs(D), Math.abs(R)) && Math.abs(H - T) <= 1E-6 * Math.max(1, Math.abs(H), Math.abs(T)) && Math.abs(g - m) <= 1E-6 * Math.max(1, Math.abs(g), Math.abs(m))
            },
            mul: d,
            sub: c
        }),
        Gb = Object.freeze({
            __proto__: null,
            create: f,
            fromMat4: function (g, m) {
                g[0] = m[0];
                g[1] = m[1];
                g[2] = m[2];
                g[3] = m[4];
                g[4] = m[5];
                g[5] = m[6];
                g[6] = m[8];
                g[7] = m[9];
                g[8] = m[10];
                return g
            },
            clone: function (g) {
                var m = new sa(9);
                m[0] = g[0];
                m[1] = g[1];
                m[2] = g[2];
                m[3] = g[3];
                m[4] = g[4];
                m[5] = g[5];
                m[6] = g[6];
                m[7] = g[7];
                m[8] = g[8];
                return m
            },
            copy: function (g,
                m) {
                g[0] = m[0];
                g[1] = m[1];
                g[2] = m[2];
                g[3] = m[3];
                g[4] = m[4];
                g[5] = m[5];
                g[6] = m[6];
                g[7] = m[7];
                g[8] = m[8];
                return g
            },
            fromValues: function (g, m, v, z, C, D, H, K, M) {
                var O = new sa(9);
                O[0] = g;
                O[1] = m;
                O[2] = v;
                O[3] = z;
                O[4] = C;
                O[5] = D;
                O[6] = H;
                O[7] = K;
                O[8] = M;
                return O
            },
            set: function (g, m, v, z, C, D, H, K, M, O) {
                g[0] = m;
                g[1] = v;
                g[2] = z;
                g[3] = C;
                g[4] = D;
                g[5] = H;
                g[6] = K;
                g[7] = M;
                g[8] = O;
                return g
            },
            identity: function (g) {
                g[0] = 1;
                g[1] = 0;
                g[2] = 0;
                g[3] = 0;
                g[4] = 1;
                g[5] = 0;
                g[6] = 0;
                g[7] = 0;
                g[8] = 1;
                return g
            },
            transpose: function (g, m) {
                if (g === m) {
                    var v = m[1],
                        z = m[2],
                        C = m[5];
                    g[1] = m[3];
                    g[2] = m[6];
                    g[3] = v;
                    g[5] = m[7];
                    g[6] = z;
                    g[7] = C
                } else g[0] = m[0], g[1] = m[3], g[2] = m[6], g[3] = m[1], g[4] = m[4], g[5] = m[7], g[6] = m[2], g[7] = m[5], g[8] = m[8];
                return g
            },
            invert: function (g, m) {
                var v = m[0],
                    z = m[1],
                    C = m[2],
                    D = m[3],
                    H = m[4],
                    K = m[5],
                    M = m[6],
                    O = m[7];
                m = m[8];
                var R = m * H - K * O,
                    T = -m * D + K * M,
                    Y = O * D - H * M,
                    X = v * R + z * T + C * Y;
                if (!X) return null;
                X = 1 / X;
                g[0] = R * X;
                g[1] = (-m * z + C * O) * X;
                g[2] = (K * z - C * H) * X;
                g[3] = T * X;
                g[4] = (m * v - C * M) * X;
                g[5] = (-K * v + C * D) * X;
                g[6] = Y * X;
                g[7] = (-O * v + z * M) * X;
                g[8] = (H * v - z * D) * X;
                return g
            },
            adjoint: function (g, m) {
                var v = m[0],
                    z = m[1],
                    C = m[2],
                    D = m[3],
                    H = m[4],
                    K = m[5],
                    M = m[6],
                    O = m[7];
                m = m[8];
                g[0] = H * m - K * O;
                g[1] = C * O - z * m;
                g[2] = z * K - C * H;
                g[3] = K * M - D * m;
                g[4] = v * m - C * M;
                g[5] = C * D - v * K;
                g[6] = D * O - H * M;
                g[7] = z * M - v * O;
                g[8] = v * H - z * D;
                return g
            },
            determinant: function (g) {
                var m = g[3],
                    v = g[4],
                    z = g[5],
                    C = g[6],
                    D = g[7],
                    H = g[8];
                return g[0] * (H * v - z * D) + g[1] * (-H * m + z * C) + g[2] * (D * m - v * C)
            },
            multiply: k,
            translate: function (g, m, v) {
                var z = m[0],
                    C = m[1],
                    D = m[2],
                    H = m[3],
                    K = m[4],
                    M = m[5],
                    O = m[6],
                    R = m[7];
                m = m[8];
                var T = v[0];
                v = v[1];
                g[0] = z;
                g[1] = C;
                g[2] = D;
                g[3] = H;
                g[4] = K;
                g[5] = M;
                g[6] = T * z + v * H + O;
                g[7] = T * C + v * K + R;
                g[8] = T * D + v * M + m;
                return g
            },
            rotate: function (g, m, v) {
                var z = m[0],
                    C = m[1],
                    D = m[2],
                    H = m[3],
                    K = m[4],
                    M = m[5],
                    O = m[6],
                    R = m[7];
                m = m[8];
                var T = Math.sin(v);
                v = Math.cos(v);
                g[0] = v * z + T * H;
                g[1] = v * C + T * K;
                g[2] = v * D + T * M;
                g[3] = v * H - T * z;
                g[4] = v * K - T * C;
                g[5] = v * M - T * D;
                g[6] = O;
                g[7] = R;
                g[8] = m;
                return g
            },
            scale: function (g, m, v) {
                var z = v[0];
                v = v[1];
                g[0] = z * m[0];
                g[1] = z * m[1];
                g[2] = z * m[2];
                g[3] = v * m[3];
                g[4] = v * m[4];
                g[5] = v * m[5];
                g[6] = m[6];
                g[7] = m[7];
                g[8] = m[8];
                return g
            },
            fromTranslation: function (g, m) {
                g[0] = 1;
                g[1] = 0;
                g[2] = 0;
                g[3] = 0;
                g[4] = 1;
                g[5] = 0;
                g[6] = m[0];
                g[7] = m[1];
                g[8] = 1;
                return g
            },
            fromRotation: function (g,
                m) {
                var v = Math.sin(m);
                m = Math.cos(m);
                g[0] = m;
                g[1] = v;
                g[2] = 0;
                g[3] = -v;
                g[4] = m;
                g[5] = 0;
                g[6] = 0;
                g[7] = 0;
                g[8] = 1;
                return g
            },
            fromScaling: function (g, m) {
                g[0] = m[0];
                g[1] = 0;
                g[2] = 0;
                g[3] = 0;
                g[4] = m[1];
                g[5] = 0;
                g[6] = 0;
                g[7] = 0;
                g[8] = 1;
                return g
            },
            fromMat2d: function (g, m) {
                g[0] = m[0];
                g[1] = m[1];
                g[2] = 0;
                g[3] = m[2];
                g[4] = m[3];
                g[5] = 0;
                g[6] = m[4];
                g[7] = m[5];
                g[8] = 1;
                return g
            },
            fromQuat: function (g, m) {
                var v = m[0],
                    z = m[1],
                    C = m[2];
                m = m[3];
                var D = v + v,
                    H = z + z,
                    K = C + C;
                v *= D;
                var M = z * D;
                z *= H;
                var O = C * D,
                    R = C * H;
                C *= K;
                D *= m;
                H *= m;
                m *= K;
                g[0] = 1 - z - C;
                g[3] = M - m;
                g[6] = O + H;
                g[1] = M + m;
                g[4] =
                    1 - v - C;
                g[7] = R - D;
                g[2] = O - H;
                g[5] = R + D;
                g[8] = 1 - v - z;
                return g
            },
            normalFromMat4: function (g, m) {
                var v = m[0],
                    z = m[1],
                    C = m[2],
                    D = m[3],
                    H = m[4],
                    K = m[5],
                    M = m[6],
                    O = m[7],
                    R = m[8],
                    T = m[9],
                    Y = m[10],
                    X = m[11],
                    fa = m[12],
                    ha = m[13],
                    ba = m[14];
                m = m[15];
                var qa = v * K - z * H,
                    ka = v * M - C * H,
                    ta = v * O - D * H,
                    ua = z * M - C * K,
                    ra = z * O - D * K,
                    za = C * O - D * M,
                    Aa = R * ha - T * fa,
                    Ba = R * ba - Y * fa;
                R = R * m - X * fa;
                var Ca = T * ba - Y * ha;
                T = T * m - X * ha;
                Y = Y * m - X * ba;
                X = qa * Y - ka * T + ta * Ca + ua * R - ra * Ba + za * Aa;
                if (!X) return null;
                X = 1 / X;
                g[0] = (K * Y - M * T + O * Ca) * X;
                g[1] = (M * R - H * Y - O * Ba) * X;
                g[2] = (H * T - K * R + O * Aa) * X;
                g[3] = (C * T - z * Y - D * Ca) * X;
                g[4] = (v * Y - C * R + D * Ba) * X;
                g[5] = (z * R - v * T - D * Aa) * X;
                g[6] = (ha * za - ba * ra + m * ua) * X;
                g[7] = (ba * ta - fa * za - m * ka) * X;
                g[8] = (fa * ra - ha * ta + m * qa) * X;
                return g
            },
            projection: function (g, m, v) {
                g[0] = 2 / m;
                g[1] = 0;
                g[2] = 0;
                g[3] = 0;
                g[4] = -2 / v;
                g[5] = 0;
                g[6] = -1;
                g[7] = 1;
                g[8] = 1;
                return g
            },
            str: function (g) {
                return "mat3(" + g[0] + ", " + g[1] + ", " + g[2] + ", " + g[3] + ", " + g[4] + ", " + g[5] + ", " + g[6] + ", " + g[7] + ", " + g[8] + ")"
            },
            frob: function (g) {
                return Math.hypot(g[0], g[1], g[2], g[3], g[4], g[5], g[6], g[7], g[8])
            },
            add: function (g, m, v) {
                g[0] = m[0] + v[0];
                g[1] = m[1] + v[1];
                g[2] = m[2] + v[2];
                g[3] = m[3] + v[3];
                g[4] = m[4] + v[4];
                g[5] = m[5] + v[5];
                g[6] = m[6] + v[6];
                g[7] = m[7] + v[7];
                g[8] = m[8] + v[8];
                return g
            },
            subtract: h,
            multiplyScalar: function (g, m, v) {
                g[0] = m[0] * v;
                g[1] = m[1] * v;
                g[2] = m[2] * v;
                g[3] = m[3] * v;
                g[4] = m[4] * v;
                g[5] = m[5] * v;
                g[6] = m[6] * v;
                g[7] = m[7] * v;
                g[8] = m[8] * v;
                return g
            },
            multiplyScalarAndAdd: function (g, m, v, z) {
                g[0] = m[0] + v[0] * z;
                g[1] = m[1] + v[1] * z;
                g[2] = m[2] + v[2] * z;
                g[3] = m[3] + v[3] * z;
                g[4] = m[4] + v[4] * z;
                g[5] = m[5] + v[5] * z;
                g[6] = m[6] + v[6] * z;
                g[7] = m[7] + v[7] * z;
                g[8] = m[8] + v[8] * z;
                return g
            },
            exactEquals: function (g, m) {
                return g[0] ===
                    m[0] && g[1] === m[1] && g[2] === m[2] && g[3] === m[3] && g[4] === m[4] && g[5] === m[5] && g[6] === m[6] && g[7] === m[7] && g[8] === m[8]
            },
            equals: function (g, m) {
                var v = g[0],
                    z = g[1],
                    C = g[2],
                    D = g[3],
                    H = g[4],
                    K = g[5],
                    M = g[6],
                    O = g[7];
                g = g[8];
                var R = m[0],
                    T = m[1],
                    Y = m[2],
                    X = m[3],
                    fa = m[4],
                    ha = m[5],
                    ba = m[6],
                    qa = m[7];
                m = m[8];
                return Math.abs(v - R) <= 1E-6 * Math.max(1, Math.abs(v), Math.abs(R)) && Math.abs(z - T) <= 1E-6 * Math.max(1, Math.abs(z), Math.abs(T)) && Math.abs(C - Y) <= 1E-6 * Math.max(1, Math.abs(C), Math.abs(Y)) && Math.abs(D - X) <= 1E-6 * Math.max(1, Math.abs(D), Math.abs(X)) &&
                    Math.abs(H - fa) <= 1E-6 * Math.max(1, Math.abs(H), Math.abs(fa)) && Math.abs(K - ha) <= 1E-6 * Math.max(1, Math.abs(K), Math.abs(ha)) && Math.abs(M - ba) <= 1E-6 * Math.max(1, Math.abs(M), Math.abs(ba)) && Math.abs(O - qa) <= 1E-6 * Math.max(1, Math.abs(O), Math.abs(qa)) && Math.abs(g - m) <= 1E-6 * Math.max(1, Math.abs(g), Math.abs(m))
            },
            mul: k,
            sub: h
        }),
        Hb = Object.freeze({
            __proto__: null,
            create: function () {
                var g = new sa(16);
                sa != Float32Array && (g[1] = 0, g[2] = 0, g[3] = 0, g[4] = 0, g[6] = 0, g[7] = 0, g[8] = 0, g[9] = 0, g[11] = 0, g[12] = 0, g[13] = 0, g[14] = 0);
                g[0] = 1;
                g[5] = 1;
                g[10] =
                    1;
                g[15] = 1;
                return g
            },
            clone: function (g) {
                var m = new sa(16);
                m[0] = g[0];
                m[1] = g[1];
                m[2] = g[2];
                m[3] = g[3];
                m[4] = g[4];
                m[5] = g[5];
                m[6] = g[6];
                m[7] = g[7];
                m[8] = g[8];
                m[9] = g[9];
                m[10] = g[10];
                m[11] = g[11];
                m[12] = g[12];
                m[13] = g[13];
                m[14] = g[14];
                m[15] = g[15];
                return m
            },
            copy: function (g, m) {
                g[0] = m[0];
                g[1] = m[1];
                g[2] = m[2];
                g[3] = m[3];
                g[4] = m[4];
                g[5] = m[5];
                g[6] = m[6];
                g[7] = m[7];
                g[8] = m[8];
                g[9] = m[9];
                g[10] = m[10];
                g[11] = m[11];
                g[12] = m[12];
                g[13] = m[13];
                g[14] = m[14];
                g[15] = m[15];
                return g
            },
            fromValues: function (g, m, v, z, C, D, H, K, M, O, R, T, Y, X, fa, ha) {
                var ba = new sa(16);
                ba[0] = g;
                ba[1] = m;
                ba[2] = v;
                ba[3] = z;
                ba[4] = C;
                ba[5] = D;
                ba[6] = H;
                ba[7] = K;
                ba[8] = M;
                ba[9] = O;
                ba[10] = R;
                ba[11] = T;
                ba[12] = Y;
                ba[13] = X;
                ba[14] = fa;
                ba[15] = ha;
                return ba
            },
            set: function (g, m, v, z, C, D, H, K, M, O, R, T, Y, X, fa, ha, ba) {
                g[0] = m;
                g[1] = v;
                g[2] = z;
                g[3] = C;
                g[4] = D;
                g[5] = H;
                g[6] = K;
                g[7] = M;
                g[8] = O;
                g[9] = R;
                g[10] = T;
                g[11] = Y;
                g[12] = X;
                g[13] = fa;
                g[14] = ha;
                g[15] = ba;
                return g
            },
            identity: l,
            transpose: function (g, m) {
                if (g === m) {
                    var v = m[1],
                        z = m[2],
                        C = m[3],
                        D = m[6],
                        H = m[7],
                        K = m[11];
                    g[1] = m[4];
                    g[2] = m[8];
                    g[3] = m[12];
                    g[4] = v;
                    g[6] = m[9];
                    g[7] = m[13];
                    g[8] = z;
                    g[9] = D;
                    g[11] = m[14];
                    g[12] = C;
                    g[13] = H;
                    g[14] = K
                } else g[0] = m[0], g[1] = m[4], g[2] = m[8], g[3] = m[12], g[4] = m[1], g[5] = m[5], g[6] = m[9], g[7] = m[13], g[8] = m[2], g[9] = m[6], g[10] = m[10], g[11] = m[14], g[12] = m[3], g[13] = m[7], g[14] = m[11], g[15] = m[15];
                return g
            },
            invert: function (g, m) {
                var v = m[0],
                    z = m[1],
                    C = m[2],
                    D = m[3],
                    H = m[4],
                    K = m[5],
                    M = m[6],
                    O = m[7],
                    R = m[8],
                    T = m[9],
                    Y = m[10],
                    X = m[11],
                    fa = m[12],
                    ha = m[13],
                    ba = m[14];
                m = m[15];
                var qa = v * K - z * H,
                    ka = v * M - C * H,
                    ta = v * O - D * H,
                    ua = z * M - C * K,
                    ra = z * O - D * K,
                    za = C * O - D * M,
                    Aa = R * ha - T * fa,
                    Ba = R * ba - Y * fa,
                    Ca = R * m - X * fa,
                    Ja = T * ba - Y * ha,
                    Pa = T * m - X * ha,
                    Qa = Y * m - X * ba,
                    Da = qa * Qa - ka * Pa + ta * Ja + ua * Ca - ra * Ba + za * Aa;
                if (!Da) return null;
                Da = 1 / Da;
                g[0] = (K * Qa - M * Pa + O * Ja) * Da;
                g[1] = (C * Pa - z * Qa - D * Ja) * Da;
                g[2] = (ha * za - ba * ra + m * ua) * Da;
                g[3] = (Y * ra - T * za - X * ua) * Da;
                g[4] = (M * Ca - H * Qa - O * Ba) * Da;
                g[5] = (v * Qa - C * Ca + D * Ba) * Da;
                g[6] = (ba * ta - fa * za - m * ka) * Da;
                g[7] = (R * za - Y * ta + X * ka) * Da;
                g[8] = (H * Pa - K * Ca + O * Aa) * Da;
                g[9] = (z * Ca - v * Pa - D * Aa) * Da;
                g[10] = (fa * ra - ha * ta + m * qa) * Da;
                g[11] = (T * ta - R * ra - X * qa) * Da;
                g[12] = (K * Ba - H * Ja - M * Aa) * Da;
                g[13] = (v * Ja - z * Ba + C * Aa) * Da;
                g[14] = (ha * ka - fa * ua - ba * qa) * Da;
                g[15] = (R * ua - T * ka + Y * qa) * Da;
                return g
            },
            adjoint: function (g,
                m) {
                var v = m[0],
                    z = m[1],
                    C = m[2],
                    D = m[3],
                    H = m[4],
                    K = m[5],
                    M = m[6],
                    O = m[7],
                    R = m[8],
                    T = m[9],
                    Y = m[10],
                    X = m[11],
                    fa = m[12],
                    ha = m[13],
                    ba = m[14];
                m = m[15];
                var qa = v * K - z * H,
                    ka = v * M - C * H,
                    ta = v * O - D * H,
                    ua = z * M - C * K,
                    ra = z * O - D * K,
                    za = C * O - D * M,
                    Aa = R * ha - T * fa,
                    Ba = R * ba - Y * fa,
                    Ca = R * m - X * fa,
                    Ja = T * ba - Y * ha,
                    Pa = T * m - X * ha,
                    Qa = Y * m - X * ba;
                g[0] = K * Qa - M * Pa + O * Ja;
                g[1] = C * Pa - z * Qa - D * Ja;
                g[2] = ha * za - ba * ra + m * ua;
                g[3] = Y * ra - T * za - X * ua;
                g[4] = M * Ca - H * Qa - O * Ba;
                g[5] = v * Qa - C * Ca + D * Ba;
                g[6] = ba * ta - fa * za - m * ka;
                g[7] = R * za - Y * ta + X * ka;
                g[8] = H * Pa - K * Ca + O * Aa;
                g[9] = z * Ca - v * Pa - D * Aa;
                g[10] = fa * ra - ha * ta + m * qa;
                g[11] =
                    T * ta - R * ra - X * qa;
                g[12] = K * Ba - H * Ja - M * Aa;
                g[13] = v * Ja - z * Ba + C * Aa;
                g[14] = ha * ka - fa * ua - ba * qa;
                g[15] = R * ua - T * ka + Y * qa;
                return g
            },
            determinant: function (g) {
                var m = g[0],
                    v = g[1],
                    z = g[2],
                    C = g[4],
                    D = g[5],
                    H = g[6],
                    K = g[8],
                    M = g[9],
                    O = g[10],
                    R = g[12],
                    T = g[13],
                    Y = g[14],
                    X = m * D - v * C,
                    fa = m * H - z * C,
                    ha = v * H - z * D,
                    ba = K * T - M * R,
                    qa = K * Y - O * R,
                    ka = M * Y - O * T;
                return g[7] * (m * ka - v * qa + z * ba) - g[3] * (C * ka - D * qa + H * ba) + g[15] * (K * ha - M * fa + O * X) - g[11] * (R * ha - T * fa + Y * X)
            },
            multiply: n,
            translate: function (g, m, v) {
                var z = v[0],
                    C = v[1];
                v = v[2];
                if (m === g) g[12] = m[0] * z + m[4] * C + m[8] * v + m[12], g[13] = m[1] *
                    z + m[5] * C + m[9] * v + m[13], g[14] = m[2] * z + m[6] * C + m[10] * v + m[14], g[15] = m[3] * z + m[7] * C + m[11] * v + m[15];
                else {
                    var D = m[0];
                    var H = m[1];
                    var K = m[2];
                    var M = m[3];
                    var O = m[4];
                    var R = m[5];
                    var T = m[6];
                    var Y = m[7];
                    var X = m[8];
                    var fa = m[9];
                    var ha = m[10];
                    var ba = m[11];
                    g[0] = D;
                    g[1] = H;
                    g[2] = K;
                    g[3] = M;
                    g[4] = O;
                    g[5] = R;
                    g[6] = T;
                    g[7] = Y;
                    g[8] = X;
                    g[9] = fa;
                    g[10] = ha;
                    g[11] = ba;
                    g[12] = D * z + O * C + X * v + m[12];
                    g[13] = H * z + R * C + fa * v + m[13];
                    g[14] = K * z + T * C + ha * v + m[14];
                    g[15] = M * z + Y * C + ba * v + m[15]
                }
                return g
            },
            scale: function (g, m, v) {
                var z = v[0],
                    C = v[1];
                v = v[2];
                g[0] = m[0] * z;
                g[1] = m[1] * z;
                g[2] = m[2] * z;
                g[3] = m[3] * z;
                g[4] = m[4] * C;
                g[5] = m[5] * C;
                g[6] = m[6] * C;
                g[7] = m[7] * C;
                g[8] = m[8] * v;
                g[9] = m[9] * v;
                g[10] = m[10] * v;
                g[11] = m[11] * v;
                g[12] = m[12];
                g[13] = m[13];
                g[14] = m[14];
                g[15] = m[15];
                return g
            },
            rotate: function (g, m, v, z) {
                var C = z[0],
                    D = z[1];
                z = z[2];
                var H = Math.hypot(C, D, z);
                if (1E-6 > H) return null;
                H = 1 / H;
                C *= H;
                D *= H;
                z *= H;
                var K = Math.sin(v);
                var M = Math.cos(v);
                var O = 1 - M;
                v = m[0];
                H = m[1];
                var R = m[2];
                var T = m[3];
                var Y = m[4];
                var X = m[5];
                var fa = m[6];
                var ha = m[7];
                var ba = m[8];
                var qa = m[9];
                var ka = m[10];
                var ta = m[11];
                var ua = C * C * O + M;
                var ra = D *
                    C * O + z * K;
                var za = z * C * O - D * K;
                var Aa = C * D * O - z * K;
                var Ba = D * D * O + M;
                var Ca = z * D * O + C * K;
                var Ja = C * z * O + D * K;
                C = D * z * O - C * K;
                D = z * z * O + M;
                g[0] = v * ua + Y * ra + ba * za;
                g[1] = H * ua + X * ra + qa * za;
                g[2] = R * ua + fa * ra + ka * za;
                g[3] = T * ua + ha * ra + ta * za;
                g[4] = v * Aa + Y * Ba + ba * Ca;
                g[5] = H * Aa + X * Ba + qa * Ca;
                g[6] = R * Aa + fa * Ba + ka * Ca;
                g[7] = T * Aa + ha * Ba + ta * Ca;
                g[8] = v * Ja + Y * C + ba * D;
                g[9] = H * Ja + X * C + qa * D;
                g[10] = R * Ja + fa * C + ka * D;
                g[11] = T * Ja + ha * C + ta * D;
                m !== g && (g[12] = m[12], g[13] = m[13], g[14] = m[14], g[15] = m[15]);
                return g
            },
            rotateX: function (g, m, v) {
                var z = Math.sin(v);
                v = Math.cos(v);
                var C = m[4],
                    D =
                    m[5],
                    H = m[6],
                    K = m[7],
                    M = m[8],
                    O = m[9],
                    R = m[10],
                    T = m[11];
                m !== g && (g[0] = m[0], g[1] = m[1], g[2] = m[2], g[3] = m[3], g[12] = m[12], g[13] = m[13], g[14] = m[14], g[15] = m[15]);
                g[4] = C * v + M * z;
                g[5] = D * v + O * z;
                g[6] = H * v + R * z;
                g[7] = K * v + T * z;
                g[8] = M * v - C * z;
                g[9] = O * v - D * z;
                g[10] = R * v - H * z;
                g[11] = T * v - K * z;
                return g
            },
            rotateY: function (g, m, v) {
                var z = Math.sin(v);
                v = Math.cos(v);
                var C = m[0],
                    D = m[1],
                    H = m[2],
                    K = m[3],
                    M = m[8],
                    O = m[9],
                    R = m[10],
                    T = m[11];
                m !== g && (g[4] = m[4], g[5] = m[5], g[6] = m[6], g[7] = m[7], g[12] = m[12], g[13] = m[13], g[14] = m[14], g[15] = m[15]);
                g[0] = C * v - M * z;
                g[1] = D * v - O *
                    z;
                g[2] = H * v - R * z;
                g[3] = K * v - T * z;
                g[8] = C * z + M * v;
                g[9] = D * z + O * v;
                g[10] = H * z + R * v;
                g[11] = K * z + T * v;
                return g
            },
            rotateZ: function (g, m, v) {
                var z = Math.sin(v);
                v = Math.cos(v);
                var C = m[0],
                    D = m[1],
                    H = m[2],
                    K = m[3],
                    M = m[4],
                    O = m[5],
                    R = m[6],
                    T = m[7];
                m !== g && (g[8] = m[8], g[9] = m[9], g[10] = m[10], g[11] = m[11], g[12] = m[12], g[13] = m[13], g[14] = m[14], g[15] = m[15]);
                g[0] = C * v + M * z;
                g[1] = D * v + O * z;
                g[2] = H * v + R * z;
                g[3] = K * v + T * z;
                g[4] = M * v - C * z;
                g[5] = O * v - D * z;
                g[6] = R * v - H * z;
                g[7] = T * v - K * z;
                return g
            },
            fromTranslation: function (g, m) {
                g[0] = 1;
                g[1] = 0;
                g[2] = 0;
                g[3] = 0;
                g[4] = 0;
                g[5] = 1;
                g[6] = 0;
                g[7] = 0;
                g[8] = 0;
                g[9] = 0;
                g[10] = 1;
                g[11] = 0;
                g[12] = m[0];
                g[13] = m[1];
                g[14] = m[2];
                g[15] = 1;
                return g
            },
            fromScaling: function (g, m) {
                g[0] = m[0];
                g[1] = 0;
                g[2] = 0;
                g[3] = 0;
                g[4] = 0;
                g[5] = m[1];
                g[6] = 0;
                g[7] = 0;
                g[8] = 0;
                g[9] = 0;
                g[10] = m[2];
                g[11] = 0;
                g[12] = 0;
                g[13] = 0;
                g[14] = 0;
                g[15] = 1;
                return g
            },
            fromRotation: function (g, m, v) {
                var z = v[0],
                    C = v[1];
                v = v[2];
                var D = Math.hypot(z, C, v);
                if (1E-6 > D) return null;
                D = 1 / D;
                z *= D;
                C *= D;
                v *= D;
                D = Math.sin(m);
                m = Math.cos(m);
                var H = 1 - m;
                g[0] = z * z * H + m;
                g[1] = C * z * H + v * D;
                g[2] = v * z * H - C * D;
                g[3] = 0;
                g[4] = z * C * H - v * D;
                g[5] = C * C * H + m;
                g[6] = v * C * H + z *
                    D;
                g[7] = 0;
                g[8] = z * v * H + C * D;
                g[9] = C * v * H - z * D;
                g[10] = v * v * H + m;
                g[11] = 0;
                g[12] = 0;
                g[13] = 0;
                g[14] = 0;
                g[15] = 1;
                return g
            },
            fromXRotation: function (g, m) {
                var v = Math.sin(m);
                m = Math.cos(m);
                g[0] = 1;
                g[1] = 0;
                g[2] = 0;
                g[3] = 0;
                g[4] = 0;
                g[5] = m;
                g[6] = v;
                g[7] = 0;
                g[8] = 0;
                g[9] = -v;
                g[10] = m;
                g[11] = 0;
                g[12] = 0;
                g[13] = 0;
                g[14] = 0;
                g[15] = 1;
                return g
            },
            fromYRotation: function (g, m) {
                var v = Math.sin(m);
                m = Math.cos(m);
                g[0] = m;
                g[1] = 0;
                g[2] = -v;
                g[3] = 0;
                g[4] = 0;
                g[5] = 1;
                g[6] = 0;
                g[7] = 0;
                g[8] = v;
                g[9] = 0;
                g[10] = m;
                g[11] = 0;
                g[12] = 0;
                g[13] = 0;
                g[14] = 0;
                g[15] = 1;
                return g
            },
            fromZRotation: function (g,
                m) {
                var v = Math.sin(m);
                m = Math.cos(m);
                g[0] = m;
                g[1] = v;
                g[2] = 0;
                g[3] = 0;
                g[4] = -v;
                g[5] = m;
                g[6] = 0;
                g[7] = 0;
                g[8] = 0;
                g[9] = 0;
                g[10] = 1;
                g[11] = 0;
                g[12] = 0;
                g[13] = 0;
                g[14] = 0;
                g[15] = 1;
                return g
            },
            fromRotationTranslation: u,
            fromQuat2: function (g, m) {
                var v = new sa(3),
                    z = -m[0],
                    C = -m[1],
                    D = -m[2],
                    H = m[3],
                    K = m[4],
                    M = m[5],
                    O = m[6],
                    R = m[7],
                    T = z * z + C * C + D * D + H * H;
                0 < T ? (v[0] = 2 * (K * H + R * z + M * D - O * C) / T, v[1] = 2 * (M * H + R * C + O * z - K * D) / T, v[2] = 2 * (O * H + R * D + K * C - M * z) / T) : (v[0] = 2 * (K * H + R * z + M * D - O * C), v[1] = 2 * (M * H + R * C + O * z - K * D), v[2] = 2 * (O * H + R * D + K * C - M * z));
                u(g, m, v);
                return g
            },
            getTranslation: w,
            getScaling: q,
            getRotation: t,
            decompose: function (g, m, v, z) {
                m[0] = z[12];
                m[1] = z[13];
                m[2] = z[14];
                var C = z[0],
                    D = z[1],
                    H = z[2],
                    K = z[4],
                    M = z[5],
                    O = z[6],
                    R = z[8];
                m = z[9];
                z = z[10];
                v[0] = Math.hypot(C, D, H);
                v[1] = Math.hypot(K, M, O);
                v[2] = Math.hypot(R, m, z);
                var T = 1 / v[0],
                    Y = 1 / v[1],
                    X = 1 / v[2];
                v = C * T;
                D *= Y;
                H *= X;
                K *= T;
                M *= Y;
                O *= X;
                R *= T;
                m *= Y;
                z *= X;
                Y = v + M + z;
                0 < Y ? (z = 2 * Math.sqrt(Y + 1), g[3] = .25 * z, g[0] = (O - m) / z, g[1] = (R - H) / z, g[2] = (D - K) / z) : v > M && v > z ? (z = 2 * Math.sqrt(1 + v - M - z), g[3] = (O - m) / z, g[0] = .25 * z, g[1] = (D + K) / z, g[2] = (R + H) / z) : M > z ? (z = 2 * Math.sqrt(1 + M - v - z), g[3] =
                    (R - H) / z, g[0] = (D + K) / z, g[1] = .25 * z, g[2] = (O + m) / z) : (z = 2 * Math.sqrt(1 + z - v - M), g[3] = (D - K) / z, g[0] = (R + H) / z, g[1] = (O + m) / z, g[2] = .25 * z);
                return g
            },
            fromRotationTranslationScale: function (g, m, v, z) {
                var C = m[0],
                    D = m[1],
                    H = m[2],
                    K = m[3],
                    M = C + C,
                    O = D + D,
                    R = H + H;
                m = C * M;
                var T = C * O;
                C *= R;
                var Y = D * O;
                D *= R;
                H *= R;
                M *= K;
                O *= K;
                K *= R;
                R = z[0];
                var X = z[1];
                z = z[2];
                g[0] = (1 - (Y + H)) * R;
                g[1] = (T + K) * R;
                g[2] = (C - O) * R;
                g[3] = 0;
                g[4] = (T - K) * X;
                g[5] = (1 - (m + H)) * X;
                g[6] = (D + M) * X;
                g[7] = 0;
                g[8] = (C + O) * z;
                g[9] = (D - M) * z;
                g[10] = (1 - (m + Y)) * z;
                g[11] = 0;
                g[12] = v[0];
                g[13] = v[1];
                g[14] = v[2];
                g[15] = 1;
                return g
            },
            fromRotationTranslationScaleOrigin: function (g, m, v, z, C) {
                var D = m[0],
                    H = m[1],
                    K = m[2],
                    M = m[3],
                    O = D + D,
                    R = H + H,
                    T = K + K;
                m = D * O;
                var Y = D * R,
                    X = D * T;
                D = H * R;
                H *= T;
                var fa = K * T;
                K = M * O;
                R *= M;
                var ha = M * T,
                    ba = z[0],
                    qa = z[1];
                T = z[2];
                z = C[0];
                M = C[1];
                C = C[2];
                O = (1 - (D + fa)) * ba;
                var ka = (Y + ha) * ba;
                ba *= X - R;
                Y = (Y - ha) * qa;
                fa = (1 - (m + fa)) * qa;
                qa *= H + K;
                X = (X + R) * T;
                H = (H - K) * T;
                m = (1 - (m + D)) * T;
                g[0] = O;
                g[1] = ka;
                g[2] = ba;
                g[3] = 0;
                g[4] = Y;
                g[5] = fa;
                g[6] = qa;
                g[7] = 0;
                g[8] = X;
                g[9] = H;
                g[10] = m;
                g[11] = 0;
                g[12] = v[0] + z - (O * z + Y * M + X * C);
                g[13] = v[1] + M - (ka * z + fa * M + H * C);
                g[14] = v[2] + C - (ba * z +
                    qa * M + m * C);
                g[15] = 1;
                return g
            },
            fromQuat: function (g, m) {
                var v = m[0],
                    z = m[1],
                    C = m[2];
                m = m[3];
                var D = v + v,
                    H = z + z,
                    K = C + C;
                v *= D;
                var M = z * D;
                z *= H;
                var O = C * D,
                    R = C * H;
                C *= K;
                D *= m;
                H *= m;
                m *= K;
                g[0] = 1 - z - C;
                g[1] = M + m;
                g[2] = O - H;
                g[3] = 0;
                g[4] = M - m;
                g[5] = 1 - v - C;
                g[6] = R + D;
                g[7] = 0;
                g[8] = O + H;
                g[9] = R - D;
                g[10] = 1 - v - z;
                g[11] = 0;
                g[12] = 0;
                g[13] = 0;
                g[14] = 0;
                g[15] = 1;
                return g
            },
            frustum: function (g, m, v, z, C, D, H) {
                var K = 1 / (v - m),
                    M = 1 / (C - z),
                    O = 1 / (D - H);
                g[0] = 2 * D * K;
                g[1] = 0;
                g[2] = 0;
                g[3] = 0;
                g[4] = 0;
                g[5] = 2 * D * M;
                g[6] = 0;
                g[7] = 0;
                g[8] = (v + m) * K;
                g[9] = (C + z) * M;
                g[10] = (H + D) * O;
                g[11] = -1;
                g[12] = 0;
                g[13] =
                    0;
                g[14] = H * D * 2 * O;
                g[15] = 0;
                return g
            },
            perspectiveNO: p,
            perspective: p,
            perspectiveZO: function (g, m, v, z, C) {
                m = 1 / Math.tan(m / 2);
                g[0] = m / v;
                g[1] = 0;
                g[2] = 0;
                g[3] = 0;
                g[4] = 0;
                g[5] = m;
                g[6] = 0;
                g[7] = 0;
                g[8] = 0;
                g[9] = 0;
                g[11] = -1;
                g[12] = 0;
                g[13] = 0;
                g[15] = 0;
                null != C && Infinity !== C ? (v = 1 / (z - C), g[10] = C * v, g[14] = C * z * v) : (g[10] = -1, g[14] = -z);
                return g
            },
            perspectiveFromFieldOfView: function (g, m, v, z) {
                var C = Math.tan(m.upDegrees * Math.PI / 180),
                    D = Math.tan(m.downDegrees * Math.PI / 180),
                    H = Math.tan(m.leftDegrees * Math.PI / 180);
                m = Math.tan(m.rightDegrees * Math.PI /
                    180);
                var K = 2 / (H + m),
                    M = 2 / (C + D);
                g[0] = K;
                g[1] = 0;
                g[2] = 0;
                g[3] = 0;
                g[4] = 0;
                g[5] = M;
                g[6] = 0;
                g[7] = 0;
                g[8] = -((H - m) * K * .5);
                g[9] = (C - D) * M * .5;
                g[10] = z / (v - z);
                g[11] = -1;
                g[12] = 0;
                g[13] = 0;
                g[14] = z * v / (v - z);
                g[15] = 0;
                return g
            },
            orthoNO: r,
            ortho: r,
            orthoZO: function (g, m, v, z, C, D, H) {
                var K = 1 / (m - v),
                    M = 1 / (z - C);
                H = 1 / (D - H);
                g[0] = -2 * K;
                g[1] = 0;
                g[2] = 0;
                g[3] = 0;
                g[4] = 0;
                g[5] = -2 * M;
                g[6] = 0;
                g[7] = 0;
                g[8] = 0;
                g[9] = 0;
                g[10] = H;
                g[11] = 0;
                g[12] = (m + v) * K;
                g[13] = (C + z) * M;
                g[14] = D * H;
                g[15] = 1;
                return g
            },
            lookAt: function (g, m, v, z) {
                var C = m[0],
                    D = m[1];
                m = m[2];
                var H = z[0];
                var K = z[1];
                var M =
                    z[2];
                var O = v[0];
                z = v[1];
                var R = v[2];
                if (1E-6 > Math.abs(C - O) && 1E-6 > Math.abs(D - z) && 1E-6 > Math.abs(m - R)) return l(g);
                v = C - O;
                z = D - z;
                O = m - R;
                var T = 1 / Math.hypot(v, z, O);
                v *= T;
                z *= T;
                O *= T;
                R = K * O - M * z;
                M = M * v - H * O;
                H = H * z - K * v;
                (T = Math.hypot(R, M, H)) ? (T = 1 / T, R *= T, M *= T, H *= T) : H = M = R = 0;
                K = z * H - O * M;
                var Y = O * R - v * H;
                var X = v * M - z * R;
                (T = Math.hypot(K, Y, X)) ? (T = 1 / T, K *= T, Y *= T, X *= T) : X = Y = K = 0;
                g[0] = R;
                g[1] = K;
                g[2] = v;
                g[3] = 0;
                g[4] = M;
                g[5] = Y;
                g[6] = z;
                g[7] = 0;
                g[8] = H;
                g[9] = X;
                g[10] = O;
                g[11] = 0;
                g[12] = -(R * C + M * D + H * m);
                g[13] = -(K * C + Y * D + X * m);
                g[14] = -(v * C + z * D + O * m);
                g[15] = 1;
                return g
            },
            targetTo: function (g, m, v, z) {
                var C = m[0],
                    D = m[1];
                m = m[2];
                var H = z[0],
                    K = z[1],
                    M = z[2];
                z = C - v[0];
                var O = D - v[1];
                v = m - v[2];
                var R = z * z + O * O + v * v;
                0 < R && (R = 1 / Math.sqrt(R), z *= R, O *= R, v *= R);
                var T = K * v - M * O;
                M = M * z - H * v;
                H = H * O - K * z;
                R = T * T + M * M + H * H;
                0 < R && (R = 1 / Math.sqrt(R), T *= R, M *= R, H *= R);
                g[0] = T;
                g[1] = M;
                g[2] = H;
                g[3] = 0;
                g[4] = O * H - v * M;
                g[5] = v * T - z * H;
                g[6] = z * M - O * T;
                g[7] = 0;
                g[8] = z;
                g[9] = O;
                g[10] = v;
                g[11] = 0;
                g[12] = C;
                g[13] = D;
                g[14] = m;
                g[15] = 1;
                return g
            },
            str: function (g) {
                return "mat4(" + g[0] + ", " + g[1] + ", " + g[2] + ", " + g[3] + ", " + g[4] + ", " + g[5] + ", " + g[6] + ", " + g[7] +
                    ", " + g[8] + ", " + g[9] + ", " + g[10] + ", " + g[11] + ", " + g[12] + ", " + g[13] + ", " + g[14] + ", " + g[15] + ")"
            },
            frob: function (g) {
                return Math.hypot(g[0], g[1], g[2], g[3], g[4], g[5], g[6], g[7], g[8], g[9], g[10], g[11], g[12], g[13], g[14], g[15])
            },
            add: function (g, m, v) {
                g[0] = m[0] + v[0];
                g[1] = m[1] + v[1];
                g[2] = m[2] + v[2];
                g[3] = m[3] + v[3];
                g[4] = m[4] + v[4];
                g[5] = m[5] + v[5];
                g[6] = m[6] + v[6];
                g[7] = m[7] + v[7];
                g[8] = m[8] + v[8];
                g[9] = m[9] + v[9];
                g[10] = m[10] + v[10];
                g[11] = m[11] + v[11];
                g[12] = m[12] + v[12];
                g[13] = m[13] + v[13];
                g[14] = m[14] + v[14];
                g[15] = m[15] + v[15];
                return g
            },
            subtract: x,
            multiplyScalar: function (g, m, v) {
                g[0] = m[0] * v;
                g[1] = m[1] * v;
                g[2] = m[2] * v;
                g[3] = m[3] * v;
                g[4] = m[4] * v;
                g[5] = m[5] * v;
                g[6] = m[6] * v;
                g[7] = m[7] * v;
                g[8] = m[8] * v;
                g[9] = m[9] * v;
                g[10] = m[10] * v;
                g[11] = m[11] * v;
                g[12] = m[12] * v;
                g[13] = m[13] * v;
                g[14] = m[14] * v;
                g[15] = m[15] * v;
                return g
            },
            multiplyScalarAndAdd: function (g, m, v, z) {
                g[0] = m[0] + v[0] * z;
                g[1] = m[1] + v[1] * z;
                g[2] = m[2] + v[2] * z;
                g[3] = m[3] + v[3] * z;
                g[4] = m[4] + v[4] * z;
                g[5] = m[5] + v[5] * z;
                g[6] = m[6] + v[6] * z;
                g[7] = m[7] + v[7] * z;
                g[8] = m[8] + v[8] * z;
                g[9] = m[9] + v[9] * z;
                g[10] = m[10] + v[10] * z;
                g[11] = m[11] + v[11] *
                    z;
                g[12] = m[12] + v[12] * z;
                g[13] = m[13] + v[13] * z;
                g[14] = m[14] + v[14] * z;
                g[15] = m[15] + v[15] * z;
                return g
            },
            exactEquals: function (g, m) {
                return g[0] === m[0] && g[1] === m[1] && g[2] === m[2] && g[3] === m[3] && g[4] === m[4] && g[5] === m[5] && g[6] === m[6] && g[7] === m[7] && g[8] === m[8] && g[9] === m[9] && g[10] === m[10] && g[11] === m[11] && g[12] === m[12] && g[13] === m[13] && g[14] === m[14] && g[15] === m[15]
            },
            equals: function (g, m) {
                var v = g[0],
                    z = g[1],
                    C = g[2],
                    D = g[3],
                    H = g[4],
                    K = g[5],
                    M = g[6],
                    O = g[7],
                    R = g[8],
                    T = g[9],
                    Y = g[10],
                    X = g[11],
                    fa = g[12],
                    ha = g[13],
                    ba = g[14];
                g = g[15];
                var qa = m[0],
                    ka = m[1],
                    ta = m[2],
                    ua = m[3],
                    ra = m[4],
                    za = m[5],
                    Aa = m[6],
                    Ba = m[7],
                    Ca = m[8],
                    Ja = m[9],
                    Pa = m[10],
                    Qa = m[11],
                    Da = m[12],
                    Bb = m[13],
                    Cb = m[14];
                m = m[15];
                return Math.abs(v - qa) <= 1E-6 * Math.max(1, Math.abs(v), Math.abs(qa)) && Math.abs(z - ka) <= 1E-6 * Math.max(1, Math.abs(z), Math.abs(ka)) && Math.abs(C - ta) <= 1E-6 * Math.max(1, Math.abs(C), Math.abs(ta)) && Math.abs(D - ua) <= 1E-6 * Math.max(1, Math.abs(D), Math.abs(ua)) && Math.abs(H - ra) <= 1E-6 * Math.max(1, Math.abs(H), Math.abs(ra)) && Math.abs(K - za) <= 1E-6 * Math.max(1, Math.abs(K), Math.abs(za)) && Math.abs(M - Aa) <=
                    1E-6 * Math.max(1, Math.abs(M), Math.abs(Aa)) && Math.abs(O - Ba) <= 1E-6 * Math.max(1, Math.abs(O), Math.abs(Ba)) && Math.abs(R - Ca) <= 1E-6 * Math.max(1, Math.abs(R), Math.abs(Ca)) && Math.abs(T - Ja) <= 1E-6 * Math.max(1, Math.abs(T), Math.abs(Ja)) && Math.abs(Y - Pa) <= 1E-6 * Math.max(1, Math.abs(Y), Math.abs(Pa)) && Math.abs(X - Qa) <= 1E-6 * Math.max(1, Math.abs(X), Math.abs(Qa)) && Math.abs(fa - Da) <= 1E-6 * Math.max(1, Math.abs(fa), Math.abs(Da)) && Math.abs(ha - Bb) <= 1E-6 * Math.max(1, Math.abs(ha), Math.abs(Bb)) && Math.abs(ba - Cb) <= 1E-6 * Math.max(1, Math.abs(ba),
                        Math.abs(Cb)) && Math.abs(g - m) <= 1E-6 * Math.max(1, Math.abs(g), Math.abs(m))
            },
            mul: n,
            sub: x
        }),
        kb = function () {
            var g = y();
            return function (m, v, z, C, D, H) {
                v || (v = 3);
                z || (z = 0);
                for (C = C ? Math.min(C * v + z, m.length) : m.length; z < C; z += v) g[0] = m[z], g[1] = m[z + 1], g[2] = m[z + 2], D(g, g, H), m[z] = g[0], m[z + 1] = g[1], m[z + 2] = g[2];
                return m
            }
        }();
    kb = Object.freeze({
        __proto__: null,
        create: y,
        clone: function (g) {
            var m = new sa(3);
            m[0] = g[0];
            m[1] = g[1];
            m[2] = g[2];
            return m
        },
        length: E,
        fromValues: G,
        copy: function (g, m) {
            g[0] = m[0];
            g[1] = m[1];
            g[2] = m[2];
            return g
        },
        set: function (g,
            m, v, z) {
            g[0] = m;
            g[1] = v;
            g[2] = z;
            return g
        },
        add: function (g, m, v) {
            g[0] = m[0] + v[0];
            g[1] = m[1] + v[1];
            g[2] = m[2] + v[2];
            return g
        },
        subtract: A,
        multiply: F,
        divide: J,
        ceil: function (g, m) {
            g[0] = Math.ceil(m[0]);
            g[1] = Math.ceil(m[1]);
            g[2] = Math.ceil(m[2]);
            return g
        },
        floor: function (g, m) {
            g[0] = Math.floor(m[0]);
            g[1] = Math.floor(m[1]);
            g[2] = Math.floor(m[2]);
            return g
        },
        min: function (g, m, v) {
            g[0] = Math.min(m[0], v[0]);
            g[1] = Math.min(m[1], v[1]);
            g[2] = Math.min(m[2], v[2]);
            return g
        },
        max: function (g, m, v) {
            g[0] = Math.max(m[0], v[0]);
            g[1] = Math.max(m[1],
                v[1]);
            g[2] = Math.max(m[2], v[2]);
            return g
        },
        round: function (g, m) {
            g[0] = Math.round(m[0]);
            g[1] = Math.round(m[1]);
            g[2] = Math.round(m[2]);
            return g
        },
        scale: function (g, m, v) {
            g[0] = m[0] * v;
            g[1] = m[1] * v;
            g[2] = m[2] * v;
            return g
        },
        scaleAndAdd: function (g, m, v, z) {
            g[0] = m[0] + v[0] * z;
            g[1] = m[1] + v[1] * z;
            g[2] = m[2] + v[2] * z;
            return g
        },
        distance: B,
        squaredDistance: I,
        squaredLength: L,
        negate: function (g, m) {
            g[0] = -m[0];
            g[1] = -m[1];
            g[2] = -m[2];
            return g
        },
        inverse: function (g, m) {
            g[0] = 1 / m[0];
            g[1] = 1 / m[1];
            g[2] = 1 / m[2];
            return g
        },
        normalize: P,
        dot: S,
        cross: U,
        lerp: function (g,
            m, v, z) {
            var C = m[0],
                D = m[1];
            m = m[2];
            g[0] = C + z * (v[0] - C);
            g[1] = D + z * (v[1] - D);
            g[2] = m + z * (v[2] - m);
            return g
        },
        slerp: function (g, m, v, z) {
            var C = Math.acos(Math.min(Math.max(S(m, v), -1), 1)),
                D = Math.sin(C),
                H = Math.sin((1 - z) * C) / D;
            z = Math.sin(z * C) / D;
            g[0] = H * m[0] + z * v[0];
            g[1] = H * m[1] + z * v[1];
            g[2] = H * m[2] + z * v[2];
            return g
        },
        hermite: function (g, m, v, z, C, D) {
            var H = D * D,
                K = H * (2 * D - 3) + 1,
                M = H * (D - 2) + D,
                O = H * (D - 1);
            D = H * (3 - 2 * D);
            g[0] = m[0] * K + v[0] * M + z[0] * O + C[0] * D;
            g[1] = m[1] * K + v[1] * M + z[1] * O + C[1] * D;
            g[2] = m[2] * K + v[2] * M + z[2] * O + C[2] * D;
            return g
        },
        bezier: function (g,
            m, v, z, C, D) {
            var H = 1 - D,
                K = H * H,
                M = D * D,
                O = K * H;
            K *= 3 * D;
            H *= 3 * M;
            D *= M;
            g[0] = m[0] * O + v[0] * K + z[0] * H + C[0] * D;
            g[1] = m[1] * O + v[1] * K + z[1] * H + C[1] * D;
            g[2] = m[2] * O + v[2] * K + z[2] * H + C[2] * D;
            return g
        },
        random: function (g, m) {
            m = m || 1;
            var v = 2 * Sa() * Math.PI,
                z = 2 * Sa() - 1,
                C = Math.sqrt(1 - z * z) * m;
            g[0] = Math.cos(v) * C;
            g[1] = Math.sin(v) * C;
            g[2] = z * m;
            return g
        },
        transformMat4: function (g, m, v) {
            var z = m[0],
                C = m[1];
            m = m[2];
            var D = v[3] * z + v[7] * C + v[11] * m + v[15];
            D = D || 1;
            g[0] = (v[0] * z + v[4] * C + v[8] * m + v[12]) / D;
            g[1] = (v[1] * z + v[5] * C + v[9] * m + v[13]) / D;
            g[2] = (v[2] * z + v[6] * C + v[10] * m +
                v[14]) / D;
            return g
        },
        transformMat3: function (g, m, v) {
            var z = m[0],
                C = m[1];
            m = m[2];
            g[0] = z * v[0] + C * v[3] + m * v[6];
            g[1] = z * v[1] + C * v[4] + m * v[7];
            g[2] = z * v[2] + C * v[5] + m * v[8];
            return g
        },
        transformQuat: function (g, m, v) {
            var z = v[0],
                C = v[1],
                D = v[2],
                H = m[0],
                K = m[1];
            m = m[2];
            var M = C * m - D * K,
                O = D * H - z * m,
                R = z * K - C * H;
            v = 2 * v[3];
            g[0] = H + M * v + 2 * (C * R - D * O);
            g[1] = K + O * v + 2 * (D * M - z * R);
            g[2] = m + R * v + 2 * (z * O - C * M);
            return g
        },
        rotateX: function (g, m, v, z) {
            var C = [],
                D = [];
            C[0] = m[0] - v[0];
            C[1] = m[1] - v[1];
            C[2] = m[2] - v[2];
            D[0] = C[0];
            D[1] = C[1] * Math.cos(z) - C[2] * Math.sin(z);
            D[2] = C[1] *
                Math.sin(z) + C[2] * Math.cos(z);
            g[0] = D[0] + v[0];
            g[1] = D[1] + v[1];
            g[2] = D[2] + v[2];
            return g
        },
        rotateY: function (g, m, v, z) {
            var C = [],
                D = [];
            C[0] = m[0] - v[0];
            C[1] = m[1] - v[1];
            C[2] = m[2] - v[2];
            D[0] = C[2] * Math.sin(z) + C[0] * Math.cos(z);
            D[1] = C[1];
            D[2] = C[2] * Math.cos(z) - C[0] * Math.sin(z);
            g[0] = D[0] + v[0];
            g[1] = D[1] + v[1];
            g[2] = D[2] + v[2];
            return g
        },
        rotateZ: function (g, m, v, z) {
            var C = [],
                D = [];
            C[0] = m[0] - v[0];
            C[1] = m[1] - v[1];
            C[2] = m[2] - v[2];
            D[0] = C[0] * Math.cos(z) - C[1] * Math.sin(z);
            D[1] = C[0] * Math.sin(z) + C[1] * Math.cos(z);
            D[2] = C[2];
            g[0] = D[0] + v[0];
            g[1] =
                D[1] + v[1];
            g[2] = D[2] + v[2];
            return g
        },
        angle: function (g, m) {
            var v = g[0],
                z = g[1],
                C = g[2],
                D = m[0],
                H = m[1],
                K = m[2];
            g = (v = Math.sqrt((v * v + z * z + C * C) * (D * D + H * H + K * K))) && S(g, m) / v;
            return Math.acos(Math.min(Math.max(g, -1), 1))
        },
        zero: function (g) {
            g[0] = 0;
            g[1] = 0;
            g[2] = 0;
            return g
        },
        str: function (g) {
            return "vec3(" + g[0] + ", " + g[1] + ", " + g[2] + ")"
        },
        exactEquals: function (g, m) {
            return g[0] === m[0] && g[1] === m[1] && g[2] === m[2]
        },
        equals: function (g, m) {
            var v = g[0],
                z = g[1];
            g = g[2];
            var C = m[0],
                D = m[1];
            m = m[2];
            return Math.abs(v - C) <= 1E-6 * Math.max(1, Math.abs(v),
                Math.abs(C)) && Math.abs(z - D) <= 1E-6 * Math.max(1, Math.abs(z), Math.abs(D)) && Math.abs(g - m) <= 1E-6 * Math.max(1, Math.abs(g), Math.abs(m))
        },
        sub: A,
        mul: F,
        div: J,
        dist: B,
        sqrDist: I,
        len: E,
        sqrLen: L,
        forEach: kb
    });
    var lb = function () {
        var g = V();
        return function (m, v, z, C, D, H) {
            v || (v = 4);
            z || (z = 0);
            for (C = C ? Math.min(C * v + z, m.length) : m.length; z < C; z += v) g[0] = m[z], g[1] = m[z + 1], g[2] = m[z + 2], g[3] = m[z + 3], D(g, g, H), m[z] = g[0], m[z + 1] = g[1], m[z + 2] = g[2], m[z + 3] = g[3];
            return m
        }
    }();
    lb = Object.freeze({
        __proto__: null,
        create: V,
        clone: Z,
        fromValues: ma,
        copy: va,
        set: Na,
        add: Ea,
        subtract: Ia,
        multiply: Ma,
        divide: Fa,
        ceil: function (g, m) {
            g[0] = Math.ceil(m[0]);
            g[1] = Math.ceil(m[1]);
            g[2] = Math.ceil(m[2]);
            g[3] = Math.ceil(m[3]);
            return g
        },
        floor: function (g, m) {
            g[0] = Math.floor(m[0]);
            g[1] = Math.floor(m[1]);
            g[2] = Math.floor(m[2]);
            g[3] = Math.floor(m[3]);
            return g
        },
        min: function (g, m, v) {
            g[0] = Math.min(m[0], v[0]);
            g[1] = Math.min(m[1], v[1]);
            g[2] = Math.min(m[2], v[2]);
            g[3] = Math.min(m[3], v[3]);
            return g
        },
        max: function (g, m, v) {
            g[0] = Math.max(m[0], v[0]);
            g[1] = Math.max(m[1], v[1]);
            g[2] = Math.max(m[2], v[2]);
            g[3] = Math.max(m[3], v[3]);
            return g
        },
        round: function (g, m) {
            g[0] = Math.round(m[0]);
            g[1] = Math.round(m[1]);
            g[2] = Math.round(m[2]);
            g[3] = Math.round(m[3]);
            return g
        },
        scale: ya,
        scaleAndAdd: function (g, m, v, z) {
            g[0] = m[0] + v[0] * z;
            g[1] = m[1] + v[1] * z;
            g[2] = m[2] + v[2] * z;
            g[3] = m[3] + v[3] * z;
            return g
        },
        distance: na,
        squaredDistance: Va,
        length: xa,
        squaredLength: Ga,
        negate: function (g, m) {
            g[0] = -m[0];
            g[1] = -m[1];
            g[2] = -m[2];
            g[3] = -m[3];
            return g
        },
        inverse: function (g, m) {
            g[0] = 1 / m[0];
            g[1] = 1 / m[1];
            g[2] = 1 / m[2];
            g[3] = 1 / m[3];
            return g
        },
        normalize: bb,
        dot: Xa,
        cross: function (g, m, v, z) {
            var C = v[0] * z[1] - v[1] * z[0],
                D = v[0] * z[2] - v[2] * z[0],
                H = v[0] * z[3] - v[3] * z[0],
                K = v[1] * z[2] - v[2] * z[1],
                M = v[1] * z[3] - v[3] * z[1];
            v = v[2] * z[3] - v[3] * z[2];
            z = m[0];
            var O = m[1],
                R = m[2];
            m = m[3];
            g[0] = O * v - R * M + m * K;
            g[1] = -(z * v) + R * H - m * D;
            g[2] = z * M - O * H + m * C;
            g[3] = -(z * K) + O * D - R * C;
            return g
        },
        lerp: ob,
        random: function (g, m) {
            m = m || 1;
            do {
                var v = 2 * Sa() - 1;
                var z = 2 * Sa() - 1;
                var C = v * v + z * z
            } while (1 <= C);
            do {
                var D = 2 * Sa() - 1;
                var H = 2 * Sa() - 1;
                var K = D * D + H * H
            } while (1 <= K);
            C = Math.sqrt((1 - C) / K);
            g[0] = m * v;
            g[1] = m * z;
            g[2] = m * D * C;
            g[3] = m * H * C;
            return g
        },
        transformMat4: function (g, m, v) {
            var z = m[0],
                C = m[1],
                D = m[2];
            m = m[3];
            g[0] = v[0] * z + v[4] * C + v[8] * D + v[12] * m;
            g[1] = v[1] * z + v[5] * C + v[9] * D + v[13] * m;
            g[2] = v[2] * z + v[6] * C + v[10] * D + v[14] * m;
            g[3] = v[3] * z + v[7] * C + v[11] * D + v[15] * m;
            return g
        },
        transformQuat: function (g, m, v) {
            var z = m[0],
                C = m[1],
                D = m[2],
                H = v[0],
                K = v[1],
                M = v[2];
            v = v[3];
            var O = v * z + K * D - M * C,
                R = v * C + M * z - H * D,
                T = v * D + H * C - K * z;
            z = -H * z - K * C - M * D;
            g[0] = O * v + z * -H + R * -M - T * -K;
            g[1] = R * v + z * -K + T * -H - O * -M;
            g[2] = T * v + z * -M + O * -K - R * -H;
            g[3] = m[3];
            return g
        },
        zero: function (g) {
            g[0] = 0;
            g[1] = 0;
            g[2] = 0;
            g[3] = 0;
            return g
        },
        str: function (g) {
            return "vec4(" + g[0] + ", " + g[1] + ", " + g[2] + ", " + g[3] + ")"
        },
        exactEquals: pb,
        equals: function (g, m) {
            var v = g[0],
                z = g[1],
                C = g[2];
            g = g[3];
            var D = m[0],
                H = m[1],
                K = m[2];
            m = m[3];
            return Math.abs(v - D) <= 1E-6 * Math.max(1, Math.abs(v), Math.abs(D)) && Math.abs(z - H) <= 1E-6 * Math.max(1, Math.abs(z), Math.abs(H)) && Math.abs(C - K) <= 1E-6 * Math.max(1, Math.abs(C), Math.abs(K)) && Math.abs(g - m) <= 1E-6 * Math.max(1, Math.abs(g), Math.abs(m))
        },
        sub: Ia,
        mul: Ma,
        div: Fa,
        dist: na,
        sqrDist: Va,
        len: xa,
        sqrLen: Ga,
        forEach: lb
    });
    var mb = function () {
            var g = y(),
                m = G(1, 0, 0),
                v = G(0, 1, 0);
            return function (z, C, D) {
                var H = S(C, D);
                if (-.999999 > H) return U(g, m, C), 1E-6 > E(g) && U(g, v, C), P(g, g), qb(z, g, Math.PI), z;
                if (.999999 < H) return z[0] = 0, z[1] = 0, z[2] = 0, z[3] = 1, z;
                U(g, C, D);
                z[0] = g[0];
                z[1] = g[1];
                z[2] = g[2];
                z[3] = 1 + H;
                return bb(z, z)
            }
        }(),
        nb = function () {
            var g = cb(),
                m = cb();
            return function (v, z, C, D, H, K) {
                db(g, z, H, K);
                db(m, C, D, K);
                db(v, g, m, 2 * K * (1 - K));
                return v
            }
        }(),
        $a = function () {
            var g = f();
            return function (m, v, z, C) {
                g[0] = z[0];
                g[3] = z[1];
                g[6] = z[2];
                g[1] = C[0];
                g[4] = C[1];
                g[7] = C[2];
                g[2] = -v[0];
                g[5] = -v[1];
                g[8] = -v[2];
                return bb(m, xb(m, g))
            }
        }();
    mb = Object.freeze({
        __proto__: null,
        create: cb,
        identity: function (g) {
            g[0] = 0;
            g[1] = 0;
            g[2] = 0;
            g[3] = 1;
            return g
        },
        setAxisAngle: qb,
        getAxisAngle: function (g, m) {
            var v = 2 * Math.acos(m[3]),
                z = Math.sin(v / 2);
            1E-6 < z ? (g[0] = m[0] / z, g[1] = m[1] / z, g[2] = m[2] / z) : (g[0] = 1, g[1] = 0, g[2] = 0);
            return v
        },
        getAngle: function (g, m) {
            g = Xa(g, m);
            return Math.acos(2 * g * g - 1)
        },
        multiply: rb,
        rotateX: sb,
        rotateY: tb,
        rotateZ: ub,
        calculateW: function (g, m) {
            var v = m[0],
                z = m[1];
            m = m[2];
            g[0] = v;
            g[1] = z;
            g[2] = m;
            g[3] = Math.sqrt(Math.abs(1 - v * v - z *
                z - m * m));
            return g
        },
        exp: vb,
        ln: wb,
        pow: function (g, m, v) {
            wb(g, m);
            ya(g, g, v);
            vb(g, g);
            return g
        },
        slerp: db,
        random: function (g) {
            var m = Sa(),
                v = Sa(),
                z = Sa(),
                C = Math.sqrt(1 - m);
            m = Math.sqrt(m);
            g[0] = C * Math.sin(2 * Math.PI * v);
            g[1] = C * Math.cos(2 * Math.PI * v);
            g[2] = m * Math.sin(2 * Math.PI * z);
            g[3] = m * Math.cos(2 * Math.PI * z);
            return g
        },
        invert: function (g, m) {
            var v = m[0],
                z = m[1],
                C = m[2];
            m = m[3];
            var D = v * v + z * z + C * C + m * m;
            D = D ? 1 / D : 0;
            g[0] = -v * D;
            g[1] = -z * D;
            g[2] = -C * D;
            g[3] = m * D;
            return g
        },
        conjugate: function (g, m) {
            g[0] = -m[0];
            g[1] = -m[1];
            g[2] = -m[2];
            g[3] = m[3];
            return g
        },
        fromMat3: xb,
        fromEuler: function (g, m, v, z) {
            var C = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : "zyx",
                D = Math.PI / 360;
            m *= D;
            z *= D;
            v *= D;
            D = Math.sin(m);
            var H = Math.cos(m),
                K = Math.sin(v),
                M = Math.cos(v),
                O = Math.sin(z),
                R = Math.cos(z);
            switch (C) {
                case "xyz":
                    g[0] = D * M * R + H * K * O;
                    g[1] = H * K * R - D * M * O;
                    g[2] = H * M * O + D * K * R;
                    g[3] = H * M * R - D * K * O;
                    break;
                case "xzy":
                    g[0] = D * M * R - H * K * O;
                    g[1] = H * K * R - D * M * O;
                    g[2] = H * M * O + D * K * R;
                    g[3] = H * M * R + D * K * O;
                    break;
                case "yxz":
                    g[0] = D * M * R + H * K * O;
                    g[1] = H * K * R - D * M * O;
                    g[2] = H * M * O - D * K * R;
                    g[3] = H * M * R + D * K * O;
                    break;
                case "yzx":
                    g[0] =
                        D * M * R + H * K * O;
                    g[1] = H * K * R + D * M * O;
                    g[2] = H * M * O - D * K * R;
                    g[3] = H * M * R - D * K * O;
                    break;
                case "zxy":
                    g[0] = D * M * R - H * K * O;
                    g[1] = H * K * R + D * M * O;
                    g[2] = H * M * O + D * K * R;
                    g[3] = H * M * R - D * K * O;
                    break;
                case "zyx":
                    g[0] = D * M * R - H * K * O;
                    g[1] = H * K * R + D * M * O;
                    g[2] = H * M * O - D * K * R;
                    g[3] = H * M * R + D * K * O;
                    break;
                default:
                    throw Error("Unknown angle order " + C);
            }
            return g
        },
        str: function (g) {
            return "quat(" + g[0] + ", " + g[1] + ", " + g[2] + ", " + g[3] + ")"
        },
        clone: Z,
        fromValues: ma,
        copy: va,
        set: Na,
        add: Ea,
        mul: rb,
        scale: ya,
        dot: Xa,
        lerp: ob,
        length: xa,
        len: xa,
        squaredLength: Ga,
        sqrLen: Ga,
        normalize: bb,
        exactEquals: pb,
        equals: function (g, m) {
            return .999999 <= Math.abs(Xa(g, m))
        },
        rotationTo: mb,
        sqlerp: nb,
        setAxes: $a
    });
    nb = Object.freeze({
        __proto__: null,
        create: function () {
            var g = new sa(8);
            sa != Float32Array && (g[0] = 0, g[1] = 0, g[2] = 0, g[4] = 0, g[5] = 0, g[6] = 0, g[7] = 0);
            g[3] = 1;
            return g
        },
        clone: function (g) {
            var m = new sa(8);
            m[0] = g[0];
            m[1] = g[1];
            m[2] = g[2];
            m[3] = g[3];
            m[4] = g[4];
            m[5] = g[5];
            m[6] = g[6];
            m[7] = g[7];
            return m
        },
        fromValues: function (g, m, v, z, C, D, H, K) {
            var M = new sa(8);
            M[0] = g;
            M[1] = m;
            M[2] = v;
            M[3] = z;
            M[4] = C;
            M[5] = D;
            M[6] = H;
            M[7] = K;
            return M
        },
        fromRotationTranslationValues: function (g,
            m, v, z, C, D, H) {
            var K = new sa(8);
            K[0] = g;
            K[1] = m;
            K[2] = v;
            K[3] = z;
            C *= .5;
            D *= .5;
            H *= .5;
            K[4] = C * z + D * v - H * m;
            K[5] = D * z + H * g - C * v;
            K[6] = H * z + C * m - D * g;
            K[7] = -C * g - D * m - H * v;
            return K
        },
        fromRotationTranslation: yb,
        fromTranslation: function (g, m) {
            g[0] = 0;
            g[1] = 0;
            g[2] = 0;
            g[3] = 1;
            g[4] = .5 * m[0];
            g[5] = .5 * m[1];
            g[6] = .5 * m[2];
            g[7] = 0;
            return g
        },
        fromRotation: function (g, m) {
            g[0] = m[0];
            g[1] = m[1];
            g[2] = m[2];
            g[3] = m[3];
            g[4] = 0;
            g[5] = 0;
            g[6] = 0;
            g[7] = 0;
            return g
        },
        fromMat4: function (g, m) {
            var v = cb();
            t(v, m);
            var z = new sa(3);
            w(z, m);
            yb(g, v, z);
            return g
        },
        copy: zb,
        identity: function (g) {
            g[0] =
                0;
            g[1] = 0;
            g[2] = 0;
            g[3] = 1;
            g[4] = 0;
            g[5] = 0;
            g[6] = 0;
            g[7] = 0;
            return g
        },
        set: function (g, m, v, z, C, D, H, K, M) {
            g[0] = m;
            g[1] = v;
            g[2] = z;
            g[3] = C;
            g[4] = D;
            g[5] = H;
            g[6] = K;
            g[7] = M;
            return g
        },
        getReal: va,
        getDual: function (g, m) {
            g[0] = m[4];
            g[1] = m[5];
            g[2] = m[6];
            g[3] = m[7];
            return g
        },
        setReal: va,
        setDual: function (g, m) {
            g[4] = m[0];
            g[5] = m[1];
            g[6] = m[2];
            g[7] = m[3];
            return g
        },
        getTranslation: function (g, m) {
            var v = m[4],
                z = m[5],
                C = m[6],
                D = m[7],
                H = -m[0],
                K = -m[1],
                M = -m[2];
            m = m[3];
            g[0] = 2 * (v * m + D * H + z * M - C * K);
            g[1] = 2 * (z * m + D * K + C * H - v * M);
            g[2] = 2 * (C * m + D * M + v * K - z * H);
            return g
        },
        translate: function (g, m, v) {
            var z = m[0],
                C = m[1],
                D = m[2],
                H = m[3],
                K = .5 * v[0],
                M = .5 * v[1];
            v = .5 * v[2];
            var O = m[4],
                R = m[5],
                T = m[6];
            m = m[7];
            g[0] = z;
            g[1] = C;
            g[2] = D;
            g[3] = H;
            g[4] = H * K + C * v - D * M + O;
            g[5] = H * M + D * K - z * v + R;
            g[6] = H * v + z * M - C * K + T;
            g[7] = -z * K - C * M - D * v + m;
            return g
        },
        rotateX: function (g, m, v) {
            var z = -m[0],
                C = -m[1],
                D = -m[2],
                H = m[3],
                K = m[4],
                M = m[5],
                O = m[6],
                R = m[7],
                T = K * H + R * z + M * D - O * C,
                Y = M * H + R * C + O * z - K * D,
                X = O * H + R * D + K * C - M * z;
            K = R * H - K * z - M * C - O * D;
            sb(g, m, v);
            z = g[0];
            C = g[1];
            D = g[2];
            H = g[3];
            g[4] = T * H + K * z + Y * D - X * C;
            g[5] = Y * H + K * C + X * z - T * D;
            g[6] = X * H + K * D + T * C - Y * z;
            g[7] = K *
                H - T * z - Y * C - X * D;
            return g
        },
        rotateY: function (g, m, v) {
            var z = -m[0],
                C = -m[1],
                D = -m[2],
                H = m[3],
                K = m[4],
                M = m[5],
                O = m[6],
                R = m[7],
                T = K * H + R * z + M * D - O * C,
                Y = M * H + R * C + O * z - K * D,
                X = O * H + R * D + K * C - M * z;
            K = R * H - K * z - M * C - O * D;
            tb(g, m, v);
            z = g[0];
            C = g[1];
            D = g[2];
            H = g[3];
            g[4] = T * H + K * z + Y * D - X * C;
            g[5] = Y * H + K * C + X * z - T * D;
            g[6] = X * H + K * D + T * C - Y * z;
            g[7] = K * H - T * z - Y * C - X * D;
            return g
        },
        rotateZ: function (g, m, v) {
            var z = -m[0],
                C = -m[1],
                D = -m[2],
                H = m[3],
                K = m[4],
                M = m[5],
                O = m[6],
                R = m[7],
                T = K * H + R * z + M * D - O * C,
                Y = M * H + R * C + O * z - K * D,
                X = O * H + R * D + K * C - M * z;
            K = R * H - K * z - M * C - O * D;
            ub(g, m, v);
            z = g[0];
            C = g[1];
            D = g[2];
            H = g[3];
            g[4] = T * H + K * z + Y * D - X * C;
            g[5] = Y * H + K * C + X * z - T * D;
            g[6] = X * H + K * D + T * C - Y * z;
            g[7] = K * H - T * z - Y * C - X * D;
            return g
        },
        rotateByQuatAppend: function (g, m, v) {
            var z = v[0],
                C = v[1],
                D = v[2];
            v = v[3];
            var H = m[0],
                K = m[1],
                M = m[2],
                O = m[3];
            g[0] = H * v + O * z + K * D - M * C;
            g[1] = K * v + O * C + M * z - H * D;
            g[2] = M * v + O * D + H * C - K * z;
            g[3] = O * v - H * z - K * C - M * D;
            H = m[4];
            K = m[5];
            M = m[6];
            O = m[7];
            g[4] = H * v + O * z + K * D - M * C;
            g[5] = K * v + O * C + M * z - H * D;
            g[6] = M * v + O * D + H * C - K * z;
            g[7] = O * v - H * z - K * C - M * D;
            return g
        },
        rotateByQuatPrepend: function (g, m, v) {
            var z = m[0],
                C = m[1],
                D = m[2];
            m = m[3];
            var H = v[0],
                K = v[1],
                M = v[2],
                O =
                v[3];
            g[0] = z * O + m * H + C * M - D * K;
            g[1] = C * O + m * K + D * H - z * M;
            g[2] = D * O + m * M + z * K - C * H;
            g[3] = m * O - z * H - C * K - D * M;
            H = v[4];
            K = v[5];
            M = v[6];
            O = v[7];
            g[4] = z * O + m * H + C * M - D * K;
            g[5] = C * O + m * K + D * H - z * M;
            g[6] = D * O + m * M + z * K - C * H;
            g[7] = m * O - z * H - C * K - D * M;
            return g
        },
        rotateAroundAxis: function (g, m, v, z) {
            if (1E-6 > Math.abs(z)) return zb(g, m);
            var C = Math.hypot(v[0], v[1], v[2]);
            z *= .5;
            var D = Math.sin(z),
                H = D * v[0] / C,
                K = D * v[1] / C;
            v = D * v[2] / C;
            z = Math.cos(z);
            C = m[0];
            D = m[1];
            var M = m[2],
                O = m[3];
            g[0] = C * z + O * H + D * v - M * K;
            g[1] = D * z + O * K + M * H - C * v;
            g[2] = M * z + O * v + C * K - D * H;
            g[3] = O * z - C * H - D * K - M * v;
            C = m[4];
            D = m[5];
            M = m[6];
            m = m[7];
            g[4] = C * z + m * H + D * v - M * K;
            g[5] = D * z + m * K + M * H - C * v;
            g[6] = M * z + m * v + C * K - D * H;
            g[7] = m * z - C * H - D * K - M * v;
            return g
        },
        add: function (g, m, v) {
            g[0] = m[0] + v[0];
            g[1] = m[1] + v[1];
            g[2] = m[2] + v[2];
            g[3] = m[3] + v[3];
            g[4] = m[4] + v[4];
            g[5] = m[5] + v[5];
            g[6] = m[6] + v[6];
            g[7] = m[7] + v[7];
            return g
        },
        multiply: eb,
        mul: eb,
        scale: function (g, m, v) {
            g[0] = m[0] * v;
            g[1] = m[1] * v;
            g[2] = m[2] * v;
            g[3] = m[3] * v;
            g[4] = m[4] * v;
            g[5] = m[5] * v;
            g[6] = m[6] * v;
            g[7] = m[7] * v;
            return g
        },
        dot: Xa,
        lerp: function (g, m, v, z) {
            var C = 1 - z;
            0 > Xa(m, v) && (z = -z);
            g[0] = m[0] * C + v[0] * z;
            g[1] =
                m[1] * C + v[1] * z;
            g[2] = m[2] * C + v[2] * z;
            g[3] = m[3] * C + v[3] * z;
            g[4] = m[4] * C + v[4] * z;
            g[5] = m[5] * C + v[5] * z;
            g[6] = m[6] * C + v[6] * z;
            g[7] = m[7] * C + v[7] * z;
            return g
        },
        invert: function (g, m) {
            var v = Ga(m);
            g[0] = -m[0] / v;
            g[1] = -m[1] / v;
            g[2] = -m[2] / v;
            g[3] = m[3] / v;
            g[4] = -m[4] / v;
            g[5] = -m[5] / v;
            g[6] = -m[6] / v;
            g[7] = m[7] / v;
            return g
        },
        conjugate: function (g, m) {
            g[0] = -m[0];
            g[1] = -m[1];
            g[2] = -m[2];
            g[3] = m[3];
            g[4] = -m[4];
            g[5] = -m[5];
            g[6] = -m[6];
            g[7] = m[7];
            return g
        },
        length: xa,
        len: xa,
        squaredLength: Ga,
        sqrLen: Ga,
        normalize: function (g, m) {
            var v = Ga(m);
            if (0 < v) {
                v = Math.sqrt(v);
                var z = m[0] / v,
                    C = m[1] / v,
                    D = m[2] / v,
                    H = m[3] / v,
                    K = m[4],
                    M = m[5],
                    O = m[6];
                m = m[7];
                var R = z * K + C * M + D * O + H * m;
                g[0] = z;
                g[1] = C;
                g[2] = D;
                g[3] = H;
                g[4] = (K - z * R) / v;
                g[5] = (M - C * R) / v;
                g[6] = (O - D * R) / v;
                g[7] = (m - H * R) / v
            }
            return g
        },
        str: function (g) {
            return "quat2(" + g[0] + ", " + g[1] + ", " + g[2] + ", " + g[3] + ", " + g[4] + ", " + g[5] + ", " + g[6] + ", " + g[7] + ")"
        },
        exactEquals: function (g, m) {
            return g[0] === m[0] && g[1] === m[1] && g[2] === m[2] && g[3] === m[3] && g[4] === m[4] && g[5] === m[5] && g[6] === m[6] && g[7] === m[7]
        },
        equals: function (g, m) {
            var v = g[0],
                z = g[1],
                C = g[2],
                D = g[3],
                H = g[4],
                K = g[5],
                M = g[6];
            g = g[7];
            var O = m[0],
                R = m[1],
                T = m[2],
                Y = m[3],
                X = m[4],
                fa = m[5],
                ha = m[6];
            m = m[7];
            return Math.abs(v - O) <= 1E-6 * Math.max(1, Math.abs(v), Math.abs(O)) && Math.abs(z - R) <= 1E-6 * Math.max(1, Math.abs(z), Math.abs(R)) && Math.abs(C - T) <= 1E-6 * Math.max(1, Math.abs(C), Math.abs(T)) && Math.abs(D - Y) <= 1E-6 * Math.max(1, Math.abs(D), Math.abs(Y)) && Math.abs(H - X) <= 1E-6 * Math.max(1, Math.abs(H), Math.abs(X)) && Math.abs(K - fa) <= 1E-6 * Math.max(1, Math.abs(K), Math.abs(fa)) && Math.abs(M - ha) <= 1E-6 * Math.max(1, Math.abs(M), Math.abs(ha)) && Math.abs(g - m) <=
                1E-6 * Math.max(1, Math.abs(g), Math.abs(m))
        }
    });
    $a = function () {
        var g = Wa();
        return function (m, v, z, C, D, H) {
            v || (v = 2);
            z || (z = 0);
            for (C = C ? Math.min(C * v + z, m.length) : m.length; z < C; z += v) g[0] = m[z], g[1] = m[z + 1], D(g, g, H), m[z] = g[0], m[z + 1] = g[1];
            return m
        }
    }();
    $a = Object.freeze({
        __proto__: null,
        create: Wa,
        clone: function (g) {
            var m = new sa(2);
            m[0] = g[0];
            m[1] = g[1];
            return m
        },
        fromValues: function (g, m) {
            var v = new sa(2);
            v[0] = g;
            v[1] = m;
            return v
        },
        copy: function (g, m) {
            g[0] = m[0];
            g[1] = m[1];
            return g
        },
        set: function (g, m, v) {
            g[0] = m;
            g[1] = v;
            return g
        },
        add: function (g,
            m, v) {
            g[0] = m[0] + v[0];
            g[1] = m[1] + v[1];
            return g
        },
        subtract: fb,
        multiply: gb,
        divide: Ya,
        ceil: function (g, m) {
            g[0] = Math.ceil(m[0]);
            g[1] = Math.ceil(m[1]);
            return g
        },
        floor: function (g, m) {
            g[0] = Math.floor(m[0]);
            g[1] = Math.floor(m[1]);
            return g
        },
        min: function (g, m, v) {
            g[0] = Math.min(m[0], v[0]);
            g[1] = Math.min(m[1], v[1]);
            return g
        },
        max: function (g, m, v) {
            g[0] = Math.max(m[0], v[0]);
            g[1] = Math.max(m[1], v[1]);
            return g
        },
        round: function (g, m) {
            g[0] = Math.round(m[0]);
            g[1] = Math.round(m[1]);
            return g
        },
        scale: function (g, m, v) {
            g[0] = m[0] * v;
            g[1] = m[1] *
                v;
            return g
        },
        scaleAndAdd: function (g, m, v, z) {
            g[0] = m[0] + v[0] * z;
            g[1] = m[1] + v[1] * z;
            return g
        },
        distance: hb,
        squaredDistance: Ta,
        length: ib,
        squaredLength: jb,
        negate: function (g, m) {
            g[0] = -m[0];
            g[1] = -m[1];
            return g
        },
        inverse: function (g, m) {
            g[0] = 1 / m[0];
            g[1] = 1 / m[1];
            return g
        },
        normalize: function (g, m) {
            var v = m[0],
                z = m[1];
            v = v * v + z * z;
            0 < v && (v = 1 / Math.sqrt(v));
            g[0] = m[0] * v;
            g[1] = m[1] * v;
            return g
        },
        dot: function (g, m) {
            return g[0] * m[0] + g[1] * m[1]
        },
        cross: function (g, m, v) {
            m = m[0] * v[1] - m[1] * v[0];
            g[0] = g[1] = 0;
            g[2] = m;
            return g
        },
        lerp: function (g, m, v,
            z) {
            var C = m[0];
            m = m[1];
            g[0] = C + z * (v[0] - C);
            g[1] = m + z * (v[1] - m);
            return g
        },
        random: function (g, m) {
            m = m || 1;
            var v = 2 * Sa() * Math.PI;
            g[0] = Math.cos(v) * m;
            g[1] = Math.sin(v) * m;
            return g
        },
        transformMat2: function (g, m, v) {
            var z = m[0];
            m = m[1];
            g[0] = v[0] * z + v[2] * m;
            g[1] = v[1] * z + v[3] * m;
            return g
        },
        transformMat2d: function (g, m, v) {
            var z = m[0];
            m = m[1];
            g[0] = v[0] * z + v[2] * m + v[4];
            g[1] = v[1] * z + v[3] * m + v[5];
            return g
        },
        transformMat3: function (g, m, v) {
            var z = m[0];
            m = m[1];
            g[0] = v[0] * z + v[3] * m + v[6];
            g[1] = v[1] * z + v[4] * m + v[7];
            return g
        },
        transformMat4: function (g, m, v) {
            var z =
                m[0];
            m = m[1];
            g[0] = v[0] * z + v[4] * m + v[12];
            g[1] = v[1] * z + v[5] * m + v[13];
            return g
        },
        rotate: function (g, m, v, z) {
            var C = m[0] - v[0];
            m = m[1] - v[1];
            var D = Math.sin(z);
            z = Math.cos(z);
            g[0] = C * z - m * D + v[0];
            g[1] = C * D + m * z + v[1];
            return g
        },
        angle: function (g, m) {
            var v = g[0];
            g = g[1];
            var z = m[0];
            m = m[1];
            var C = Math.sqrt((v * v + g * g) * (z * z + m * m));
            return Math.acos(Math.min(Math.max(C && (v * z + g * m) / C, -1), 1))
        },
        zero: function (g) {
            g[0] = 0;
            g[1] = 0;
            return g
        },
        str: function (g) {
            return "vec2(" + g[0] + ", " + g[1] + ")"
        },
        exactEquals: function (g, m) {
            return g[0] === m[0] && g[1] === m[1]
        },
        equals: function (g, m) {
            var v = g[0];
            g = g[1];
            var z = m[0];
            m = m[1];
            return Math.abs(v - z) <= 1E-6 * Math.max(1, Math.abs(v), Math.abs(z)) && Math.abs(g - m) <= 1E-6 * Math.max(1, Math.abs(g), Math.abs(m))
        },
        len: ib,
        sub: fb,
        mul: gb,
        div: Ya,
        dist: hb,
        sqrDist: Ta,
        sqrLen: jb,
        forEach: $a
    });
    e.glMatrix = Db;
    e.mat2 = Eb;
    e.mat2d = Fb;
    e.mat3 = Gb;
    e.mat4 = Hb;
    e.quat = mb;
    e.quat2 = nb;
    e.vec2 = $a;
    e.vec3 = kb;
    e.vec4 = lb;
    Object.defineProperty(e, "__esModule", {
        value: !0
    })
}); {
    "use strict";

    function e(B, I, L) {
        var P = [0, 0];
        var S = B[1][1] - B[0][1];
        var U = B[0][0] - B[1][0];
        B = S * B[0][0] + U * B[0][1];
        var V = I[1][1] - I[0][1];
        var Z = I[0][0] - I[1][0];
        I = V * I[0][0] + Z * I[0][1];
        var ma = S * Z - V * U;
        F(ma, 0, L || 0) || (P[0] = (Z * B - U * I) / ma, P[1] = (S * I - V * B) / ma);
        return P
    }

    function a(B, I, L, P) {
        var S = I[0] - B[0];
        I = I[1] - B[1];
        var U = P[0] - L[0],
            V = P[1] - L[1];
        if (0 === U * I - V * S) return !1;
        P = (S * (L[1] - B[1]) + I * (B[0] - L[0])) / (U * I - V * S);
        B = (U * (B[1] - L[1]) + V * (L[0] - B[0])) / (V * S - U * I);
        return 0 <= P && 1 >= P && 0 <= B && 1 >= B
    }

    function b(B, I, L) {
        return (I[0] - B[0]) *
            (L[1] - B[1]) - (L[0] - B[0]) * (I[1] - B[1])
    }

    function d(B, I, L) {
        return 0 < b(B, I, L)
    }

    function c(B, I, L) {
        return 0 <= b(B, I, L)
    }

    function f(B, I, L) {
        return 0 > b(B, I, L)
    }

    function k(B, I, L) {
        return 0 >= b(B, I, L)
    }
    var tmpPoint1$$module$str$c3runtime = [],
        tmpPoint2$$module$str$c3runtime = [];

    function h(B, I, L, P) {
        if (P) {
            var S = tmpPoint1$$module$str$c3runtime,
                U = tmpPoint2$$module$str$c3runtime;
            S[0] = I[0] - B[0];
            S[1] = I[1] - B[1];
            U[0] = L[0] - I[0];
            U[1] = L[1] - I[1];
            return Math.acos((S[0] * U[0] + S[1] * U[1]) / (Math.sqrt(S[0] * S[0] + S[1] * S[1]) * Math.sqrt(U[0] * U[0] +
                U[1] * U[1]))) < P
        }
        return 0 === b(B, I, L)
    }

    function l(B, I) {
        var L = I[0] - B[0];
        B = I[1] - B[1];
        return L * L + B * B
    }

    function n(B, I) {
        var L = B.length;
        return B[0 > I ? I % L + L : I % L]
    }

    function u(B) {
        B.length = 0
    }

    function w(B, I, L, P) {
        for (; L < P; L++) B.push(I[L])
    }

    function q(B) {
        for (var I = [], L = B.length, P = 0; P !== L; P++) I.push(B.pop());
        for (P = 0; P !== L; P++) B[P] = I[P]
    }

    function t(B, I) {
        return f(n(B, I - 1), n(B, I), n(B, I + 1))
    }
    var tmpLine1$$module$str$c3runtime = [],
        tmpLine2$$module$str$c3runtime = [];

    function p(B, I, L) {
        var P = tmpLine1$$module$str$c3runtime,
            S = tmpLine2$$module$str$c3runtime;
        if (c(n(B, I + 1), n(B, I), n(B, L)) && k(n(B, I - 1), n(B, I), n(B, L))) return !1;
        var U = l(n(B, I), n(B, L));
        for (var V = 0; V !== B.length; ++V)
            if ((V + 1) % B.length !== I && V !== I && c(n(B, I), n(B, L), n(B, V + 1)) && k(n(B, I), n(B, L), n(B, V))) {
                P[0] = n(B, I);
                P[1] = n(B, L);
                S[0] = n(B, V);
                S[1] = n(B, V + 1);
                var Z = e(P, S);
                if (l(n(B, I), Z) < U) return !1
            } return !0
    }

    function r(B, I, L) {
        for (var P = 0; P !== B.length; ++P)
            if (P !== I && P !== L && (P + 1) % B.length !== I && (P + 1) % B.length !== L && a(n(B, I), n(B, L), n(B, P), n(B, P + 1))) return !1;
        return !0
    }

    function x(B, I, L, P) {
        P = P || [];
        u(P);
        if (I < L)
            for (var S =
                    I; S <= L; S++) P.push(B[S]);
        else {
            for (S = 0; S <= L; S++) P.push(B[S]);
            for (S = I; S < B.length; S++) P.push(B[S])
        }
        return P
    }

    function y(B) {
        for (var I = [], L, P, S = [], U = Number.MAX_VALUE, V = 0; V < B.length; ++V)
            if (t(B, V))
                for (var Z = 0; Z < B.length; ++Z)
                    if (p(B, V, Z)) {
                        L = y(x(B, V, Z, S));
                        P = y(x(B, Z, V, S));
                        for (var ma = 0; ma < P.length; ma++) L.push(P[ma]);
                        L.length < U && (I = L, U = L.length, I.push([n(B, V), n(B, Z)]))
                    } return I
    }

    function E(B, I) {
        if (0 === I.length) return [B];
        if (I instanceof Array && I.length && I[0] instanceof Array && 2 === I[0].length && I[0][0] instanceof Array) {
            B = [B];
            for (var L = 0; L < I.length; L++)
                for (var P = I[L], S = 0; S < B.length; S++) {
                    var U = E(B[S], P);
                    if (U) {
                        B.splice(S, 1);
                        B.push(U[0], U[1]);
                        break
                    }
                }
            return B
        }
        P = I;
        L = B.indexOf(P[0]);
        S = B.indexOf(P[1]);
        return -1 !== L && -1 !== S ? [x(B, L, S), x(B, S, L)] : !1
    }

    function G(B, I, L, P, S) {
        var U = I[1] - B[1];
        I = B[0] - I[0];
        B = U * B[0] + I * B[1];
        var V = P[1] - L[1];
        P = L[0] - P[0];
        L = V * L[0] + P * L[1];
        var Z = U * P - V * I;
        return F(Z, 0, S || 0) ? [0, 0] : [(P * B - I * L) / Z, (U * L - V * B) / Z]
    }

    function A(B, I, L, P, S, U, V) {
        U = U || 100;
        V = V || 0;
        S = S || 25;
        I = "undefined" !== typeof I ? I : [];
        L = L || [];
        P = P || [];
        var Z = [0, 0],
            ma = [0, 0],
            va = [0, 0],
            Na, Ea = 0,
            Ia = 0,
            Ma = 0,
            Fa = [],
            ya = [];
        if (3 > B.length) return I;
        V++;
        if (V > U) return console.warn("quickDecomp: max level (" + U + ") reached."), I;
        for (var na = 0; na < B.length; ++na)
            if (t(B, na)) {
                L.push(B[na]);
                var Va = Na = Number.MAX_VALUE;
                for (var xa = 0; xa < B.length; ++xa) {
                    if (d(n(B, na - 1), n(B, na), n(B, xa)) && k(n(B, na - 1), n(B, na), n(B, xa - 1)) && (va = G(n(B, na - 1), n(B, na), n(B, xa), n(B, xa - 1)), f(n(B, na + 1), n(B, na), va))) {
                        var Ga = l(B[na], va);
                        Ga < Na && (Na = Ga, ma = va, Ia = xa)
                    }
                    d(n(B, na + 1), n(B, na), n(B, xa + 1)) && k(n(B, na + 1), n(B, na), n(B, xa)) &&
                        (va = G(n(B, na + 1), n(B, na), n(B, xa), n(B, xa + 1)), d(n(B, na - 1), n(B, na), va) && (Ga = l(B[na], va), Ga < Va && (Va = Ga, Z = va, Ea = xa)))
                }
                if (Ia === (Ea + 1) % B.length) va[0] = (ma[0] + Z[0]) / 2, va[1] = (ma[1] + Z[1]) / 2, P.push(va), na < Ea ? (w(Fa, B, na, Ea + 1), Fa.push(va), ya.push(va), 0 !== Ia && w(ya, B, Ia, B.length), w(ya, B, 0, na + 1)) : (0 !== na && w(Fa, B, na, B.length), w(Fa, B, 0, Ea + 1), Fa.push(va), ya.push(va), w(ya, B, Ia, na + 1));
                else {
                    Ia > Ea && (Ea += B.length);
                    Z = Number.MAX_VALUE;
                    if (Ea < Ia) return I;
                    for (xa = Ia; xa <= Ea; ++xa) c(n(B, na - 1), n(B, na), n(B, xa)) && k(n(B, na + 1), n(B, na),
                        n(B, xa)) && (Ga = l(n(B, na), n(B, xa)), Ga < Z && r(B, na, xa) && (Z = Ga, Ma = xa % B.length));
                    na < Ma ? (w(Fa, B, na, Ma + 1), 0 !== Ma && w(ya, B, Ma, B.length), w(ya, B, 0, na + 1)) : (0 !== na && w(Fa, B, na, B.length), w(Fa, B, 0, Ma + 1), w(ya, B, Ma, na + 1))
                }
                Fa.length < ya.length ? (A(Fa, I, L, P, S, U, V), A(ya, I, L, P, S, U, V)) : (A(ya, I, L, P, S, U, V), A(Fa, I, L, P, S, U, V));
                return I
            } I.push(B);
        return I
    }

    function F(B, I, L) {
        return Math.abs(B - I) <= (L || 0)
    }

    function J(B, I, L) {
        return F(B[0], I[0], L) && F(B[1], I[1], L)
    }
    self.polyDecomp = {
        decomp: function (B) {
            var I = y(B);
            return 0 < I.length ? E(B, I) : [B]
        },
        quickDecomp: A,
        isSimple: function (B) {
            var I;
            for (I = 0; I < B.length - 1; I++)
                for (var L = 0; L < I - 1; L++)
                    if (a(B[I], B[I + 1], B[L], B[L + 1])) return !1;
            for (I = 1; I < B.length - 2; I++)
                if (a(B[0], B[B.length - 1], B[I], B[I + 1])) return !1;
            return !0
        },
        removeCollinearPoints: function (B, I) {
            for (var L = 0, P = B.length - 1; 3 < B.length && 0 <= P; --P) h(n(B, P - 1), n(B, P), n(B, P + 1), I) && (B.splice(P % B.length, 1), L++);
            return L
        },
        removeDuplicatePoints: function (B, I) {
            for (var L = B.length - 1; 1 <= L; --L)
                for (var P = B[L], S = L - 1; 0 <= S; --S) J(P, B[S], I) && B.splice(L, 1)
        },
        makeCCW: function (B) {
            for (var I =
                    0, L = 1; L < B.length; ++L)
                if (B[L][1] < B[I][1] || B[L][1] === B[I][1] && B[L][0] > B[I][0]) I = L;
            if (d(n(B, I - 1), n(B, I), n(B, I + 1))) return !1;
            q(B);
            return !0
        }
    }
} {
    "use strict";
    let e = !1,
        a = !1,
        b = "dev";
    const d = self.C3 = class {
        constructor() {
            throw TypeError("static class can't be instantiated");
        }
        static SetReady() {
            e = !0
        }
        static IsReady() {
            return e
        }
        static SetAppStarted() {
            a = !0
        }
        static HasAppStarted() {
            return a
        }
        static SetBuildMode(c) {
            b = c
        }
        static GetBuildMode() {
            return b
        }
        static IsReleaseBuild() {
            return "final" === b
        }
    };
    d.isDebug = !1;
    d.isDebugDefend = !1;
    d.hardwareConcurrency = navigator.hardwareConcurrency || 2;
    self.C3X = {}
} {
    "use strict";
    const e = self.C3;
    e.QueryParser = class {
        constructor(a) {
            this._queryString = a;
            this._parameters = new Map;
            this._Parse()
        }
        _Parse() {
            var a = this._queryString;
            if (a.startsWith("?") || a.startsWith("#")) a = a.substr(1);
            a = a.split("&");
            for (const b of a) this._ParseParameter(b)
        }
        _ParseParameter(a) {
            if (a)
                if (a.includes("=")) {
                    var b = a.indexOf("="),
                        d = decodeURIComponent(a.substring(0, b));
                    a = decodeURIComponent(a.substring(b + 1));
                    this._parameters.set(d, a)
                } else this._parameters.set(a, null)
        }
        LogAll() {
            for (const a of this._parameters) console.log("[QueryParser] Parameter '" +
                a[0] + "' = " + (null === a[1] ? "null" : "'" + a[1] + "'"))
        }
        Has(a) {
            return this._parameters.has(a)
        }
        Get(a) {
            a = this._parameters.get(a);
            return "undefined" === typeof a ? null : a
        }
        ClearHash() {
            history.replaceState("", document.title, location.pathname + location.search)
        }
        Reparse(a) {
            this._queryString = a;
            this._parameters.clear();
            this._Parse()
        }
    };
    e.QueryString = new e.QueryParser(location.search);
    e.LocationHashString = new e.QueryParser(location.hash);
    "dev" !== e.QueryString.Get("mode") && e.SetBuildMode("final")
} {
    "use strict";
    const e = self.C3,
        a = navigator.userAgent;
    let b = {
        linux: /linux|openbsd|freebsd|netbsd/i.test(a),
        chromeOS: /CrOS/.test(a),
        windowsTizen: /trident|iemobile|msie|tizen/i.test(a),
        genericMS: /trident|iemobile|msie|edge\//i.test(a),
        opera: /OPR\//.test(a),
        blackberry: /bb10/i.test(a),
        edge: /edge\//i.test(a),
        trident: /trident/i.test(a),
        webkit: /webkit/i.test(a),
        safari: /safari\//i.test(a),
        chrome: /chrome\//i.test(a),
        chromium: /chromium\//i.test(a),
        crosswalk: /crosswalk|xwalk/i.test(a),
        nwjs: /nwjs/i.test(a),
        amazonwebapp: /amazonwebappplatform/i.test(a),
        webview: /wv\)/.test(a),
        android: /android/i.test(a),
        nokia: /nokiabrowser\/[0-9.]+/i.test(a)
    };
    var JSCompiler_object_inline_windows_0 = /windows\s+nt\s+\d+\.\d+/i.exec(a),
        JSCompiler_object_inline_OSX_1 = /mac\s+os\s+x\s+[0-9_]+/i.exec(a),
        JSCompiler_object_inline_android_2 = /android\s+[0-9.]+/i.exec(a),
        JSCompiler_object_inline_opera_3 = /OPR\/[0-9.]+/.exec(a),
        JSCompiler_object_inline_tizen_4 = /tizen\s+[0-9.]+/i.exec(a),
        JSCompiler_object_inline_iphone_5 = /iphone\s+os\s+[0-9_]+/i.exec(a),
        JSCompiler_object_inline_ipad_6 =
        /ipad[^)]*os\s+[0-9_]+/i.exec(a),
        JSCompiler_object_inline_winPhone_7 = /windows\s+phone\s+[0-9.]+/i.exec(a),
        JSCompiler_object_inline_winPhoneOS_8 = /windows\s+phone\s+os\s+[0-9.]+/i.exec(a),
        JSCompiler_object_inline_chrome_9 = /chrome\/[0-9.]+/i.exec(a),
        JSCompiler_object_inline_chromium_10 = /chromium\/[0-9.]+/i.exec(a),
        JSCompiler_object_inline_nwjs_11 = /nwjs\/[0-9.]+/i.exec(a),
        JSCompiler_object_inline_firefox_12 = /firefox\/[0-9.]+/i.exec(a),
        JSCompiler_object_inline_ie_13 = /msie\s+[0-9.]+/i.exec(a),
        JSCompiler_object_inline_edge_14 =
        /edge\/[0-9.]+/i.exec(a),
        JSCompiler_object_inline_edgeChromium_15 = /edg\/[0-9.]+/i.exec(a),
        JSCompiler_object_inline_silk_16 = /silk\/[0-9.]+/i.exec(a);
    let d = "(unknown)",
        c = "(unknown)",
        f = "(unknown)",
        k = "(unknown)",
        h = "(unknown)",
        l = "browser",
        n = !1,
        u = !1,
        w = new Map;

    function q(p, r, x) {
        !0 === r ? (x(), w.set(p, !0)) : r && r.length && (x(r[0]), w.set(p, !0))
    }
    q("isWindows", JSCompiler_object_inline_windows_0, p => {
        d = "Windows";
        if (p = p.split(" ")[2]) switch (p) {
            case "5.0":
                c = "2000";
                break;
            case "5.1":
                c = "XP";
                break;
            case "5.2":
                c = "XP";
                break;
            case "6.0":
                c = "Vista";
                break;
            case "6.1":
                c = "7";
                break;
            case "6.2":
                c = "8";
                break;
            case "6.3":
                c = "8.1";
                break;
            case "10.0":
                c = "10"
        }
    });
    q("isOSX", JSCompiler_object_inline_OSX_1, p => {
        d = "Mac OS X";
        (p = p.split(" ")[3]) && (c = p.replace("_", "."))
    });
    q("isLinux", b.linux, () => {
        d = "Linux"
    });
    q("isChromeOS", b.chromeOS, () => {
        d = "Chrome OS"
    });
    q("isAndroid", !b.windowsTizen && JSCompiler_object_inline_android_2, p => {
        d = "Android";
        (p = p.split(" ")[1]) && (c = p)
    });
    q("isTizen", JSCompiler_object_inline_tizen_4, p => {
        d = "Tizen";
        (p = p.split(" ")[1]) && (c =
            p)
    });
    q("isIPhone", !b.windowsTizen && JSCompiler_object_inline_iphone_5, p => {
        d = "iOS";
        (p = p.split(" ")[2]) && (c = p.replace("_", "."))
    });
    q("isIPad", !b.windowsTizen && JSCompiler_object_inline_ipad_6, p => {
        d = "iOS";
        (p = p.split(" ")[3]) && (c = p.replace("_", "."))
    });
    q("isWindowsPhone", JSCompiler_object_inline_winPhone_7, p => {
        d = "Windows Phone";
        (p = p.split(" ")[2]) && (c = p)
    });
    q("isWindowsPhoneOS", JSCompiler_object_inline_winPhoneOS_8, p => {
        d = "Windows Phone";
        (p = p.split(" ")[3]) && (c = p)
    });
    q("isBlackberry", b.blackberry, () => {
        d = "Blackberry";
        c = "10";
        f = "stock";
        h = "webkit"
    });
    q("isChrome", !b.edge && !b.opera && JSCompiler_object_inline_chrome_9, p => {
        f = "Chrome";
        h = "Chromium";
        (p = p.split("/")[1]) && (k = p)
    });
    q("isOpera", JSCompiler_object_inline_opera_3, p => {
        f = "Opera";
        h = "Chromium";
        (p = p.split("/")[1]) && (k = p)
    });
    q("isChromium", JSCompiler_object_inline_chromium_10, p => {
        h = f = "Chromium";
        (p = p.split("/")[1]) && (k = p)
    });
    q("isFirefox", JSCompiler_object_inline_firefox_12, p => {
        f = "Firefox";
        h = "Gecko";
        (p = p.split("/")[1]) && (k = p)
    });
    q("isInternetExplorer", JSCompiler_object_inline_ie_13,
        p => {
            f = "Internet Explorer";
            h = "Trident";
            (p = p.split(" ")[1]) && (k = p)
        });
    q("isTrident", "Internet Explorer" !== f && b.trident, () => {
        h = "Trident";
        var p = /rv:[0-9.]+/i.exec(a);
        p && p.length && (f = "Internet Explorer", (p = p[0].split(":")[1]) && (k = p))
    });
    q("isEdge", JSCompiler_object_inline_edge_14, p => {
        h = f = "Edge";
        (p = p.split("/")[1]) && (k = p)
    });
    q("isEdgeChromium", JSCompiler_object_inline_edgeChromium_15, p => {
        f = "Edge";
        h = "Chromium";
        (p = p.split("/")[1]) && (k = p)
    });
    q("isSafari", b.safari && !b.nokia && !b.chrome && !b.chromium && !b.genericIE &&
        !b.blackberry, () => {
            f = "Safari";
            h = "WebKit";
            var p = /version\/[0-9.]+/i.exec(a),
                r = /crios\/[0-9.]+/i.exec(a),
                x = /fxios\/[0-9.]+/i.exec(a);
            p && p.length && (p = p[0].split("/")[1]) && (k = p);
            r && r.length && (f = "Chrome for iOS", (r = r[0].split("/")[1]) && (k = r));
            x && x.length && (f = "Firefox for iOS", (x = x[0].split("/")[1]) && (k = x))
        });
    q("isSilk", JSCompiler_object_inline_silk_16, p => {
        f = "Silk";
        (p = p.split("/")[1]) && (k = p)
    });
    q("isCrosswalk", b.crosswalk, () => l = "crosswalk");
    q("isCordova", self.device && (self.device.cordova || self.device.phonegap),
        () => l = "cordova");
    q("isNWJS", JSCompiler_object_inline_nwjs_11, p => {
        l = "nwjs";
        f = "NW.js";
        h = "Chromium";
        (p = p.split("/")[1]) && (k = p)
    });
    q("isAmazonWebApp", b.amazonwebapp, () => l = "webapp");
    q("isHomeScreenWebApp", "nwjs" !== l && "undefined" !== typeof window && (window.matchMedia && window.matchMedia("(display-mode: standalone)").matches || navigator.standalone), () => l = "webapp");
    q("isFalseSafari", "Safari" === f && ("Android" === d || "Tizen" === d || "Blackberry" === d), () => f = "stock");
    q("isAndroidWebview", "Chrome" === f && "browser" === l && b.webview,
        () => l = "webview");
    q("isFirefoxOS", "Firefox" === f && "(unknown)" === d, () => d = "Firefox OS");
    q("isAndroidFallback", "(unknown)" === d && !b.windowsTizen && b.android, () => d = "Android");
    q("isTridentFallback", "(unknown)" === d && b.trident, () => h = "Trident");
    q("isWebkitFallback", "(unknown)" === d && b.webkit, () => h = "WebKit");
    q("isDesktop", (() => "Windows" === d || "Mac OS X" === d || "Linux" === d || "Chrome OS" === d || "nwjs" === l)(), () => n = !0);
    u = "nwjs" === l;
    const t = "Mac OS X" === d && navigator.maxTouchPoints && 2 < navigator.maxTouchPoints;
    t && (d = "iOS",
        c = k, u = n = !1);
    e.Platform = {
        OS: d,
        OSVersion: c,
        Browser: f,
        BrowserVersion: k,
        BrowserVersionNumber: parseFloat(k),
        BrowserEngine: h,
        Context: l,
        IsDesktop: n,
        IsMobile: !n,
        IsDesktopApp: u,
        IsChromeWebStore: !!(self.chrome && self.chrome.runtime && self.chrome.runtime.id),
        IsAppleOS: "Mac OS X" === d || "iOS" === d,
        IsIpadOS: t,
        IsLinux: "Linux" === d
    }
}
"use strict"; {
    const e = new Map,
        a = "undefined" !== typeof IDBObjectStore && "function" === typeof IDBObjectStore.prototype.getAll,
        b = "undefined" !== typeof IDBObjectStore && "function" === typeof IDBObjectStore.prototype.getAllKeys;

    function d(t) {
        return new Promise((p, r) => {
            t.onsuccess = () => p(t.result);
            t.onerror = () => r(t.error)
        })
    }

    function c(t) {
        return new Promise((p, r) => {
            t.oncomplete = () => p();
            t.onerror = () => r(t.error);
            t.onabort = () => r(t.error)
        })
    }

    function f(t, p) {
        return h(t, p)
    }

    function k(t, p) {
        return h(t, p, !0)
    }
    async function h(t, p, r = !1,
        x = !0) {
        const y = await l(t);
        try {
            const E = y.transaction(["keyvaluepairs"], r ? "readwrite" : "readonly");
            return p(E)
        } catch (E) {
            if (x && "InvalidStateError" === E.name) return e.delete(t), h(t, p, r, !1);
            throw E;
        }
    }

    function l(t) {
        u(t);
        let p = e.get(t);
        p instanceof Promise || (p = n(t), e.set(t, p), p.catch(r => e.delete(t)));
        return p
    }
    async function n(t) {
        u(t);
        const p = indexedDB.open(t, 2);
        p.addEventListener("upgradeneeded", r => {
            try {
                r.target.result.createObjectStore("keyvaluepairs")
            } catch (x) {
                console.error(`Failed to create objectstore for database ${t}`,
                    x)
            }
        });
        return d(p)
    }

    function u(t) {
        if ("string" !== typeof t) throw new TypeError("expected string");
    }

    function w(t, p) {
        const r = t.objectStore("keyvaluepairs").openCursor();
        return new Promise(x => {
            const y = [];
            r.onsuccess = E => {
                if (E = E.target.result) {
                    switch (p) {
                        case "entries":
                            y.push([E.key, E.value]);
                            break;
                        case "keys":
                            y.push(E.key);
                            break;
                        case "values":
                            y.push(E.value)
                    }
                    E.continue()
                } else x(y)
            }
        })
    }
    class q {
        constructor(t) {
            u(t);
            this.name = t
        }
        async ready() {
            await l(this.name)
        }
        set(t, p) {
            u(t);
            return k(this.name, async r => {
                var x = r.objectStore("keyvaluepairs").put(p,
                    t);
                x = d(x);
                r = c(r);
                await Promise.all([r, x])
            })
        }
        get(t) {
            u(t);
            return f(this.name, async p => {
                var r = p.objectStore("keyvaluepairs").get(t);
                r = d(r);
                p = c(p);
                [, p] = await Promise.all([p, r]);
                return p
            })
        }
        delete(t) {
            u(t);
            return k(this.name, async p => {
                var r = p.objectStore("keyvaluepairs").delete(t);
                r = d(r);
                p = c(p);
                await Promise.all([p, r])
            })
        }
        clear() {
            return k(this.name, async t => {
                var p = t.objectStore("keyvaluepairs").clear();
                p = d(p);
                t = c(t);
                await Promise.all([t, p])
            })
        }
        keys() {
            return f(this.name, async t => {
                if (b) {
                    var p = t.objectStore("keyvaluepairs").getAllKeys();
                    p = d(p)
                } else p = w(t, "keys");
                t = c(t);
                [, t] = await Promise.all([t, p]);
                return t
            })
        }
        values() {
            return f(this.name, async t => {
                if (a) {
                    var p = t.objectStore("keyvaluepairs").getAll();
                    p = d(p)
                } else p = w(t, "values");
                t = c(t);
                [, t] = await Promise.all([t, p]);
                return t
            })
        }
        entries() {
            return f(this.name, async t => {
                var p = w(t, "entries");
                t = c(t);
                [, p] = await Promise.all([t, p]);
                return p
            })
        }
    }
    self.KVStorageContainer = q
}
"use strict"; {
    const e = self.KVStorageContainer,
        a = [/no available storage method found/i, /an attempt was made to break through the security policy of the user agent/i, /the user denied permission to access the database/i, /a mutation operation was attempted on a database that did not allow mutations/i, /idbfactory\.open\(\) called in an invalid security context/i],
        b = new WeakMap;
    let d = !1;
    "undefined" === typeof indexedDB && (d = !0, console.warn("Unable to use local storage because indexedDB is not defined"));

    function c(l) {
        throw Error(`"${l}" is not implemented`);
    }

    function f(l) {
        if ("function" === typeof l) throw Error("localforage callback API is not implemented; please use the promise API instead");
    }

    function k(l) {
        return "object" === typeof l ? new Promise(n => {
            const {
                port1: u,
                port2: w
            } = new MessageChannel;
            w.onmessage = q => n(q.data);
            u.postMessage(l)
        }) : Promise.resolve(l)
    }
    class h {
        constructor(l) {
            this._inst = l;
            b.set(this, new Map)
        }
        _MaybeSwitchToMemoryFallback(l) {
            if (!d)
                for (const n of a)
                    if (l && n.test(l.message)) {
                        console.error("Unable to use local storage, reverting to in-memory store: ",
                            l, l.message);
                        d = !0;
                        break
                    }
        }
        async _getItemFallback(l) {
            l = b.get(this).get(l);
            l = await k(l);
            return "undefined" === typeof l ? null : l
        }
        async _setItemFallback(l, n) {
            n = await k(n);
            b.get(this).set(l, n)
        }
        _removeItemFallback(l) {
            b.get(this).delete(l)
        }
        _clearFallback() {
            b.get(this).clear()
        }
        _keysFallback() {
            return Array.from(b.get(this).keys())
        }
        IsUsingFallback() {
            return d
        }
        async getItem(l, n) {
            f(n);
            if (d) return await this._getItemFallback(l);
            let u;
            try {
                u = await this._inst.get(l)
            } catch (w) {
                this._MaybeSwitchToMemoryFallback(w);
                if (d) return await this._getItemFallback(l);
                console.error(`Error reading '${l}' from storage, returning null: `, w);
                return null
            }
            return "undefined" === typeof u ? null : u
        }
        async setItem(l, n, u) {
            f(u);
            "undefined" === typeof n && (n = null);
            if (d) await this._setItemFallback(l, n);
            else try {
                await this._inst.set(l, n)
            } catch (w) {
                if (this._MaybeSwitchToMemoryFallback(w), d) await this._setItemFallback(l, n);
                else throw w;
            }
        }
        async removeItem(l, n) {
            f(n);
            if (d) this._removeItemFallback(l);
            else try {
                await this._inst.delete(l)
            } catch (u) {
                this._MaybeSwitchToMemoryFallback(u), d ? this._removeItemFallback(l) :
                    console.error(`Error removing '${l}' from storage: `, u)
            }
        }
        async clear(l) {
            f(l);
            if (d) this._clearFallback();
            else try {
                await this._inst.clear()
            } catch (n) {
                this._MaybeSwitchToMemoryFallback(n), d ? this._clearFallback() : console.error("Error clearing storage: ", n)
            }
        }
        async keys(l) {
            f(l);
            if (d) return this._keysFallback();
            l = [];
            try {
                l = await this._inst.keys()
            } catch (n) {
                this._MaybeSwitchToMemoryFallback(n);
                if (d) return this._keysFallback();
                console.error("Error getting storage keys: ", n)
            }
            return l
        }
        ready(l) {
            f(l);
            return d ? Promise.resolve(!0) :
                this._inst.ready()
        }
        createInstance(l) {
            if ("object" !== typeof l) throw new TypeError("invalid options object");
            l = l.name;
            if ("string" !== typeof l) throw new TypeError("invalid store name");
            l = new e(l);
            return new h(l)
        }
        length(l) {
            c("localforage.length()")
        }
        key(l, n) {
            c("localforage.key()")
        }
        iterate(l, n) {
            c("localforage.iterate()")
        }
        setDriver(l) {
            c("localforage.setDriver()")
        }
        config(l) {
            c("localforage.config()")
        }
        defineDriver(l) {
            c("localforage.defineDriver()")
        }
        driver() {
            c("localforage.driver()")
        }
        supports(l) {
            c("localforage.supports()")
        }
        dropInstance() {
            c("localforage.dropInstance()")
        }
        disableMemoryMode() {
            d = !1
        }
    }
    self.localforage = new h(new e("localforage"))
} {
    "use strict";
    const e = self.C3;
    e.Supports = {};
    e.Supports.WebAnimations = (() => {
        try {
            if ("Safari" === e.Platform.Browser || "undefined" === typeof document) return !1;
            const a = document.createElement("div");
            return "undefined" === typeof a.animate ? !1 : "undefined" !== typeof a.animate([{
                opacity: "0"
            }, {
                opacity: "1"
            }], 1E3).reverse
        } catch (a) {
            return !1
        }
    })();
    e.Supports.DialogElement = "undefined" !== typeof HTMLDialogElement;
    e.Supports.RequestIdleCallback = !!self.requestIdleCallback;
    e.Supports.ImageBitmap = !!self.createImageBitmap && "Safari" !==
        e.Platform.Browser;
    e.Supports.ImageBitmapOptions = !1;
    if (e.Supports.ImageBitmap) try {
        self.createImageBitmap(new ImageData(32, 32), {
            resizeWidth: 10,
            resizeHeight: 10,
            premultiplyAlpha: "none"
        }).then(a => {
            e.Supports.ImageBitmapOptions = 10 === a.width && 10 === a.height ? !0 : !1
        }).catch(a => {
            e.Supports.ImageBitmapOptions = !1
        })
    } catch (a) {
        e.Supports.ImageBitmapOptions = !1
    }
    e.Supports.ClipboardReadText = !(!navigator.clipboard || !navigator.clipboard.readText || "Firefox" === e.Platform.Browser);
    e.Supports.PermissionsQuery = !(!navigator.permissions ||
        !navigator.permissions.query);
    e.Supports.Proxies = "undefined" !== typeof Proxy;
    e.Supports.DownloadAttribute = (() => "undefined" === typeof document ? !1 : "undefined" !== typeof document.createElement("a").download)();
    e.Supports.CanvasToBlob = (() => "undefined" !== typeof HTMLCanvasElement && HTMLCanvasElement.prototype.toBlob)();
    e.Supports.Fetch = "function" === typeof fetch;
    e.Supports.PersistentStorage = !!(self.isSecureContext && "Opera" !== e.Platform.Browser && navigator.storage && navigator.storage.persist);
    e.Supports.StorageQuotaEstimate = !!(self.isSecureContext && navigator.storage && navigator.storage.estimate);
    e.Supports.Fullscreen = (() => {
        if ("undefined" === typeof document || "iOS" === e.Platform.OS) return !1;
        const a = document.documentElement;
        return !!(a.requestFullscreen || a.msRequestFullscreen || a.mozRequestFullScreen || a.webkitRequestFullscreen)
    })();
    e.Supports.ImageDecoder = "undefined" !== typeof self.ImageDecoder;
    e.Supports.NativeFileSystemAPI = !!self.showOpenFilePicker;
    e.Supports.NavigatorFontsQuery = !(!navigator.fonts || !navigator.fonts.query)
} {
    "use strict";
    const e = self.C3;
    if (!String.prototype.trimStart) {
        const a = /^[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]*/;
        String.prototype.trimStart = function () {
            return this.replace(a, "")
        }
    }
    if (!String.prototype.trimEnd) {
        const a = /[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]*$/;
        String.prototype.trimEnd = function () {
            return this.replace(a,
                "")
        }
    }
    String.prototype.replaceAll || (String.prototype.replaceAll = function (a, b) {
        return this.replace(new RegExp(e.EscapeRegex(a), "g"), b)
    });
    Array.prototype.values || (Array.prototype.values = function* () {
        for (const a of this) yield a
    });
    if (!Array.prototype.flat) {
        function a(b, d) {
            return b.reduce((c, f) => {
                0 < d && Array.isArray(f) ? Array.prototype.push.apply(c, a(f, d - 1)) : c.push(f);
                return c
            }, [])
        }
        Array.prototype.flat = function (b = 1) {
            return a(this, b)
        }
    }
    Array.prototype.at || (Array.prototype.at = function (a) {
        a = Math.trunc(a) || 0;
        0 >
            a && (a += this.length);
        if (!(0 > a || a >= this.length)) return this[a]
    });
    String.prototype.at || (String.prototype.at = function (a) {
        a = Math.trunc(a) || 0;
        0 > a && (a += this.length);
        if (!(0 > a || a >= this.length)) return this[a]
    });
    RegExp.escape || (RegExp.escape = function (a) {
        return String(a).replace(/[\\^$*+?.()|[\]{}]/g, "\\$&")
    });
    navigator.storage && !navigator.storage.estimate && navigator.webkitTemporaryStorage && navigator.webkitTemporaryStorage.queryUsageAndQuota && (navigator.storage.estimate = function () {
        return new Promise((a, b) => navigator.webkitTemporaryStorage.queryUsageAndQuota((d,
            c) => a({
            usage: d,
            quota: c
        }), b))
    });
    "undefined" === typeof self.isSecureContext && (self.isSecureContext = "https:" === location.protocol);
    "undefined" === typeof self.globalThis && (self.globalThis = self)
} {
    "use strict";
    const e = self.C3;

    function a(b) {
        let d = e.GetCallStack();
        console.error("Assertion failure: " + b + "\n\nStack trace:\n" + d)
    }
    self.assert = function (b, d) {
        b || a(d)
    }
} {
    "use strict";
    const e = self.C3,
        a = self.C3X;
    e.IsNumber = function (d) {
        return "number" === typeof d
    };
    e.IsFiniteNumber = function (d) {
        return e.IsNumber(d) && isFinite(d)
    };
    e.RequireNumber = function (d) {
        if (!e.IsNumber(d)) throw new TypeError("expected number");
    };
    e.RequireOptionalNumber = function (d) {
        e.IsNullOrUndefined(d)
    };
    e.RequireNumberInRange = function (d, c, f) {
        if (!e.IsNumber(d) || isNaN(d) || c > d || f < d) throw new RangeError("number outside of range");
    };
    e.RequireAllNumber = function (...d) {
        for (let c of d);
    };
    e.RequireFiniteNumber =
        function (d) {
            if (!e.IsFiniteNumber(d)) throw new TypeError("expected finite number");
        };
    e.RequireOptionalFiniteNumber = function (d) {
        e.IsNullOrUndefined(d)
    };
    e.RequireAllFiniteNumber = function (...d) {
        for (let c of d);
    };
    e.IsString = function (d) {
        return "string" === typeof d
    };
    e.RequireString = function (d) {
        if (!e.IsString(d)) throw new TypeError("expected string");
    };
    e.RequireOptionalString = function (d) {
        e.IsNullOrUndefined(d)
    };
    e.RequireAllString = function (...d) {
        for (let c of d);
    };
    e.IsSimpleObject = function (d) {
        return "object" !==
            typeof d || null === d ? !1 : (d = Object.getPrototypeOf(d)) ? d.constructor === Object : null === d
    };
    e.RequireSimpleObject = function (d) {
        if (!e.IsSimpleObject(d)) throw new TypeError("expected simple object");
    };
    e.RequireOptionalSimpleObject = function (d) {
        if (!e.IsNullOrUndefined(d) && !e.IsSimpleObject(d)) throw new TypeError("expected simple object");
    };
    e.IsObject = function (d) {
        return "object" === typeof d && null !== d && !Array.isArray(d)
    };
    e.RequireObject = function (d) {
        if (!e.IsObject(d)) throw new TypeError("expected object");
    };
    e.RequireOptionalObject =
        function (d) {
            e.IsNullOrUndefined(d)
        };
    e.RequireAllObject = function (...d) {
        for (let c of d);
    };
    e.IsFileLike = function (d) {
        return e.IsInstanceOf(d, Blob) && "string" === typeof d.name
    };
    e.RequireFileLike = function (d) {
        if (!e.IsFileLike(d)) throw new TypeError("expected file");
    };
    e.RequireOptionalFileLike = function (d) {
        e.IsNullOrUndefined(d)
    };
    e.IsArray = function (d) {
        return Array.isArray(d)
    };
    e.RequireArray = function (d) {
        if (!e.IsArray(d)) throw new TypeError("expected array");
    };
    e.RequireOptionalArray = function (d) {
        e.IsNullOrUndefined(d)
    };
    e.RequireAllArray = function (...d) {
        for (let c of d);
    };
    e.Is2DArray = function (d) {
        return e.IsArray(d) ? d.length ? e.IsArray(d[0]) ? !0 : !1 : !0 : !1
    };
    e.Require2DArray = function (d) {
        if (!e.Is2DArray(d)) throw new TypeError("expected 2d array");
        for (let c of d)
            if (!e.IsArray(c)) throw new TypeError("expected 2d array");
    };
    e.RequireOptional2DArray = function (d) {
        e.IsNullOrUndefined(d)
    };
    e.IsFunction = function (d) {
        return "function" === typeof d
    };
    e.RequireFunction = function (d, c) {
        if (!e.IsFunction(d)) throw new TypeError("expected function");
        if (!e.IsNullOrUndefined(c) && d !== c) throw new TypeError("expected same function reference");
    };
    e.RequireOptionalFunction = function (d) {
        e.IsNullOrUndefined(d)
    };
    e.RequireAllFunction = function (...d) {
        for (let c of d);
    };
    e.RequireAnyFunction = function (d, ...c) {
        if (!e.IsFunction(d)) throw new TypeError("expected function");
        if (!c.length) throw Error("missing comparison functions");
        for (let f of c)
            if (!e.IsNullOrUndefined(f) && d === f) return;
        throw new TypeError("expected same function reference");
    };
    e.RequireOptionalAllFunction =
        function (...d) {
            if (!e.IsNullOrUndefined(d))
                for (let c of d);
        };
    e.IsInstanceOf = function (d, c) {
        return d instanceof c
    };
    e.IsInstanceOfAny = function (d, ...c) {
        for (let f of c)
            if (e.IsInstanceOf(d, f)) return !0;
        return !1
    };
    e.RequireInstanceOf = function (d, c) {
        if (!e.IsInstanceOf(d, c)) throw new TypeError("unexpected type");
    };
    e.RequireOptionalInstanceOf = function (d, c) {
        e.IsNullOrUndefined(d)
    };
    e.RequireAllInstanceOf = function (d, ...c) {
        for (let f of c);
    };
    e.RequireAnyInstanceOf = function (d, ...c) {
        if (!e.IsInstanceOfAny(d, ...c)) throw new TypeError("unexpected type");
    };
    e.RequireAnyOptionalInstanceOf = function (d, ...c) {
        if (!e.IsNullOrUndefined(d) && !e.IsInstanceOfAny(d, ...c)) throw new TypeError("unexpected type");
    };
    e.IsArrayOf = function (d, c) {
        for (let f of d)
            if (!e.IsInstanceOf(f, c)) return !1;
        return !0
    };
    e.IsArrayOfFiniteNumbers = function (d) {
        for (let c of d)
            if (!e.IsFiniteNumber(c)) return !1;
        return !0
    };
    e.RequireArrayOf = function (d, c) {
        for (let f of d);
    };
    e.RequireOptionalArrayOf = function (d, c) {
        if (!e.IsNullOrUndefined(d))
            for (let f of d);
    };
    e.RequireArrayOfAny = function (d, ...c) {
        for (let f of d);
    };
    e.RequireOptionalArrayOfAny = function (d, ...c) {
        if (!e.IsNullOrUndefined(d))
            for (let f of d);
    };
    e.IsDOMNode = function (d, c) {
        return e.IsNullOrUndefined(d) || !e.IsString(d.nodeName) ? !1 : !c || e.equalsNoCase(d.nodeName, c)
    };
    e.RequireDOMNode = function (d, c) {
        if (e.IsNullOrUndefined(d) || !e.IsString(d.nodeName)) throw new TypeError("expected DOM node");
        if (c && !e.equalsNoCase(d.nodeName, c)) throw new TypeError(`expected DOM '${c}' node`);
    };
    e.RequireOptionalDOMNode = function (d, c) {
        e.IsNullOrUndefined(d)
    };
    e.IsHTMLElement = function (d,
        c) {
        return e.IsNullOrUndefined(d) || !e.IsString(d.tagName) ? !1 : !c || e.equalsNoCase(d.tagName, c)
    };
    e.RequireHTMLElement = function (d, c) {
        if (e.IsNullOrUndefined(d) || !e.IsString(d.tagName)) throw new TypeError("expected HTML element");
        if (c && !e.equalsNoCase(d.tagName, c)) throw new TypeError(`expected HTML '${c}' element`);
    };
    e.RequireOptionalHTMLElement = function (d, c) {
        e.IsNullOrUndefined(d)
    };
    e.IsDrawable = function (d) {
        return e.IsHTMLElement(d, "img") || e.IsHTMLElement(d, "canvas") || e.IsHTMLElement(d, "video") || "undefined" !==
            typeof OffscreenCanvas && d instanceof OffscreenCanvas || "undefined" !== typeof ImageBitmap && d instanceof ImageBitmap
    };
    e.RequireDrawable = function (d) {
        if (!e.IsDrawable(d)) throw new TypeError("expected drawable");
    };
    e.RequireOptionalDrawable = function (d) {
        e.IsNullOrUndefined(d)
    };
    e.IsDrawableOrImageData = function (d) {
        return d instanceof ImageData ? !0 : e.IsDrawable(d)
    };
    e.RequireDrawableOrImageData = function (d) {
        if (!e.IsDrawableOrImageData(d)) throw new TypeError("expected drawable or image data");
    };
    e.RequireOptionalDrawableOrImageData =
        function (d) {
            if (!e.IsNullOrUndefined(d) && !e.IsDrawableOrImageData(d)) throw new TypeError("expected drawable or image data");
        };
    e.IsStringLike = function (d) {
        return "string" === typeof d || d instanceof e.HtmlString || d instanceof e.BBString
    };
    e.RequireStringLike = function (d) {
        if (!e.IsStringLike(d)) throw new TypeError("expected string-like");
    };
    e.RequireOptionalStringLike = function (d) {
        e.IsNullOrUndefined(d)
    };
    e.RequireAllStringLike = function (...d) {
        for (let c of d);
    };
    e.RequireOverride = function () {
        throw Error("must be overridden");
    };
    e.NotYetImplemented = function () {
        throw Error("not yet implemented");
    };
    e.IsDefined = function (d, ...c) {
        if ("undefined" === typeof d) return !1;
        for (let f of c) {
            if ("undefined" === typeof d[f]) return !1;
            d = d[f]
        }
        return !0
    };
    e.IsNullOrUndefined = function (d) {
        return "undefined" === typeof d || null === d
    };
    e.AreArrayElementsOfSameType = function (d) {
        let c = d[0].constructor;
        for (let f of d)
            if (f.constructor !== c) return !1;
        return c
    };
    e.AreArrayElementsOfType = function (d, c) {
        for (let f of d)
            if (!(f instanceof c)) return !1;
        return !0
    };
    const b = Object.getPrototypeOf(Uint8Array);
    e.IsTypedArray = function (d) {
        return e.IsInstanceOf(d, b)
    };
    e.RequireTypedArray = function (d) {};
    e.WeakRequireTypedArray = function (d) {
        e.WeakRequireInstanceOf(d, b)
    };
    e.WeakRequireAnyInstanceOf = function (d, ...c) {
        if (!e.WeakIsAnyInstanceOf(d, ...c)) throw new TypeError("unexpected type");
    };
    e.WeakIsAnyInstanceOf = function (d, ...c) {
        for (const f of c)
            if (e.WeakIsInstanceOf(d, f)) return !0;
        return !1
    };
    e.WeakRequireInstanceOf = function (d, c) {
        if (!e.WeakIsInstanceOf(d, c)) throw new TypeError("unexpected type");
    };
    e.WeakIsInstanceOf =
        function (d, c) {
            for (; d = Object.getPrototypeOf(d);)
                if (d.constructor.name === c.name) return !0;
            return !1
        };
    a.RequireNumber = e.RequireNumber;
    a.RequireOptionalNumber = e.RequireOptionalNumber;
    a.RequireFiniteNumber = e.RequireFiniteNumber;
    a.RequireOptionalFiniteNumber = e.RequireOptionalFiniteNumber;
    a.RequireString = e.RequireString;
    a.RequireOptionalString = e.RequireOptionalString;
    a.RequireObject = e.RequireObject;
    a.RequireOptionalObject = e.RequireOptionalObject;
    a.RequireArray = e.RequireArray;
    a.RequireOptionalArray = e.RequireOptionalArray;
    a.RequireFunction = e.RequireFunction;
    a.RequireOptionalFunction = e.RequireOptionalFunction;
    a.RequireInstanceOf = e.RequireInstanceOf;
    a.RequireOptionalInstanceOf = e.RequireOptionalInstanceOf;
    a.IsNullOrUndefined = e.IsNullOrUndefined
} {
    "use strict";
    const e = self.C3,
        a = new Map;
    e.RafLog = function (r, ...x) {
        a.has(r) || a.set(r, -1); - 1 === a.get(r) && a.set(r, requestAnimationFrame(() => {
            console.log(`%c${r}`, "font-weight: bold", ...x);
            a.set(r, -1)
        }))
    };
    let b;
    e.StartMeasure = function (r) {
        performance.mark(r);
        b || (b = new Map);
        b.has(r) || b.set(r, {
            current: 0,
            total: 0,
            average: 0,
            calls: 1,
            toString: function () {
                return `current => ${this.current.toPrecision(3)} :: average => ${this.average.toPrecision(3)} :: calls => ${this.calls}`
            }
        })
    };
    e.EndMeasure = function (r) {
        performance.measure("measure",
            r);
        const x = performance.getEntriesByName("measure")[0];
        r = b.get(r);
        r.current = x.duration;
        r.total += r.current;
        r.average = r.total / r.calls;
        r.calls++;
        console.log(r.toString());
        performance.clearMarks();
        performance.clearMeasures()
    };
    e.GetCallStack = function () {
        return Error().stack
    };
    e.Debugger = function () {
        debugger
    };
    e.cast = function (r, x) {
        return r && r instanceof x ? r : null
    };
    e.getName = function (r) {
        return "undefined" === typeof r ? "undefined" : null === r ? "null" : "boolean" === typeof r ? "<boolean>" : e.IsNumber(r) ? "<number>" : e.IsString(r) ?
            "<string>" : e.IsArray(r) ? "<array>" : "symbol" === typeof r ? "<" + r.toString() + ">" : e.IsFunction(r) ? r.name && "Function" !== r.name ? r.name : "<anonymous function>" : "object" === typeof r ? r.constructor && r.constructor.name && "Object" !== r.constructor.name ? r.constructor.name : "<anonymous object>" : "<unknown>"
    };
    e.getType = function (r) {
        return null === r ? "null" : Array.isArray(r) ? "array" : typeof r
    };
    e.range = function* (r, x) {
        if (!isFinite(Math.abs(r - x))) throw Error("Invalid parameters");
        if (r > x)
            for (--r; r >= x; r--) yield r;
        else
            for (; r < x; r++) yield r
    };

    function d(r, x) {
        r = e.getType(r);
        x = e.getType(x);
        return "null" === r || "null" === x ? !0 : "undefined" === r || "undefined" === x ? !1 : r === x
    }
    let c = new Map,
        f = new Map,
        k = new WeakMap,
        h = new WeakMap;
    e.DefendHandler = {};
    const l = new Set(["then", "splice"]);

    function n(r) {
        console.warn("[Defence] " + r + " @", e.GetCallStack())
    }
    e.DefendHandler.get = function (r, x) {
        x in r || "symbol" === typeof x || l.has(x) || n(`Accessed missing property '${x}' from defended object '${e.getName(r)}', returning undefined`);
        h.has(r) && "symbol" !== typeof x && !l.has(x) &&
            n(`Accessed property '${x}' on a released object '${e.getName(r)}'\nObject was originally released at: ${h.get(r)})\nCall stack at access: `);
        return r[x]
    };
    e.DefendHandler.set = function (r, x, y) {
        x in r || c.has(r) || n(`Set non-existent property '${x}' to '${y}' on defended object '${e.getName(r)}'`);
        d(r[x], y) || c.has(r) || n(`Set '${e.getType(r[x])}' property '${x}' to type '${e.getType(y)}' on defended object '${e.getName(r)}'`);
        h.has(r) && n(`Set property '${x}' on a released object '${e.getName(r)}'\nObject was originally released at: ${h.get(r)})\nCall stack at access: `);
        r[x] = y;
        return !0
    };
    e.DefendHandler.deleteProperty = function (r, x) {
        throw new ReferenceError(`Cannot delete property '${x}' from defended object '${e.getName(r)}'`);
    };
    e.DefendHandler.defineProperty = function (r, x, y) {
        throw new ReferenceError(`Cannot define property '${x}' on defended object '${e.getName(r)}'`);
    };
    e.DefendHandler.enumerate = function (r) {
        throw new ReferenceError(`Cannot enumerate defended object '${e.getName(r)}'`);
    };
    let u = -1;

    function w() {
        u = -1;
        if (0 < c.size || 0 < f.size) {
            let r = [...new Set([...c.keys()].map(x =>
                e.getName(x)))].join();
            console.warn(`An object derived from DefendedBase was not protected with debugDefend(). This will disable some checks. See the coding guidelines! Possible affected class names: ${r}`);
            c.clear();
            f.clear()
        }
    }
    e.DefendedBase = class {
        constructor() {
            if (e.isDebugDefend && e.Supports.Proxies) {
                var r = new.target;
                r = Object.create(r.prototype);
                var x = new Proxy(r, e.DefendHandler);
                c.set(r, x);
                f.set(x, r);
                k.set(x, r); - 1 === u && (u = requestAnimationFrame(w));
                return x
            }
        }
    };
    e.debugDefend = function (r) {
        if (e.isDebugDefend &&
            e.Supports.Proxies && r instanceof e.DefendedBase) {
            if (!f.has(r)) return r;
            let x = f.get(r);
            f.delete(r);
            c.delete(x);
            return r
        }
        return e.isDebug ? Object.seal(r) : r
    };
    e.New = function (r, ...x) {
        let y;
        try {
            y = new r(...x)
        } catch (E) {
            throw f.clear(), c.clear(), E;
        }
        e.isDebugDefend && p(r, y);
        return e.debugDefend(y)
    };
    e.Release = function (r) {
        (r = k.get(r)) && h.set(r, e.GetCallStack())
    };
    e.WasReleased = function (r) {
        return (r = k.get(r)) ? !!h.get(r) : !1
    };
    let q = new Map;

    function t(r) {
        let x = new Set;
        for (let y in r) x.add(y);
        return x
    }

    function p(r, x) {
        x =
            t(x);
        let y = q.get(r);
        if (y) {
            let E = [];
            for (let G of y.values()) x.has(G) ? x.delete(G) : E.push(G);
            e.appendArray(E, [...x]);
            E.length && console.warn(`[Defence] '${e.getName(r)}' constructor creates inconsistent properties: ${E.join(", ")}`)
        } else q.set(r, x)
    }
    e.PerfMark = class {
        constructor(r) {
            this._name = "";
            r && this.start(r)
        }
        start(r) {
            this._name = r;
            performance.mark(this._name + "-Start")
        }
        end() {
            performance.mark(this._name + "-End");
            performance.measure(this._name, this._name + "-Start", this._name + "-End")
        }
        next(r) {
            this.end();
            this._name =
                r;
            performance.mark(this._name + "-Start")
        }
    }
} {
    "use strict";
    const e = self.C3,
        a = 2 * Math.PI,
        b = Math.PI / 180,
        d = 180 / Math.PI;
    e.wrap = function (k, h, l) {
        k = Math.floor(k);
        h = Math.floor(h);
        l = Math.floor(l);
        return k < h ? (k = l - (h - k) % (l - h), k === l ? 0 : k) : h + (k - h) % (l - h)
    };
    e.mapToRange = function (k, h, l, n, u) {
        return (k - h) * (u - n) / (l - h) + n
    };
    e.normalize = function (k, h, l) {
        return (k - h) / (l - h)
    };
    e.clamp = function (k, h, l) {
        return k < h ? h : k > l ? l : k
    };
    e.clampAngle = function (k) {
        k %= a;
        0 > k && (k += a);
        return k
    };
    e.toRadians = function (k) {
        return k * b
    };
    e.toDegrees = function (k) {
        return k * d
    };
    e.distanceTo = function (k, h, l, n) {
        return Math.hypot(l -
            k, n - h)
    };
    e.distanceSquared = function (k, h, l, n) {
        k = l - k;
        h = n - h;
        return k * k + h * h
    };
    e.angleTo = function (k, h, l, n) {
        return Math.atan2(n - h, l - k)
    };
    e.angleDiff = function (k, h) {
        if (k === h) return 0;
        k = Math.sin(k) * Math.sin(h) + Math.cos(k) * Math.cos(h);
        return 1 <= k ? 0 : -1 >= k ? Math.PI : Math.acos(k)
    };
    e.angleRotate = function (k, h, l) {
        let n = Math.sin(k),
            u = Math.cos(k),
            w = Math.sin(h),
            q = Math.cos(h);
        return Math.acos(n * w + u * q) > l ? 0 < u * w - n * q ? e.clampAngle(k + l) : e.clampAngle(k - l) : e.clampAngle(h)
    };
    e.angleClockwise = function (k, h) {
        return 0 >= Math.cos(k) * Math.sin(h) -
            Math.sin(k) * Math.cos(h)
    };
    e.angleLerp = function (k, h, l, n = 0) {
        let u = e.angleDiff(k, h);
        n *= a;
        return e.angleClockwise(h, k) ? e.clampAngle(k + (u + n) * l) : e.clampAngle(k - (u + n) * l)
    };
    e.angleLerpClockwise = function (k, h, l, n = 0) {
        const u = e.angleDiff(k, h);
        n *= a;
        return e.angleClockwise(h, k) ? e.clampAngle(k + (u + n) * l) : e.clampAngle((a - u + n) * l)
    };
    e.angleLerpAntiClockwise = function (k, h, l, n = 0) {
        const u = e.angleDiff(k, h);
        n *= a;
        return e.angleClockwise(h, k) ? e.clampAngle((-a + u - n) * l) : e.clampAngle(k - (u + n) * l)
    };
    e.lerp = function (k, h, l) {
        return k + l * (h -
            k)
    };
    e.unlerp = function (k, h, l) {
        return k === h ? 0 : (l - k) / (h - k)
    };
    e.relerp = function (k, h, l, n, u) {
        return e.lerp(n, u, e.unlerp(k, h, l))
    };
    e.qarp = function (k, h, l, n) {
        return e.lerp(e.lerp(k, h, n), e.lerp(h, l, n), n)
    };
    e.cubic = function (k, h, l, n, u) {
        return e.lerp(e.qarp(k, h, l, u), e.qarp(h, l, n, u), u)
    };
    e.cosp = function (k, h, l) {
        return (k + h + (k - h) * Math.cos(l * Math.PI)) / 2
    };
    e.isPOT = function (k) {
        return 0 < k && 0 === (k - 1 & k)
    };
    e.nextHighestPowerOfTwo = function (k) {
        --k;
        for (let h = 1; 32 > h; h <<= 1) k |= k >> h;
        return k + 1
    };
    e.roundToNearestFraction = function (k, h) {
        return Math.round(k *
            h) / h
    };
    e.floorToNearestFraction = function (k, h) {
        return Math.floor(k * h) / h
    };
    e.round6dp = function (k) {
        return Math.round(1E6 * k) / 1E6
    };
    e.toFixed = function (k, h) {
        k = k.toFixed(h);
        for (h = k.length - 1; 0 <= h && "0" === k.charAt(h); --h);
        0 <= h && "." === k.charAt(h) && --h;
        return 0 > h ? k : k.substr(0, h + 1)
    };
    e.PackRGB = function (k, h, l) {
        return e.clamp(k, 0, 255) | e.clamp(h, 0, 255) << 8 | e.clamp(l, 0, 255) << 16
    };
    e.PackRGBAEx = function (k, h, l, n) {
        k = e.clamp(Math.floor(1024 * k), -8192, 8191);
        h = e.clamp(Math.floor(1024 * h), -8192, 8191);
        l = e.clamp(Math.floor(1024 * l),
            -8192, 8191);
        n = e.clamp(Math.floor(1023 * n), 0, 1023);
        0 > k && (k += 16384);
        0 > h && (h += 16384);
        0 > l && (l += 16384);
        return -(274877906944 * k + 16777216 * h + 1024 * l + n)
    };
    e.PackRGBEx = function (k, h, l) {
        return e.PackRGBAEx(k, h, l, 1)
    };

    function c(k) {
        return 0 === k && 0 > 1 / k
    }
    e.GetRValue = function (k) {
        if (0 <= k) return (k & 255) / 255;
        k = Math.floor(-k / 274877906944);
        8191 < k && (k -= 16384);
        return k / 1024
    };
    e.GetGValue = function (k) {
        if (0 <= k) return ((k & 65280) >> 8) / 255;
        k = Math.floor(-k % 274877906944 / 16777216);
        8191 < k && (k -= 16384);
        return k / 1024
    };
    e.GetBValue = function (k) {
        if (0 <=
            k) return ((k & 16711680) >> 16) / 255;
        k = Math.floor(-k % 16777216 / 1024);
        8191 < k && (k -= 16384);
        return k / 1024
    };
    e.GetAValue = function (k) {
        return c(k) ? 0 : 0 <= k ? 1 : Math.floor(-k % 1024) / 1023
    };
    e.greatestCommonDivisor = function (k, h) {
        k = Math.floor(k);
        for (h = Math.floor(h); 0 !== h;) {
            let l = h;
            h = k % h;
            k = l
        }
        return k
    };
    const f = [
        [3, 2],
        [4, 3],
        [5, 4],
        [5, 3],
        [6, 5],
        [14, 9],
        [16, 9],
        [16, 10],
        [21, 9]
    ];
    e.getAspectRatio = function (k, h) {
        k = Math.floor(k);
        h = Math.floor(h);
        if (k === h) return [1, 1];
        for (var l of f) {
            let n = k / l[0] * l[1];
            if (1 > Math.abs(h - n)) return l.slice(0);
            n = k / l[1] * l[0];
            if (1 > Math.abs(h - n)) return [l[1], l[0]]
        }
        l = e.greatestCommonDivisor(k, h);
        return [k / l, h / l]
    };
    e.segmentsIntersect = function (k, h, l, n, u, w, q, t) {
        var p = Math.min(k, l),
            r = Math.max(u, q);
        if (Math.max(k, l) < Math.min(u, q) || p > r) return !1;
        p = Math.min(h, n);
        r = Math.max(w, t);
        if (Math.max(h, n) < Math.min(w, t) || p > r) return !1;
        p = u - k + q - l;
        r = w - h + t - n;
        k = l - k;
        h = n - h;
        u = q - u;
        w = t - w;
        t = Math.abs(h * u - w * k);
        return Math.abs(u * r - w * p) > t ? !1 : Math.abs(k * r - h * p) <= t
    };
    e.segmentsIntersectPreCalc = function (k, h, l, n, u, w, q, t, p, r, x, y) {
        const E = Math.max(p, x);
        if (w < Math.min(p, x) || u > E) return !1;
        u = Math.max(r, y);
        if (t < Math.min(r, y) || q > u) return !1;
        q = p - k + x - l;
        t = r - h + y - n;
        k = l - k;
        h = n - h;
        p = x - p;
        r = y - r;
        y = Math.abs(h * p - r * k);
        return Math.abs(p * t - r * q) > y ? !1 : Math.abs(k * t - h * q) <= y
    };
    e.segmentIntersectsQuad = function (k, h, l, n, u) {
        const w = Math.min(k, l),
            q = Math.max(k, l),
            t = Math.min(h, n),
            p = Math.max(h, n),
            r = u.getTlx(),
            x = u.getTly(),
            y = u.getTrx(),
            E = u.getTry(),
            G = u.getBrx(),
            A = u.getBry(),
            F = u.getBlx();
        u = u.getBly();
        return e.segmentsIntersectPreCalc(k, h, l, n, w, q, t, p, r, x, y, E) || e.segmentsIntersectPreCalc(k,
            h, l, n, w, q, t, p, y, E, G, A) || e.segmentsIntersectPreCalc(k, h, l, n, w, q, t, p, G, A, F, u) || e.segmentsIntersectPreCalc(k, h, l, n, w, q, t, p, F, u, r, x)
    };
    e.segmentIntersectsAnyN = function (k, h, l, n, u) {
        const w = Math.min(k, l),
            q = Math.max(k, l),
            t = Math.min(h, n),
            p = Math.max(h, n);
        let r = 0;
        for (let x = u.length - 4; r <= x; r += 2)
            if (e.segmentsIntersectPreCalc(k, h, l, n, w, q, t, p, u[r], u[r + 1], u[r + 2], u[r + 3])) return !0;
        return e.segmentsIntersectPreCalc(k, h, l, n, w, q, t, p, u[r], u[r + 1], u[0], u[1])
    };
    e.rayIntersect = function (k, h, l, n, u, w, q, t) {
        l -= k;
        w = t - w;
        const p = l *
            w - (n - h) * (q - u);
        if (0 === p) return 2;
        n = ((h - n) * (q - k) + l * (t - h)) / p;
        return 0 < n && 1.000001 > n ? (w * (q - k) + (u - q) * (t - h)) / p : 2
    };
    e.rayIntersectExtended = function (k, h, l, n, u, w, q, t, p) {
        const r = (q - u) * p;
        p *= t - w;
        return e.rayIntersect(k, h, l, n, u - r, w - p, q + r, t + p)
    };
    e.isPointInTriangleInclusive = function (k, h, l, n, u, w, q, t) {
        u -= l;
        w -= n;
        q -= l;
        t -= n;
        k -= l;
        l = h - n;
        h = u * u + w * w;
        n = u * q + w * t;
        u = u * k + w * l;
        w = q * q + t * t;
        q = q * k + t * l;
        t = 1 / (h * w - n * n);
        w = (w * u - n * q) * t;
        u = (h * q - n * u) * t;
        return 0 <= w && 0 <= u && 1 >= w + u
    };
    e.triangleCartesianToBarycentric = function (k, h, l, n, u, w, q, t) {
        u -= l;
        w -=
            n;
        q -= l;
        t -= n;
        k -= l;
        const p = h - n;
        h = u * u + w * w;
        n = u * q + w * t;
        l = q * q + t * t;
        u = k * u + p * w;
        w = k * q + p * t;
        q = h * l - n * n;
        t = (l * u - n * w) / q;
        u = (h * w - n * u) / q;
        return [1 - t - u, t, u]
    };
    e.triangleBarycentricToCartesian = function (k, h, l, n, u, w, q, t, p) {
        return [k * n + h * w + l * t, k * u + h * q + l * p]
    }
} {
    "use strict";
    const e = self.C3;
    let a = null,
        b = "";
    if ("undefined" !== typeof document) {
        a = document;
        const l = document.querySelector("base");
        if (b = l && l.hasAttribute("href") ? l.getAttribute("href") : "") b.startsWith("/") && (b = b.substr(1)), b.endsWith("/") || (b += "/")
    }
    e.GetBaseHref = function () {
        return b
    };
    e.GetBaseURL = function () {
        if (!a) return "";
        const l = a.location;
        return e.GetPathFromURL(l.origin + l.pathname) + b
    };
    e.GetPathFromURL = function (l) {
        if (!l.length || l.endsWith("/") || l.endsWith("\\")) return l;
        const n = Math.max(l.lastIndexOf("/"),
            l.lastIndexOf("\\"));
        return -1 === n ? "" : l.substr(0, n + 1)
    };
    e.GetFilenameFromURL = function (l) {
        if (!l.length) return l;
        if (l.endsWith("/") || l.endsWith("\\")) return "";
        const n = Math.max(l.lastIndexOf("/"), l.lastIndexOf("\\"));
        return -1 === n ? l : l.substr(n + 1)
    };
    e.GetFileExtension = function (l) {
        let n = l.lastIndexOf(".");
        return 1 > n ? "" : l.substr(n)
    };
    e.GetFileNamePart = function (l) {
        let n = l.lastIndexOf(".");
        return 1 > n ? l : l.substr(0, n)
    };
    e.NormalizeFileSeparator = function (l) {
        return l.replace(/\\/g, "/")
    };
    e.IsFileExtension = function (l,
        n) {
        l = l ? e.GetFileExtension(l).slice(1) : "";
        return n === l
    };
    e.FileNameEquals = function (l, n) {
        let u, w;
        e.IsFileLike(l) && (u = e.GetFileNamePart(l.name));
        e.IsString(l) && (u = e.GetFileNamePart(l));
        e.IsFileLike(n) && (w = e.GetFileNamePart(n.name));
        e.IsString(n) && (w = e.GetFileNamePart(n));
        return u === w
    };
    e.ParseFilePath = function (l) {
        l = e.NormalizeFileSeparator(l);
        let n = /^\w:\//.exec(l);
        n ? (n = n[0], l = l.slice(3), "/" !== l[0] && (l = "/" + l)) : n = "";
        l = l.replace(/\/{2,}/g, "/");
        1 < l.length && "/" === l.slice(-1) && (l = l.slice(0, -1));
        var u = l.lastIndexOf("/") +
            1;
        let w = "",
            q = l,
            t = "";
        0 < u && (w = l.slice(0, u), q = l.slice(u));
        l = q;
        u = q.lastIndexOf(".");
        0 < u && (t = q.slice(u), l = q.slice(0, -t.length));
        return {
            dir: w,
            base: q,
            name: l,
            root: n,
            ext: t,
            full: n + w + q
        }
    };
    e.Wait = function (l, n) {
        return new Promise((u, w) => {
            self.setTimeout(u, l, n)
        })
    };
    e.swallowException = function (l) {
        try {
            l()
        } catch (n) {
            e.isDebug && console.warn("Swallowed exception: ", n)
        }
    };
    e.noop = function () {};
    e.equalsNoCase = function (l, n) {
        return "string" !== typeof l || "string" !== typeof n ? !1 : l === n || l.normalize().toLowerCase() === n.normalize().toLowerCase()
    };
    e.equalsCase = function (l, n) {
        return "string" !== typeof l || "string" !== typeof n ? !1 : l === n ? !0 : l.normalize() === n.normalize()
    };
    e.typedArraySet16 = function (l, n, u) {
        l[u++] = n[0];
        l[u++] = n[1];
        l[u++] = n[2];
        l[u++] = n[3];
        l[u++] = n[4];
        l[u++] = n[5];
        l[u++] = n[6];
        l[u++] = n[7];
        l[u++] = n[8];
        l[u++] = n[9];
        l[u++] = n[10];
        l[u++] = n[11];
        l[u++] = n[12];
        l[u++] = n[13];
        l[u++] = n[14];
        l[u] = n[15]
    };
    e.truncateArray = function (l, n) {
        l.length = n
    };
    e.clearArray = function (l) {
        l && 0 !== l.length && e.truncateArray(l, 0)
    };
    e.clear2DArray = function (l) {
        if (l) {
            for (let n = 0; n <
                l.length; n++) e.truncateArray(l[n], 0);
            e.truncateArray(l, 0)
        }
    };
    e.extendArray = function (l, n, u) {
        n |= 0;
        var w = l.length;
        if (!(n <= w))
            for (; w < n; ++w) l.push(u)
    };
    e.resizeArray = function (l, n, u) {
        n |= 0;
        const w = l.length;
        n < w ? e.truncateArray(l, n) : n > w && e.extendArray(l, n, u)
    };
    e.shallowAssignArray = function (l, n) {
        e.clearArray(l);
        e.appendArray(l, n)
    };
    e.appendArray = function (l, n) {
        if (1E4 > n.length) l.push(...n);
        else
            for (let u = 0, w = n.length; u < w; ++u) l.push(n[u])
    };
    e.arrayRemove = function (l, n) {
        n = Math.floor(n);
        if (!(0 > n || n >= l.length)) {
            for (var u =
                    l.length - 1; n < u; ++n) l[n] = l[n + 1];
            e.truncateArray(l, u)
        }
    };
    e.arrayFindRemove = function (l, n) {
        n = l.indexOf(n);
        0 <= n && l.splice(n, 1)
    };
    e.arraysEqual = function (l, n) {
        let u = l.length;
        if (n.length !== u) return !1;
        for (let w = 0; w < u; ++w)
            if (l[w] !== n[w]) return !1;
        return !0
    };
    e.arrayFilterOut = function (l, n) {
        let u = [],
            w = 0;
        for (let q = 0, t = l.length; q < t; ++q) {
            let p = l[q];
            n(p) ? u.push(p) : (l[w] = p, ++w)
        }
        e.truncateArray(l, w);
        return u
    };
    e.arrayRemoveAllInSet = function (l, n) {
        const u = l.length;
        let w = 0;
        for (let q = 0, t = l.length; q < t; ++q) {
            let p = l[q];
            n.has(p) ||
                (l[w++] = p)
        }
        e.truncateArray(l, w);
        return u - w
    };
    e.isArrayIndexInBounds = function (l, n) {
        return l !== Math.floor(l) ? !1 : 0 <= l && l < n.length
    };
    e.validateArrayIndex = function (l, n) {
        if (!e.isArrayIndexInBounds(l, n)) throw new RangeError("array index out of bounds");
    };
    e.cloneArray = function (l) {
        return l.slice()
    };
    e.deepCloneArray = function (l, n) {
        let u = [];
        for (let w of l)
            if (e.IsObject(w)) {
                l = n(w);
                if (!l) throw Error("missing clone");
                if (l.constructor !== w.constructor) throw Error("object is not a clone");
                u.push(l)
            } else e.IsArray(w) ?
                u.push(e.deepCloneArray(w, n)) : u.push(w);
        return u
    };
    e.clone2DArray = function (l) {
        let n = [];
        for (let u of l) n.push(u.slice());
        return n
    };
    e.mergeSets = function (l, n) {
        return new Set([...l, ...n])
    };
    e.mergeSetsInPlace = function (l, n) {
        for (const u of n) l.add(u);
        return l
    };
    e.first = function (l) {
        for (let n of l) return n;
        return null
    };
    e.xor = function (l, n) {
        return !l !== !n
    };
    e.compare = function (l, n, u) {
        switch (n) {
            case 0:
                return l === u;
            case 1:
                return l !== u;
            case 2:
                return l < u;
            case 3:
                return l <= u;
            case 4:
                return l > u;
            case 5:
                return l >= u;
            default:
                return !1
        }
    };
    e.hasAnyOwnProperty = function (l) {
        for (let n in l)
            if (l.hasOwnProperty(n)) return !0;
        return !1
    };
    e.PromiseAllWithProgress = function (l, n) {
        return l.length ? new Promise((u, w) => {
            const q = [];
            let t = 0,
                p = !1;
            for (let r = 0, x = l.length; r < x; ++r) q.push(void 0), l[r].then(y => {
                p || (q[r] = y, ++t, t === l.length ? u(q) : n(t, l.length))
            }).catch(y => {
                p = !0;
                w(y)
            })
        }) : Promise.resolve([])
    };
    let d = [];
    e.AddLibraryMemoryCallback = function (l) {
        d.push(l)
    };
    e.GetEstimatedLibraryMemoryUsage = function () {
        let l = 0;
        for (let n of d) {
            let u = n();
            l += u
        }
        return Math.floor(l)
    };
    let c = 1;
    const f = new Map,
        k = new MessageChannel;
    k.port2.onmessage = function (l) {
        l = l.data;
        const n = f.get(l);
        f.delete(l);
        n && n(performance.now())
    };
    e.RequestUnlimitedAnimationFrame = function (l) {
        const n = c++;
        f.set(n, l);
        k.port1.postMessage(n);
        return n
    };
    e.CancelUnlimitedAnimationFrame = function (l) {
        f.delete(l)
    };
    e.PostTask = e.RequestUnlimitedAnimationFrame;
    e.WaitForNextTask = function () {
        return new Promise(l => e.PostTask(l))
    };
    const h = new Set;
    e.RequestPostAnimationFrame = function (l) {
        const n = self.requestAnimationFrame(async u => {
            await e.WaitForNextTask();
            h.has(n) && (h.delete(n), l(u))
        });
        h.add(n);
        return n
    };
    e.CancelPostAnimationFrame = function (l) {
        h.has(l) && (self.cancelAnimationFrame(l), h.delete(l))
    }
} {
    "use strict";
    const e = self.C3;
    e.IsAbsoluteURL = function (a) {
        return /^(?:[a-z\-]+:)?\/\//.test(a) || "data:" === a.substr(0, 5) || "blob:" === a.substr(0, 5)
    };
    e.IsRelativeURL = function (a) {
        return !e.IsAbsoluteURL(a)
    };
    e.ThrowIfNotOk = function (a) {
        if (!a.ok) throw Error(`fetch '${a.url}' response returned ${a.status} ${a.statusText}`);
    };
    e.FetchOk = function (a, b) {
        return fetch(a, b).then(d => {
            e.ThrowIfNotOk(d);
            return d
        })
    };
    e.FetchText = function (a) {
        return e.FetchOk(a).then(b => b.text())
    };
    e.FetchJson = function (a) {
        return e.FetchOk(a).then(b =>
            b.json())
    };
    e.FetchBlob = function (a) {
        return e.FetchOk(a).then(b => b.blob())
    };
    e.FetchArrayBuffer = function (a) {
        return e.FetchOk(a).then(b => b.arrayBuffer())
    };
    e.FetchImage = function (a) {
        return new Promise((b, d) => {
            const c = new Image;
            c.onload = () => b(c);
            c.onerror = f => d(f);
            c.src = a
        })
    };
    e.BlobToArrayBuffer = function (a) {
        return "function" === typeof a.arrayBuffer ? a.arrayBuffer() : new Promise((b, d) => {
            const c = new FileReader;
            c.onload = () => b(c.result);
            c.onerror = () => d(c.error);
            c.readAsArrayBuffer(a)
        })
    };
    e.BlobToString = function (a) {
        return "function" ===
            typeof a.text ? a.text() : new Promise((b, d) => {
                const c = new FileReader;
                c.onload = () => b(c.result);
                c.onerror = () => d(c.error);
                c.readAsText(a)
            })
    };
    e.BlobToJson = function (a) {
        return e.BlobToString(a).then(b => JSON.parse(b))
    };
    e.BlobToImage = async function (a, b) {
        a = URL.createObjectURL(a);
        try {
            const d = await e.FetchImage(a);
            URL.revokeObjectURL(a);
            a = "";
            b && "function" === typeof d.decode && await d.decode();
            return d
        } finally {
            a && URL.revokeObjectURL(a)
        }
    };
    e.CreateCanvas = function (a, b) {
        if ("undefined" !== typeof document && "function" ===
            typeof document.createElement) {
            const d = document.createElement("canvas");
            d.width = a;
            d.height = b;
            return d
        }
        return new OffscreenCanvas(a, b)
    };
    e.CanvasToBlob = function (a, b, d) {
        "number" !== typeof d && (d = 1);
        b = b || "image/png";
        d = e.clamp(d, 0, 1);
        return a.toBlob ? new Promise(c => a.toBlob(c, b, d)) : a.convertToBlob ? a.convertToBlob({
            type: b,
            quality: d
        }) : e.Asyncify(() => e.CanvasToBlobSync(a, b, d))
    };
    e.CanvasToBlobSync = function (a, b, d) {
        "number" !== typeof d && (d = 1);
        b = b || "image/png";
        d = e.clamp(d, 0, 1);
        return e.DataURIToBinaryBlobSync(a.toDataURL(b,
            d))
    };
    e.DataURIToBinaryBlobSync = function (a) {
        a = e.ParseDataURI(a);
        return e.BinaryStringToBlob(a.data, a.mime_type)
    };
    e.ParseDataURI = function (a) {
        if ("data:" !== a.substr(0, 5)) throw new URIError("expected data: uri");
        var b = a.indexOf(",");
        if (0 > b) throw new URIError("expected comma in data: uri");
        var d = a.substring(5, b);
        a = a.substring(b + 1);
        b = d.split(";");
        d = b[0] || "";
        let c = b[2];
        a = "base64" === b[1] || "base64" === c ? atob(a) : decodeURIComponent(a);
        return {
            mime_type: d,
            data: a
        }
    };
    e.BinaryStringToBlob = function (a, b) {
        var d = a.length;
        let c = d >> 2,
            f = new Uint8Array(d),
            k = new Uint32Array(f.buffer, 0, c),
            h, l;
        for (l = h = 0; h < c; ++h) k[h] = a.charCodeAt(l++) | a.charCodeAt(l++) << 8 | a.charCodeAt(l++) << 16 | a.charCodeAt(l++) << 24;
        for (d &= 3; d--;) f[l] = a.charCodeAt(l), ++l;
        return b ? new Blob([f], {
            type: b
        }) : new Blob([f])
    };
    e.DrawableToBlob = function (a, b, d) {
        const c = e.CreateCanvas(a.width, a.height);
        c.getContext("2d").drawImage(a, 0, 0);
        return e.CanvasToBlob(c, b, d)
    };
    e.ImageDataToBlobSync = function (a, b, d) {
        const c = e.CreateCanvas(a.width, a.height);
        c.getContext("2d").putImageData(a,
            0, 0);
        return e.CanvasToBlobSync(c, b, d)
    };
    e.ImageDataToBlob = function (a, b, d) {
        if (e.Supports.ImageBitmapOptions) return createImageBitmap(a, {
            premultiplyAlpha: "none"
        }).then(c => e.DrawableToBlob(c, b, d));
        if (e.Supports.ImageBitmap) return createImageBitmap(a).then(c => e.DrawableToBlob(c, b, d)); {
            const c = e.CreateCanvas(a.width, a.height);
            c.getContext("2d").putImageData(a, 0, 0);
            return e.CanvasToBlob(c, b, d)
        }
    };
    e.CopySet = function (a, b) {
        a.clear();
        for (const d of b) a.add(d)
    };
    e.MapToObject = function (a) {
        const b = Object.create(null);
        for (const [d, c] of a.entries()) b[d] = c;
        return b
    };
    e.ObjectToMap = function (a, b) {
        b.clear();
        for (const [d, c] of Object.entries(a)) b.set(d, c)
    };
    e.ToSuperJSON = function d(b) {
        if ("object" === typeof b && null !== b) {
            if (b instanceof Set) return {
                _c3type_: "set",
                data: [...b].map(c => d(c))
            };
            if (b instanceof Map) return {
                _c3type_: "map",
                data: [...b].map(c => [c[0], d(c[1])])
            }; {
                const c = Object.create(null);
                for (const [f, k] of Object.entries(b)) c[f] = d(k);
                return c
            }
        }
        return b
    };
    e.FromSuperJSON = function c(d) {
        if ("object" === typeof d & null !== d) {
            if ("set" ===
                d._c3type_) return new Set(d.data.map(f => c(f)));
            if ("map" === d._c3type_) return new Map(d.data.map(f => [f[0], c(f[1])])); {
                const f = Object.create(null);
                for (const [k, h] of Object.entries(d)) f[k] = c(h);
                return f
            }
        }
        return d
    };
    e.CSSToCamelCase = function (d) {
        let c = "",
            f = !1;
        for (const k of d) "-" === k ? f = !0 : f ? (c += k.toUpperCase(), f = !1) : c += k;
        return c
    };
    e.IsIterator = function (d) {
        return "object" === typeof d && "function" === typeof d.next
    };
    e.MakeFilledArray = function (d, c) {
        const f = [];
        if ("function" === typeof c)
            for (var k = 0; k < d; ++k) f.push(c());
        else
            for (k = 0; k < d; ++k) f.push(c);
        return f
    }
} {
    "use strict";
    const e = self.C3,
        a = /([0-9.]+),([0-9.]+)%?,([0-9.]+)%?/i,
        b = /([0-9.]+),([0-9.]+)%?,([0-9.]+)%?,([0-9.])/i;

    function d(f) {
        return 0 === f.length ? "00" : 1 === f.length ? "0" + f : f
    }

    function c(f, k, h) {
        0 > h && (h += 1);
        1 < h && --h;
        return h < 1 / 6 ? f + 6 * (k - f) * h : .5 > h ? k : h < 2 / 3 ? f + (k - f) * (2 / 3 - h) * 6 : f
    }
    e.Color = class {
        constructor(f, k, h, l) {
            this._a = this._b = this._g = this._r = 0;
            f instanceof e.Color ? this.set(f) : this.setRgba(f || 0, k || 0, h || 0, l || 0)
        }
        setRgb(f, k, h) {
            this._r = +f;
            this._g = +k;
            this._b = +h;
            this.clamp();
            return this
        }
        setRgba(f, k, h, l) {
            this._r = +f;
            this._g = +k;
            this._b = +h;
            this._a = +l;
            this.clamp();
            return this
        }
        set(f) {
            this._r = f._r;
            this._g = f._g;
            this._b = f._b;
            this._a = f._a;
            return this
        }
        copy(f) {
            return this.set(f)
        }
        add(f) {
            this._r += f._r;
            this._g += f._g;
            this._b += f._b;
            this._a += f._a;
            this.clamp()
        }
        addRgb(f, k, h, l = 0) {
            this._r += +f;
            this._g += +k;
            this._b += +h;
            this._a += +l;
            this.clamp()
        }
        diff(f) {
            this.setR(Math.max(this._r, f._r) - Math.min(this._r, f._r));
            this.setG(Math.max(this._g, f._g) - Math.min(this._g, f._g));
            this.setB(Math.max(this._b, f._b) - Math.min(this._b, f._b));
            this.setA(Math.max(this._a,
                f._a) - Math.min(this._a, f._a));
            this.clamp()
        }
        copyRgb(f) {
            this._r = f._r;
            this._g = f._g;
            this._b = f._b
        }
        setR(f) {
            this._r = e.clamp(+f, 0, 1)
        }
        getR() {
            return this._r
        }
        setG(f) {
            this._g = e.clamp(+f, 0, 1)
        }
        getG() {
            return this._g
        }
        setB(f) {
            this._b = e.clamp(+f, 0, 1)
        }
        getB() {
            return this._b
        }
        setA(f) {
            this._a = e.clamp(+f, 0, 1)
        }
        getA() {
            return this._a
        }
        clone() {
            return e.New(e.Color, this._r, this._g, this._b, this._a)
        }
        toArray() {
            return [this._r, this._g, this._b, this._a]
        }
        toTypedArray() {
            return new Float64Array(this.toArray())
        }
        writeToTypedArray(f, k) {
            f[k++] =
                this._r;
            f[k++] = this._g;
            f[k++] = this._b;
            f[k] = this._a
        }
        writeRGBToTypedArray(f, k) {
            f[k++] = this._r;
            f[k++] = this._g;
            f[k] = this._b
        }
        equals(f) {
            return this._r === f._r && this._g === f._g && this._b === f._b && this._a === f._a
        }
        equalsIgnoringAlpha(f) {
            return this._r === f._r && this._g === f._g && this._b === f._b
        }
        equalsRgb(f, k, h) {
            return this._r === f && this._g === k && this._b === h
        }
        equalsRgba(f, k, h, l) {
            return this._r === f && this._g === k && this._b === h && this._a === l
        }
        equalsF32Array(f, k) {
            return f[k] === Math.fround(this._r) && f[k + 1] === Math.fround(this._g) &&
                f[k + 2] === Math.fround(this._b) && f[k + 3] === Math.fround(this._a)
        }
        equalsRGBF32Array(f, k) {
            return f[k] === Math.fround(this._r) && f[k + 1] === Math.fround(this._g) && f[k + 2] === Math.fround(this._b)
        }
        multiply(f) {
            this._r *= f._r;
            this._g *= f._g;
            this._b *= f._b;
            this._a *= f._a
        }
        multiplyAlpha(f) {
            this._r *= f;
            this._g *= f;
            this._b *= f;
            this._a *= f
        }
        premultiply() {
            this._r *= this._a;
            this._g *= this._a;
            this._b *= this._a;
            return this
        }
        unpremultiply() {
            this._r /= this._a;
            this._g /= this._a;
            this._b /= this._a;
            return this
        }
        clamp() {
            this._r = e.clamp(this._r, 0, 1);
            this._g = e.clamp(this._g, 0, 1);
            this._b = e.clamp(this._b, 0, 1);
            this._a = e.clamp(this._a, 0, 1);
            return this
        }
        setFromRgbValue(f) {
            this._r = e.GetRValue(f);
            this._g = e.GetGValue(f);
            this._b = e.GetBValue(f);
            this._a = e.GetAValue(f)
        }
        getCssRgb(f, k, h) {
            f = e.IsFiniteNumber(f) ? f : this.getR();
            k = e.IsFiniteNumber(k) ? k : this.getG();
            h = e.IsFiniteNumber(h) ? h : this.getB();
            return `rgb(${100*f}%, ${100*k}%, ${100*h}%)`
        }
        getCssRgba(f, k, h, l) {
            f = e.IsFiniteNumber(f) ? f : this.getR();
            k = e.IsFiniteNumber(k) ? k : this.getG();
            h = e.IsFiniteNumber(h) ? h : this.getB();
            l = e.IsFiniteNumber(l) ? l : this.getA();
            return `rgba(${100*f}%, ${100*k}%, ${100*h}%, ${l})`
        }
        toHexString() {
            const f = Math.round(255 * this.getR()),
                k = Math.round(255 * this.getG()),
                h = Math.round(255 * this.getB());
            return "#" + d(f.toString(16)) + d(k.toString(16)) + d(h.toString(16))
        }
        parseHexString(f) {
            if ("string" !== typeof f) return !1;
            f = f.trim();
            "#" === f.charAt(0) && (f = f.substr(1));
            let k, h;
            if (3 === f.length) k = parseInt(f[0], 16) / 15, h = parseInt(f[1], 16) / 15, f = parseInt(f[2], 16) / 15;
            else if (6 === f.length) k = parseInt(f.substr(0, 2), 16) /
                255, h = parseInt(f.substr(2, 2), 16) / 255, f = parseInt(f.substr(4, 2), 16) / 255;
            else return !1;
            isFinite(k) && this.setR(k);
            isFinite(h) && this.setG(h);
            isFinite(f) && this.setB(f);
            this.setA(1);
            return !0
        }
        toCommaSeparatedRgb() {
            const f = Math.round(255 * this.getR()),
                k = Math.round(255 * this.getG()),
                h = Math.round(255 * this.getB());
            return `${f}, ${k}, ${h}`
        }
        toRgbArray() {
            const f = Math.round(255 * this.getR()),
                k = Math.round(255 * this.getG()),
                h = Math.round(255 * this.getB());
            return [f, k, h]
        }
        parseCommaSeparatedRgb(f) {
            if ("string" !== typeof f) return !1;
            f = f.replace(/^rgb\(|\)|%/, "");
            var k = f.split(",");
            if (3 > k.length) return !1;
            f = parseInt(k[0].trim(), 10) / 255;
            const h = parseInt(k[1].trim(), 10) / 255;
            k = parseInt(k[2].trim(), 10) / 255;
            isFinite(f) && this.setR(f);
            isFinite(h) && this.setG(h);
            isFinite(k) && this.setB(k);
            this.setA(1);
            return !0
        }
        parseCommaSeparatedPercentageRgb(f) {
            if ("string" !== typeof f) return !1;
            f = f.replace(/^rgb\(|\)|%/, "");
            var k = f.split(",");
            if (3 > k.length) return !1;
            f = parseInt(k[0].trim(), 10) / 100;
            const h = parseInt(k[1].trim(), 10) / 100;
            k = parseInt(k[2].trim(),
                10) / 100;
            isFinite(f) && this.setR(f);
            isFinite(h) && this.setG(h);
            isFinite(k) && this.setB(k);
            this.setA(1);
            return !0
        }
        parseCommaSeparatedRgba(f) {
            if ("string" !== typeof f) return !1;
            f = f.replace(/^rgba\(|\)|%/, "");
            var k = f.split(",");
            if (4 > k.length) return !1;
            f = parseInt(k[0].trim(), 10) / 255;
            const h = parseInt(k[1].trim(), 10) / 255,
                l = parseInt(k[2].trim(), 10) / 255;
            k = parseFloat(k[3].trim());
            isFinite(f) && this.setR(f);
            isFinite(h) && this.setG(h);
            isFinite(l) && this.setB(l);
            isFinite(k) && this.setA(k);
            return !0
        }
        parseCommaSeparatedPercentageRgba(f) {
            if ("string" !==
                typeof f) return !1;
            f = f.replace(/^rgba\(|\)|%/, "");
            var k = f.split(",");
            if (4 > k.length) return !1;
            f = parseInt(k[0].trim(), 10) / 100;
            const h = parseInt(k[1].trim(), 10) / 100,
                l = parseInt(k[2].trim(), 10) / 100;
            k = parseFloat(k[3].trim());
            isFinite(f) && this.setR(f);
            isFinite(h) && this.setG(h);
            isFinite(l) && this.setB(l);
            isFinite(k) && this.setA(k);
            return !0
        }
        parseString(f) {
            if ("string" !== typeof f) return !1;
            f = f.replace(/\s+/, "");
            if (f.includes(",")) {
                if (f.startsWith("rgb(")) return f.includes("%") ? this.parseCommaSeparatedPercentageRgb(f) :
                    this.parseCommaSeparatedRgb(f);
                if (f.startsWith("rgba(")) return f.includes("%") ? this.parseCommaSeparatedPercentageRgba(f) : this.parseCommaSeparatedRgba(f);
                if (f.startsWith("hsl(") || f.startsWith("hsla(")) return this.parseHSLString(f); {
                    const k = f.split(",");
                    if (f.includes("%")) {
                        if (3 === k.length) return this.parseCommaSeparatedPercentageRgb(f);
                        if (4 === k.length) return this.parseCommaSeparatedPercentageRgba(f)
                    } else {
                        if (3 === k.length) return this.parseCommaSeparatedRgb(f);
                        if (4 === k.length) return this.parseCommaSeparatedRgba(f)
                    }
                    return !1
                }
            }
            return this.parseHexString(f)
        }
        toJSON() {
            return [this._r,
                this._g, this._b, this._a
            ]
        }
        setFromHSLA(f, k, h, l) {
            f %= 360;
            k = e.clamp(k, 0, 100);
            h = e.clamp(h, 0, 100);
            l = e.clamp(l, 0, 1);
            f /= 360;
            k /= 100;
            h /= 100;
            if (0 === k) h = k = f = h;
            else {
                const n = .5 > h ? h * (1 + k) : h + k - h * k,
                    u = 2 * h - n;
                h = c(u, n, f + 1 / 3);
                k = c(u, n, f);
                f = c(u, n, f - 1 / 3)
            }
            this.setR(h);
            this.setG(k);
            this.setB(f);
            this.setA(l);
            return this
        }
        parseHSLString(f) {
            var k = f.replace(/ |hsl|hsla|\(|\)|;/gi, "");
            f = a.exec(k);
            k = b.exec(k);
            return f && 4 === f.length ? (this.setFromHSLA(+f[1], +f[2], +f[3], 1), !0) : k && 5 === k.length ? (this.setFromHSLA(+f[1], +f[2], +f[3], +f[4]),
                !0) : !1
        }
        toHSLAString() {
            var f = this._r;
            const k = this._g,
                h = this._b,
                l = this._a,
                n = e.Color.GetHue(f, k, h),
                u = e.Color.GetSaturation(f, k, h);
            f = e.Color.GetLuminosity(f, k, h);
            return `hsla(${n}, ${u}%, ${f}%, ${l})`
        }
        toHSLAArray() {
            const f = this._r,
                k = this._g,
                h = this._b;
            return [e.Color.GetHue(f, k, h), e.Color.GetSaturation(f, k, h), e.Color.GetLuminosity(f, k, h), this._a]
        }
        setFromJSON(f) {
            !Array.isArray(f) || 3 > f.length || (this._r = f[0], this._g = f[1], this._b = f[2], this._a = 4 <= f.length ? f[3] : 1)
        }
        set r(f) {
            this.setR(f)
        }
        get r() {
            return this.getR()
        }
        set g(f) {
            this.setG(f)
        }
        get g() {
            return this.getG()
        }
        set b(f) {
            this.setB(f)
        }
        get b() {
            return this.getB()
        }
        set a(f) {
            this.setA(f)
        }
        get a() {
            return this.getA()
        }
        setAtIndex(f,
            k) {
            switch (f) {
                case 0:
                    this.setR(k);
                    break;
                case 1:
                    this.setG(k);
                    break;
                case 2:
                    this.setB(k);
                    break;
                case 3:
                    this.setA(k);
                    break;
                default:
                    throw new RangeError("invalid color index");
            }
        }
        getAtIndex(f) {
            switch (f) {
                case 0:
                    return this.getR();
                case 1:
                    return this.getG();
                case 2:
                    return this.getB();
                case 3:
                    return this.getA();
                default:
                    throw new RangeError("invalid color index");
            }
        }
        static Equals(f, k) {
            let h;
            if (Array.isArray(f)) h = new e.Color, h.setFromJSON(f);
            else if (f instanceof e.Color) h = f;
            else throw Error("unexpected type");
            if (Array.isArray(k)) f =
                new e.Color, f.setFromJSON(k);
            else if (k instanceof e.Color) f = k;
            else throw Error("unexpected type");
            return h.equals(f)
        }
        static DiffChannel(f, k) {
            return e.clamp(Math.max(f, k) - Math.min(f, k), 0, 1)
        }
        static Diff(f, k) {
            const h = new e.Color;
            h.setR(Math.max(f._r, k._r) - Math.min(f._r, k._r));
            h.setG(Math.max(f._g, k._g) - Math.min(f._g, k._g));
            h.setB(Math.max(f._b, k._b) - Math.min(f._b, k._b));
            h.setA(Math.max(f._a, k._a) - Math.min(f._a, k._a));
            return h
        }
        static DiffNoAlpha(f, k) {
            const h = new e.Color(0, 0, 0, 1);
            h.setR(Math.max(f._r,
                k._r) - Math.min(f._r, k._r));
            h.setG(Math.max(f._g, k._g) - Math.min(f._g, k._g));
            h.setB(Math.max(f._b, k._b) - Math.min(f._b, k._b));
            return h
        }
        static GetHue(f, k, h) {
            const l = Math.max(f, k, h),
                n = Math.min(f, k, h);
            if (l === n) return 0;
            let u = 0;
            switch (l) {
                case f:
                    u = (k - h) / (l - n) + (k < h ? 6 : 0);
                    break;
                case k:
                    u = (h - f) / (l - n) + 2;
                    break;
                case h:
                    u = (f - k) / (l - n) + 4
            }
            return Math.round(u / 6 * 360)
        }
        static GetSaturation(f, k, h) {
            const l = Math.max(f, k, h);
            f = Math.min(f, k, h);
            if (l === f) return 0;
            k = l - f;
            return Math.round(100 * (.5 < (l + f) / 2 ? k / (2 - l - f) : k / (l + f)))
        }
        static GetLuminosity(f,
            k, h) {
            const l = Math.max(f, k, h);
            return l ? Math.round((l + Math.min(f, k, h)) / 2 * 100) : 0
        }
    };
    e.Color.White = Object.freeze(e.New(e.Color, 1, 1, 1, 1));
    e.Color.Black = Object.freeze(e.New(e.Color, 0, 0, 0, 1));
    e.Color.TransparentBlack = Object.freeze(e.New(e.Color, 0, 0, 0, 0))
} {
    "use strict";
    const e = self.C3;
    e.Vector2 = class {
        constructor(a, b) {
            this._y = this._x = 0;
            a instanceof e.Vector2 ? this.copy(a) : this.set(a || 0, b || 0)
        }
        set(a, b) {
            this._x = +a;
            this._y = +b
        }
        copy(a) {
            this._x = a._x;
            this._y = a._y
        }
        equals(a) {
            return this._x === a._x && this._y === a._y
        }
        equalsValues(a, b) {
            return this._x === a && this._y === b
        }
        equalsF32Array(a, b) {
            return a[b] === Math.fround(this._x) && a[b + 1] === Math.fround(this._y)
        }
        setX(a) {
            this._x = +a
        }
        getX() {
            return this._x
        }
        setY(a) {
            this._y = +a
        }
        getY() {
            return this._y
        }
        toArray() {
            return [this._x, this._y]
        }
        toTypedArray() {
            return new Float64Array(this.toArray())
        }
        writeToTypedArray(a,
            b) {
            a[b++] = this._x;
            a[b] = this._y
        }
        offset(a, b) {
            this._x += +a;
            this._y += +b
        }
        scale(a, b) {
            this._x *= a;
            this._y *= b
        }
        divide(a, b) {
            this._x /= a;
            this._y /= b
        }
        round() {
            this._x = Math.round(this._x);
            this._y = Math.round(this._y)
        }
        floor() {
            this._x = Math.floor(this._x);
            this._y = Math.floor(this._y)
        }
        ceil() {
            this._x = Math.ceil(this._x);
            this._y = Math.ceil(this._y)
        }
        angle() {
            return e.angleTo(0, 0, this._x, this._y)
        }
        lengthSquared() {
            return this._x * this._x + this._y * this._y
        }
        length() {
            return Math.sqrt(this.lengthSquared())
        }
        rotatePrecalc(a, b) {
            const d = this._x *
                b - this._y * a;
            this._y = this._y * b + this._x * a;
            this._x = d
        }
        rotate(a) {
            0 !== a && this.rotatePrecalc(Math.sin(a), Math.cos(a))
        }
        rotateAbout(a, b, d) {
            0 === a || b === this._x && d === this._y || (this._x -= b, this._y -= d, this.rotatePrecalc(Math.sin(a), Math.cos(a)), this._x += +b, this._y += +d)
        }
        move(a, b) {
            0 !== b && (this._x += Math.cos(a) * b, this._y += Math.sin(a) * b)
        }
        normalize() {
            const a = this.length();
            0 !== a && 1 !== a && (this._x /= a, this._y /= a)
        }
        clamp(a, b) {
            this._x = e.clamp(this._x, a, b);
            this._y = e.clamp(this._y, a, b)
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Rect = class {
        constructor(a, b, d, c) {
            this._bottom = this._right = this._top = this._left = 0;
            a instanceof e.Rect ? this.copy(a) : this.set(a || 0, b || 0, d || 0, c || 0)
        }
        set(a, b, d, c) {
            this._left = +a;
            this._top = +b;
            this._right = +d;
            this._bottom = +c
        }
        setWH(a, b, d, c) {
            a = +a;
            b = +b;
            this._left = a;
            this._top = b;
            this._right = a + +d;
            this._bottom = b + +c
        }
        copy(a) {
            this._left = +a._left;
            this._top = +a._top;
            this._right = +a._right;
            this._bottom = +a._bottom
        }
        clone() {
            return new e.Rect(this._left, this._top, this._right, this._bottom)
        }
        static Merge(a,
            b) {
            const d = new e.Rect;
            d.setLeft(Math.min(a._left, b._left));
            d.setTop(Math.min(a._top, b._top));
            d.setRight(Math.max(a._right, b._right));
            d.setBottom(Math.max(a._bottom, b._bottom));
            return d
        }
        static FromObject(a) {
            return new e.Rect(a.left, a.top, a.right, a.bottom)
        }
        equals(a) {
            return this._left === a._left && this._top === a._top && this._right === a._right && this._bottom === a._bottom
        }
        equalsWH(a, b, d, c) {
            return this._left === a && this._top === b && this.width() === d && this.height() === c
        }
        equalsF32Array(a, b) {
            return a[b] === Math.fround(this._left) &&
                a[b + 1] === Math.fround(this._top) && a[b + 2] === Math.fround(this._right) && a[b + 3] === Math.fround(this._bottom)
        }
        setLeft(a) {
            this._left = +a
        }
        getLeft() {
            return this._left
        }
        setTop(a) {
            this._top = +a
        }
        getTop() {
            return this._top
        }
        setRight(a) {
            this._right = +a
        }
        getRight() {
            return this._right
        }
        setBottom(a) {
            this._bottom = +a
        }
        getBottom() {
            return this._bottom
        }
        toArray() {
            return [this._left, this._top, this._right, this._bottom]
        }
        toTypedArray() {
            return new Float64Array(this.toArray())
        }
        toDOMRect() {
            return new DOMRect(this._left, this._top, this.width(),
                this.height())
        }
        writeToTypedArray(a, b) {
            a[b++] = this._left;
            a[b++] = this._top;
            a[b++] = this._right;
            a[b] = this._bottom
        }
        writeAsQuadToTypedArray(a, b) {
            a[b++] = this._left;
            a[b++] = this._top;
            a[b++] = this._right;
            a[b++] = this._top;
            a[b++] = this._right;
            a[b++] = this._bottom;
            a[b++] = this._left;
            a[b] = this._bottom
        }
        writeAsQuadToTypedArray3D(a, b, d) {
            a[b++] = this._left;
            a[b++] = this._top;
            a[b++] = d;
            a[b++] = this._right;
            a[b++] = this._top;
            a[b++] = d;
            a[b++] = this._right;
            a[b++] = this._bottom;
            a[b++] = d;
            a[b++] = this._left;
            a[b++] = this._bottom;
            a[b] = d
        }
        width() {
            return this._right -
                this._left
        }
        height() {
            return this._bottom - this._top
        }
        midX() {
            return (this._left + this._right) / 2
        }
        midY() {
            return (this._top + this._bottom) / 2
        }
        offset(a, b) {
            a = +a;
            b = +b;
            this._left += a;
            this._top += b;
            this._right += a;
            this._bottom += b
        }
        offsetLeft(a) {
            this._left += +a
        }
        offsetTop(a) {
            this._top += +a
        }
        offsetRight(a) {
            this._right += +a
        }
        offsetBottom(a) {
            this._bottom += +a
        }
        toSquare(a) {
            if ("x" !== a) throw Error("invalid axis, only 'x' supported");
            this._bottom = this._top < this._bottom ? this._left < this._right ? this._top + this.width() : this._top - this.width() :
                this._left < this._right ? this._top - this.width() : this._top + this.width()
        }
        inflate(a, b) {
            a = +a;
            b = +b;
            this._left -= a;
            this._top -= b;
            this._right += a;
            this._bottom += b
        }
        deflate(a, b) {
            a = +a;
            b = +b;
            this._left += a;
            this._top += b;
            this._right -= a;
            this._bottom -= b
        }
        multiply(a, b) {
            this._left *= a;
            this._top *= b;
            this._right *= a;
            this._bottom *= b
        }
        divide(a, b) {
            this._left /= a;
            this._top /= b;
            this._right /= a;
            this._bottom /= b
        }
        mirrorAround(a) {
            this._left = +a - this._left;
            this._right = +a - this._right
        }
        flipAround(a) {
            this._top = +a - this._top;
            this._bottom = +a - this._bottom
        }
        swapLeftRight() {
            const a =
                this._left;
            this._left = this._right;
            this._right = a
        }
        swapTopBottom() {
            const a = this._top;
            this._top = this._bottom;
            this._bottom = a
        }
        shuntY(a) {
            const b = this._top;
            this._top = +a - this._bottom;
            this._bottom = +a - b
        }
        round() {
            this._left = Math.round(this._left);
            this._top = Math.round(this._top);
            this._right = Math.round(this._right);
            this._bottom = Math.round(this._bottom)
        }
        roundInner() {
            this._left = Math.ceil(this._left);
            this._top = Math.ceil(this._top);
            this._right = Math.floor(this._right);
            this._bottom = Math.floor(this._bottom)
        }
        roundOuter() {
            this._left =
                Math.floor(this._left);
            this._top = Math.floor(this._top);
            this._right = Math.ceil(this._right);
            this._bottom = Math.ceil(this._bottom)
        }
        floor() {
            this._left = Math.floor(this._left);
            this._top = Math.floor(this._top);
            this._right = Math.floor(this._right);
            this._bottom = Math.floor(this._bottom)
        }
        ceil() {
            this._left = Math.ceil(this._left);
            this._top = Math.ceil(this._top);
            this._right = Math.ceil(this._right);
            this._bottom = Math.ceil(this._bottom)
        }
        clamp(a, b, d, c) {
            this._left < a && (this._left = +a);
            this._top < b && (this._top = +b);
            this._right >
                d && (this._right = +d);
            this._bottom > c && (this._bottom = +c)
        }
        clampFlipped(a, b, d, c) {
            this._left < a && (this._left = +a);
            this._top > b && (this._top = +b);
            this._right > d && (this._right = +d);
            this._bottom < c && (this._bottom = +c)
        }
        normalize() {
            this._left > this._right && this.swapLeftRight();
            this._top > this._bottom && this.swapTopBottom()
        }
        intersectsRect(a) {
            return !(a._right < this._left || a._bottom < this._top || a._left > this._right || a._top > this._bottom)
        }
        intersectsRectOffset(a, b, d) {
            return !(a._right + b < this._left || a._bottom + d < this._top || a._left +
                b > this._right || a._top + d > this._bottom)
        }
        containsPoint(a, b) {
            return a >= this._left && a <= this._right && b >= this._top && b <= this._bottom
        }
        containsRect(a) {
            return a._left >= this._left && a._top >= this._top && a._right <= this._right && a._bottom <= this._bottom
        }
        expandToContain(a) {
            a._left < this._left && (this._left = +a._left);
            a._top < this._top && (this._top = +a._top);
            a._right > this._right && (this._right = +a._right);
            a._bottom > this._bottom && (this._bottom = +a._bottom)
        }
        lerpInto(a) {
            this._left = e.lerp(a._left, a._right, this._left);
            this._top = e.lerp(a._top,
                a._bottom, this._top);
            this._right = e.lerp(a._left, a._right, this._right);
            this._bottom = e.lerp(a._top, a._bottom, this._bottom)
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Quad = class {
        constructor(a, b, d, c, f, k, h, l) {
            this._bly = this._blx = this._bry = this._brx = this._try = this._trx = this._tly = this._tlx = 0;
            a instanceof e.Quad ? this.copy(a) : this.set(a || 0, b || 0, d || 0, c || 0, f || 0, k || 0, h || 0, l || 0)
        }
        set(a, b, d, c, f, k, h, l) {
            this._tlx = +a;
            this._tly = +b;
            this._trx = +d;
            this._try = +c;
            this._brx = +f;
            this._bry = +k;
            this._blx = +h;
            this._bly = +l
        }
        setRect(a, b, d, c) {
            this.set(a, b, d, b, d, c, a, c)
        }
        copy(a) {
            this._tlx = a._tlx;
            this._tly = a._tly;
            this._trx = a._trx;
            this._try = a._try;
            this._brx = a._brx;
            this._bry =
                a._bry;
            this._blx = a._blx;
            this._bly = a._bly
        }
        equals(a) {
            return this._tlx === a._tlx && this._tly === a._tly && this._trx === a._trx && this._try === a._try && this._brx === a._brx && this._bry === a._bry && this._blx === a._blx && this._bly === a._bly
        }
        setTlx(a) {
            this._tlx = +a
        }
        getTlx() {
            return this._tlx
        }
        setTly(a) {
            this._tly = +a
        }
        getTly() {
            return this._tly
        }
        setTrx(a) {
            this._trx = +a
        }
        getTrx() {
            return this._trx
        }
        setTry(a) {
            this._try = +a
        }
        getTry() {
            return this._try
        }
        setBrx(a) {
            this._brx = +a
        }
        getBrx() {
            return this._brx
        }
        setBry(a) {
            this._bry = +a
        }
        getBry() {
            return this._bry
        }
        setBlx(a) {
            this._blx = +a
        }
        getBlx() {
            return this._blx
        }
        setBly(a) {
            this._bly = +a
        }
        getBly() {
            return this._bly
        }
        toDOMQuad() {
            return new DOMQuad(new DOMPoint(this._tlx, this._tly), new DOMPoint(this._trx, this._try), new DOMPoint(this._brx, this._bry), new DOMPoint(this._blx, this._bly))
        }
        toArray() {
            return [this._tlx, this._tly, this._trx, this._try, this._brx, this._bry, this._blx, this._bly]
        }
        toTypedArray() {
            return new Float64Array(this.toArray())
        }
        writeToTypedArray(a, b) {
            a[b++] = this._tlx;
            a[b++] = this._tly;
            a[b++] = this._trx;
            a[b++] = this._try;
            a[b++] = this._brx;
            a[b++] = this._bry;
            a[b++] = this._blx;
            a[b] = this._bly
        }
        writeToTypedArray3D(a, b, d) {
            a[b++] = this._tlx;
            a[b++] = this._tly;
            a[b++] = d;
            a[b++] = this._trx;
            a[b++] = this._try;
            a[b++] = d;
            a[b++] = this._brx;
            a[b++] = this._bry;
            a[b++] = d;
            a[b++] = this._blx;
            a[b++] = this._bly;
            a[b] = d
        }
        offset(a, b) {
            a = +a;
            b = +b;
            this._tlx += a;
            this._tly += b;
            this._trx += a;
            this._try += b;
            this._brx += a;
            this._bry += b;
            this._blx += a;
            this._bly += b
        }
        round() {
            this._tlx = Math.round(this._tlx);
            this._tly = Math.round(this._tly);
            this._trx = Math.round(this._trx);
            this._try = Math.round(this._try);
            this._brx = Math.round(this._brx);
            this._bry = Math.round(this._bry);
            this._blx = Math.round(this._blx);
            this._bly = Math.round(this._bly)
        }
        floor() {
            this._tlx = Math.floor(this._tlx);
            this._tly = Math.floor(this._tly);
            this._trx = Math.floor(this._trx);
            this._try = Math.floor(this._try);
            this._brx = Math.floor(this._brx);
            this._bry = Math.floor(this._bry);
            this._blx = Math.floor(this._blx);
            this._bly = Math.floor(this._bly)
        }
        ceil() {
            this._tlx = Math.ceil(this._tlx);
            this._tly = Math.ceil(this._tly);
            this._trx = Math.ceil(this._trx);
            this._try =
                Math.ceil(this._try);
            this._brx = Math.ceil(this._brx);
            this._bry = Math.ceil(this._bry);
            this._blx = Math.ceil(this._blx);
            this._bly = Math.ceil(this._bly)
        }
        setFromRect(a) {
            this._tlx = a._left;
            this._tly = a._top;
            this._trx = a._right;
            this._try = a._top;
            this._brx = a._right;
            this._bry = a._bottom;
            this._blx = a._left;
            this._bly = a._bottom
        }
        setFromRotatedRect(a, b) {
            0 === b ? this.setFromRect(a) : this.setFromRotatedRectPrecalc(a, Math.sin(b), Math.cos(b))
        }
        setFromRotatedRectPrecalc(a, b, d) {
            const c = a._left * b,
                f = a._top * b,
                k = a._right * b;
            b *= a._bottom;
            const h = a._left * d,
                l = a._top * d,
                n = a._right * d;
            a = a._bottom * d;
            this._tlx = h - f;
            this._tly = l + c;
            this._trx = n - f;
            this._try = l + k;
            this._brx = n - b;
            this._bry = a + k;
            this._blx = h - b;
            this._bly = a + c
        }
        getBoundingBox(a) {
            a.set(Math.min(this._tlx, this._trx, this._brx, this._blx), Math.min(this._tly, this._try, this._bry, this._bly), Math.max(this._tlx, this._trx, this._brx, this._blx), Math.max(this._tly, this._try, this._bry, this._bly))
        }
        containsPoint(a, b) {
            var d = this._trx - this._tlx,
                c = this._try - this._tly;
            const f = this._brx - this._tlx,
                k = this._bry - this._tly;
            a -= this._tlx;
            b -= this._tly;
            var h = d * d + c * c;
            let l = d * f + c * k;
            c = d * a + c * b;
            const n = f * f + k * k,
                u = f * a + k * b;
            let w = 1 / (h * n - l * l);
            d = (n * c - l * u) * w;
            h = (h * u - l * c) * w;
            if (0 <= d && 0 < h && 1 > d + h) return !0;
            d = this._blx - this._tlx;
            c = this._bly - this._tly;
            h = d * d + c * c;
            l = d * f + c * k;
            c = d * a + c * b;
            w = 1 / (h * n - l * l);
            d = (n * c - l * u) * w;
            h = (h * u - l * c) * w;
            return 0 <= d && 0 < h && 1 > d + h
        }
        midX() {
            return (this._tlx + this._trx + this._brx + this._blx) / 4
        }
        midY() {
            return (this._tly + this._try + this._bry + this._bly) / 4
        }
        intersectsSegment(a, b, d, c) {
            return this.containsPoint(a, b) || this.containsPoint(d, c) ?
                !0 : e.segmentIntersectsQuad(a, b, d, c, this)
        }
        intersectsQuad(a) {
            var b = a.midX(),
                d = a.midY();
            if (this.containsPoint(b, d)) return !0;
            b = this.midX();
            d = this.midY();
            if (a.containsPoint(b, d)) return !0;
            b = this._tlx;
            d = this._tly;
            const c = this._trx,
                f = this._try,
                k = this._brx,
                h = this._bry,
                l = this._blx,
                n = this._bly;
            return e.segmentIntersectsQuad(b, d, c, f, a) || e.segmentIntersectsQuad(c, f, k, h, a) || e.segmentIntersectsQuad(k, h, l, n, a) || e.segmentIntersectsQuad(l, n, b, d, a)
        }
        rotatePointsAnticlockwise() {
            const a = this._tlx,
                b = this._tly;
            this._tlx =
                this._trx;
            this._tly = this._try;
            this._trx = this._brx;
            this._try = this._bry;
            this._brx = this._blx;
            this._bry = this._bly;
            this._blx = a;
            this._bly = b
        }
        mirror() {
            this._swap(0, 2);
            this._swap(1, 3);
            this._swap(6, 4);
            this._swap(7, 5)
        }
        flip() {
            this._swap(0, 6);
            this._swap(1, 7);
            this._swap(2, 4);
            this._swap(3, 5)
        }
        diag() {
            this._swap(2, 6);
            this._swap(3, 7)
        }
        _swap(a, b) {
            const d = this._getAtIndex(a);
            this._setAtIndex(a, this._getAtIndex(b));
            this._setAtIndex(b, d)
        }
        _getAtIndex(a) {
            switch (a) {
                case 0:
                    return this._tlx;
                case 1:
                    return this._tly;
                case 2:
                    return this._trx;
                case 3:
                    return this._try;
                case 4:
                    return this._brx;
                case 5:
                    return this._bry;
                case 6:
                    return this._blx;
                case 7:
                    return this._bly;
                default:
                    throw new RangeError("invalid quad point index");
            }
        }
        _setAtIndex(a, b) {
            b = +b;
            switch (a) {
                case 0:
                    this._tlx = b;
                    break;
                case 1:
                    this._tly = b;
                    break;
                case 2:
                    this._trx = b;
                    break;
                case 3:
                    this._try = b;
                    break;
                case 4:
                    this._brx = b;
                    break;
                case 5:
                    this._bry = b;
                    break;
                case 6:
                    this._blx = b;
                    break;
                case 7:
                    this._bly = b;
                    break;
                default:
                    throw new RangeError("invalid quad point index");
            }
        }
    }
} {
    "use strict";
    const e = self.C3,
        a = [0, 0, 1, 0, 1, 1, 0, 1],
        b = e.New(e.Quad);
    e.CollisionPoly = class extends e.DefendedBase {
        constructor(d, c = !0) {
            super();
            d || (d = a);
            this._ptsArr = Float64Array.from(d);
            this._bbox = new e.Rect;
            this._isBboxChanged = !0;
            this._enabled = c
        }
        Release() {}
        pointsArr() {
            return this._ptsArr
        }
        pointCount() {
            return this._ptsArr.length / 2
        }
        setPoints(d) {
            this._ptsArr.length === d.length ? this._ptsArr.set(d) : this._ptsArr = Float64Array.from(d);
            this._isBboxChanged = !0
        }
        setDefaultPoints() {
            this.setPoints(a)
        }
        copy(d) {
            this.setPoints(d._ptsArr)
        }
        setBboxChanged() {
            this._isBboxChanged = !0
        }
        _updateBbox() {
            if (this._isBboxChanged) {
                var d = this._ptsArr,
                    c = d[0],
                    f = d[1],
                    k = c,
                    h = f;
                for (let l = 0, n = d.length; l < n; l += 2) {
                    const u = d[l],
                        w = d[l + 1];
                    u < c && (c = u);
                    u > k && (k = u);
                    w < f && (f = w);
                    w > h && (h = w)
                }
                this._bbox.set(c, f, k, h);
                this._isBboxChanged = !1
            }
        }
        setFromRect(d, c, f) {
            let k = this._ptsArr;
            8 !== k.length && (this._ptsArr = k = new Float64Array(8));
            k[0] = d.getLeft() - c;
            k[1] = d.getTop() - f;
            k[2] = d.getRight() - c;
            k[3] = d.getTop() - f;
            k[4] = d.getRight() - c;
            k[5] = d.getBottom() - f;
            k[6] = d.getLeft() - c;
            k[7] = d.getBottom() - f;
            this._bbox.copy(d);
            0 === c && 0 ===
                f || this._bbox.offset(-c, -f);
            this._isBboxChanged = !1
        }
        setFromQuad(d, c, f) {
            b.copy(d);
            b.offset(c, f);
            this.setPoints(b.toArray());
            this._isBboxChanged = !0
        }
        transform(d, c, f) {
            let k = 0,
                h = 1;
            0 !== f && (k = Math.sin(f), h = Math.cos(f));
            this.transformPrecalc(d, c, k, h)
        }
        transformPrecalc(d, c, f, k) {
            const h = this._ptsArr;
            for (let l = 0, n = h.length; l < n; l += 2) {
                const u = l + 1,
                    w = h[l] * d,
                    q = h[u] * c;
                h[l] = w * k - q * f;
                h[u] = q * k + w * f
            }
            this._isBboxChanged = !0
        }
        offset(d, c) {
            const f = this._ptsArr;
            for (let k = 0, h = f.length; k < h; k += 2) f[k] += d, f[k + 1] += c
        }
        containsPoint(d, c) {
            const f =
                this._ptsArr;
            if (d === f[0] && c === f[1]) return !0;
            this._updateBbox();
            var k = this._bbox;
            const h = k.getLeft() - 110,
                l = k.getTop() - 101,
                n = k.getRight() + 131;
            k = k.getBottom() + 120;
            let u, w, q, t, p, r, x, y;
            h < d ? (u = h, q = d) : (u = d, q = h);
            l < c ? (w = l, t = c) : (w = c, t = l);
            n < d ? (p = n, x = d) : (p = d, x = n);
            k < c ? (r = k, y = c) : (r = c, y = k);
            let E = 0,
                G = 0;
            for (let F = 0, J = f.length; F < J; F += 2) {
                var A = (F + 2) % J;
                const B = f[F],
                    I = f[F + 1],
                    L = f[A];
                A = f[A + 1];
                e.segmentsIntersectPreCalc(h, l, d, c, u, q, w, t, B, I, L, A) && ++E;
                e.segmentsIntersectPreCalc(n, k, d, c, p, x, r, y, B, I, L, A) && ++G
            }
            return 1 === E % 2 ||
                1 === G % 2
        }
        intersectsPoly(d, c, f) {
            const k = d._ptsArr,
                h = this._ptsArr;
            if (this.containsPoint(k[0] + c, k[1] + f) || d.containsPoint(h[0] - c, h[1] - f)) return !0;
            for (let n = 0, u = h.length; n < u; n += 2) {
                var l = (n + 2) % u;
                d = h[n];
                const w = h[n + 1],
                    q = h[l];
                l = h[l + 1];
                let t, p, r, x;
                d < q ? (t = d, r = q) : (t = q, r = d);
                w < l ? (p = w, x = l) : (p = l, x = w);
                for (let y = 0, E = k.length; y < E; y += 2) {
                    const G = (y + 2) % E;
                    if (e.segmentsIntersectPreCalc(d, w, q, l, t, r, p, x, k[y] + c, k[y + 1] + f, k[G] + c, k[G + 1] + f)) return !0
                }
            }
            return !1
        }
        intersectsSegment(d, c, f, k, h, l) {
            if (this.containsPoint(f - d, k - c) || this.containsPoint(h -
                    d, l - c)) return !0;
            let n, u, w, q;
            f < h ? (n = f, w = h) : (n = h, w = f);
            k < l ? (u = k, q = l) : (u = l, q = k);
            const t = this._ptsArr;
            for (let p = 0, r = t.length; p < r; p += 2) {
                const x = (p + 2) % r;
                if (e.segmentsIntersectPreCalc(f, k, h, l, n, w, u, q, t[p] + d, t[p + 1] + c, t[x] + d, t[x + 1] + c)) return !0
            }
            return !1
        }
        mirror(d) {
            const c = this._ptsArr;
            for (let f = 0, k = c.length; f < k; f += 2) c[f] = 2 * d - c[f];
            this._isBboxChanged = !0
        }
        flip(d) {
            const c = this._ptsArr;
            for (let f = 0, k = c.length; f < k; f += 2) {
                const h = f + 1;
                c[h] = 2 * d - c[h]
            }
            this._isBboxChanged = !0
        }
        diag() {
            const d = this._ptsArr;
            for (let c = 0, f = d.length; c <
                f; c += 2) {
                const k = c + 1,
                    h = d[c];
                d[c] = d[k];
                d[k] = h
            }
            this._isBboxChanged = !0
        }
        GetMidX() {
            const d = this._ptsArr;
            let c = 0;
            for (let f = 0, k = d.length; f < k; f += 2) c += d[f];
            return c / this.pointCount()
        }
        GetMidY() {
            const d = this._ptsArr;
            let c = 0;
            for (let f = 0, k = d.length; f < k; f += 2) c += d[f + 1];
            return c / this.pointCount()
        }
        GetPointsArray() {
            return this._ptsArr
        }
        GetPointCount() {
            return this.pointCount()
        }
        IsEnabled() {
            return this._enabled
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.PairMap = class extends e.DefendedBase {
        constructor(a) {
            super();
            this._firstMap = new Map;
            if (a)
                for (const [b, d, c] of a) this.Set(b, d, c)
        }
        Release() {
            this.Clear();
            this._firstMap = null
        }
        Clear() {
            const a = this._firstMap;
            for (const b of a.values()) b.clear();
            a.clear()
        }
        Set(a, b, d) {
            const c = this._firstMap;
            let f = c.get(a);
            f || (f = new Map, c.set(a, f));
            f.set(b, d)
        }
        Get(a, b) {
            return (a = this._firstMap.get(a)) ? a.get(b) : a
        }
        Has(a, b) {
            return (a = this._firstMap.get(a)) ? a.has(b) : !1
        }
        Delete(a, b) {
            const d = this._firstMap,
                c = d.get(a);
            if (!c) return !1;
            (b = c.delete(b)) && 0 === c.size && d.delete(a);
            return b
        }
        DeleteEither(a) {
            const b = this._firstMap,
                d = b.get(a);
            d && (d.clear(), b.delete(a));
            for (const [c, f] of b.entries()) f.delete(a) && 0 === f.size && b.delete(c)
        }
        GetSize() {
            let a = 0;
            for (const b of this._firstMap.values()) a += b.size;
            return a
        }* values() {
            for (const a of this._firstMap.values()) yield* a.values()
        }* keyPairs() {
            for (const [a, b] of this._firstMap.entries())
                for (const d of b.keys()) yield [a, d]
        }* entries() {
            for (const [a, b] of this._firstMap.entries())
                for (const [d,
                        c
                    ] of b.entries()) yield [a, d, c]
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.ArraySet = class extends e.DefendedBase {
        constructor() {
            super();
            this._set = new Set;
            this._arr = [];
            this._needToRebuildArray = !1
        }
        Release() {
            this.Clear()
        }
        Clear() {
            this._set.clear();
            e.clearArray(this._arr);
            this._needToRebuildArray = !1
        }
        Add(a) {
            this._set.has(a) || (this._set.add(a), this._needToRebuildArray || this._arr.push(a))
        }
        Has(a) {
            return this._set.has(a)
        }
        Delete(a) {
            this._set.delete(a) && (this._needToRebuildArray = !0)
        }
        GetSize() {
            return this._set.size
        }
        IsEmpty() {
            return 0 === this._set.size
        }
        GetArray() {
            this._needToRebuildArray &&
                (this._RebuildArray(), this._needToRebuildArray = !1);
            return this._arr
        }
        _RebuildArray() {
            const a = this._arr;
            e.clearArray(a);
            for (const b of this._set) a.push(b)
        }
    }
} {
    "use strict";
    const e = new Map,
        a = new Map,
        b = new Map,
        d = new Map,
        c = new Map,
        f = new Map;
    f.set("linear", "noease");
    f.set("default", "noease");
    self.Ease = class q {
        constructor() {}
        static InheritEase() {
            return "default"
        }
        static DefaultEase() {
            return "noease"
        }
        static GetEditorEaseNames(t, ...p) {
            this._CreateEaseMap();
            b.has(t) || b.set(t, new Map);
            t = [...b.get(t).keys()];
            t.sort();
            return [...a.keys()].concat(t).filter(r => !p.includes(r))
        }
        static GetRuntimeEaseNames() {
            this._CreateEaseMap();
            const t = [...d.keys()];
            t.sort();
            return [...a.keys()].concat(t)
        }
        static IsNamePredefined(t) {
            this._CreateEaseMap();
            return [...a.keys()].includes(t)
        }
        static _GetEase(t) {
            const p = f.get(t);
            if (p) return e.get(p);
            if (q.IsNamePredefined(t)) return e.get(t);
            if (c.has(t)) return c.get(t)
        }
        static GetEditorEase(t, p) {
            this._CreateEaseMap();
            const r = q._GetEase(t);
            return r ? r : b.get(p).get(t)
        }
        static GetRuntimeEase(t) {
            this._CreateEaseMap();
            const p = q._GetEase(t);
            return p ? p : d.get(t)
        }
        static GetEaseFromIndex(t) {
            this._CreateEaseMap();
            return this.GetRuntimeEaseNames()[t]
        }
        static GetIndexForEase(t, p) {
            this._CreateEaseMap();
            return this.GetEditorEaseNames(p).indexOf(t)
        }
        static _CreateEaseMap() {
            0 ===
                e.size && (this._AddPredifinedEase("default", () => {}), this._AddPredifinedEase("noease", this.NoEase), this._AddPredifinedEase("easeinsine", this.EaseInSine), this._AddPredifinedEase("easeoutsine", this.EaseOutSine), this._AddPredifinedEase("easeinoutsine", this.EaseInOutSine), this._AddPredifinedEase("easeinelastic", this.EaseInElastic), this._AddPredifinedEase("easeoutelastic", this.EaseOutElastic), this._AddPredifinedEase("easeinoutelastic", this.EaseInOutElastic), this._AddPredifinedEase("easeinback", this.EaseInBack),
                    this._AddPredifinedEase("easeoutback", this.EaseOutBack), this._AddPredifinedEase("easeinoutback", this.EaseInOutBack), this._AddPredifinedEase("easeinbounce", this.EaseInBounce), this._AddPredifinedEase("easeoutbounce", this.EaseOutBounce), this._AddPredifinedEase("easeinoutbounce", this.EaseInOutBounce), this._AddPredifinedEase("easeincubic", this.EaseInCubic), this._AddPredifinedEase("easeoutcubic", this.EaseOutCubic), this._AddPredifinedEase("easeinoutcubic", this.EaseInOutCubic), this._AddPredifinedEase("easeinquad",
                        this.EaseInQuad), this._AddPredifinedEase("easeoutquad", this.EaseOutQuad), this._AddPredifinedEase("easeinoutquad", this.EaseInOutQuad), this._AddPredifinedEase("easeinquart", this.EaseInQuart), this._AddPredifinedEase("easeoutquart", this.EaseOutQuart), this._AddPredifinedEase("easeinoutquart", this.EaseInOutQuart), this._AddPredifinedEase("easeinquint", this.EaseInQuint), this._AddPredifinedEase("easeoutquint", this.EaseOutQuint), this._AddPredifinedEase("easeinoutquint", this.EaseInOutQuint), this._AddPredifinedEase("easeincirc",
                        this.EaseInCirc), this._AddPredifinedEase("easeoutcirc", this.EaseOutCirc), this._AddPredifinedEase("easeinoutcirc", this.EaseInOutCirc), this._AddPredifinedEase("easeinexpo", this.EaseInExpo), this._AddPredifinedEase("easeoutexpo", this.EaseOutExpo), this._AddPredifinedEase("easeinoutexpo", this.EaseInOutExpo), this._AddPrivateCustomEase("cubicbezier", this.EaseCubicBezier), this._AddPrivateCustomEase("spline", this.EaseSpline))
        }
        static _AddPredifinedEase(t, p) {
            q._AddEase(t, p, "predefined")
        }
        static _AddPrivateCustomEase(t,
            p) {
            q._AddEase(t, p, "private")
        }
        static AddCustomEase(t, p, r) {
            this._CreateEaseMap();
            q._AddEase(t, p, "custom", r)
        }
        static RemoveCustomEase(t, p) {
            this.IsNamePredefined(t) || [...c.keys()].includes(t) || (p = b.get(p)) && p.delete(t)
        }
        static _AddEase(t, p, r, x) {
            switch (r) {
                case "predefined":
                    e.set(t, p);
                    a.set(t, p);
                    break;
                case "custom":
                    x ? (b.has(x) || b.set(x, new Map), b.get(x).set(t, p)) : d.set(t, p);
                    break;
                case "private":
                    e.set(t, p);
                    c.set(t, p);
                    break;
                default:
                    throw Error("unexpected ease mode");
            }
        }
        static NoEase(t, p, r, x) {
            return r * t / x + p
        }
        static EaseInQuad(t,
            p, r, x) {
            return r * (t /= x) * t + p
        }
        static EaseOutQuad(t, p, r, x) {
            return -r * (t /= x) * (t - 2) + p
        }
        static EaseInOutQuad(t, p, r, x) {
            return 1 > (t /= x / 2) ? r / 2 * t * t + p : -r / 2 * (--t * (t - 2) - 1) + p
        }
        static EaseInCubic(t, p, r, x) {
            return r * (t /= x) * t * t + p
        }
        static EaseOutCubic(t, p, r, x) {
            return r * ((t = t / x - 1) * t * t + 1) + p
        }
        static EaseInOutCubic(t, p, r, x) {
            return 1 > (t /= x / 2) ? r / 2 * t * t * t + p : r / 2 * ((t -= 2) * t * t + 2) + p
        }
        static EaseInQuart(t, p, r, x) {
            return r * (t /= x) * t * t * t + p
        }
        static EaseOutQuart(t, p, r, x) {
            return -r * ((t = t / x - 1) * t * t * t - 1) + p
        }
        static EaseInOutQuart(t, p, r, x) {
            return 1 > (t /=
                x / 2) ? r / 2 * t * t * t * t + p : -r / 2 * ((t -= 2) * t * t * t - 2) + p
        }
        static EaseInQuint(t, p, r, x) {
            return r * (t /= x) * t * t * t * t + p
        }
        static EaseOutQuint(t, p, r, x) {
            return r * ((t = t / x - 1) * t * t * t * t + 1) + p
        }
        static EaseInOutQuint(t, p, r, x) {
            return 1 > (t /= x / 2) ? r / 2 * t * t * t * t * t + p : r / 2 * ((t -= 2) * t * t * t * t + 2) + p
        }
        static EaseInSine(t, p, r, x) {
            return -r * Math.cos(t / x * (Math.PI / 2)) + r + p
        }
        static EaseOutSine(t, p, r, x) {
            return r * Math.sin(t / x * (Math.PI / 2)) + p
        }
        static EaseInOutSine(t, p, r, x) {
            return -r / 2 * (Math.cos(Math.PI * t / x) - 1) + p
        }
        static EaseInExpo(t, p, r, x) {
            return 0 === t ? p : r * Math.pow(2,
                10 * (t / x - 1)) + p
        }
        static EaseOutExpo(t, p, r, x) {
            return t === x ? p + r : r * (-Math.pow(2, -10 * t / x) + 1) + p
        }
        static EaseInOutExpo(t, p, r, x) {
            return 0 === t ? p : t === x ? p + r : 1 > (t /= x / 2) ? r / 2 * Math.pow(2, 10 * (t - 1)) + p : r / 2 * (-Math.pow(2, -10 * --t) + 2) + p
        }
        static EaseInCirc(t, p, r, x) {
            return -r * (Math.sqrt(1 - (t /= x) * t) - 1) + p
        }
        static EaseOutCirc(t, p, r, x) {
            return r * Math.sqrt(1 - (t = t / x - 1) * t) + p
        }
        static EaseInOutCirc(t, p, r, x) {
            return 1 > (t /= x / 2) ? -r / 2 * (Math.sqrt(1 - t * t) - 1) + p : r / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + p
        }
        static EaseInElastic(t, p, r, x) {
            let y = 0,
                E = r;
            if (0 === t) return p;
            if (1 === (t /= x)) return p + r;
            y || (y = .3 * x);
            E < Math.abs(r) ? (E = r, r = y / 4) : r = y / (2 * Math.PI) * Math.asin(r / E);
            return -(E * Math.pow(2, 10 * --t) * Math.sin(2 * (t * x - r) * Math.PI / y)) + p
        }
        static EaseOutElastic(t, p, r, x) {
            let y, E = 0,
                G = r;
            if (0 === t) return p;
            if (1 === (t /= x)) return p + r;
            E || (E = .3 * x);
            G < Math.abs(r) ? (G = r, y = E / 4) : y = E / (2 * Math.PI) * Math.asin(r / G);
            return G * Math.pow(2, -10 * t) * Math.sin(2 * (t * x - y) * Math.PI / E) + r + p
        }
        static EaseInOutElastic(t, p, r, x) {
            let y, E = 0,
                G = r;
            if (0 === t) return p;
            if (2 === (t /= x / 2)) return p + r;
            E || (E = .3 * x * 1.5);
            G < Math.abs(r) ? (G = r,
                y = E / 4) : y = E / (2 * Math.PI) * Math.asin(r / G);
            return 1 > t ? -.5 * G * Math.pow(2, 10 * --t) * Math.sin(2 * (t * x - y) * Math.PI / E) + p : G * Math.pow(2, -10 * --t) * Math.sin(2 * (t * x - y) * Math.PI / E) * .5 + r + p
        }
        static EaseInBack(t, p, r, x, y) {
            void 0 === y && (y = 1.70158);
            return r * (t /= x) * t * ((y + 1) * t - y) + p
        }
        static EaseOutBack(t, p, r, x, y) {
            void 0 === y && (y = 1.70158);
            return r * ((t = t / x - 1) * t * ((y + 1) * t + y) + 1) + p
        }
        static EaseInOutBack(t, p, r, x, y) {
            void 0 === y && (y = 1.70158);
            return 1 > (t /= x / 2) ? r / 2 * t * t * (((y *= 1.525) + 1) * t - y) + p : r / 2 * ((t -= 2) * t * (((y *= 1.525) + 1) * t + y) + 2) + p
        }
        static EaseInBounce(t,
            p, r, x) {
            return r - q.EaseOutBounce(x - t, 0, r, x) + p
        }
        static EaseOutBounce(t, p, r, x) {
            return (t /= x) < 1 / 2.75 ? 7.5625 * r * t * t + p : t < 2 / 2.75 ? r * (7.5625 * (t -= 1.5 / 2.75) * t + .75) + p : t < 2.5 / 2.75 ? r * (7.5625 * (t -= 2.25 / 2.75) * t + .9375) + p : r * (7.5625 * (t -= 2.625 / 2.75) * t + .984375) + p
        }
        static EaseInOutBounce(t, p, r, x) {
            return t < x / 2 ? .5 * q.EaseInBounce(2 * t, 0, r, x) + p : .5 * q.EaseOutBounce(2 * t - x, 0, r, x) + .5 * r + p
        }
        static EaseCubicBezier(t, p, r, x, y) {
            return p + 3 * t * (r - p) + 3 * t ** 2 * (p + x - 2 * r) + t ** 3 * (y - p + 3 * r - 3 * x)
        }
        static EaseSpline(t, p, r, x, y, E, G, A, F, J) {
            if (x === y && E === G) return t;
            t = w(t, p, x, E, A, J);
            p = k(r, y, G, F);
            x = h(r, y, G, F);
            r = l(r, y, G, F);
            return n(t, p, x, r)
        }
        static GetBezierSamples(t, p, r, x) {
            const y = [],
                E = k(t, p, r, x),
                G = h(t, p, r, x);
            t = l(t, p, r, x);
            for (p = 0; 11 > p; ++p) r = n(.1 * p, E, G, t), y.push(r);
            return y
        }
    };
    const k = (q, t, p, r) => r - 3 * p + 3 * t - q,
        h = (q, t, p, r) => 3 * p - 6 * t + 3 * q,
        l = (q, t, p, r) => 3 * (t - q),
        n = (q, t, p, r) => ((t * q + p) * q + r) * q,
        u = (q, t, p, r) => 3 * t * q * q + 2 * p * q + r,
        w = (q, t, p, r, x, y) => {
            if (1 == q) return 1;
            for (var E = 0, G = 1, A = y[G]; 10 != G && A <= q;) G++, A = y[G], E += .1;
            G--;
            A = y[G];
            y = E + (q - A) / (y[G + 1] - A) * .1;
            G = k(t, p, r, x);
            A = h(t, p, r, x);
            t = l(t,
                p, r, x);
            p = u(y, G, A, t);
            if (0 !== p)
                if (.02 <= p)
                    for (E = 0; 4 > E; ++E) p = n(y, G, A, t) - q, r = u(y, G, A, t), y -= p / r;
                else {
                    p = E;
                    E += .1;
                    r = 0;
                    let F;
                    do y = p + (E - p) / 2, x = n(y, G, A, t) - q, 0 < x ? E = y : p = y, x = 1E-7 < Math.abs(x), F = 10 > ++r; while (x && F)
                } return y
        }
} {
    "use strict";
    const e = self.C3;

    function a(b) {
        e.IsString(b)
    }
    e.ProbabilityTable = class {
        constructor() {
            this._items = [];
            this._totalWeight = 0
        }
        Release() {
            this.Clear();
            this._items = null
        }
        Clear() {
            e.clear2DArray(this._items);
            this._totalWeight = 0
        }
        GetTotalWeight() {
            return this._totalWeight
        }
        Sample(b = Math.random() * this.GetTotalWeight()) {
            let d = 0;
            for (const [c, f] of this._items)
                if (d += c, b < d) return f;
            return 0
        }
        AddItem(b, d) {
            a(d);
            this._totalWeight += b;
            this._items.push([b, d])
        }
        RemoveItem(b, d) {
            a(d);
            const c = 0 === b;
            for (let f = 0; f < this._items.length; f++) {
                const k =
                    this._items[f],
                    h = k[1] === d;
                if ((c || k[0] === b) && h) {
                    this._items.splice(f, 1);
                    this._totalWeight -= k[0];
                    break
                }
            }
        }
        asJSON() {
            return JSON.stringify(this._items)
        }
        static fromJSON(b) {
            const d = new e.ProbabilityTable;
            b = JSON.parse(b);
            for (const c of b) d.AddItem(c[0], c[1]);
            return d
        }
    }
}
"use strict";
self.C3.Event = class {
    constructor(e, a) {
        this.type = e;
        this.cancelable = !!a;
        this.isAsync = this.propagationStopped = this.defaultPrevented = !1
    }
    preventDefault() {
        if (!this.cancelable) throw Error(`event '${this.type}' is not cancelable`);
        this.defaultPrevented = !0
    }
    stopPropagation() {
        if (!this.cancelable) throw Error(`event '${this.type}' cannot be stopped`);
        if (this.isAsync) throw Error(`cannot stop async event '${this.type}' propagation`);
        this.propagationStopped = !0
    }
}; {
    "use strict";
    const e = self.C3;
    e.Event.Handler = class extends e.DefendedBase {
        constructor(a) {
            super();
            this._type = a;
            this._captureListeners = [];
            this._captureListenersSet = new Set;
            this._listeners = [];
            this._listenersSet = new Set;
            this._fireDepth = 0;
            this._queueModifyListeners = []
        }
        Release() {
            0 < this._fireDepth || (e.clearArray(this._captureListeners), this._captureListenersSet.clear(), e.clearArray(this._listeners), this._listenersSet.clear(), e.clearArray(this._queueModifyListeners), e.Release(this))
        }
        _AddListener(a, b) {
            this._IsFiring() ?
                this._queueModifyListeners.push({
                    op: "add",
                    func: a,
                    capture: b
                }) : b ? this._captureListenersSet.has(a) || (this._captureListeners.push(a), this._captureListenersSet.add(a)) : this._listenersSet.has(a) || (this._listeners.push(a), this._listenersSet.add(a))
        }
        _RemoveListener(a, b) {
            this._IsFiring() ? this._queueModifyListeners.push({
                op: "remove",
                func: a,
                capture: b
            }) : b ? this._captureListenersSet.has(a) && (this._captureListenersSet.delete(a), e.arrayFindRemove(this._captureListeners, a)) : this._listenersSet.has(a) && (this._listenersSet.delete(a),
                e.arrayFindRemove(this._listeners, a))
        }
        _IsEmpty() {
            return !this._captureListeners.length && !this._listeners.length
        }
        _IsFiring() {
            return 0 < this._fireDepth
        }
        _ProcessQueuedListeners() {
            const a = new Set,
                b = new Set;
            for (const d of this._queueModifyListeners)
                if ("add" === d.op) this._AddListener(d.func, d.capture), d.capture ? b.delete(d.func) : a.delete(d.func);
                else if ("remove" === d.op) d.capture ? (this._captureListenersSet.delete(d.func), b.add(d.func)) : (this._listenersSet.delete(d.func), a.add(d.func));
            else throw Error("invalid op");
            e.arrayRemoveAllInSet(this._listeners, a);
            e.arrayRemoveAllInSet(this._captureListeners, b);
            e.clearArray(this._queueModifyListeners)
        }
        _FireCancellable(a) {
            this._IncreaseFireDepth();
            let b = !1;
            for (let d = 0, c = this._captureListeners.length; d < c; ++d)
                if (this._captureListeners[d](a), a.propagationStopped) {
                    b = !0;
                    break
                } if (!b)
                for (let d = 0, c = this._listeners.length; d < c && (this._listeners[d](a), !a.propagationStopped); ++d);
            this._DecreaseFireDepth();
            return !a.defaultPrevented
        }
        _FireNonCancellable(a) {
            this._IncreaseFireDepth();
            for (let b = 0, d = this._captureListeners.length; b < d; ++b) this._captureListeners[b](a);
            for (let b = 0, d = this._listeners.length; b < d; ++b) this._listeners[b](a);
            this._DecreaseFireDepth();
            return !0
        }
        _IncreaseFireDepth() {
            this._fireDepth++
        }
        _DecreaseFireDepth() {
            this._fireDepth--;
            0 === this._fireDepth && 0 < this._queueModifyListeners.length && this._ProcessQueuedListeners()
        }
        SetDelayRemoveEventsEnabled(a) {
            a ? this._IncreaseFireDepth() : this._DecreaseFireDepth()
        }
        _FireAsync(a) {
            let b = [];
            for (let d = 0, c = this._captureListeners.length; d <
                c; ++d) {
                let f = this._captureListeners[d];
                b.push(e.Asyncify(() => f(a)))
            }
            for (let d = 0, c = this._listeners.length; d < c; ++d) {
                let f = this._listeners[d];
                b.push(e.Asyncify(() => f(a)))
            }
            return Promise.all(b).then(() => !a.defaultPrevented)
        }
        _FireAndWait_AsyncOptional(a) {
            const b = [];
            this._IncreaseFireDepth();
            for (let c = 0, f = this._captureListeners.length; c < f; ++c) {
                var d = this._captureListeners[c](a);
                d instanceof Promise && b.push(d)
            }
            for (let c = 0, f = this._listeners.length; c < f; ++c) d = this._listeners[c](a), d instanceof Promise && b.push(d);
            this._DecreaseFireDepth();
            return b.length ? Promise.all(b).then(() => !a.defaultPrevented) : !a.defaultPrevented
        }
        async _FireAndWaitAsync(a) {
            return await this._FireAndWait_AsyncOptional(a)
        }
        async _FireAndWaitAsyncSequential(a) {
            this._IncreaseFireDepth();
            for (let d = 0, c = this._captureListeners.length; d < c; ++d) {
                var b = this._captureListeners[d](a);
                b instanceof Promise && await b
            }
            for (let d = 0, c = this._listeners.length; d < c; ++d) b = this._listeners[d](a), b instanceof Promise && await b;
            this._DecreaseFireDepth();
            return !a.defaultPrevented
        }* _FireAsGenerator(a) {
            this._IncreaseFireDepth();
            for (let d = 0, c = this._captureListeners.length; d < c; ++d) {
                var b = this._captureListeners[d](a);
                e.IsIterator(b) && (yield* b)
            }
            for (let d = 0, c = this._listeners.length; d < c; ++d) b = this._listeners[d](a), e.IsIterator(b) && (yield* b);
            this._DecreaseFireDepth()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Event.Dispatcher = class extends e.DefendedBase {
        constructor() {
            super();
            this._eventHandlers = new Map;
            this._dispatcherWasReleased = !1
        }
        Release() {
            if (this._dispatcherWasReleased) throw Error("already released");
            this.ClearEvents();
            this._dispatcherWasReleased = !0;
            e.Release(this)
        }
        WasReleased() {
            return this._dispatcherWasReleased
        }
        ClearEvents() {
            for (let a of this._eventHandlers.values()) a.Release();
            this._eventHandlers.clear()
        }
        _GetHandlerByType(a, b) {
            let d = this._eventHandlers.get(a);
            return d ?
                d : b ? (d = e.New(e.Event.Handler, a), this._eventHandlers.set(a, d), d) : null
        }
        HasAnyHandlerFor(a) {
            return this._eventHandlers.has(a)
        }
        addEventListener(a, b, d) {
            this._GetHandlerByType(a, !0)._AddListener(b, !!d)
        }
        removeEventListener(a, b, d) {
            let c = this._GetHandlerByType(a, !1);
            c && (c._RemoveListener(b, !!d), c._IsEmpty() && this._eventHandlers.delete(a))
        }
        dispatchEvent(a) {
            const b = this._GetHandlerByType(a.type, !1);
            return b ? a.cancelable ? b._FireCancellable(a) : b._FireNonCancellable(a) : !0
        }
        dispatchEventAsync(a) {
            const b = this._GetHandlerByType(a.type,
                !1);
            if (!b) return Promise.resolve(!0);
            a.isAsync = !0;
            return b._FireAsync(a)
        }
        async dispatchEventAndClearAsync(a) {
            const b = this._GetHandlerByType(a.type, !1);
            if (!b) return !0;
            this._eventHandlers.delete(a.type);
            a.isAsync = !0;
            a = await b._FireAsync(a);
            b.Release();
            return a
        }
        async dispatchEventAndWaitAsync(a) {
            const b = this._GetHandlerByType(a.type, !1);
            return b ? await b._FireAndWaitAsync(a) : !0
        }
        dispatchEventAndWait_AsyncOptional(a) {
            const b = this._GetHandlerByType(a.type, !1);
            return b ? b._FireAndWait_AsyncOptional(a) : !0
        }
        async dispatchEventAndWaitAsyncSequential(a) {
            const b =
                this._GetHandlerByType(a.type, !1);
            return b ? await b._FireAndWaitAsyncSequential(a) : !0
        }
        dispatchGeneratorEvent(a) {
            const b = this._GetHandlerByType(a.type, !1);
            if (!b) return null;
            if (a.cancelable) throw Error("not supported");
            return b._FireAsGenerator(a)
        }
        SetDelayRemoveEventsEnabled(a) {
            for (const b of this._eventHandlers.values()) b.SetDelayRemoveEventsEnabled(a)
        }
    }
} {
    "use strict";
    const e = self.C3,
        a = "undefined" !== typeof requestIdleCallback;
    let b = [],
        d = -1,
        c = 0;

    function f(n) {
        d = a && 0 === c ? requestIdleCallback(k, {
            timeout: 35
        }) : setTimeout(k, 0 < c ? 1 : n)
    }

    function k(n) {
        d = -1;
        if (b.length) {
            var u = performance.now(),
                w = 0;
            do {
                h(b.shift());
                var q = performance.now();
                ++w;
                var t = (q - u) / w * 1.1
            } while (b.length && (a && 0 === c && "undefined" !== typeof n ? t < n.timeRemaining() : 12 > q - u + t)); - 1 === d && b.length && f(Math.max(16 - (q - u), 4))
        }
    }

    function h(n) {
        let u;
        try {
            u = n.func()
        } catch (w) {
            n.reject(w);
            return
        }
        n.resolve(u)
    }
    let l =
        e.QueryString.Has("disable-asyncify");
    l && console.warn("[Asyncify] Asyncify has been disabled due to disable-asyncify in the query string. Some work will now be done synchronously.");
    e.Asyncify = function (n) {
        let u = null;
        e.isDebug && (u = e.GetCallStack());
        return new Promise((w, q) => {
            b.push({
                func: n,
                resolve: w,
                reject: q,
                stack: u
            });
            l ? h(b.pop()) : -1 === d && f(16)
        })
    };
    e.Asyncify.SetHighThroughputMode = function (n) {
        if (n) ++c;
        else if (--c, 0 > c) throw Error("already turned off high throughput mode");
    }
} {
    "use strict";
    const e = self.C3;
    let a = -1;

    function b() {
        a = -1
    }
    e.FastGetDateNow = function () {
        -1 === a && (a = Date.now(), self.setTimeout(b, 16));
        return a
    };
    let d = -1,
        c = -1,
        f = new Set;

    function k() {
        c = d = -1;
        let h = Date.now();
        for (let l of f)
            if (l._CheckTimeout(h)) {
                let n = l._GetDeadline();
                if (-1 === c || n < c) c = n
            } else f.delete(l); - 1 !== c && (d = self.setTimeout(k, Math.max(c - h + 100, 1E3)))
    }
    e.IdleTimeout = class {
        constructor(h, l) {
            this._callback = h;
            this._timeout = 1E3 * l;
            this._deadline = 0;
            this._isActive = !1
        }
        Reset() {
            let h = e.FastGetDateNow();
            this._deadline =
                h + this._timeout;
            this._isActive || (f.add(this), this._isActive = !0); - 1 === d ? (c = this._deadline, d = self.setTimeout(k, this._timeout + 100)) : this._deadline < c && c > h + 1E3 && (self.clearTimeout(d), c = this._deadline, d = self.setTimeout(k, this._timeout + 100))
        }
        _CheckTimeout(h) {
            return h >= this._deadline ? this._callback() ? (this._deadline = h + this._timeout, !0) : this._isActive = !1 : !0
        }
        _GetDeadline() {
            return this._deadline
        }
        Cancel() {
            this._isActive && (f.delete(this), this._isActive = !1, 0 === f.size && -1 !== d && (self.clearTimeout(d), c = d = -1))
        }
        Release() {
            this.Cancel();
            this._callback = null
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Disposable = class a {
        constructor(b) {
            this._disposed = !1;
            this._disposeAction = b
        }
        Dispose() {
            this._disposed || (this._disposed = !0, this._disposeAction && (this._disposeAction(), this._disposeAction = null))
        }
        IsDisposed() {
            return this._disposed
        }
        Release() {
            this.Dispose()
        }
        static Release(b) {
            return new a(() => b.Release())
        }
        static From(b, d, c, f, k) {
            if ("undefined" === typeof f || null === f) f = !1;
            else if ("boolean" !== typeof f && "object" !== typeof f) throw new TypeError("invalid event listener options");
            k &&
                (c = c.bind(k));
            if (d.includes(" ")) {
                d = d.split(" ");
                k = new e.CompositeDisposable;
                for (let h of d) b.addEventListener(h, c, f), k.Add(e.New(e.Disposable, () => b.removeEventListener(h, c, f)));
                return k
            }
            b.addEventListener(d, c, f);
            return e.New(e.Disposable, () => b.removeEventListener(d, c, f))
        }
    };
    e.StubDisposable = class extends e.Disposable {
        SetAction(a) {
            this._disposeAction = a
        }
    };
    e.CompositeDisposable = class extends e.Disposable {
        constructor(...a) {
            super();
            this._disposables = new Set;
            for (let b of a) this.Add(b)
        }
        Add(...a) {
            if (this._disposed) throw Error("already disposed");
            for (let b of a) this._disposables.add(b)
        }
        Remove(a) {
            if (this._disposed) throw Error("already disposed");
            this._disposables.delete(a)
        }
        RemoveAll() {
            if (this._disposed) throw Error("already disposed");
            if (this._disposables) {
                for (let a of this._disposables) a.Dispose();
                this._disposables.clear()
            }
        }
        IsDisposed() {
            return this._disposed
        }
        Dispose() {
            if (this._disposed) throw Error("already disposed");
            this._disposed = !0;
            for (let a of this._disposables) a.Dispose();
            this._disposables.clear();
            this._disposables = null
        }
        Release() {
            this.Dispose()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.KahanSum = class extends e.DefendedBase {
        constructor() {
            super();
            this._sum = this._t = this._y = this._c = 0
        }
        Add(a) {
            this._y = +a - this._c;
            this._t = this._sum + this._y;
            this._c = this._t - this._sum - this._y;
            this._sum = this._t
        }
        Subtract(a) {
            this._sum -= +a
        }
        Get() {
            return this._sum
        }
        Reset() {
            this._sum = this._t = this._y = this._c = 0
        }
        Set(a) {
            this._t = this._y = this._c = 0;
            this._sum = +a
        }
        Release() {}
    }
} {
    "use strict";
    const e = self.C3,
        a = {
            RBnode: function (b) {
                this.tree = b;
                this.left = this.right = this.tree.sentinel;
                this.parent = null;
                this.color = !1;
                this.key = null
            },
            RedBlackSet: function (b) {
                this.size = 0;
                this.sentinel = new a.RBnode(this);
                this.sentinel.color = !1;
                this.root = this.sentinel;
                this.root.parent = this.sentinel;
                this.compare = b || this.default_compare
            }
        };
    a.RedBlackSet.prototype.default_compare = function (b, d) {
        return b < d ? -1 : d < b ? 1 : 0
    };
    a.RedBlackSet.prototype.clone = function () {
        var b = new a.RedBlackSet(this.compare);
        b.insertAll(this);
        return b
    };
    a.RedBlackSet.prototype.clear = function () {
        this.size = 0;
        this.sentinel = new a.RBnode(this);
        this.sentinel.color = !1;
        this.root = this.sentinel;
        this.root.parent = this.sentinel
    };
    a.RedBlackSet.prototype.leftRotate = function (b) {
        var d = b.right;
        b.right = d.left;
        d.left != this.sentinel && (d.left.parent = b);
        d.parent = b.parent;
        b.parent == this.sentinel ? this.root = d : b == b.parent.left ? b.parent.left = d : b.parent.right = d;
        d.left = b;
        b.parent = d
    };
    a.RedBlackSet.prototype.rightRotate = function (b) {
        var d = b.left;
        b.left = d.right;
        d.right !=
            this.sentinel && (d.right.parent = b);
        d.parent = b.parent;
        b.parent == this.sentinel ? this.root = d : b == b.parent.right ? b.parent.right = d : b.parent.left = d;
        d.right = b;
        b.parent = d
    };
    a.RedBlackSet.prototype.insert = function (b) {
        if (this.contains(b)) this.get_(b).key = b;
        else {
            var d = new a.RBnode(this);
            d.key = b;
            b = this.sentinel;
            for (var c = this.root; c != this.sentinel;) b = c, c = 0 > this.compare(d.key, c.key) ? c.left : c.right;
            d.parent = b;
            b == this.sentinel ? this.root = d : 0 > this.compare(d.key, b.key) ? b.left = d : b.right = d;
            d.left = this.sentinel;
            d.right = this.sentinel;
            d.color = !0;
            this.insertFixup(d);
            this.size++
        }
    };
    a.RedBlackSet.prototype.insertFixup = function (b) {
        for (; b != this.sentinel && b != this.root && 1 == b.parent.color;)
            if (b.parent == b.parent.parent.left) {
                var d = b.parent.parent.right;
                1 == d.color ? (b.parent.color = !1, d.color = !1, b.parent.parent.color = !0, b = b.parent.parent) : (b == b.parent.right && (b = b.parent, this.leftRotate(b)), b.parent.color = !1, b.parent.parent.color = !0, b.parent.parent != this.sentinel && this.rightRotate(b.parent.parent))
            } else d = b.parent.parent.left, 1 == d.color ? (b.parent.color = !1, d.color = !1, b.parent.parent.color = !0, b = b.parent.parent) : (b == b.parent.left && (b = b.parent, this.rightRotate(b)), b.parent.color = !1, b.parent.parent.color = !0, b.parent.parent != this.sentinel && this.leftRotate(b.parent.parent));
        this.root.color = !1
    };
    a.RedBlackSet.prototype.delete_ = function (b) {
        var d = b.left == this.sentinel || b.right == this.sentinel ? b : this.successor_(b);
        var c = d.left != this.sentinel ? d.left : d.right;
        c.parent = d.parent;
        d.parent == this.sentinel ? this.root = c : d == d.parent.left ? d.parent.left = c : d.parent.right =
            c;
        d != b && (b.key = d.key);
        0 == d.color && this.deleteFixup(c);
        this.size--
    };
    a.RedBlackSet.prototype.deleteFixup = function (b) {
        for (; b != this.root && 0 == b.color;)
            if (b == b.parent.left) {
                var d = b.parent.right;
                1 == d.color && (d.color = !1, b.parent.color = !0, this.leftRotate(b.parent), d = b.parent.right);
                0 == d.left.color && 0 == d.right.color ? (d.color = !0, b = b.parent) : (0 == d.right.color && (d.left.color = !1, d.color = !0, this.rightRotate(d), d = b.parent.right), d.color = b.parent.color, b.parent.color = !1, d.right.color = !1, this.leftRotate(b.parent),
                    b = this.root)
            } else d = b.parent.left, 1 == d.color && (d.color = !1, b.parent.color = !0, this.rightRotate(b.parent), d = b.parent.left), 0 == d.right.color && 0 == d.left.color ? (d.color = !0, b = b.parent) : (0 == d.left.color && (d.right.color = !1, d.color = !0, this.leftRotate(d), d = b.parent.left), d.color = b.parent.color, b.parent.color = !1, d.left.color = !1, this.rightRotate(b.parent), b = this.root);
        b.color = !1
    };
    a.RedBlackSet.prototype.remove = function (b) {
        b = this.get_(b);
        if (b != this.sentinel) {
            var d = b.key;
            this.delete_(b);
            return d
        }
        return null
    };
    a.RedBlackSet.prototype.removeSwapped =
        function (b, d) {
            this.remove(d)
        };
    a.RedBlackSet.prototype.min = function (b) {
        for (; b.left != this.sentinel;) b = b.left;
        return b
    };
    a.RedBlackSet.prototype.max = function (b) {
        for (; b.right != this.sentinel;) b = b.right;
        return b
    };
    a.RedBlackSet.prototype.successor_ = function (b) {
        if (b.right != this.sentinel) return this.min(b.right);
        for (var d = b.parent; d != this.sentinel && b == d.right;) b = d, d = d.parent;
        return d
    };
    a.RedBlackSet.prototype.predeccessor_ = function (b) {
        if (b.left != this.sentinel) return this.max(b.left);
        for (var d = b.parent; d != this.sentinel &&
            b == d.left;) b = d, d = d.parent;
        return d
    };
    a.RedBlackSet.prototype.successor = function (b) {
        if (0 < this.size) {
            b = this.get_(b);
            if (b == this.sentinel) return null;
            if (b.right != this.sentinel) return this.min(b.right).key;
            for (var d = b.parent; d != this.sentinel && b == d.right;) b = d, d = d.parent;
            return d != this.sentinel ? d.key : null
        }
        return null
    };
    a.RedBlackSet.prototype.predecessor = function (b) {
        if (0 < this.size) {
            b = this.get_(b);
            if (b == this.sentinel) return null;
            if (b.left != this.sentinel) return this.max(b.left).key;
            for (var d = b.parent; d != this.sentinel &&
                b == d.left;) b = d, d = d.parent;
            return d != this.sentinel ? d.key : null
        }
        return null
    };
    a.RedBlackSet.prototype.getMin = function () {
        return this.min(this.root).key
    };
    a.RedBlackSet.prototype.getMax = function () {
        return this.max(this.root).key
    };
    a.RedBlackSet.prototype.get_ = function (b) {
        for (var d = this.root; d != this.sentinel && 0 != this.compare(d.key, b);) d = 0 > this.compare(b, d.key) ? d.left : d.right;
        return d
    };
    a.RedBlackSet.prototype.contains = function (b) {
        return null != this.get_(b).key
    };
    a.RedBlackSet.prototype.getValues = function () {
        var b = [];
        this.forEach(function (d) {
            b.push(d)
        });
        return b
    };
    a.RedBlackSet.prototype.insertAll = function (b) {
        if ("array" == a.typeOf(b))
            for (var d = 0; d < b.length; d++) this.insert(b[d]);
        else if ("function" == a.typeOf(b.forEach)) b.forEach(this.insert, this);
        else if ("function" == a.typeOf(b.getValues))
            for (b = b.getValues(), d = 0; d < b.length; d++) this.insert(b[d]);
        else if ("object" == a.typeOf(b))
            for (d in b) this.insert(b[d])
    };
    a.RedBlackSet.prototype.removeAll = function (b) {
        if ("array" == a.typeOf(b))
            for (var d = 0; d < b.length; d++) this.remove(b[d]);
        else if ("function" == a.typeOf(b.forEach)) b.forEach(this.removeSwapped, this);
        else if ("function" == a.typeOf(b.getValues))
            for (b = b.getValues(), d = 0; d < b.length; d++) this.remove(b[d]);
        else if ("object" == a.typeOf(b))
            for (d in b) this.remove(b[d])
    };
    a.RedBlackSet.prototype.containsAll = function (b) {
        if ("array" == a.typeOf(b)) {
            for (var d = 0; d < b.length; d++)
                if (!this.contains(b[d])) return !1;
            return !0
        }
        if ("function" == a.typeOf(b.forEach)) return b.every(this.contains, this);
        if ("function" == a.typeOf(b.getValues)) {
            b = b.getValues();
            for (d =
                0; d < b.length; d++)
                if (!this.contains(b[d])) return !1;
            return !0
        }
        if ("object" == a.typeOf(b)) {
            for (d in b)
                if (!this.contains(b[d])) return !1;
            return !0
        }
    };
    a.RedBlackSet.prototype.range = function (b, d) {
        var c = [];
        this.traverseFromTo(function (f) {
            c.push(f)
        }, b, d);
        return c
    };
    a.RedBlackSet.prototype.traverse = function (b, d) {
        if (!this.isEmpty())
            for (var c = this.min(this.root); c != this.sentinel && !b.call(d, c.key, this);) c = this.successor_(c)
    };
    a.RedBlackSet.prototype.traverseFrom = function (b, d, c) {
        if (!this.isEmpty())
            for (d = this.get_(d); d !=
                this.sentinel && !b.call(c, d.key, this);) d = this.successor_(d)
    };
    a.RedBlackSet.prototype.traverseTo = function (b, d, c) {
        if (!this.isEmpty()) {
            var f = this.min(this.root);
            for (d = this.get_(d); f != d && !b.call(c, f.key, this);) f = this.successor_(f)
        }
    };
    a.RedBlackSet.prototype.traverseFromTo = function (b, d, c, f) {
        if (!this.isEmpty())
            for (d = this.get_(d), c = this.get_(c); d != c && !b.call(f, d.key, this);) d = this.successor_(d)
    };
    a.RedBlackSet.prototype.traverseBackwards = function (b, d) {
        if (!this.isEmpty())
            for (var c = this.max(this.root); c != this.sentinel &&
                !b.call(d, c.key, this);) c = this.predeccessor_(c)
    };
    a.RedBlackSet.prototype.forEach = function (b, d) {
        if (!this.isEmpty())
            for (var c = this.min(this.root); c != this.sentinel; c = this.successor_(c)) b.call(d, c.key, c.key, this)
    };
    a.RedBlackSet.prototype.some = function (b, d) {
        if (this.isEmpty()) return !1;
        for (var c = this.min(this.root); c != this.sentinel; c = this.successor_(c))
            if (b.call(d, c.key, c.key, this)) return !0;
        return !1
    };
    a.RedBlackSet.prototype.every = function (b, d) {
        if (this.isEmpty()) return !1;
        for (var c = this.min(this.root); c != this.sentinel; c =
            this.successor_(c))
            if (!b.call(d, c.key, c.key, this)) return !1;
        return !0
    };
    a.RedBlackSet.prototype.map = function (b, d) {
        var c = [];
        if (this.isEmpty()) return c;
        for (var f = this.min(this.root); f != this.sentinel; f = this.successor_(f)) c.push(b.call(d, f.key, f.key, this));
        return c
    };
    a.RedBlackSet.prototype.filter = function (b, d) {
        var c = [];
        if (this.isEmpty()) return c;
        for (var f = this.min(this.root); f != this.sentinel; f = this.successor_(f)) b.call(d, f.key, f.key, this) && c.push(f.key);
        return c
    };
    a.RedBlackSet.prototype.getCount = function () {
        return this.size
    };
    a.RedBlackSet.prototype.isEmpty = function () {
        return 0 == this.size
    };
    a.RedBlackSet.prototype.isSubsetOf = function (b) {
        var d = a.getCount(b);
        if (this.getCount() > d) return !1;
        d = 0;
        if (this.isEmpty()) return !0;
        for (var c = this.min(this.root); c != this.sentinel; c = this.successor_(c)) a.contains.call(b, b, c.key) && d++;
        return d == this.getCount()
    };
    a.RedBlackSet.prototype.intersection = function (b) {
        var d = new a.RedBlackSet(this.compare);
        if (this.isEmpty()) return d;
        for (var c = this.min(this.root); c != this.sentinel; c = this.successor_(c)) b.contains.call(b,
            c.key, c.key, this) && d.insert(c.key);
        return d
    };
    e.RedBlackSet = class extends e.DefendedBase {
        constructor(b) {
            super();
            this._rbSet = new a.RedBlackSet(b);
            this._enableQueue = !1;
            this._queueInsert = new Set;
            this._queueRemove = new Set
        }
        Add(b) {
            this._enableQueue ? this._rbSet.contains(b) ? this._queueRemove.delete(b) : this._queueInsert.add(b) : this._rbSet.insert(b)
        }
        Remove(b) {
            this._enableQueue ? this._rbSet.contains(b) ? this._queueRemove.add(b) : this._queueInsert.delete(b) : this._rbSet.remove(b)
        }
        Has(b) {
            return this._enableQueue ? this._queueInsert.has(b) ?
                !0 : !this._queueRemove.has(b) && this._rbSet.contains(b) : this._rbSet.contains(b)
        }
        Clear() {
            this._rbSet.clear();
            this._queueInsert.clear();
            this._queueRemove.clear()
        }
        toArray() {
            if (this._enableQueue) throw Error("cannot be used in queueing mode");
            return this._rbSet.getValues()
        }
        GetSize() {
            return this._rbSet.getCount() + this._queueInsert.size - this._queueRemove.size
        }
        IsEmpty() {
            return 0 === this.GetSize()
        }
        Front() {
            if (this.IsEmpty()) throw Error("empty set");
            if (this._enableQueue) throw Error("cannot be used in queueing mode");
            const b = this._rbSet;
            return b.min(b.root).key
        }
        Shift() {
            if (this.IsEmpty()) throw Error("empty set");
            if (this._enableQueue) throw Error("cannot be used in queueing mode");
            const b = this.Front();
            this.Remove(b);
            return b
        }
        SetQueueingEnabled(b) {
            b = !!b;
            if (this._enableQueue !== b && (this._enableQueue = b, !b)) {
                for (const d of this._queueRemove) this._rbSet.remove(d);
                this._queueRemove.clear();
                for (const d of this._queueInsert) this._rbSet.insert(d);
                this._queueInsert.clear()
            }
        }
        ForEach(b) {
            this._rbSet.forEach(b)
        }* values() {
            if (!this.IsEmpty()) {
                var b =
                    this._rbSet;
                for (let d = b.min(b.root); d != b.sentinel; d = b.successor_(d)) yield d.key
            }
        } [Symbol.iterator]() {
            return this.values()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.PromiseThrottle = class {
        constructor(a = e.hardwareConcurrency) {
            this._maxParallel = a;
            this._queue = [];
            this._activeCount = 0
        }
        Add(a) {
            return new Promise((b, d) => {
                this._queue.push({
                    func: a,
                    resolve: b,
                    reject: d
                });
                this._MaybeStartNext()
            })
        }
        _FindInQueue(a) {
            for (let b = 0, d = this._queue.length; b < d; ++b)
                if (this._queue[b].func === a) return b;
            return -1
        }
        RemoveAndResolve(a, b) {
            a = this._FindInQueue(a);
            if (-1 === a) throw Error("cannot find promise to resolve");
            this._queue[a].resolve(b);
            this._queue.splice(a,
                1)
        }
        RemoveAndReject(a, b) {
            a = this._FindInQueue(a);
            if (-1 === a) throw Error("cannot find promise to reject");
            this._queue[a].reject(b);
            this._queue.splice(a, 1)
        }
        async _MaybeStartNext() {
            if (this._queue.length && !(this._activeCount >= this._maxParallel)) {
                this._activeCount++;
                var a = this._queue.shift();
                try {
                    const b = await a.func();
                    a.resolve(b)
                } catch (b) {
                    a.reject(b)
                }
                this._activeCount--;
                this._MaybeStartNext()
            }
        }
        static async Batch(a, b) {
            const d = [];
            let c = !1;
            const f = async h => {
                for (;
                    (h = b.pop()) && !c;) try {
                    d.push(await h())
                } catch (l) {
                    throw c = !0, l;
                }
            }, k = [];
            for (; a--;) k.push(f());
            await Promise.all(k);
            return d
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.RateLimiter = class {
        constructor(a, b, d) {
            this._callback = a;
            this._interval = b;
            this._intervalOnBattery = d || 2 * b;
            this._timerId = -1;
            this._lastCallTime = -Infinity;
            this._timerCallFunc = () => this._OnTimer();
            this._canRunImmediate = this._ignoreReset = !1;
            this._callbackArguments = null
        }
        SetCanRunImmediate(a) {
            this._canRunImmediate = !!a
        }
        _GetInterval() {
            return "undefined" !== typeof e.Battery && e.Battery.IsOnBatteryPower() ? this._intervalOnBattery : this._interval
        }
        Call(...a) {
            if (-1 === this._timerId) {
                this._callbackArguments =
                    a;
                a = e.FastGetDateNow();
                var b = a - this._lastCallTime,
                    d = this._GetInterval();
                b >= d && this._canRunImmediate ? (this._lastCallTime = a, this._RunCallback()) : this._timerId = self.setTimeout(this._timerCallFunc, Math.max(d - b, 4))
            }
        }
        _RunCallback() {
            this._ignoreReset = !0;
            const a = this._callbackArguments;
            this._callbackArguments = null;
            a ? this._callback(...a) : this._callback();
            this._ignoreReset = !1
        }
        Reset() {
            this._ignoreReset || (this._CancelTimer(), this._callbackArguments = null, this._lastCallTime = e.FastGetDateNow())
        }
        _OnTimer() {
            this._timerId = -1;
            this._lastCallTime = e.FastGetDateNow();
            this._RunCallback()
        }
        _CancelTimer() {
            -1 !== this._timerId && (self.clearTimeout(this._timerId), this._timerId = -1)
        }
        Release() {
            this._CancelTimer();
            this._timerCallFunc = this._callbackArguments = this._callback = null
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.SVGRasterManager = class {
        constructor() {
            this._images = new Map;
            this._allowNpotSurfaces = !1;
            this._redrawCallback = this._releaseResultCallback = this._rasterAtSizeCallback = this._getBaseSizeCallback = null
        }
        SetNpotSurfaceAllowed(a) {
            this._allowNpotSurfaces = !!a
        }
        IsNpotSurfaceAllowed() {
            return this._allowNpotSurfaces
        }
        SetGetBaseSizeCallback(a) {
            this._getBaseSizeCallback = a
        }
        GetBaseSize(a) {
            if (!this._getBaseSizeCallback) throw Error("no get base size callback set");
            return this._getBaseSizeCallback(a)
        }
        SetRasterAtSizeCallback(a) {
            this._rasterAtSizeCallback =
                a
        }
        RasterAtSize(a, b, d, c, f, k) {
            if (!this._rasterAtSizeCallback) throw Error("no raster at size callback set");
            return this._rasterAtSizeCallback(a, b, d, c, f, k)
        }
        SetReleaseResultCallback(a) {
            this._releaseResultCallback = a
        }
        ReleaseResult(a) {
            if (!this._releaseResultCallback) throw Error("no release result callback set");
            this._releaseResultCallback(a)
        }
        SetRedrawCallback(a) {
            this._redrawCallback = a
        }
        Redraw() {
            if (!this._redrawCallback) throw Error("no redraw callback set");
            this._redrawCallback()
        }
        AddImage(a) {
            let b = this._images.get(a);
            b || (b = e.New(e.SVGRasterImage, this, a), this._images.set(a, b));
            b.IncReference();
            return b
        }
        _RemoveImage(a) {
            this._images.delete(a.GetDataSource())
        }
        OnTexturesChanged() {
            for (const a of this._images.values()) a.ReleaseRasterizedResult(), a.ForceRasterAgain()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.SVGRasterImage = class {
        constructor(a, b) {
            this._manager = a;
            this._dataSource = b;
            this._baseHeight = this._baseWidth = this._refCount = 0;
            this._getBaseSizePromise = this._manager.GetBaseSize(b).then(d => {
                this._baseWidth = d[0];
                this._baseHeight = d[1];
                this._manager.Redraw()
            }).catch(d => {
                console.error("[SVG] Error loading SVG: ", d);
                this._hadError = !0;
                this._manager.Redraw()
            });
            this._rasterImageHeight = this._rasterImageWidth = this._rasterSurfaceHeight = this._rasterSurfaceWidth = 0;
            this._isRasterizing = !1;
            this._rasterizedResult = null;
            this._hadError = this._forceRaster = !1
        }
        Release() {
            if (0 >= this._refCount) throw Error("already released");
            this._refCount--;
            0 === this._refCount && this._Release()
        }
        ReleaseRasterizedResult() {
            this._rasterizedResult && (this._manager.ReleaseResult(this._rasterizedResult), this._rasterizedResult = null)
        }
        _Release() {
            this.ReleaseRasterizedResult();
            this._manager._RemoveImage(this);
            this._manager = null
        }
        GetDataSource() {
            return this._dataSource
        }
        IncReference() {
            this._refCount++
        }
        HasReferences() {
            return 0 <
                this._refCount
        }
        GetRasterizedResult() {
            return this._rasterizedResult
        }
        ForceRasterAgain() {
            this._forceRaster = !0
        }
        async StartRasterForSize(a, b, d) {
            if (0 !== b && 0 !== d && !this._hadError && !this._isRasterizing) {
                var c = e.nextHighestPowerOfTwo(Math.ceil(b)),
                    f = e.nextHighestPowerOfTwo(Math.ceil(d)),
                    k = Math.max(c, f);
                2048 < k && (k = 2048 / k, b *= k, d *= k, c = Math.min(Math.ceil(c * k), 2048), f = Math.min(Math.ceil(f * k), 2048));
                b < c && d < f && (d = b / d, c / f > d ? (b = f * d, d = f) : (b = c, d = c / d));
                this._manager.IsNpotSurfaceAllowed() && (c = Math.ceil(b), f = Math.ceil(d));
                c <= this._rasterSurfaceWidth && f <= this._rasterSurfaceHeight && !this._forceRaster || (this._isRasterizing = !0, this._rasterSurfaceWidth = c, this._rasterSurfaceHeight = f, a = await this._manager.RasterAtSize(this._dataSource, a, this._rasterSurfaceWidth, this._rasterSurfaceHeight, b, d), this._manager && (this.ReleaseRasterizedResult(), this._rasterizedResult = a, this._rasterImageWidth = b, this._rasterImageHeight = d, this._forceRaster = this._isRasterizing = !1, this._manager.Redraw()))
            }
        }
        WhenBaseSizeReady() {
            return this._getBaseSizePromise
        }
        GetBaseWidth() {
            return this._baseWidth
        }
        GetBaseHeight() {
            return this._baseHeight
        }
        GetRasterWidth() {
            return this._rasterImageWidth
        }
        GetRasterHeight() {
            return this._rasterImageHeight
        }
        HadError() {
            return this._hadError
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.UTF8_BOM = "\ufeff";
    const a = new Set([..."0123456789"]);
    e.IsNumericChar = function (n) {
        return a.has(n)
    };
    const b = new Set([..." \t\n\r\u00a0\u0085\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u2028\u2029\u202f\u205f\u3000"]);
    e.IsWhitespaceChar = function (n) {
        return b.has(n)
    };
    e.FilterWhitespace = function (n) {
        return [...n].filter(u => !e.IsWhitespaceChar(u)).join("")
    };
    e.IsStringAllWhitespace = function (n) {
        for (const u of n)
            if (!e.IsWhitespaceChar(u)) return !1;
        return !0
    };
    e.IsUnprintableChar = function (n) {
        return 1 === n.length && 32 > n.charCodeAt(0)
    };
    e.FilterUnprintableChars = function (n) {
        return [...n].filter(u => !e.IsUnprintableChar(u)).join("")
    };
    const d = new Set([..."0123456789.+-e"]);
    e.IsStringNumber = function (n) {
        n = n.trim();
        if (!n.length) return !1;
        let u = n.charAt(0);
        if ("-" !== u && !a.has(u)) return !1;
        for (let w of n)
            if (!d.has(w)) return !1;
        return !0
    };
    e.RemoveTrailingDigits = function (n) {
        let u = n.length;
        for (; 0 < u;) {
            let w = n.charAt(u - 1);
            if (!e.IsNumericChar(w)) break;
            --u
        }
        return n.substr(0, u)
    };
    e.IncrementNumberAtEndOf = function (n) {
        let u = e.RemoveTrailingDigits(n);
        n = (n = n.substr(u.length)) ? (parseInt(n, 10) + 1).toString() : "2";
        return u + n
    };
    const c = new Map([
        ["&", "&amp;"],
        ["<", "&lt;"],
        [">", "&gt;"],
        ['"', "&quot;"],
        ["'", "&#39;"]
    ]);

    function f(n) {
        return c.get(n)
    }
    const k = /[&<>"']/g;
    e.EscapeHTML = function (n) {
        return n.replace(k, f)
    };
    e.EscapeJS = function (n) {
        n = e.ReplaceAll(n, "\\", "\\\\");
        n = e.ReplaceAll(n, '"', '\\"');
        n = e.ReplaceAll(n, "\t", "\\t");
        n = e.ReplaceAll(n, "\r", "");
        return e.ReplaceAll(n, "\n", "\\n")
    };
    e.EscapeXML =
        function (n) {
            n = e.ReplaceAll(n, "&", "&amp;");
            n = e.ReplaceAll(n, "<", "&lt;");
            n = e.ReplaceAll(n, ">", "&gt;");
            return e.ReplaceAll(n, '"', "&quot;")
        };
    const h = /[-[\]{}()*+?.,\\^$|#\s]/g;
    e.EscapeRegex = function (n) {
        return n.replace(h, "\\$&")
    };
    e.FindAll = function (n, u, w = !1) {
        if (!u) return [];
        w || (n = n.toLowerCase(), u = u.toLowerCase());
        w = u.length;
        var q = 0;
        let t = [];
        for (; - 1 < (q = n.indexOf(u, q));) t.push(q), q += w;
        return t
    };
    e.ReplaceAll = function (n, u, w) {
        return n.replaceAll(u, () => w)
    };
    e.ReplaceAllCaseInsensitive = function (n, u, w) {
        return n.replace(new RegExp(e.EscapeRegex(u),
            "gi"), () => w)
    };
    e.SetElementContent = function (n, u) {
        "string" === typeof u ? n.textContent = u : u.isPlainText() ? n.textContent = u.toString() : (n.innerHTML = u.toHTML(), u instanceof e.BBString && u.attachLinkHandlers(n))
    };
    e.StringLikeEquals = function (n, u) {
        return n instanceof e.HtmlString || n instanceof e.BBString ? n.equals(u) : u instanceof e.HtmlString || u instanceof e.BBString ? u.equals(n) : n === u
    };
    e.StringSubstitute = function (n, ...u) {
        let w = n;
        for (let q = 0, t = u.length; q < t; ++q) {
            const p = `{${q}}`;
            if (!n.includes(p)) throw Error(`missing placeholder '${p}' in string substitution`);
            w = w.replace(p, u[q].toString())
        }
        return w
    };
    e.StringSubstituteAllowMissing = function (n, ...u) {
        let w = n,
            q = -1,
            t = -1;
        for (let p = 0, r = u.length; p < r; ++p) {
            const x = `{${p}}`;
            n.includes(x) ? (t = p, w = w.replace(x, u[p].toString())) : -1 === q && (q = p)
        }
        if (0 <= q && 0 <= t && q < t) throw Error(`missing placeholder '${q}' in string substitution`);
        return w
    };
    e.StringSubstituteMap = function (n, u) {
        for (let [w, q] of Object.entries(u)) n = n.replaceAll(w, q.toString());
        return n
    };
    e.SortAZCaseInsensitive = function (n, u) {
        n = n.toLowerCase();
        u = u.toLowerCase();
        return n >
            u ? 1 : n < u ? -1 : 0
    };
    e.FormatDataSize = function (n, u) {
        u = "common." + (u ? "dataRates" : "dataSizes") + ".";
        const w = self.langSub;
        if (1024 > n) return w(u + "bytes", n);
        if (1048576 > n) return n /= 1024, n = 10 > n ? Math.round(10 * n) / 10 : Math.round(n), w(u + "kilobytes", n);
        if (1073741824 > n) return n /= 1048576, n = 10 > n ? Math.round(10 * n) / 10 : Math.round(n), w(u + "megabytes", n);
        if (1099511627776 > n) return n /= 1073741824, n = 10 > n ? Math.round(10 * n) / 10 : Math.round(n), w(u + "gigabytes", n);
        n /= 1099511627776;
        n = 10 > n ? Math.round(10 * n) / 10 : Math.round(n);
        return w(u + "terabytes",
            n)
    };
    const l = {
        approximate: !1,
        days: !0,
        hours: !0,
        minutes: !0,
        seconds: !0
    };
    e.FormatTime = function (n, u) {
        u = Object.assign({}, l, u);
        e.Lang.PushContext("common.time");
        const w = [],
            q = self.lang,
            t = self.langPluralSub;
        if (u.days) {
            var p = Math.floor(n / 86400);
            0 < p && (n -= 86400 * p, w.push(t(".days", null, p)))
        }
        u.hours && (p = Math.floor(n / 3600), 0 < p || w.length) && (n -= 3600 * p, w.push(t(".hours", null, p)));
        u.minutes && (p = Math.floor(n / 60), 0 < p || w.length || !u.seconds) && (n -= 60 * p, w.push(t(".minutes", null, p)));
        u.seconds && w.push(t(".seconds", null, Math.floor(n %
            60)));
        n = (u.approximate ? q(".approx-prefix") : "") + w.join(q(".separator"));
        e.Lang.PopContext();
        return n
    };
    e.ZeroPad = function (n, u) {
        let w = 0 > n ? "-" : "";
        n = Math.abs(n);
        n = n.toString();
        u -= n.length;
        for (let q = 0; q < u; ++q) w += "0";
        return w + n
    };
    e.StringToTitleCase = function (n) {
        return n.toLowerCase().replace(/\b\w/g, u => u.toUpperCase())
    };
    e.CompareVersionStrings = function (n, u) {
        n = n.split(".").map(w => w.trim());
        u = u.split(".").map(w => w.trim());
        e.resizeArray(n, 4, "0");
        e.resizeArray(u, 4, "0");
        n = n.map(w => parseInt(w, 10));
        u = u.map(w => parseInt(w,
            10));
        for (let w = 0; 4 > w; ++w) {
            const q = n[w] - u[w];
            if (0 !== q) return 0 > q ? -1 : 1
        }
        return 0
    };
    e.CreateGUID = function () {
        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, n => {
            const u = Math.floor(16 * Math.random());
            return ("x" === n ? u : u & 3 | 8).toString(16)
        })
    };
    e.StringHammingDistance = function (n, u) {
        if (n.length !== u.length) throw Error("strings must be same length");
        let w = 0;
        for (let q = 0, t = n.length; q < t; ++q) n.charAt(q) !== u.charAt(q) && ++w;
        return w
    };
    e.StringLevenshteinDistance = function (n, u) {
        if (0 === n.length) return u.length;
        if (0 === u.length) return n.length;
        let w, q, t, p;
        if (n.length > u.length) {
            var r = n;
            n = u;
            u = r
        }
        p = Array(n.length + 1);
        for (r = 0; r <= n.length; r++) p[r] = r;
        for (r = 1; r <= u.length; r++) {
            q = r;
            for (w = 1; w <= n.length; w++) t = u[r - 1] === n[w - 1] ? p[w - 1] : Math.min(p[w - 1] + 1, Math.min(q + 1, p[w] + 1)), p[w - 1] = q, q = t;
            p[n.length] = q
        }
        return p[n.length]
    }
} {
    "use strict";
    const e = self.C3,
        a = new Map([
            ["b", "strong"],
            ["i", "em"],
            ["s", "s"],
            ["u", "u"],
            ["sub", "sub"],
            ["sup", "sup"],
            ["small", "small"],
            ["mark", "mark"],
            ["a1", "a"],
            ["a2", "a"],
            ["a3", "a"],
            ["a4", "a"],
            ["a5", "a"],
            ["a6", "a"],
            ["a7", "a"],
            ["a8", "a"],
            ["a9", "a"],
            ["bad", ["span", "bbCodeBad"]],
            ["good", ["span", "bbCodeGood"]],
            ["info", ["span", "bbCodeInfo"]],
            ["h1", ["span", "bbCodeH1"]],
            ["h2", ["span", "bbCodeH2"]],
            ["h3", ["span", "bbCodeH3"]],
            ["h4", ["span", "bbCodeH4"]],
            ["item", ["span", "bbCodeItem"]]
        ]),
        b = /\[(\/?)([a-zA-Z0-9]+)\]/g,
        d = /\[(\/?)([^\[\n]*?)\]/g;
    let c = null,
        f = 0;

    function k(l, n, u) {
        var w = a.get(u);
        if (w) {
            if ("string" === typeof w) {
                if ("a" !== w || n) return "<" + n + w + ">";
                n = parseInt(u.substring(1), 10) - 1;
                if (0 > n || n >= c.length) throw Error("invalid bbcode link substitution");
                w = c[n];
                if ("string" === typeof w) return `<a href="${c[n]}">`;
                if ("function" === typeof w) return `<a class="bblink${n}">`;
                throw new TypeError("invalid bbcode link action");
            }
            if (Array.isArray(w)) return l = w[0], w = w[1], n ? "</" + l + ">" : `<${l} class="${w}">`
        } else return "class" === u ? n ?
            "</span>" : `<span class="bbclass${f++}">` : l
    }
    const h = /\n/g;
    e.BBString = class {
        constructor(l, n) {
            this._bbstr = n && n.noEscape ? l : e.EscapeHTML(l);
            this._htmlstr = "";
            this._convertLineBreaks = !1;
            this._linkActions = [];
            if (n && (this._convertLineBreaks = !!n.convertLineBreaks, n.links)) {
                if (9 < n.links.length) throw Error("too many links");
                this._linkActions = n.links
            }
            this._hasAnyBBtags = this._bbstr.includes("[");
            this._needsLineBreakConversion = this._convertLineBreaks && this._bbstr.includes("\n");
            this._isPlain = !this._hasAnyBBtags &&
                !this._needsLineBreakConversion && !this._bbstr.includes("&");
            this._hasParsedFragments = !1;
            this._fragments = []
        }
        toString() {
            return this._bbstr
        }
        valueOf() {
            return this._bbstr
        }
        isPlainText() {
            return this._isPlain
        }
        toPlainText() {
            return this._hasAnyBBtags ? this._bbstr.replace(b, "") : this._bbstr
        }
        toHTML() {
            if (this._isPlain) return this._bbstr;
            if (!this._htmlstr && this._bbstr) {
                let l = this._bbstr;
                this._hasAnyBBtags && (f = 0, c = this._linkActions, l = l.replace(b, k), c = null);
                this._needsLineBreakConversion && (l = l.replace(h, "<br>"));
                this._htmlstr =
                    l
            }
            return this._htmlstr
        }
        attachLinkHandlers(l) {
            if (this._linkActions.length)
                for (let n = 0, u = this._linkActions.length; n < u; ++n) {
                    const w = this._linkActions[n];
                    if ("function" !== typeof w) continue;
                    const q = l.querySelector(".bblink" + n);
                    if (!q) throw Error("unable to attach BBString link handler");
                    q.onclick = w
                }
        }
        equals(l) {
            return l instanceof e.HtmlString ? this.toHTML() === l.toHTML() : l instanceof e.BBString ? this._bbstr === l._bbstr : this._bbstr === l
        }
        toFragmentList() {
            if (this._hasParsedFragments) return this._fragments;
            const l =
                this._bbstr,
                n = [];
            let u = d.lastIndex = 0;
            for (var w; null !== (w = d.exec(l));) {
                var q = w.index;
                if (0 < q && "\\" === l.charAt(q - 1)) continue;
                var t = w[0],
                    p = w[1];
                w = w[2];
                const r = l.substring(u, q);
                u = q + t.length;
                r && this._fragments.push({
                    text: r,
                    styles: n.slice(0)
                });
                if (w)
                    if (p)
                        for (w = w.toLowerCase(), q = n.length - 1; 0 <= q; --q) {
                            if (n[q].tag === w) {
                                n.splice(q, 1);
                                break
                            }
                        } else q = w, t = null, p = w.indexOf("="), -1 !== p ? (q = w.substring(0, p).toLowerCase(), t = w.substring(p + 1)) : q = q.toLowerCase(), n.push({
                            tag: q,
                            param: t
                        })
            }
            u < l.length && this._fragments.push({
                text: l.substring(u),
                styles: n.slice(0)
            });
            for (const r of this._fragments) r.text = this._ProcessBBCodeEscapeSequences(r.text);
            this._hasParsedFragments = !0;
            return this._fragments
        }
        _ProcessBBCodeEscapeSequences(l) {
            l = e.ReplaceAll(l, "\\[", "[");
            return e.ReplaceAll(l, "\\\\", "\\")
        }
        static StripTags(l) {
            return e.New(e.BBString, l, {
                noEscape: !0
            }).toPlainText()
        }
        static StripAnyTags(l) {
            return l.replace(d, "")
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.WordWrap = class {
        constructor() {
            this._lines = []
        }
        GetLines() {
            return this._lines
        }
        GetLineCount() {
            return this._lines.length
        }
        _MeasureLine(a, b) {
            let d = 0,
                c = 0,
                f = 0,
                k = 0,
                h = 0;
            for (const l of a) - 1 === l.width && (a = b(l.text, l.styles), l.width = a.width, l.height = a.height, l.fontBoundingBoxAscent = a.fontBoundingBoxAscent || 0, l.fontBoundingBoxDescent = a.fontBoundingBoxDescent || 0, l.topToAlphabeticDistance = a.topToAlphabeticDistance || 0), d += l.width, c = Math.max(c, l.height), f = Math.max(f, l.fontBoundingBoxAscent),
                k = Math.max(k, l.fontBoundingBoxDescent), h = Math.max(h, l.topToAlphabeticDistance);
            return {
                width: d,
                height: c,
                fontBoundingBoxAscent: f,
                fontBoundingBoxDescent: k,
                topToAlphabeticDistance: h
            }
        }
        _AddLine(a, b, d, c, f, k) {
            this._lines.push({
                fragments: a,
                width: b,
                height: d,
                fontBoundingBoxAscent: c,
                fontBoundingBoxDescent: f,
                topToAlphabeticDistance: k
            })
        }
        WordWrap(a, b, d, c, f) {
            "string" === typeof a && (a = [{
                text: a,
                styles: []
            }]);
            e.clearArray(this._lines);
            if (!(!a.length || 1 === a.length && !a[0].text.length || 2 > d)) {
                if (1 === a.length) {
                    var k = a[0];
                    const h =
                        k.text;
                    k = k.styles;
                    if (100 >= h.length && !h.includes("\n")) {
                        let {
                            width: l,
                            height: n,
                            fontBoundingBoxAscent: u,
                            fontBoundingBoxDescent: w,
                            topToAlphabeticDistance: q
                        } = b(h, k);
                        l += f;
                        u = u || 0;
                        w = w || 0;
                        q = q || 0;
                        if (l <= d) {
                            this._AddLine([{
                                text: h,
                                styles: k,
                                width: l,
                                height: n,
                                fontBoundingBoxAscent: u,
                                fontBoundingBoxDescent: w,
                                topToAlphabeticDistance: q
                            }], l, n, u, w, q);
                            return
                        }
                    }
                }
                if ("word" === c) c = this._TokeniseWords(a);
                else {
                    c = [];
                    for (const h of a) e.appendArray(c, [...h.text].map(l => [{
                        text: l,
                        styles: h.styles
                    }]))
                }
                this._WrapText(c, b, d, f)
            }
        }
        _TokeniseWords(a) {
            const b = [];
            let d = [],
                c = !1;
            for (const k of a) {
                var f = k.text;
                a = k.styles;
                for (const h of f) "\n" === h ? (0 < d.length && b.push(d), b.push([{
                    text: "\n",
                    styles: a
                }]), d = []) : 0 === d.length ? (d.push({
                    text: h,
                    styles: a
                }), c = e.IsWhitespaceChar(h)) : (f = e.IsWhitespaceChar(h), f === c ? (f = d.at(-1), f.styles === a ? f.text += h : d.push({
                    text: h,
                    styles: a
                })) : (b.push(d), d = [], d.push({
                    text: h,
                    styles: a
                }), c = f))
            }
            0 < d.length && b.push(d);
            return b
        }
        _CopyLine(a) {
            return a.map(b => ({
                text: b.text,
                styles: b.styles,
                width: b.width,
                height: b.height,
                fontBoundingBoxAscent: b.fontBoundingBoxAscent,
                fontBoundingBoxDescent: b.fontBoundingBoxDescent,
                topToAlphabeticDistance: b.topToAlphabeticDistance
            }))
        }
        _AddWordToLine(a, b) {
            var d = a.length ? a.at(-1) : null;
            let c = 0;
            d && b[0].styles === d.styles && (d.text += b[0].text, d.width = -1, d.height = -1, d.fontBoundingBoxAscent = -1, d.fontBoundingBoxDescent = -1, d.topToAlphabeticDistance = -1, c = 1);
            for (d = b.length; c < d; ++c) {
                const f = b[c];
                a.push({
                    text: f.text,
                    styles: f.styles,
                    width: -1,
                    height: -1,
                    fontBoundingBoxAscent: -1,
                    fontBoundingBoxDescent: -1,
                    topToAlphabeticDistance: -1
                })
            }
        }
        _WrapText(a,
            b, d, c) {
            let f = [],
                k = 0,
                h = 0,
                l = 0,
                n = 0;
            var u = 0;
            for (const w of a) {
                if (1 === w.length && "\n" === w[0].text) {
                    0 === h && (u = b(" ", w[0].styles), h = u.height, l = u.fontBoundingBoxAscent || 0, n = u.fontBoundingBoxDescent || 0, u = u.topToAlphabeticDistance || 0);
                    this._AddLine(f, k, h, l, n, u);
                    f = [];
                    u = n = l = h = k = 0;
                    continue
                }
                a = this._CopyLine(f);
                this._AddWordToLine(a, w);
                const q = this._MeasureLine(a, b),
                    t = q.width;
                t >= d ? (0 < f.length && this._AddLine(f, k, h, l, n, u), f = [], e.IsStringAllWhitespace(w[0].text) ? u = n = l = h = k = 0 : (this._AddWordToLine(f, w), u = this._MeasureLine(f,
                    b), k = u.width, h = u.height, l = u.fontBoundingBoxAscent, n = u.fontBoundingBoxDescent, u = u.topToAlphabeticDistance)) : (f = a, k = t, h = q.height, l = q.fontBoundingBoxAscent, n = q.fontBoundingBoxDescent, u = q.topToAlphabeticDistance)
            }
            0 < f.length && this._AddLine(f, k, h, l, n, u);
            this._TrimLinesTrailingWhitespace(b, c)
        }
        _TrimLinesTrailingWhitespace(a, b) {
            for (const c of this._lines) {
                const f = c.fragments;
                if (!f.length) continue;
                let k = f.at(-1);
                var d = k.text;
                const h = d.trimEnd();
                if (!h) c.width -= k.width, f.pop();
                else if (h.length < d.length) {
                    d = a(h,
                        k.styles).width;
                    const l = k.width - d;
                    k.width = d;
                    k.text = h;
                    c.width -= l
                }
                0 !== b && 0 < f.length && (k = f.at(-1), k.width += b, c.width += b)
            }
        }
        Clear() {
            e.clearArray(this._lines)
        }
        GetMaxLineWidth() {
            return this._lines.reduce((a, b) => Math.max(a, b.width), 0)
        }
        GetTotalLineHeight() {
            return this._lines.reduce((a, b) => a + b.height, 0)
        }
    }
} {
    "use strict";
    const e = self.C3,
        a = self.glMatrix,
        b = a.vec3,
        d = a.vec4,
        c = a.mat4,
        f = b.create(),
        k = b.create(),
        h = b.create(),
        l = d.create(),
        n = c.create(),
        u = b.create(),
        w = b.create(),
        q = b.create(),
        t = b.create(),
        p = b.create(),
        r = b.create(),
        x = b.create(),
        y = b.create(),
        E = d.fromValues(0, 0, 1, 1);
    e.Gfx = {
        Project(B, I, L, P, S, U, V) {
            const Z = P[0] * B + P[4] * I + P[8] * L + P[12],
                ma = P[1] * B + P[5] * I + P[9] * L + P[13],
                va = P[2] * B + P[6] * I + P[10] * L + P[14];
            P = P[3] * B + P[7] * I + P[11] * L + P[15];
            B = S[0] * Z + S[4] * ma + S[8] * va + S[12] * P;
            I = S[1] * Z + S[5] * ma + S[9] * va + S[13] * P;
            L = S[2] * Z + S[6] *
                ma + S[10] * va + S[14] * P;
            S = S[3] * Z + S[7] * ma + S[11] * va + S[15] * P;
            if (0 === S) return !1;
            S = 1 / S;
            V[0] = (B * S * .5 + .5) * U[2] + U[0];
            V[1] = (I * S * .5 + .5) * U[3] + U[1];
            V[2] = .5 * (1 + L * S);
            return !0
        },
        Unproject(B, I, L, P, S, U, V) {
            c.multiply(n, S, P);
            if (null === c.invert(n, n)) return !1;
            l[0] = (B - U[0]) / U[2] * 2 - 1;
            l[1] = (I - U[1]) / U[3] * 2 - 1;
            l[2] = 2 * L - 1;
            l[3] = 1;
            d.transformMat4(l, l, n);
            if (0 === l[3]) return !1;
            l[3] = 1 / l[3];
            V[0] = l[0] * l[3];
            V[1] = l[1] * l[3];
            V[2] = l[2] * l[3];
            return !0
        },
        UnprojectScreenToWorldZ(B, I, L, P, S, U, V) {
            if (!e.Gfx.Unproject(B, I, 0, P, S, U, f) || !e.Gfx.Unproject(B,
                    I, 1, P, S, U, k)) return !1;
            b.subtract(k, k, f);
            b.set(h, 0, 0, 1);
            B = -L;
            I = b.dot(h, k);
            L = 0;
            if (0 === I) {
                if (0 !== b.dot(h, f) + B) return !1
            } else if (L = -(b.dot(f, h) + B) / I, 0 > L) return !1;
            b.scaleAndAdd(V, f, k, L);
            return !0
        }
    };

    function G(B, I, L, P) {
        b.subtract(f, L, I);
        b.subtract(k, B, I);
        b.cross(h, f, k);
        b.normalize(h, h);
        P.set(h[0], h[1], h[2], b.dot(B, h))
    }

    function A(B, I, L, P, S, U, V) {
        const Z = V.x,
            ma = V.y,
            va = V.z,
            Na = V.w,
            Ea = V.xF,
            Ia = V.yF;
        V = V.zF;
        const Ma = 1 - Ea,
            Fa = 1 - Ia,
            ya = 1 - V;
        return Z * B * Ea + Z * P * Ma + ma * I * Ia + ma * S * Fa + va * L * V + va * U * ya >= Na ? !0 : Z * P * Ea + Z * B * Ma + ma * S *
            Ia + ma * I * Fa + va * U * V + va * L * ya > Na
    }

    function F(B, I, L, P) {
        return P.x * B + P.y * I + P.z * L >= P.w
    }
    class J {
        constructor() {
            this.zF = this.yF = this.xF = this.w = this.z = this.y = this.x = NaN
        }
        set(B, I, L, P) {
            this.x = B;
            this.y = I;
            this.z = L;
            this.w = P;
            this.xF = 0 < B ? 1 : 0;
            this.yF = 0 < I ? 1 : 0;
            this.zF = 0 < L ? 1 : 0
        }
    }
    e.Gfx.ViewFrustum = class {
        constructor() {
            this._leftP = new J;
            this._topP = new J;
            this._rightP = new J;
            this._bottomP = new J;
            this._nearP = new J;
            this._farP = new J
        }
        CalculatePlanes(B, I) {
            e.Gfx.Unproject(0, 1, 0, B, I, E, u);
            e.Gfx.Unproject(1, 1, 0, B, I, E, w);
            e.Gfx.Unproject(0,
                0, 0, B, I, E, q);
            e.Gfx.Unproject(1, 0, 0, B, I, E, t);
            e.Gfx.Unproject(0, 1, 1, B, I, E, p);
            e.Gfx.Unproject(1, 1, 1, B, I, E, r);
            e.Gfx.Unproject(0, 0, 1, B, I, E, x);
            e.Gfx.Unproject(1, 0, 1, B, I, E, y);
            G(q, u, p, this._leftP);
            G(u, w, r, this._topP);
            G(w, t, y, this._rightP);
            G(t, q, x, this._bottomP);
            G(x, p, r, this._farP);
            G(t, w, u, this._nearP)
        }
        ContainsAABB(B, I, L, P, S, U) {
            return A(B, I, L, P, S, U, this._leftP) && A(B, I, L, P, S, U, this._topP) && A(B, I, L, P, S, U, this._rightP) && A(B, I, L, P, S, U, this._bottomP) && A(B, I, L, P, S, U, this._nearP) && A(B, I, L, P, S, U, this._farP)
        }
        IsBehindNearPlane(B,
            I, L) {
            return !F(B, I, L, this._nearP)
        }
    }
} {
    "use strict";
    const e = self.C3,
        a = self.glMatrix,
        b = a.vec3,
        d = a.vec4,
        c = a.mat4,
        f = c.create(),
        k = b.fromValues(0, 0, 0),
        h = b.fromValues(0, 0, 0),
        l = b.fromValues(0, 0, 0),
        n = b.fromValues(0, 1, 0);
    d.fromValues(0, 0, 0, 0);
    const u = new e.Quad,
        w = new e.Rect,
        q = new e.Quad(0, 0, 1, 0, 1, 1, 0, 1);
    e.Gfx.RendererBase = class {
        constructor() {
            this._height = this._width = 0;
            this._fovY = e.toRadians(45);
            this._tan_fovY_2 = Math.tan(this._fovY / 2);
            this._matP = c.create();
            this._matMV = c.create();
            this._allShaderPrograms = [];
            this._shaderProgramsByName = new Map;
            this._spSmoothLineFill =
                this._spSmoothEllipseOutline = this._spSmoothEllipseFill = this._spHardEllipseOutline = this._spHardEllipseFill = this._spLinearGradientFill = this._spColorFill = this._spTilemapFill = this._spPoints = this._spTextureFill = null;
            this._stateGroups = new Map;
            this._currentStateGroup = null;
            this._blendModeTable = [];
            this._namedBlendModeMap = new Map;
            this._currentZ = this._baseZ = 0;
            this._lineWidth = 1;
            this._lineWidthStack = [this._lineWidth];
            this._lineCap = 1;
            this._lineCapStack = [this._lineCap];
            this._lineOffset = .5;
            this._lineOffsetStack = [this._lineOffset];
            this._frameNumber = 0;
            this._enableMipmaps = !0;
            this._hasMajorPerformanceCaveat = !1
        }
        FillIndexBufferData(t) {
            let p = 0,
                r = t.length,
                x = 0;
            for (; p < r;) t[p++] = x, t[p++] = x + 1, t[p++] = x + 2, t[p++] = x, t[p++] = x + 2, t[p++] = x + 3, x += 4
        }
        _ClearState() {
            this._currentZ = this._baseZ = 0;
            this._spSmoothLineFill = this._spSmoothEllipseOutline = this._spSmoothEllipseFill = this._spHardEllipseOutline = this._spHardEllipseFill = this._spLinearGradientFill = this._spColorFill = this._spTilemapFill = this._spPoints = this._spTextureFill = null;
            this._ClearAllShaderPrograms()
        }
        InitState() {
            this._ClearState();
            this._currentStateGroup = null
        }
        OnDeviceOrContextLost() {
            for (const t of this._allShaderPrograms) t.Release();
            this._ClearState()
        }
        GetWidth() {
            return this._width
        }
        GetHeight() {
            return this._height
        }
        GetDefaultCameraZ() {
            return 100
        }
        GetNearZ() {
            return 1
        }
        GetFarZ() {
            return 1E4
        }
        GetFovY() {
            return this._fovY
        }
        _GetTanFovYDiv2() {
            return this._tan_fovY_2
        }
        CalculatePerspectiveMatrix(t, p, r = .5, x = .5) {
            const y = this.GetNearZ(),
                E = this.GetFarZ();
            var G = this.GetFovY();
            if (.5 === r && .5 === x) this.IsWebGPU() ? c.perspectiveZO(t, G, p, y, E) : c.perspective(t,
                G, p, y, E);
            else {
                r = 1 - r;
                G = 2 * r - 2;
                r *= 2;
                const A = 2 * x - 2;
                x *= 2;
                const F = this._GetTanFovYDiv2() * y;
                p *= F;
                c.frustum(t, G * p, r * p, A * F, x * F, y, E)
            }
        }
        CalculateOrthographicMatrix(t, p, r, x = 1) {
            var y = self.devicePixelRatio;
            const E = 2 * this.GetDefaultCameraZ() * y * this._GetTanFovYDiv2() / r;
            p = p * E / (2 * y * x);
            r = r * E / (2 * y * x);
            x = -p;
            y = -r;
            this.IsWebGPU() ? c.orthoZO(t, x, p, y, r, this.GetNearZ(), this.GetFarZ()) : c.ortho(t, x, p, y, r, this.GetNearZ(), this.GetFarZ())
        }
        CalculateLookAtModelView(t, p, r, x, y = this.GetHeight()) {
            y = 2 * this.GetDefaultCameraZ() * self.devicePixelRatio *
                this._GetTanFovYDiv2() / y;
            b.set(l, y, -y, 1);
            b.multiply(k, p, l);
            b.multiply(h, r, l);
            c.lookAt(t, k, h, x || n);
            c.scale(t, t, l)
        }
        CalculateLookAtModelView2(t, p, r, x, y, E, G) {
            b.set(k, t, p, r);
            b.set(h, x, y, E);
            this.CalculateLookAtModelView(f, k, h, n, G);
            return f
        }
        _AddShaderProgram(t) {
            this._allShaderPrograms.push(t);
            this._shaderProgramsByName.set(t.GetName(), t)
        }
        _RemoveShaderProgram(t) {
            const p = this._allShaderPrograms.indexOf(t); - 1 !== p && this._allShaderPrograms.splice(p, 1);
            this._shaderProgramsByName.delete(t.GetName())
        }
        _ClearAllShaderPrograms() {
            e.clearArray(this._allShaderPrograms);
            this._shaderProgramsByName.clear()
        }
        GetShaderProgramByName(t) {
            return this._shaderProgramsByName.get(t) || null
        }
        GetTextureFillShaderProgram() {
            return this._spTextureFill
        }
        SetTextureFillMode() {
            this.SetProgram(this._spTextureFill)
        }
        GetPointsRenderingProgram() {
            return this._spPoints
        }
        SetPointsRenderingProgram() {
            this.SetProgram(this._spPoints)
        }
        SetTilemapFillMode() {
            this.SetProgram(this._spTilemapFill)
        }
        SetColorFillMode() {
            this.SetProgram(this._spColorFill)
        }
        SetLinearGradientFillMode() {
            this.SetProgram(this._spLinearGradientFill)
        }
        SetHardEllipseFillMode() {
            this.SetProgram(this._spHardEllipseFill)
        }
        SetHardEllipseOutlineMode() {
            this.SetProgram(this._spHardEllipseOutline)
        }
        SetSmoothEllipseFillMode() {
            this.SetProgram(this._spSmoothEllipseFill)
        }
        SetSmoothEllipseOutlineMode() {
            this.SetProgram(this._spSmoothEllipseOutline)
        }
        SetSmoothLineFillMode() {
            this.SetProgram(this._spSmoothLineFill)
        }
        _SetCurrentStateGroup(t) {
            this._currentStateGroup =
                t
        }
        GetCurrentStateGroup() {
            return this._currentStateGroup
        }
        AcquireStateGroup(t, p, r, x) {
            const y = e.Gfx.StateGroup.MakeKey(t, p, r, x);
            let E = this._stateGroups.get(y);
            E || (E = e.New(e.Gfx.StateGroup, this, t, p, r, x), this._stateGroups.set(y, E));
            E.AddRef();
            return E
        }
        ReleaseStateGroup(t) {
            t.DecRef();
            0 === t._GetRefCount() && (this._currentStateGroup === t && (this._currentStateGroup = null), this._stateGroups.delete(t.GetKey()), t.Release())
        }
        _InitBlendModeData(t) {
            e.clearArray(this._blendModeTable);
            this._namedBlendModeMap.clear();
            let p = 0;
            for (const r of t) {
                t = r[0];
                const x = r[1],
                    y = r[2];
                this._blendModeTable.push([x, y]);
                this._namedBlendModeMap.set(t, {
                    number: p,
                    srcBlend: x,
                    destBlend: y
                });
                p++
            }
        }
        _GetBlendByIndex(t) {
            return this._blendModeTable[t]
        }
        GetSrcBlendByIndex(t) {
            return this._GetBlendByIndex(t)[0]
        }
        GetDestBlendByIndex(t) {
            return this._GetBlendByIndex(t)[1]
        }
        GetNamedBlend(t) {
            t = this._namedBlendModeMap.get(t);
            if ("undefined" === typeof t) throw Error("invalid blend name");
            return t
        }
        NamedBlendToNumber(t) {
            t = this._namedBlendModeMap.get(t);
            if ("undefined" ===
                typeof t) throw Error("invalid blend name");
            return t.number
        }
        SetBaseZ(t) {
            this._baseZ = t
        }
        GetBaseZ() {
            return this._baseZ
        }
        SetCurrentZ(t) {
            this._currentZ = t;
            this._currentStateGroup = null
        }
        GetCurrentZ() {
            return this._currentZ
        }
        Line(t, p, r, x) {
            var y = e.angleTo(t, p, r, x),
                E = .5 * this._lineWidth;
            const G = Math.sin(y) * E;
            y = Math.cos(y) * E;
            E = this._lineCap;
            2 === E ? this.LinePreCalc_LineCap2(t, p, 0, r, x, 0, G, y) : 1 === E ? this.LinePreCalc_LineCap1(t, p, 0, r, x, 0, G, y) : this.LinePreCalc_LineCap0(t, p, 0, r, x, 0, G, y)
        }
        Line3D(t, p, r, x, y, E) {
            var G = e.angleTo(t,
                    p, x, y),
                A = .5 * this._lineWidth;
            const F = Math.sin(G) * A;
            G = Math.cos(G) * A;
            A = this._lineCap;
            2 === A ? this.LinePreCalc_LineCap2(t, p, r, x, y, E, F, G) : 1 === A ? this.LinePreCalc_LineCap1(t, p, r, x, y, E, F, G) : this.LinePreCalc_LineCap0(t, p, r, x, y, E, F, G)
        }
        LinePreCalc_LineCap2(t, p, r, x, y, E, G, A) {
            var F = this._lineOffset;
            t = t + F - A;
            p = p + F - G;
            x = x + F + A;
            y = y + F + G;
            F = 2 * A;
            const J = 2 * G;
            this.Quad3D2(t + G, p - A, r, x + G, y - A, E, x - G - F, y + A - J, E, t - G + F, p + A + J, r, q)
        }
        LinePreCalc_LineCap1(t, p, r, x, y, E, G, A) {
            const F = this._lineOffset;
            t = t + F - A;
            p = p + F - G;
            x = x + F + A;
            y = y + F + G;
            this.Quad3D2(t +
                G, p - A, r, x + G, y - A, E, x - G, y + A, E, t - G, p + A, r, q)
        }
        LinePreCalc_LineCap0(t, p, r, x, y, E, G, A) {
            const F = this._lineOffset;
            t += F;
            p += F;
            x += F;
            y += F;
            this.Quad3D2(t + G, p - A, r, x + G, y - A, E, x - G, y + A, E, t - G, p + A, r, q)
        }
        TexturedLine(t, p, r, x, y, E) {
            var G = e.angleTo(t, p, r, x),
                A = .5 * this._lineWidth;
            const F = Math.sin(G) * A;
            G = Math.cos(G) * A;
            A = this._lineCap;
            2 === A ? this.TexturedLinePreCalc_LineCap2(t, p, r, x, F, G, y, E) : 1 === A ? this.TexturedLinePreCalc_LineCap1(t, p, r, x, F, G, y, E) : this.TexturedLinePreCalc_LineCap0(t, p, r, x, F, G, y, E)
        }
        TexturedLinePreCalc_LineCap2(t,
            p, r, x, y, E, G, A) {
            var F = this._lineOffset;
            t = t + F - E;
            p = p + F - y;
            r = r + F + E;
            x = x + F + y;
            F = 2 * E;
            const J = 2 * y;
            u.set(t + y, p - E, r + y, x - E, r - y - F, x + E - J, t - y + F, p + E + J);
            w.set(G, 0, A, 0);
            this.Quad3(u, w)
        }
        TexturedLinePreCalc_LineCap1(t, p, r, x, y, E, G, A) {
            const F = this._lineOffset;
            t = t + F - E;
            p = p + F - y;
            r = r + F + E;
            x = x + F + y;
            u.set(t + y, p - E, r + y, x - E, r - y, x + E, t - y, p + E);
            w.set(G, 0, A, 0);
            this.Quad3(u, w)
        }
        TexturedLinePreCalc_LineCap0(t, p, r, x, y, E, G, A) {
            const F = this._lineOffset;
            t += F;
            p += F;
            r += F;
            x += F;
            u.set(t + y, p - E, r + y, x - E, r - y, x + E, t - y, p + E);
            w.set(G, 0, A, 0);
            this.Quad3(u, w)
        }
        LineRect(t,
            p, r, x) {
            const y = .5 * this._lineWidth,
                E = this._lineCap;
            2 === E ? this._LineRectPreCalc_LineCap2(t, p, r, x, y) : 1 === E ? this._LineRectPreCalc_LineCap1(t, p, r, x, y) : this._LineRectPreCalc_LineCap0(t, p, r, x, y)
        }
        _LineRectPreCalc_LineCap2(t, p, r, x, y) {
            this.LinePreCalc_LineCap2(t, p, 0, r, p, 0, 0, y);
            this.LinePreCalc_LineCap2(r, p, 0, r, x, 0, y, 0);
            this.LinePreCalc_LineCap2(r, x, 0, t, x, 0, 0, -y);
            this.LinePreCalc_LineCap2(t, x, 0, t, p, 0, -y, 0)
        }
        _LineRectPreCalc_LineCap1(t, p, r, x, y) {
            this.LinePreCalc_LineCap1(t, p, 0, r, p, 0, 0, y);
            this.LinePreCalc_LineCap1(r,
                p, 0, r, x, 0, y, 0);
            this.LinePreCalc_LineCap1(r, x, 0, t, x, 0, 0, -y);
            this.LinePreCalc_LineCap1(t, x, 0, t, p, 0, -y, 0)
        }
        _LineRectPreCalc_LineCap0(t, p, r, x, y) {
            this.LinePreCalc_LineCap0(t, p, 0, r, p, 0, 0, y);
            this.LinePreCalc_LineCap0(r, p, 0, r, x, 0, y, 0);
            this.LinePreCalc_LineCap0(r, x, 0, t, x, 0, 0, -y);
            this.LinePreCalc_LineCap0(t, x, 0, t, p, 0, -y, 0)
        }
        LineRect2(t) {
            this.LineRect(t.getLeft(), t.getTop(), t.getRight(), t.getBottom())
        }
        LineQuad(t) {
            var p = e.angleTo(t.getTlx(), t.getTly(), t.getTrx(), t.getTry()),
                r = .5 * this._lineWidth;
            const x = Math.sin(p) *
                r;
            p = Math.cos(p) * r;
            r = this._lineCap;
            2 === r ? this._LineQuadPreCalc_LineCap2(t, x, p) : 1 === r ? this._LineQuadPreCalc_LineCap1(t, x, p) : this._LineQuadPreCalc_LineCap0(t, x, p)
        }
        _LineQuadPreCalc_LineCap2(t, p, r) {
            this.LinePreCalc_LineCap2(t.getTlx(), t.getTly(), 0, t.getTrx(), t.getTry(), 0, p, r);
            this.LinePreCalc_LineCap2(t.getTrx(), t.getTry(), 0, t.getBrx(), t.getBry(), 0, r, -p);
            this.LinePreCalc_LineCap2(t.getBrx(), t.getBry(), 0, t.getBlx(), t.getBly(), 0, -p, -r);
            this.LinePreCalc_LineCap2(t.getBlx(), t.getBly(), 0, t.getTlx(), t.getTly(),
                0, -r, p)
        }
        _LineQuadPreCalc_LineCap1(t, p, r) {
            this.LinePreCalc_LineCap1(t.getTlx(), t.getTly(), 0, t.getTrx(), t.getTry(), 0, p, r);
            this.LinePreCalc_LineCap1(t.getTrx(), t.getTry(), 0, t.getBrx(), t.getBry(), 0, r, -p);
            this.LinePreCalc_LineCap1(t.getBrx(), t.getBry(), 0, t.getBlx(), t.getBly(), 0, -p, -r);
            this.LinePreCalc_LineCap1(t.getBlx(), t.getBly(), 0, t.getTlx(), t.getTly(), 0, -r, p)
        }
        _LineQuadPreCalc_LineCap0(t, p, r) {
            this.LinePreCalc_LineCap0(t.getTlx(), t.getTly(), 0, t.getTrx(), t.getTry(), 0, p, r);
            this.LinePreCalc_LineCap0(t.getTrx(),
                t.getTry(), 0, t.getBrx(), t.getBry(), 0, r, -p);
            this.LinePreCalc_LineCap0(t.getBrx(), t.getBry(), 0, t.getBlx(), t.getBly(), 0, -p, -r);
            this.LinePreCalc_LineCap0(t.getBlx(), t.getBly(), 0, t.getTlx(), t.getTly(), 0, -r, p)
        }
        SetLineWidth(t) {
            this._lineWidth = t;
            this._lineWidthStack[this._lineWidthStack.length - 1] = t
        }
        GetLineWidth() {
            return this._lineWidth
        }
        PushLineWidth(t) {
            if (100 <= this._lineWidthStack.length) throw Error("pushed too many line widths - check push/pop pairs");
            this._lineWidthStack.push(t);
            this._lineWidth = t
        }
        PopLineWidth() {
            if (1 >=
                this._lineWidthStack.length) throw Error("cannot pop last line width - check push/pop pairs");
            this._lineWidthStack.pop();
            this._lineWidth = this._lineWidthStack.at(-1)
        }
        SetLineCapButt() {
            this._lineCap = 0;
            this._lineCapStack[this._lineCapStack.length - 1] = 0
        }
        SetLineCapSquare() {
            this._lineCap = 1;
            this._lineCapStack[this._lineCapStack.length - 1] = 0
        }
        SetLineCapZag() {
            this._lineCap = 2;
            this._lineCapStack[this._lineCapStack.length - 1] = 0
        }
        PushLineCap(t) {
            if ("butt" === t) this.PushLineCapButt();
            else if ("square" === t) this.PushLineCapSquare();
            else if ("zag" === t) this.PushLineCapZag();
            else throw Error("invalid line cap");
        }
        PushLineCapButt() {
            if (100 <= this._lineCapStack.length) throw Error("pushed too many line caps - check push/pop pairs");
            this._lineCapStack.push(0);
            this._lineCap = 0
        }
        PushLineCapSquare() {
            if (100 <= this._lineCapStack.length) throw Error("pushed too many line caps - check push/pop pairs");
            this._lineCapStack.push(1);
            this._lineCap = 1
        }
        PushLineCapZag() {
            if (100 <= this._lineCapStack.length) throw Error("pushed too many line caps - check push/pop pairs");
            this._lineCapStack.push(2);
            this._lineCap = 2
        }
        PopLineCap() {
            if (1 >= this._lineCapStack.length) throw Error("cannot pop last line cap - check push/pop pairs");
            this._lineCapStack.pop();
            this._lineCap = this._lineCapStack.at(-1)
        }
        SetLineOffset(t) {
            this._lineOffset = t;
            this._lineOffsetStack[this._lineOffsetStack.length - 1] = t
        }
        GetLineOffset() {
            return this._lineOffset
        }
        PushLineOffset(t) {
            if (100 <= this._lineOffsetStack.length) throw Error("pushed too many line offsets - check push/pop pairs");
            this._lineOffsetStack.push(t);
            this._lineOffset =
                t
        }
        PopLineOffset() {
            if (1 >= this._lineOffsetStack.length) throw Error("cannot pop last line offset - check push/pop pairs");
            this._lineOffsetStack.pop();
            this._lineOffset = this._lineOffsetStack.at(-1)
        }
        ConvexPoly(t) {
            var p = t.length / 2;
            if (3 > p) throw Error("need at least 3 points");
            p -= 2;
            const r = p - 1,
                x = t[0],
                y = t[1];
            for (let E = 0; E < p; E += 2) {
                const G = 2 * E,
                    A = t[G + 2],
                    F = t[G + 3],
                    J = t[G + 4],
                    B = t[G + 5];
                E === r ? this.Quad2(x, y, A, F, J, B, J, B) : this.Quad2(x, y, A, F, J, B, t[G + 6], t[G + 7])
            }
        }
        GetNumVertexComponents() {
            return 3
        }
        Finish() {
            this.EndBatch(!0);
            this._frameNumber++
        }
        GetFrameNumber() {
            return this._frameNumber
        }
        IncrementFrameNumber() {
            this._frameNumber++
        }
        SetMipmapsEnabled(t) {
            this._enableMipmaps = !!t
        }
        AreMipmapsEnabled() {
            return this._enableMipmaps
        }
        SetHasMajorPerformanceCaveat(t) {
            this._hasMajorPerformanceCaveat = !!t
        }
        HasMajorPerformanceCaveat() {
            return this._hasMajorPerformanceCaveat
        }
        IsWebGL() {
            return !1
        }
        IsWebGPU() {
            return !1
        }
    }
}
"use strict";
self.C3.Gfx.ShaderProgramBase = class {
    constructor(e, a, b) {
        this._name = a;
        this._renderer = e;
        this._extendBoxHorizontal = b.extendBoxHorizontal || 0;
        this._extendBoxVertical = b.extendBoxVertical || 0;
        this._crossSampling = !!b.crossSampling;
        this._mustPreDraw = !!b.mustPreDraw;
        this._preservesOpaqueness = !!b.preservesOpaqueness;
        this._animated = !!b.animated;
        this._blendsBackground = !!b.blendsBackground;
        this._usesDepth = !!b.usesDepth;
        this._usesAnySrcRectOrPixelSize = !1;
        this._needsPostDrawOrExtendBox = this._crossSampling || this._blendsBackground ||
            0 !== this._extendBoxHorizontal || 0 !== this._extendBoxVertical
    }
    Release() {
        this._renderer = null
    }
    GetRenderer() {
        return this._renderer
    }
    GetName() {
        return this._name
    }
    ExtendsBox() {
        return 0 !== this._extendBoxHorizontal || 0 !== this._extendBoxVertical
    }
    GetBoxExtendHorizontal() {
        return this._extendBoxHorizontal
    }
    GetBoxExtendVertical() {
        return this._extendBoxVertical
    }
    UsesCrossSampling() {
        return this._crossSampling
    }
    MustPreDraw() {
        return this._mustPreDraw
    }
    PreservesOpaqueness() {
        return this._preservesOpaqueness
    }
    IsAnimated() {
        return this._animated
    }
    BlendsBackground() {
        return this._blendsBackground
    }
    UsesDepth() {
        return this._usesDepth
    }
    UsesAnySrcRectOrPixelSize() {
        return this._usesAnySrcRectOrPixelSize
    }
    NeedsPostDrawOrExtendsBox() {
        return this._needsPostDrawOrExtendBox
    }
}; {
    "use strict";
    const e = self.C3;
    e.Gfx.StateGroup = class {
        constructor(a, b, d, c, f) {
            this._renderer = a;
            this._refCount = 0;
            this._shaderProgram = null;
            this._shaderProgramName = "";
            this._blendMode = d;
            this._color = e.New(e.Color);
            this._color.set(c);
            this._zElevation = f;
            "string" === typeof b ? this._shaderProgramName = b : (this._shaderProgram = b, this._shaderProgramName = this._shaderProgram.GetName())
        }
        Release() {
            if (0 < this._refCount) throw Error("releasing state group still in use");
            this._shaderProgram = this._renderer = null;
            this._shaderProgramName =
                ""
        }
        Apply() {
            const a = this._renderer;
            a.SetProgram(this._shaderProgram);
            a.SetBlendMode(this._blendMode);
            a.SetColor(this._color);
            a.SetCurrentZ(this._zElevation);
            a._SetCurrentStateGroup(this)
        }
        GetKey() {
            return e.Gfx.StateGroup.MakeKey(this._shaderProgramName, this._blendMode, this._color, this._zElevation)
        }
        AddRef() {
            ++this._refCount
        }
        DecRef() {
            --this._refCount
        }
        _GetRefCount() {
            return this._refCount
        }
        OnContextLost() {
            this._shaderProgram = null
        }
        OnContextRestored(a) {
            this._shaderProgram = a.GetShaderProgramByName(this._shaderProgramName);
            if (!this._shaderProgram) throw Error("failed to restore shader program");
        }
        static MakeKey(a, b, d, c) {
            return ("string" === typeof a ? a : a.GetName()) + "," + b + "," + d.getR() + "," + d.getG() + "," + d.getB() + "," + d.getA() + "," + c
        }
    }
} {
    "use strict";
    const e = self.C3,
        a = e.New(e.Quad);

    function b(d, c, f) {
        const k = f.getTlx(),
            h = f.getTly(),
            l = f.getTrx() - k,
            n = f.getTry() - h,
            u = f.getBlx() - k;
        f = f.getBly() - h;
        return [k + l * d + u * c, h + n * d + f * c]
    }
    e.Gfx.MeshPoint = class {
        constructor(d, c, f) {
            this._mesh = d;
            this._col = c;
            this._row = f;
            this._v = this._u = this._zElevation = this._y = this._x = 0
        }
        _Init(d, c, f, k) {
            this._x = d;
            this._y = c;
            this._u = f;
            this._v = k
        }
        GetX() {
            return this._x
        }
        SetX(d) {
            this._x !== d && (this._x = d, this._mesh._SetPointsChanged())
        }
        GetY() {
            return this._y
        }
        SetY(d) {
            this._y !== d && (this._y =
                d, this._mesh._SetPointsChanged())
        }
        GetZElevation() {
            return this._zElevation
        }
        SetZElevation(d) {
            this._zElevation !== d && (this._zElevation = Math.max(d, 0), this._mesh._SetPointsChanged())
        }
        GetU() {
            return this._u
        }
        SetU(d) {
            this._u = d
        }
        GetV() {
            return this._v
        }
        SetV(d) {
            this._v = d
        }
        _Interpolate_TexRect(d, c, f) {
            [this._x, this._y] = b(d._x, d._y, c);
            this._zElevation = d._zElevation;
            this._u = e.lerp(f.getLeft(), f.getRight(), d._u);
            this._v = e.lerp(f.getTop(), f.getBottom(), d._v)
        }
        _Interpolate_TexQuad(d, c, f) {
            [this._x, this._y] = b(d._x, d._y, c);
            this._zElevation = d._zElevation;
            [this._u, this._v] = b(d._u, d._v, f)
        }
        SaveToJson() {
            return {
                x: this.GetX(),
                y: this.GetY(),
                z: this.GetZElevation(),
                u: this.GetU(),
                v: this.GetV()
            }
        }
        LoadFromJson(d) {
            this.SetX(d.x);
            this.SetY(d.y);
            d.hasOwnProperty("z") && this.SetZElevation(d.z);
            this.SetU(d.u);
            this.SetV(d.v)
        }
        GetMesh() {
            return this._mesh
        }
        GetColumn() {
            return this._col
        }
        GetRow() {
            return this._row
        }
    };
    e.Gfx.Mesh = class {
        constructor(d, c, f) {
            if (2 > d || 2 > c) throw Error("invalid mesh size");
            this._hsize = d;
            this._vsize = c;
            this._owner = f || null;
            this._pts = [];
            this._minY = this._minX = 0;
            this._maxY = this._maxX = 1;
            this._maxZ = 0;
            this._pointsChanged = !1;
            f = d - 1;
            const k = c - 1;
            for (let h = 0; h < c; ++h) {
                const l = [];
                for (let n = 0; n < d; ++n) {
                    const u = e.New(e.Gfx.MeshPoint, this, n, h),
                        w = n / f,
                        q = h / k;
                    u._Init(w, q, w, q);
                    l.push(u)
                }
                this._pts.push(l)
            }
        }
        Release() {
            e.clearArray(this._pts)
        }
        GetHSize() {
            return this._hsize
        }
        GetVSize() {
            return this._vsize
        }
        GetOwner() {
            return this._owner
        }
        _GetPoints() {
            return this._pts
        }
        _SetPointsChanged() {
            this._pointsChanged = !0
        }
        _MaybeComputeBounds() {
            if (this._pointsChanged) {
                var d =
                    Infinity,
                    c = Infinity,
                    f = -Infinity,
                    k = -Infinity,
                    h = 0;
                for (const l of this._pts)
                    for (const n of l) {
                        const u = n.GetX(),
                            w = n.GetY();
                        d = Math.min(d, u);
                        c = Math.min(c, w);
                        f = Math.max(f, u);
                        k = Math.max(k, w);
                        h = Math.max(h, n.GetZElevation())
                    }
                this._minX = d;
                this._minY = c;
                this._maxX = f;
                this._maxY = k;
                this._maxZ = h;
                this._pointsChanged = !1
            }
        }
        GetMinX() {
            this._MaybeComputeBounds();
            return this._minX
        }
        GetMinY() {
            this._MaybeComputeBounds();
            return this._minY
        }
        GetMaxX() {
            this._MaybeComputeBounds();
            return this._maxX
        }
        GetMaxY() {
            this._MaybeComputeBounds();
            return this._maxY
        }
        GetMaxZ() {
            this._MaybeComputeBounds();
            return this._maxZ
        }
        HasAnyZElevation() {
            return 0 < this.GetMaxZ()
        }
        GetMeshPointAt(d, c) {
            d = Math.floor(d);
            c = Math.floor(c);
            return 0 > d || d >= this._hsize || 0 > c || c >= this._vsize ? null : this._pts[c][d]
        }
        CalculateTransformedMesh(d, c, f) {
            const k = f instanceof e.Rect;
            if (d.GetHSize() !== this.GetHSize() || d.GetVSize() !== this.GetVSize()) throw Error("source mesh wrong size");
            d = d._pts;
            const h = this._pts;
            for (let l = 0, n = h.length; l < n; ++l) {
                const u = d[l],
                    w = h[l];
                for (let q = 0, t = w.length; q <
                    t; ++q) {
                    const p = u[q],
                        r = w[q];
                    k ? r._Interpolate_TexRect(p, c, f) : r._Interpolate_TexQuad(p, c, f)
                }
            }
        }
        Draw(d) {
            const c = this._pts;
            let f = c[0];
            for (let k = 1, h = c.length; k < h; ++k) {
                const l = c[k];
                let n = f[0],
                    u = l[0];
                for (let w = 1, q = l.length; w < q; ++w) {
                    const t = f[w],
                        p = l[w];
                    a.set(n.GetU(), n.GetV(), t.GetU(), t.GetV(), p.GetU(), p.GetV(), u.GetU(), u.GetV());
                    d.Quad3D2(n.GetX(), n.GetY(), n.GetZElevation(), t.GetX(), t.GetY(), t.GetZElevation(), p.GetX(), p.GetY(), p.GetZElevation(), u.GetX(), u.GetY(), u.GetZElevation(), a);
                    n = t;
                    u = p
                }
                f = l
            }
        }
        Outline(d,
            c) {
            c || (c = (h, l, n) => [h, l, n]);
            const f = this._pts;
            let k = f[0];
            for (let h = 1, l = f.length; h < l; ++h) {
                const n = f[h];
                let u = k[0],
                    w = n[0];
                for (let q = 1, t = n.length; q < t; ++q) {
                    const p = k[q],
                        r = n[q],
                        [x, y, E] = c(u.GetX(), u.GetY(), u.GetZElevation()),
                        [G, A, F] = c(p.GetX(), p.GetY(), p.GetZElevation()),
                        [J, B, I] = c(r.GetX(), r.GetY(), r.GetZElevation()),
                        [L, P, S] = c(w.GetX(), w.GetY(), w.GetZElevation());
                    d.Line3D(x, y, E, G, A, F);
                    d.Line3D(x, y, E, J, B, I);
                    d.Line3D(x, y, E, L, P, S);
                    q === t - 1 && d.Line3D(G, A, F, J, B, I);
                    h === l - 1 && d.Line3D(L, P, S, J, B, I);
                    u = p;
                    w = r
                }
                k = n
            }
        }
        InsertPolyMeshVertices(d) {
            d =
                d.pointsArr();
            const c = [],
                f = this.GetHSize() - 1,
                k = this.GetVSize() - 1,
                h = 1 / f,
                l = 1 / k,
                n = f - 1,
                u = k - 1;
            let w = d[0],
                q = d[1],
                t = e.clamp(Math.floor(w * f), 0, n),
                p = e.clamp(Math.floor(q * k), 0, u),
                r = 0,
                x = 0,
                y = 0;
            var E = -1;
            const G = () => {
                w = e.clamp(e.lerp(w, r, y), 0, 1);
                q = e.clamp(e.lerp(q, x, y), 0, 1);
                c.push(w, q)
            };
            for (let A = 0, F = d.length; A < F; A += 2)
                for (w = d[A], q = d[A + 1], c.push(w, q), t = e.clamp(Math.floor(w * f), 0, n), p = e.clamp(Math.floor(q * k), 0, u), E = (A + 2) % F, r = d[E], x = d[E + 1], E = -1;;) {
                    if (1E6 < c.length) throw Error("Too many mesh poly points");
                    const J = t *
                        h,
                        B = p * l,
                        I = (t + 1) * h,
                        L = (p + 1) * l;
                    e.isPointInTriangleInclusive(w, q, J, B, I, B, I, L);
                    if (0 !== E && (y = e.rayIntersectExtended(w, q, r, x, J, B, I, L, -.001), 0 <= y && .99999999 >= y)) {
                        G();
                        E = 0;
                        continue
                    }
                    if (0 < p && 2 !== E && (y = e.rayIntersectExtended(w, q, r, x, J, B, I, B, .001), 0 <= y && .99999999 >= y)) {
                        G();
                        p--;
                        E = 4;
                        continue
                    }
                    if (t < n && 3 !== E && (y = e.rayIntersectExtended(w, q, r, x, I, B, I, L, .001), 0 <= y && .99999999 >= y)) {
                        G();
                        t++;
                        E = 1;
                        continue
                    }
                    if (0 < t && 1 !== E && (y = e.rayIntersectExtended(w, q, r, x, J, B, J, L, .001), 0 <= y && .99999999 >= y)) {
                        G();
                        t--;
                        E = 3;
                        continue
                    }
                    if (p < u && 4 !== E &&
                        (y = e.rayIntersectExtended(w, q, r, x, J, L, I, L, .001), 0 <= y && .99999999 >= y)) {
                        G();
                        p++;
                        E = 2;
                        continue
                    }
                    break
                }
            return e.New(e.CollisionPoly, c)
        }
        TransformCollisionPoly(d, c) {
            d = this._TransformPolyPoints(d);
            this._SimplifyPoly(d);
            c.setPoints(d)
        }
        _TransformPolyPoints(d) {
            const c = [];
            d = d.pointsArr();
            for (let f = 0, k = d.length; f < k; f += 2) {
                const [h, l] = this.TransformPoint(d[f], d[f + 1]);
                c.push(h, l)
            }
            return c
        }
        TransformPoint(d, c) {
            var f = this.GetHSize() - 1,
                k = this.GetVSize() - 1,
                h = 1 / f,
                l = 1 / k;
            f = e.clamp(Math.floor(d * f), 0, f - 1);
            const n = e.clamp(Math.floor(c *
                k), 0, k - 1);
            k = f * h;
            const u = n * l,
                w = (f + 1) * h,
                q = (n + 1) * l,
                t = this.GetMeshPointAt(f, n),
                p = this.GetMeshPointAt(f + 1, n + 1),
                r = e.isPointInTriangleInclusive(d, c, k, u, w, u, w, q);
            h = r ? k + h : k;
            l = r ? u : u + l;
            f = this.GetMeshPointAt(f + (r ? 1 : 0), n + (r ? 0 : 1));
            const [x, y, E] = e.triangleCartesianToBarycentric(d, c, k, u, h, l, w, q);
            return e.triangleBarycentricToCartesian(x, y, E, t.GetX(), t.GetY(), f.GetX(), f.GetY(), p.GetX(), p.GetY())
        }
        _SimplifyPoly(d) {
            const c = [];
            let f = d[0],
                k = d[1],
                h = f - d.at(-2),
                l = k - d.at(-1);
            for (let u = 0, w = d.length; u < w; u += 2) {
                var n = (u + 2) % w;
                const q = d[n];
                n = d[n + 1];
                const t = q - f,
                    p = n - k,
                    r = 1E-7 > Math.abs(p) && 1E-7 > Math.abs(l) && Math.sign(t) === Math.sign(h);
                (!(1E-7 > Math.abs(t) && 1E-7 > Math.abs(h) && Math.sign(p) === Math.sign(l) || r) && 1E-7 < Math.abs(t / h - p / l) || 0 == t && 0 === p) && c.push(f, k);
                f = q;
                k = n;
                h = t;
                l = p
            }
            6 <= c.length && c.length < d.length && e.shallowAssignArray(d, c)
        }
        SaveToJson() {
            return {
                cols: this.GetHSize(),
                rows: this.GetVSize(),
                points: this._pts.map(d => d.map(c => c.SaveToJson()))
            }
        }
        LoadFromJson(d) {
            const c = this.GetHSize(),
                f = this.GetVSize();
            if (d.cols !== c || d.rows !== f) throw Error("mesh data wrong size");
            d = d.points;
            for (let k = 0; k < f; ++k) {
                const h = d[k];
                for (let l = 0; l < c; ++l) this.GetMeshPointAt(l, k).LoadFromJson(h[l])
            }
        }
    }
} {
    "use strict";
    const e = self.C3,
        a = new Set(["rgba8", "rgb8", "rgba4", "rgb5_a1", "rgb565"]),
        b = new Set(["nearest", "bilinear", "trilinear"]),
        d = new Set(["default", "low", "high"]),
        c = new Set(["clamp-to-edge", "repeat", "mirror-repeat"]);

    function f(n, u) {
        let w, q;
        switch (n) {
            case "rgba8":
                n = u.RGBA8;
                q = w = u.RGBA;
                u = u.UNSIGNED_BYTE;
                break;
            case "rgb8":
                n = u.RGB8;
                q = w = u.RGB;
                u = u.UNSIGNED_BYTE;
                break;
            case "rgba4":
                n = u.RGBA4;
                q = w = u.RGBA;
                u = u.UNSIGNED_SHORT_4_4_4_4;
                break;
            case "rgb5_a1":
                n = u.RGB5_A1;
                q = w = u.RGBA;
                u = u.UNSIGNED_SHORT_5_5_5_1;
                break;
            case "rgb565":
                n = u.RGB565;
                q = w = u.RGB;
                u = u.UNSIGNED_SHORT_5_6_5;
                break;
            default:
                throw Error("invalid pixel format");
        }
        return {
            sizedinternalformat: n,
            internalformat: w,
            format: q,
            type: u
        }
    }
    const k = {
            wrapX: "clamp-to-edge",
            wrapY: "clamp-to-edge",
            sampling: "trilinear",
            anisotropy: 0,
            pixelFormat: "rgba8",
            mipMap: !0,
            mipMapQuality: "default",
            premultiplyAlpha: !0,
            isSvg: !1,
            width: -1,
            height: -1
        },
        h = {
            premultiplyAlpha: !0,
            flipY: !1
        },
        l = new Set;
    e.Gfx.WebGLRendererTexture = class {
        constructor(n) {
            this._renderer = n;
            this._texture = null;
            this._height =
                this._width = 0;
            this._isStatic = !0;
            this._wrapY = this._wrapX = "clamp-to-edge";
            this._sampling = "trilinear";
            this._anisotropy = 0;
            this._pixelFormat = "rgba8";
            this._isMipMapped = !1;
            this._mipMapQuality = "default";
            this._refCount = 0
        }
        _CreateStatic(n, u) {
            if (!("undefined" !== typeof HTMLImageElement && n instanceof HTMLImageElement || "undefined" !== typeof HTMLCanvasElement && n instanceof HTMLCanvasElement || "undefined" !== typeof ImageBitmap && n instanceof ImageBitmap || "undefined" !== typeof OffscreenCanvas && n instanceof OffscreenCanvas ||
                    n instanceof ImageData || n instanceof ArrayBuffer) && null !== n) throw Error("invalid texture source");
            u = Object.assign({}, k, u);
            if (this._texture) throw Error("already created texture");
            this._wrapX = u.wrapX;
            this._wrapY = u.wrapY;
            this._sampling = u.sampling;
            this._anisotropy = u.anisotropy;
            this._pixelFormat = u.pixelFormat;
            this._isMipMapped = !!u.mipMap && this._renderer.AreMipmapsEnabled();
            this._mipMapQuality = u.mipMapQuality;
            if (!c.has(this._wrapX) || !c.has(this._wrapY)) throw Error("invalid wrap mode");
            if (!b.has(this._sampling)) throw Error("invalid sampling");
            if (!a.has(this._pixelFormat)) throw Error("invalid pixel format");
            if (!d.has(this._mipMapQuality)) throw Error("invalid mipmap quality");
            this._isStatic = !0;
            if (n instanceof ArrayBuffer || null === n || u.isSvg) {
                if (this._width = u.width, this._height = u.height, n instanceof ArrayBuffer && n.byteLength !== this._width * this._height * 4) throw Error("ArrayBuffer wrong size");
            } else this._width = n.width, this._height = n.height;
            if (0 >= this._width || 0 >= this._height) throw Error("invalid texture data size");
            if (u.isSvg) {
                var w = e.CreateCanvas(this._width,
                    this._height);
                w.getContext("2d").drawImage(n, 0, 0, this._width, this._height);
                n = w
            }
            var q = e.isPOT(this._width) && e.isPOT(this._height);
            w = this._renderer.GetMaxTextureSize();
            if (this._width > w || this._height > w) throw Error("texture data exceeds maximum texture size");
            w = this._renderer.GetContext();
            var t = this._renderer.GetWebGLVersionNumber();
            this._texture = w.createTexture();
            w.bindTexture(w.TEXTURE_2D, this._texture);
            w.pixelStorei(w.UNPACK_PREMULTIPLY_ALPHA_WEBGL, u.premultiplyAlpha);
            w.pixelStorei(w.UNPACK_FLIP_Y_WEBGL,
                !1);
            u = f(this._pixelFormat, w);
            if (this._renderer.SupportsNPOTTextures() || q || !this._IsTiled()) 2 <= t ? (w.texStorage2D(w.TEXTURE_2D, this._isMipMapped ? Math.floor(Math.log2(Math.max(this._width, this._height)) + 1) : 1, u.sizedinternalformat, this._width, this._height), n instanceof ArrayBuffer ? w.texSubImage2D(w.TEXTURE_2D, 0, 0, 0, this._width, this._height, u.format, u.type, new Uint8Array(n)) : null !== n && w.texSubImage2D(w.TEXTURE_2D, 0, 0, 0, u.format, u.type, n)) : n instanceof ArrayBuffer ? w.texImage2D(w.TEXTURE_2D, 0, u.internalformat,
                this._width, this._height, 0, u.format, u.type, new Uint8Array(n)) : null === n ? w.texImage2D(w.TEXTURE_2D, 0, u.internalformat, this._width, this._height, 0, u.format, u.type, null) : w.texImage2D(w.TEXTURE_2D, 0, u.internalformat, u.format, u.type, n);
            else {
                if (null === n) throw Error("cannot pass null data when creating a NPOT tiled texture without NPOT support");
                n instanceof ArrayBuffer && (n = new ImageData(new Uint8ClampedArray(n), this._width, this._height));
                n instanceof ImageData && (q = e.CreateCanvas(this._width, this._height),
                    q.getContext("2d").putImageData(n, 0, 0), n = q);
                q = e.CreateCanvas(e.nextHighestPowerOfTwo(this._width), e.nextHighestPowerOfTwo(this._height));
                t = q.getContext("2d");
                t.imageSmoothingEnabled = "nearest" !== this._sampling;
                t.drawImage(n, 0, 0, this._width, this._height, 0, 0, q.width, q.height);
                w.texImage2D(w.TEXTURE_2D, 0, u.internalformat, u.format, u.type, q)
            }
            null !== n && this._SetTextureParameters(w);
            w.bindTexture(w.TEXTURE_2D, null);
            this._renderer._ResetLastTexture();
            this._refCount = 1;
            l.add(this)
        }
        _CreateDynamic(n, u, w) {
            w = Object.assign({},
                k, w);
            if (this._texture) throw Error("already created texture");
            this._wrapX = w.wrapX;
            this._wrapY = w.wrapY;
            this._sampling = w.sampling;
            this._pixelFormat = w.pixelFormat;
            this._isMipMapped = !!w.mipMap && this._renderer.AreMipmapsEnabled();
            this._mipMapQuality = w.mipMapQuality;
            if (!c.has(this._wrapX) || !c.has(this._wrapY)) throw Error("invalid wrap mode");
            if (!b.has(this._sampling)) throw Error("invalid sampling");
            if (!a.has(this._pixelFormat)) throw Error("invalid pixel format");
            if (!d.has(this._mipMapQuality)) throw Error("invalid mipmap quality");
            this._isStatic = !1;
            this._width = Math.floor(n);
            this._height = Math.floor(u);
            n = e.isPOT(this._width) && e.isPOT(this._height);
            u = this._renderer.GetMaxTextureSize();
            if (0 >= this._width || 0 >= this._height) throw Error("invalid texture size");
            if (this._width > u || this._height > u) throw Error("texture exceeds maximum texture size");
            if (!this._renderer.SupportsNPOTTextures() && this._IsTiled() && !n) throw Error("non-power-of-two tiled textures not supported");
            n = this._renderer.GetContext();
            u = this._renderer.GetWebGLVersionNumber();
            this._texture = n.createTexture();
            n.bindTexture(n.TEXTURE_2D, this._texture);
            n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, w.premultiplyAlpha);
            n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, !1);
            w = f(this._pixelFormat, n);
            n.texImage2D(n.TEXTURE_2D, 0, 2 <= u ? w.sizedinternalformat : w.internalformat, this._width, this._height, 0, w.format, w.type, null);
            this._SetTextureParameters(n);
            n.bindTexture(n.TEXTURE_2D, null);
            this._renderer._ResetLastTexture();
            this._refCount = 1;
            l.add(this)
        }
        _GetMipMapHint(n) {
            if ("default" === this._mipMapQuality) return this._isStatic ?
                n.NICEST : n.FASTEST;
            if ("low" === this._mipMapQuality) return n.FASTEST;
            if ("high" === this._mipMapQuality) return n.NICEST;
            throw Error("invalid mipmap quality");
        }
        _IsTiled() {
            return "clamp-to-edge" !== this._wrapX || "clamp-to-edge" !== this._wrapY
        }
        _GetTextureWrapMode(n, u) {
            if ("clamp-to-edge" === u) return n.CLAMP_TO_EDGE;
            if ("repeat" === u) return n.REPEAT;
            if ("mirror-repeat" === u) return n.MIRRORED_REPEAT;
            throw Error("invalid wrap mode");
        }
        _SetTextureParameters(n) {
            var u = e.isPOT(this._width) && e.isPOT(this._height);
            n.texParameteri(n.TEXTURE_2D,
                n.TEXTURE_WRAP_S, this._GetTextureWrapMode(n, this._wrapX));
            n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, this._GetTextureWrapMode(n, this._wrapY));
            "nearest" === this._sampling ? (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, n.NEAREST), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, n.NEAREST), this._isMipMapped = !1) : (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, n.LINEAR), (u || this._renderer.SupportsNPOTTextures()) && this._isMipMapped ? (n.hint(n.GENERATE_MIPMAP_HINT, this._GetMipMapHint(n)), n.generateMipmap(n.TEXTURE_2D),
                u = "trilinear" === this._sampling && !this._renderer.HasMajorPerformanceCaveat(), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, u ? n.LINEAR_MIPMAP_LINEAR : n.LINEAR_MIPMAP_NEAREST)) : (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, n.LINEAR), this._isMipMapped = !1));
            (u = this._renderer._GetAnisotropicExtension()) && 0 < this._anisotropy && "nearest" !== this._sampling && n.texParameterf(n.TEXTURE_2D, u.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(this._anisotropy, this._renderer._GetMaxAnisotropy()))
        }
        _Update(n, u) {
            if (!("undefined" !==
                    typeof HTMLImageElement && n instanceof HTMLImageElement || "undefined" !== typeof HTMLVideoElement && n instanceof HTMLVideoElement || "undefined" !== typeof HTMLCanvasElement && n instanceof HTMLCanvasElement || "undefined" !== typeof ImageBitmap && n instanceof ImageBitmap || "undefined" !== typeof OffscreenCanvas && n instanceof OffscreenCanvas || n instanceof ImageData)) throw Error("invalid texture source");
            if (!this._texture || 0 >= this._refCount) throw Error("texture not created");
            if (this._isStatic) throw Error("cannot update static texture");
            u = Object.assign({}, h, u);
            const w = n.width || n.videoWidth,
                q = n.height || n.videoHeight;
            var t = this._renderer.GetWebGLVersionNumber();
            const p = this._renderer.GetContext();
            p.bindTexture(p.TEXTURE_2D, this._texture);
            p.pixelStorei(p.UNPACK_PREMULTIPLY_ALPHA_WEBGL, u.premultiplyAlpha);
            p.pixelStorei(p.UNPACK_FLIP_Y_WEBGL, !!u.flipY);
            u = f(this._pixelFormat, p);
            t = 2 <= t ? u.sizedinternalformat : u.internalformat;
            try {
                if (this._width === w && this._height === q) {
                    const r = e.isPOT(this._width) && e.isPOT(this._height);
                    p.texSubImage2D(p.TEXTURE_2D,
                        0, 0, 0, u.format, u.type, n);
                    (r || this._renderer.SupportsNPOTTextures()) && this._isMipMapped && (p.hint(p.GENERATE_MIPMAP_HINT, this._GetMipMapHint(p)), p.generateMipmap(p.TEXTURE_2D))
                } else {
                    this._width = w;
                    this._height = q;
                    const r = e.isPOT(this._width) && e.isPOT(this._height);
                    if (!this._renderer.SupportsNPOTTextures() && this._IsTiled() && !r) throw Error("non-power-of-two tiled textures not supported");
                    p.texImage2D(p.TEXTURE_2D, 0, t, u.format, u.type, n);
                    (r || this._renderer.SupportsNPOTTextures()) && this._isMipMapped && (p.hint(p.GENERATE_MIPMAP_HINT,
                        this._GetMipMapHint(p)), p.generateMipmap(p.TEXTURE_2D))
                }
            } catch (r) {
                console.error("Error updating WebGL texture: ", r)
            }
            p.bindTexture(p.TEXTURE_2D, null);
            this._renderer._ResetLastTexture()
        }
        _Delete() {
            if (0 < this._refCount) throw Error("texture still has references");
            if (!this._texture) throw Error("already deleted texture");
            l.delete(this);
            this._renderer.GetContext().deleteTexture(this._texture);
            this._texture = null
        }
        IsValid() {
            return !!this._texture
        }
        _GetTexture() {
            return this._texture
        }
        GetRenderer() {
            return this._renderer
        }
        AddReference() {
            this._refCount++
        }
        SubtractReference() {
            if (0 >=
                this._refCount) throw Error("no more references");
            this._refCount--
        }
        GetReferenceCount() {
            return this._refCount
        }
        GetWidth() {
            return this._width
        }
        GetHeight() {
            return this._height
        }
        IsStatic() {
            return this._isStatic
        }
        GetEstimatedMemoryUsage() {
            let n = this._width * this._height;
            switch (this._pixelFormat) {
                case "rgba8":
                    n *= 4;
                    break;
                case "rgb8":
                    n *= 3;
                    break;
                case "rgba4":
                case "rgb5_a1":
                case "rgb565":
                    n *= 2
            }
            this._isMipMapped && (n += Math.floor(n / 3));
            return n
        }
        static OnContextLost() {
            l.clear()
        }
        static allTextures() {
            return l.values()
        }
    }
} {
    "use strict";
    const e = self.C3,
        a = self.glMatrix.mat4,
        b = new Set(["nearest", "bilinear", "trilinear"]),
        d = {
            sampling: "trilinear",
            alpha: !0,
            depth: !1,
            isSampled: !0,
            isDefaultSize: !0,
            multisampling: 0
        },
        c = new Set;
    e.Gfx.WebGLRenderTarget = class {
        constructor(f) {
            this._renderer = f;
            this._renderBuffer = this._texture = this._frameBufferNoDepth = this._frameBuffer = null;
            this._height = this._width = 0;
            this._isDefaultSize = !0;
            this._sampling = "trilinear";
            this._alpha = !0;
            this._depth = !1;
            this._isSampled = !0;
            this._multisampling = 0;
            this._projectionMatrix =
                a.create()
        }
        _Create(f, k, h) {
            h = Object.assign({}, d, h);
            const l = this._renderer.GetWebGLVersionNumber();
            if (this._texture || this._renderBuffer) throw Error("already created render target");
            this._sampling = h.sampling;
            this._alpha = !!h.alpha;
            this._depth = !!h.depth;
            this._isSampled = !!h.isSampled;
            this._isDefaultSize = !!h.isDefaultSize;
            this._multisampling = h.multisampling;
            if (!b.has(this._sampling)) throw Error("invalid sampling");
            if (0 < this._multisampling && (2 > l || this._isSampled)) throw Error("invalid use of multisampling");
            2 > l && (this._isSampled = !0);
            this._width = f;
            this._height = k;
            if (0 >= this._width || 0 >= this._height) throw Error("invalid render target size");
            this._CalculateProjection();
            f = this._renderer.GetContext();
            this._frameBuffer = f.createFramebuffer();
            this._depth && (this._frameBufferNoDepth = f.createFramebuffer());
            this._isSampled ? (this._texture = this._renderer.CreateDynamicTexture(this._width, this._height, {
                sampling: this._sampling,
                pixelFormat: this._alpha ? "rgba8" : "rgb8",
                mipMap: !1
            }), k = this._texture._GetTexture(), f.bindFramebuffer(f.FRAMEBUFFER,
                this._frameBuffer), f.framebufferTexture2D(f.FRAMEBUFFER, f.COLOR_ATTACHMENT0, f.TEXTURE_2D, k, 0), this._depth && (f.bindFramebuffer(f.FRAMEBUFFER, this._frameBufferNoDepth), f.framebufferTexture2D(f.FRAMEBUFFER, f.COLOR_ATTACHMENT0, f.TEXTURE_2D, k, 0))) : (this._renderBuffer = f.createRenderbuffer(), f.bindRenderbuffer(f.RENDERBUFFER, this._renderBuffer), k = this._alpha ? f.RGBA8 : f.RGB8, 0 < this._multisampling && ((h = f.getInternalformatParameter(f.RENDERBUFFER, k, f.SAMPLES)) && h[0] ? (h = h[0], this._multisampling > h && (this._multisampling =
                h)) : this._multisampling = 0), 0 === this._multisampling ? f.renderbufferStorage(f.RENDERBUFFER, k, this._width, this._height) : f.renderbufferStorageMultisample(f.RENDERBUFFER, this._multisampling, k, this._width, this._height), f.bindFramebuffer(f.FRAMEBUFFER, this._frameBuffer), f.framebufferRenderbuffer(f.FRAMEBUFFER, f.COLOR_ATTACHMENT0, f.RENDERBUFFER, this._renderBuffer), this._depth && (f.bindFramebuffer(f.FRAMEBUFFER, this._frameBufferNoDepth), f.framebufferRenderbuffer(f.FRAMEBUFFER, f.COLOR_ATTACHMENT0, f.RENDERBUFFER,
                this._renderBuffer)), f.bindRenderbuffer(f.RENDERBUFFER, null));
            k = this._renderer._GetDepthBuffer();
            this._depth && k && (f.bindFramebuffer(f.FRAMEBUFFER, this._frameBuffer), this._renderer._CanSampleDepth() ? f.framebufferTexture2D(f.FRAMEBUFFER, f.DEPTH_STENCIL_ATTACHMENT, f.TEXTURE_2D, k, 0) : f.framebufferRenderbuffer(f.FRAMEBUFFER, f.DEPTH_STENCIL_ATTACHMENT, f.RENDERBUFFER, k));
            f.bindFramebuffer(f.FRAMEBUFFER, null);
            c.add(this)
        }
        _Resize(f, k) {
            if (this._width !== f || this._height !== k) this._width = f, this._height = k, this._CalculateProjection(),
                f = this._renderer.GetContext(), f.bindFramebuffer(f.FRAMEBUFFER, this._frameBuffer), this._texture ? this._texture._Update(new ImageData(this._width, this._height)) : (f.bindRenderbuffer(f.RENDERBUFFER, this._renderBuffer), f.renderbufferStorage(f.RENDERBUFFER, this._alpha ? f.RGBA8 : f.RGB8, this._width, this._height), f.bindRenderbuffer(f.RENDERBUFFER, null)), k = this._renderer._GetDepthBuffer(), this._depth && k && (this._renderer._CanSampleDepth() ? f.framebufferTexture2D(f.FRAMEBUFFER, f.DEPTH_STENCIL_ATTACHMENT, f.TEXTURE_2D,
                    k, 0) : f.framebufferRenderbuffer(f.FRAMEBUFFER, f.DEPTH_STENCIL_ATTACHMENT, f.RENDERBUFFER, k)), f.bindFramebuffer(f.FRAMEBUFFER, null)
        }
        _Delete() {
            if (!this._texture && !this._renderBuffer) throw Error("already deleted render target");
            c.delete(this);
            var f = this._renderer.GetContext();
            this._texture ? (f.bindFramebuffer(f.FRAMEBUFFER, this._frameBuffer), f.framebufferTexture2D(f.FRAMEBUFFER, f.COLOR_ATTACHMENT0, f.TEXTURE_2D, null, 0), this._depth && (f.bindFramebuffer(f.FRAMEBUFFER, this._frameBufferNoDepth), f.framebufferTexture2D(f.FRAMEBUFFER,
                f.COLOR_ATTACHMENT0, f.TEXTURE_2D, null, 0)), this._renderer.DeleteTexture(this._texture), this._texture = null) : this._renderBuffer && (f.bindFramebuffer(f.FRAMEBUFFER, this._frameBuffer), f.framebufferRenderbuffer(f.FRAMEBUFFER, f.COLOR_ATTACHMENT0, f.RENDERBUFFER, null), this._depth && (f.bindFramebuffer(f.FRAMEBUFFER, this._frameBufferNoDepth), f.framebufferRenderbuffer(f.FRAMEBUFFER, f.COLOR_ATTACHMENT0, f.RENDERBUFFER, null)), f.deleteRenderbuffer(this._renderBuffer), this._renderBuffer = null);
            f.bindFramebuffer(f.FRAMEBUFFER,
                null);
            2 <= this._renderer.GetWebGLVersionNumber() && (f.bindFramebuffer(f.READ_FRAMEBUFFER, null), f.bindFramebuffer(f.DRAW_FRAMEBUFFER, null));
            f.deleteFramebuffer(this._frameBuffer);
            this._depth && f.deleteFramebuffer(this._frameBufferNoDepth);
            f = this._renderer.GetBatchState();
            f.currentFramebuffer = null;
            this._frameBuffer = f.currentFramebufferNoDepth = null
        }
        _CalculateProjection() {
            this._renderer.CalculatePerspectiveMatrix(this._projectionMatrix, this._width / this._height)
        }
        _GetFramebuffer() {
            return this._frameBuffer
        }
        _GetFramebufferNoDepth() {
            return this._frameBufferNoDepth
        }
        GetRenderer() {
            return this._renderer
        }
        GetTexture() {
            return this._texture
        }
        GetProjectionMatrix() {
            return this._projectionMatrix
        }
        IsLinearSampling() {
            return "nearest" !==
                this._sampling
        }
        HasAlpha() {
            return this._alpha
        }
        IsSampled() {
            return this._isSampled
        }
        HasDepthBuffer() {
            return this._depth
        }
        GetWidth() {
            return this._width
        }
        GetHeight() {
            return this._height
        }
        IsDefaultSize() {
            return this._isDefaultSize
        }
        GetMultisampling() {
            return this._multisampling
        }
        GetOptions() {
            const f = {
                sampling: this._sampling,
                alpha: this._alpha,
                isSampled: this._isSampled
            };
            this._isDefaultSize || (f.width = this._width, f.height = this._height);
            return f
        }
        IsCompatibleWithOptions(f) {
            f = Object.assign({}, d, f);
            return "nearest" !==
                f.sampling !== this.IsLinearSampling() || !!f.alpha !== this.HasAlpha() || !!f.depth !== this.HasDepthBuffer() || 2 <= this._renderer.GetWebGLVersionNumber() && !!f.isSampled !== this.IsSampled() ? !1 : "number" === typeof f.width || "number" === typeof f.height ? !this.IsDefaultSize() && this.GetWidth() === f.width && this.GetHeight() === f.height : this.IsDefaultSize()
        }
        _GetWebGLTexture() {
            return this._texture ? this._texture._GetTexture() : null
        }
        GetEstimatedMemoryUsage() {
            return this._texture ? this._texture.GetEstimatedMemoryUsage() : this._width *
                this._height * (this._alpha ? 4 : 3)
        }
        static async DebugReadPixelsToBlob(f, k) {
            f = await f.ReadBackRenderTargetToImageData(k, !0);
            return await e.ImageDataToBlob(f)
        }
        static OnContextLost() {
            c.clear()
        }
        static allRenderTargets() {
            return c.values()
        }
        static ResizeAll(f, k) {
            for (const h of c) h.IsDefaultSize() && h._Resize(f, k)
        }
    }
} {
    "use strict";
    const e = self.C3,
        a = new Set("aPos aTex aPoints matP matMV samplerFront samplerBack samplerDepth destStart destEnd srcStart srcEnd srcOriginStart srcOriginEnd pixelSize seconds devicePixelRatio layerScale layerAngle layoutStart layoutEnd color color2_ pointTexStart pointTexEnd zElevation tileSize tileSpacing outlineThickness".split(" "));
    e.Gfx.WebGLShaderProgram = class extends e.Gfx.ShaderProgramBase {
        static async Compile(b, d, c, f) {
            const k = b.GetContext(),
                h = k.createShader(k.FRAGMENT_SHADER);
            k.shaderSource(h, d);
            k.compileShader(h);
            d = k.createShader(k.VERTEX_SHADER);
            k.shaderSource(d, c);
            k.compileShader(d);
            const l = k.createProgram();
            k.attachShader(l, h);
            k.attachShader(l, d);
            k.bindAttribLocation(l, 0, "aPos");
            k.bindAttribLocation(l, 1, "aTex");
            k.bindAttribLocation(l, 2, "aPoints");
            k.linkProgram(l);
            const n = b._GetParallelShaderCompileExtension();
            n ? await b._WaitForObjectReady(() => k.getProgramParameter(l, n.COMPLETION_STATUS_KHR)) : await e.Wait(5);
            if (!k.getShaderParameter(h, k.COMPILE_STATUS)) throw f = k.getShaderInfoLog(h),
                k.deleteShader(h), k.deleteShader(d), k.deleteProgram(l), Error("Error compiling fragment shader: " + f);
            if (!k.getShaderParameter(d, k.COMPILE_STATUS)) throw f = k.getShaderInfoLog(d), k.deleteShader(h), k.deleteShader(d), k.deleteProgram(l), Error("Error compiling vertex shader: " + f);
            if (!k.getProgramParameter(l, k.LINK_STATUS)) throw f = k.getProgramInfoLog(l), k.deleteShader(h), k.deleteShader(d), k.deleteProgram(l), Error("Error linking shader program: " + f);
            (b = e.FilterUnprintableChars(k.getProgramInfoLog(l) || "").trim()) &&
            !e.IsStringAllWhitespace(b) && console.info(`[WebGL] Shader program '${f}' compilation log: `, b);
            k.deleteShader(h);
            k.deleteShader(d);
            return l
        }
        static async Create(b, d, c, f) {
            c = await e.Gfx.WebGLShaderProgram.Compile(b, d.src, c, f);
            return new e.Gfx.WebGLShaderProgram(b, c, d, f)
        }
        constructor(b, d, c, f) {
            super(b, f, c);
            const k = b.GetContext();
            var h = b.GetBatchState();
            b.EndBatch();
            k.useProgram(d);
            this._gl = k;
            this._shaderProgram = d;
            this._isDeviceTransform = "<default-device-transform>" === f;
            f = k.getAttribLocation(d, "aPos");
            const l =
                k.getAttribLocation(d, "aTex");
            this._locAPoints = k.getAttribLocation(d, "aPoints"); - 1 !== f && (k.bindBuffer(k.ARRAY_BUFFER, b._vertexBuffer), k.vertexAttribPointer(f, b.GetNumVertexComponents(), k.FLOAT, !1, 0, 0), k.enableVertexAttribArray(f)); - 1 !== l && (k.bindBuffer(k.ARRAY_BUFFER, b._texcoordBuffer), k.vertexAttribPointer(l, 2, k.FLOAT, !1, 0, 0), k.enableVertexAttribArray(l)); - 1 !== this._locAPoints && (k.bindBuffer(k.ARRAY_BUFFER, b._pointBuffer), k.vertexAttribPointer(this._locAPoints, 4, k.FLOAT, !1, 0, 0), k.enableVertexAttribArray(this._locAPoints));
            k.bindBuffer(k.ARRAY_BUFFER, null);
            this._uMatP = new e.Gfx.WebGLShaderUniform(this, "matP", "mat4");
            this._uMatMV = new e.Gfx.WebGLShaderUniform(this, "matMV", "mat4");
            this._uColor = new e.Gfx.WebGLShaderUniform(this, "color", "vec4");
            this._uSamplerFront = new e.Gfx.WebGLShaderUniform(this, "samplerFront", "sampler");
            this._uPointTexStart = new e.Gfx.WebGLShaderUniform(this, "pointTexStart", "vec2");
            this._uPointTexEnd = new e.Gfx.WebGLShaderUniform(this, "pointTexEnd", "vec2");
            this._uZElevation = new e.Gfx.WebGLShaderUniform(this,
                "zElevation", "float");
            this._uTileSize = new e.Gfx.WebGLShaderUniform(this, "tileSize", "vec2");
            this._uTileSpacing = new e.Gfx.WebGLShaderUniform(this, "tileSpacing", "vec2");
            this._uColor2 = new e.Gfx.WebGLShaderUniform(this, "color2_", "vec4");
            this._uOutlineThickness = new e.Gfx.WebGLShaderUniform(this, "outlineThickness", "float");
            this._uSamplerBack = new e.Gfx.WebGLShaderUniform(this, "samplerBack", "sampler");
            this._uSamplerDepth = new e.Gfx.WebGLShaderUniform(this, "samplerDepth", "sampler");
            this._uDestStart = new e.Gfx.WebGLShaderUniform(this,
                "destStart", "vec2");
            this._uDestEnd = new e.Gfx.WebGLShaderUniform(this, "destEnd", "vec2");
            this._uSrcStart = new e.Gfx.WebGLShaderUniform(this, "srcStart", "vec2");
            this._uSrcEnd = new e.Gfx.WebGLShaderUniform(this, "srcEnd", "vec2");
            this._uSrcOriginStart = new e.Gfx.WebGLShaderUniform(this, "srcOriginStart", "vec2");
            this._uSrcOriginEnd = new e.Gfx.WebGLShaderUniform(this, "srcOriginEnd", "vec2");
            this._uPixelSize = new e.Gfx.WebGLShaderUniform(this, "pixelSize", "vec2");
            this._uSeconds = new e.Gfx.WebGLShaderUniform(this, "seconds",
                "float");
            this._uDevicePixelRatio = new e.Gfx.WebGLShaderUniform(this, "devicePixelRatio", "float");
            this._uLayerScale = new e.Gfx.WebGLShaderUniform(this, "layerScale", "float");
            this._uLayerAngle = new e.Gfx.WebGLShaderUniform(this, "layerAngle", "float");
            this._uLayoutStart = new e.Gfx.WebGLShaderUniform(this, "layoutStart", "vec2");
            this._uLayoutEnd = new e.Gfx.WebGLShaderUniform(this, "layoutEnd", "vec2");
            this._hasAnyOptionalUniforms = !!(this._uPixelSize.IsUsed() || this._uSeconds.IsUsed() || this._uSamplerBack.IsUsed() ||
                this._uDestStart.IsUsed() || this._uDestEnd.IsUsed() || this._uSrcStart.IsUsed() || this._uSrcEnd.IsUsed() || this._uSrcOriginStart.IsUsed() || this._uSrcOriginEnd.IsUsed() || this._uDevicePixelRatio.IsUsed() || this._uLayerScale.IsUsed() || this._uLayerAngle.IsUsed() || this._uLayoutStart.IsUsed() || this._uLayoutEnd.IsUsed());
            b = c.parameters || [];
            this._uCustomParameters = [];
            this._usesAnySrcRectOrPixelSize = this._uPixelSize.IsUsed() || this._uSrcStart.IsUsed() || this._uSrcEnd.IsUsed() || this._uSrcOriginStart.IsUsed() || this._uSrcOriginEnd.IsUsed();
            this._hasCurrentMatMV = this._hasCurrentMatP = !1;
            this._uColor.Init4f(1, 1, 1, 1);
            this._uColor2.Init4f(1, 1, 1, 1);
            this._uSamplerFront.Init1i(0);
            this._uSamplerBack.Init1i(1);
            this._uSamplerDepth.Init1i(2);
            this._uPointTexStart.Init2f(0, 0);
            this._uPointTexEnd.Init2f(1, 1);
            this._uZElevation.Init1f(0);
            this._uTileSize.Init2f(0, 0);
            this._uTileSpacing.Init2f(0, 0);
            this._uDestStart.Init2f(0, 0);
            this._uDestEnd.Init2f(1, 1);
            this._uSrcStart.Init2f(0, 0);
            this._uSrcEnd.Init2f(0, 0);
            this._uSrcOriginStart.Init2f(0, 0);
            this._uSrcOriginEnd.Init2f(0,
                0);
            this._uPixelSize.Init2f(0, 0);
            this._uDevicePixelRatio.Init1f(1);
            this._uLayerScale.Init1f(1);
            this._uLayerAngle.Init1f(0);
            this._uSeconds.Init1f(0);
            this._uLayoutStart.Init2f(0, 0);
            this._uLayoutEnd.Init2f(0, 0);
            this._uOutlineThickness.Init1f(1);
            for (const n of b) b = n[2], d = new e.Gfx.WebGLShaderUniform(this, n[0], b), "color" === b ? d.Init3f(0, 0, 0) : d.Init1f(0), this._uCustomParameters.push(d);
            this._isDeviceTransform ? this._UpdateDeviceTransformUniforms(h.currentMatP) : (this.UpdateMatP(h.currentMatP, !0), this.UpdateMatMV(h.currentMV,
                !0));
            h = h.currentShader;
            k.useProgram(h ? h._shaderProgram : null)
        }
        Release() {
            this._gl.deleteProgram(this._shaderProgram);
            this._shaderProgram = null;
            this._renderer._RemoveShaderProgram(this);
            this._gl = null;
            super.Release()
        }
        GetWebGLContext() {
            return this._gl
        }
        GetShaderProgram() {
            return this._shaderProgram
        }
        GetParameterCount() {
            return this._uCustomParameters.length
        }
        GetParameterType(b) {
            return this._uCustomParameters[b].GetType()
        }
        AreCustomParametersAlreadySetInBatch(b) {
            for (let d = 0, c = b.length; d < c; ++d)
                if (!this._uCustomParameters[d].IsSetToCustomInBatch(b[d])) return !1;
            return !0
        }
        SetCustomParametersInBatch(b) {
            for (let d = 0, c = b.length; d < c; ++d) this._uCustomParameters[d].SetBatchValueCustom(b[d])
        }
        AreOptionalUniformsAlreadySetInBatch(b, d, c, f, k, h, l, n, u, w) {
            return this._uSamplerBack.IsUsed() || this._uPixelSize.IsUsed() && !this._uPixelSize.IsSetTo2InBatch(k, h) || this._uDestStart.IsUsed() && !this._uDestStart.IsSetTo2InBatch(b.getLeft(), b.getTop()) || this._uDestEnd.IsUsed() && !this._uDestEnd.IsSetTo2InBatch(b.getRight(), b.getBottom()) || this._uDevicePixelRatio.IsUsed() && !this._uDevicePixelRatio.IsSetTo1InBatch(l) ||
                this._uLayerScale.IsUsed() && !this._uLayerScale.IsSetTo1InBatch(n) || this._uLayerAngle.IsUsed() && !this._uLayerAngle.IsSetTo1InBatch(u) || this._uSrcStart.IsUsed() && !this._uSrcStart.IsSetTo2InBatch(d.getLeft(), d.getTop()) || this._uSrcEnd.IsUsed() && !this._uSrcEnd.IsSetTo2InBatch(d.getRight(), d.getBottom()) || this._uSrcOriginStart.IsUsed() && !this._uSrcOriginStart.IsSetTo2InBatch(c.getLeft(), c.getTop()) || this._uSrcOriginEnd.IsUsed() && !this._uSrcOriginEnd.IsSetTo2InBatch(c.getRight(), c.getBottom()) || this._uLayoutStart.IsUsed() &&
                !this._uLayoutStart.IsSetTo2InBatch(f.getLeft(), f.getTop()) || this._uLayoutEnd.IsUsed() && !this._uLayoutEnd.IsSetTo2InBatch(f.getTop(), f.getBottom()) || this._uSeconds.IsUsed() && !this._uSeconds.IsSetTo1InBatch(w) ? !1 : !0
        }
        SetOptionalUniformsInBatch(b, d, c, f, k, h, l, n, u, w) {
            this._uSamplerBack.IsUsed() || (this._uPixelSize.IsUsed() && this._uPixelSize.SetBatch2(k, h), this._uDestStart.IsUsed() && this._uDestStart.SetBatch2(b.getLeft(), b.getTop()), this._uDestEnd.IsUsed() && this._uDestEnd.SetBatch2(b.getRight(), b.getBottom()),
                this._uDevicePixelRatio.IsUsed() && this._uDevicePixelRatio.SetBatch1(l), this._uLayerScale.IsUsed() && this._uLayerScale.SetBatch1(n), this._uLayerAngle.IsUsed() && this._uLayerAngle.SetBatch1(u), this._uSrcStart.IsUsed() && this._uSrcStart.SetBatch2(d.getLeft(), d.getTop()), this._uSrcEnd.IsUsed() && this._uSrcEnd.SetBatch2(d.getRight(), d.getBottom()), this._uSrcOriginStart.IsUsed() && this._uSrcOriginStart.SetBatch2(c.getLeft(), c.getTop()), this._uSrcOriginEnd.IsUsed() && this._uSrcOriginEnd.SetBatch2(c.getRight(),
                    c.getBottom()), this._uLayoutStart.IsUsed() && this._uLayoutStart.SetBatch2(f.getLeft(), f.getTop()), this._uLayoutEnd.IsUsed() && this._uLayoutEnd.SetBatch2(f.getTop(), f.getBottom()), this._uSeconds.IsUsed() && this._uSeconds.SetBatch1(w))
        }
        UpdateMatP(b, d) {
            this._hasCurrentMatP && !d || this._isDeviceTransform || (this._uMatP.IsUsed() && this._uMatP.UpdateMatrix4fv(b), this._hasCurrentMatP = !0)
        }
        SetMatPStale() {
            this._hasCurrentMatP = !1
        }
        UpdateMatMV(b, d) {
            this._hasCurrentMatMV && !d || this._isDeviceTransform || (this._uMatMV.IsUsed() &&
                this._uMatMV.UpdateMatrix4fv(b), this._hasCurrentMatMV = !0)
        }
        SetMatMVStale() {
            this._hasCurrentMatMV = !1
        }
        _UpdateDeviceTransformUniforms(b) {
            if (!this._isDeviceTransform) throw Error("not device transform shader");
            this._uMatP.UpdateMatrix4fv(b);
            b = this._renderer;
            const d = b.GetWidth() / 2,
                c = b.GetHeight() / 2;
            b = b.CalculateLookAtModelView2(d, c, b.GetDefaultCameraZ() * self.devicePixelRatio, d, c, 0);
            this._uMatMV.UpdateMatrix4fv(b)
        }
        UpdateColor(b) {
            this._uColor.IsUsed() && this._uColor.Update4f(b[0], b[1], b[2], b[3])
        }
        static GetReservedUniformNames() {
            return a
        }
        static GetDefaultVertexShaderSource(b) {
            b =
                b ? "highmedp" : "mediump";
            return ["#ifdef GL_FRAGMENT_PRECISION_HIGH\n#define highmedp highp\n#else\n#define highmedp mediump\n#endif\nattribute highp vec3 aPos;", `attribute ${b} vec2 aTex;`, `varying ${b} vec2 vTex;`, "uniform highp mat4 matP;\nuniform highp mat4 matMV;\nvoid main(void) {\n\tgl_Position = matP * matMV * vec4(aPos, 1.0);\n\tvTex = aTex;\n}"].join("\n")
        }
        static GetTextureFillFragmentShaderSource() {
            return "varying mediump vec2 vTex;\nuniform lowp vec4 color;\nuniform lowp sampler2D samplerFront;\nvoid main(void) {\n\tgl_FragColor = texture2D(samplerFront, vTex) * color;\n}"
        }
        static GetTilemapFragmentShaderSource() {
            return "#ifdef GL_FRAGMENT_PRECISION_HIGH\n#define highmedp highp\n#else\n#define highmedp mediump\n#endif\nvarying highmedp vec2 vTex;\nuniform lowp vec4 color;\nuniform lowp sampler2D samplerFront;\nuniform highmedp vec2 srcStart;\nuniform highmedp vec2 pixelSize;\nuniform highmedp vec2 tileSize;\nuniform highmedp vec2 tileSpacing;\nvoid main(void) {\n\thighmedp vec2 tile = floor(vTex);\n\thighmedp vec2 tex = fract(vTex);\n\thighmedp vec2 tileOrigin = srcStart + tile * (tileSize + tileSpacing);\n\thighmedp vec2 lowerBound = tileOrigin + pixelSize / 2.0;\n\thighmedp vec2 upperBound = tileOrigin + tileSize - pixelSize / 2.0;\n\tgl_FragColor = texture2D(samplerFront, clamp(tex, lowerBound, upperBound), -16.0) * color;\n}"
        }
        static GetPointVertexShaderSource(b) {
            return e.Gfx.WebGLShaderProgram.GetPointVertexShaderSource_WebGL1()
        }
        static GetPointFragmentShaderSource(b) {
            return e.Gfx.WebGLShaderProgram.GetPointFragmentShaderSource_WebGL1()
        }
        static GetPointVertexShaderSource_WebGL1() {
            return "attribute vec4 aPoints;\nvarying float pointOpacity;\nuniform float zElevation;\nuniform mat4 matP;\nuniform mat4 matMV;\nvoid main(void) {\n\tgl_Position = matP * matMV * vec4(aPoints.xy, zElevation, 1.0);\n\tgl_PointSize = aPoints.z;\n\tpointOpacity = aPoints.w;\n}"
        }
        static GetPointFragmentShaderSource_WebGL1() {
            return "uniform lowp sampler2D samplerFront;\nvarying lowp float pointOpacity;\nuniform mediump vec2 pointTexStart;\nuniform mediump vec2 pointTexEnd;\nuniform lowp vec4 color;\nvoid main(void) {\n\tgl_FragColor = texture2D(samplerFront, mix(pointTexStart, pointTexEnd, gl_PointCoord)) * color * pointOpacity;\n}"
        }
        static GetColorFillFragmentShaderSource() {
            return "uniform lowp vec4 color;\nvoid main(void) {\n\tgl_FragColor = color;\n}"
        }
        static GetLinearGradientFillFragmentShaderSource() {
            return "precision lowp float;\nvarying mediump vec2 vTex;\nuniform vec4 color;\nuniform vec4 color2_;\nvec3 fromLinear(vec3 linearRGB)\n{\n\tbvec3 cutoff = lessThan(linearRGB, vec3(0.0031308));\n\tvec3 higher = vec3(1.055) * pow(abs(linearRGB), vec3(1.0/2.4)) - vec3(0.055);\n\tvec3 lower = linearRGB * vec3(12.92);\n\treturn mix(higher, lower, vec3(cutoff));\n}\nvec3 toLinear(vec3 sRGB)\n{\n\tbvec3 cutoff = lessThan(sRGB, vec3(0.04045));\n\tvec3 higher = pow(abs((sRGB + vec3(0.055))/vec3(1.055)), vec3(2.4));\n\tvec3 lower = sRGB/vec3(12.92);\n\treturn mix(higher, lower, vec3(cutoff));\n}\nvoid main(void) {\n\tvec3 linearGrad = mix(toLinear(color.rgb), toLinear(color2_.rgb), vTex.x);\n\tfloat a = mix(color.a, color2_.a, vTex.x);\n\tgl_FragColor = vec4(fromLinear(linearGrad) * a, a);\n}"
        }
        static GetSmoothLineFillFragmentShaderSource() {
            return "varying mediump vec2 vTex;\nuniform lowp vec4 color;\nvoid main(void) {\n\tlowp float f = 1.0 - abs(vTex.y - 0.5) * 2.0;\n\tgl_FragColor = color * f;\n}"
        }
        static GetHardEllipseFillFragmentShaderSource() {
            return "varying mediump vec2 vTex;\nuniform lowp vec4 color;\nvoid main(void) {\n\tmediump vec2 diff = vTex - vec2(0.5, 0.5);\n\tmediump vec2 diffSq = diff * diff;\n\tmediump float f = step(diffSq.x + diffSq.y, 0.25);\n\tgl_FragColor = color * f;\n}"
        }
        static GetHardEllipseOutlineFragmentShaderSource() {
            return "varying mediump vec2 vTex;\nuniform lowp vec4 color;\nuniform mediump vec2 pixelSize;\nuniform mediump float outlineThickness;\nvoid main(void) {\n\tmediump vec2 diff = vTex - vec2(0.5, 0.5);\n\tmediump vec2 diffSq = diff * diff;\n\tmediump float distSq = diffSq.x + diffSq.y;\n\tmediump vec2 norm = normalize(diff);\n\tmediump vec2 halfNorm = norm * 0.5;\n\tmediump float innerF = step(distSq, 0.25);\n\tmediump vec2 innerEdge = halfNorm - pixelSize * norm * outlineThickness;\n\tmediump vec2 innerEdgeSq = innerEdge * innerEdge;\n\tmediump float outerF = step(innerEdgeSq.x + innerEdgeSq.y, distSq);\n\tgl_FragColor = color * innerF * outerF;\n}"
        }
        static GetSmoothEllipseFillFragmentShaderSource() {
            return "varying mediump vec2 vTex;\nuniform lowp vec4 color;\nuniform mediump vec2 pixelSize;\nvoid main(void) {\n\tmediump vec2 diff = vTex - vec2(0.5, 0.5);\n\tmediump vec2 diffSq = diff * diff;\n\tmediump vec2 norm = normalize(diff);\n\tmediump vec2 halfNorm = norm * 0.5;\n\tmediump vec2 halfNormSq = halfNorm * halfNorm;\n\tmediump vec2 innerEdge = halfNorm - pixelSize * norm;\n\tmediump vec2 innerEdgeSq = innerEdge * innerEdge;\n\tmediump float f = smoothstep(halfNormSq.x + halfNormSq.y, innerEdgeSq.x + innerEdgeSq.y, diffSq.x + diffSq.y);\n\tgl_FragColor = color * f;\n}"
        }
        static GetSmoothEllipseOutlineFragmentShaderSource() {
            return "varying mediump vec2 vTex;\nuniform lowp vec4 color;\nuniform mediump vec2 pixelSize;\nuniform mediump float outlineThickness;\nvoid main(void) {\n\tmediump vec2 diff = vTex - vec2(0.5, 0.5);\n\tmediump vec2 diffSq = diff * diff;\n\tmediump float distSq = diffSq.x + diffSq.y;\n\tmediump vec2 norm = normalize(diff);\n\tmediump vec2 halfNorm = norm * 0.5;\n\tmediump vec2 halfNormSq = halfNorm * halfNorm;\n\tmediump vec2 pxNorm = pixelSize * norm;\n\tmediump vec2 innerEdge1 = halfNorm - pxNorm;\n\tmediump vec2 innerEdge1Sq = innerEdge1 * innerEdge1;\n\tmediump float innerF = smoothstep(halfNormSq.x + halfNormSq.y, innerEdge1Sq.x + innerEdge1Sq.y, distSq);\n\tmediump vec2 innerEdge2 = halfNorm - pxNorm * outlineThickness;\n\tmediump vec2 innerEdge2Sq = innerEdge2 * innerEdge2;\n\tmediump vec2 innerEdge3 = halfNorm - pxNorm * (outlineThickness + 1.0);\n\tmediump vec2 innerEdge3Sq = innerEdge3 * innerEdge3;\n\tmediump float outerF = smoothstep(innerEdge3Sq.x + innerEdge3Sq.y, innerEdge2Sq.x + innerEdge2Sq.y, distSq);\n\tgl_FragColor = color * innerF * outerF;\n}"
        }
    }
} {
    "use strict";
    const e = self.C3,
        a = self.glMatrix.mat4,
        b = new Map([
            ["float", 1],
            ["percent", 1],
            ["sampler", 1],
            ["vec2", 2],
            ["vec3", 3],
            ["color", 3],
            ["vec4", 4],
            ["mat4", 16]
        ]);
    e.Gfx.WebGLShaderUniform = class {
        constructor(d, c, f) {
            if (!b.has(f)) throw Error("invalid uniform type");
            this._owner = d;
            this._gl = this._owner.GetWebGLContext();
            this._name = c;
            this._type = f;
            this._isColorType = "color" === this._type;
            this._location = this._gl.getUniformLocation(this._owner.GetShaderProgram(), c);
            this._isUsed = !!this._location;
            d = b.get(f);
            this._lastValue =
                new Float32Array(d);
            this._lastBatchValue = new Float32Array(d)
        }
        Release() {
            this._location = this._gl = this._owner = null
        }
        IsUsed() {
            return this._isUsed
        }
        GetType() {
            return this._type
        }
        IsColorType() {
            return this._isColorType
        }
        Init1f(d) {
            this.IsUsed() && (this._lastValue[0] = d, this._lastBatchValue.set(this._lastValue), this._gl.uniform1f(this._location, d))
        }
        Init1i(d) {
            this.IsUsed() && (this._lastValue[0] = d, this._lastBatchValue.set(this._lastValue), this._gl.uniform1i(this._location, d))
        }
        Init2f(d, c) {
            this.IsUsed() && (this._lastValue[0] =
                d, this._lastValue[1] = c, this._lastBatchValue.set(this._lastValue), this._gl.uniform2f(this._location, d, c))
        }
        Init3f(d, c, f) {
            this.IsUsed() && (this._lastValue[0] = d, this._lastValue[1] = c, this._lastValue[2] = f, this._lastBatchValue.set(this._lastValue), this._gl.uniform3f(this._location, d, c, f))
        }
        Init4f(d, c, f, k) {
            this.IsUsed() && (this._lastValue[0] = d, this._lastValue[1] = c, this._lastValue[2] = f, this._lastValue[3] = k, this._lastBatchValue.set(this._lastValue), this._gl.uniform4f(this._location, d, c, f, k))
        }
        Update1f(d) {
            d = Math.fround(d);
            const c = this._lastValue;
            c[0] !== d && (c[0] = d, this._gl.uniform1f(this._location, d))
        }
        Update1i(d) {
            const c = this._lastValue;
            c[0] !== d && (c[0] = d, this._gl.uniform1i(this._location, d))
        }
        Update2f(d, c) {
            d = Math.fround(d);
            c = Math.fround(c);
            const f = this._lastValue;
            if (f[0] !== d || f[1] !== c) f[0] = d, f[1] = c, this._gl.uniform2f(this._location, d, c)
        }
        Update3f(d, c, f) {
            d = Math.fround(d);
            c = Math.fround(c);
            f = Math.fround(f);
            const k = this._lastValue;
            if (k[0] !== d || k[1] !== c || k[2] !== f) k[0] = d, k[1] = c, k[2] = f, this._gl.uniform3f(this._location, d, c,
                f)
        }
        Update4f(d, c, f, k) {
            d = Math.fround(d);
            c = Math.fround(c);
            f = Math.fround(f);
            k = Math.fround(k);
            const h = this._lastValue;
            if (h[0] !== d || h[1] !== c || h[2] !== f || h[3] !== k) h[0] = d, h[1] = c, h[2] = f, h[3] = k, this._gl.uniform4f(this._location, d, c, f, k)
        }
        UpdateMatrix4fv(d) {
            const c = this._lastValue;
            a.exactEquals(c, d) || (e.typedArraySet16(c, d, 0), this._gl.uniformMatrix4fv(this._location, !1, d))
        }
        IsSetToCustomInBatch(d) {
            const c = this._lastBatchValue;
            return this.IsColorType() ? c[0] === Math.fround(d.getR()) && c[1] === Math.fround(d.getG()) &&
                c[2] === Math.fround(d.getB()) : c[0] === Math.fround(d)
        }
        SetBatchValueCustom(d) {
            const c = this._lastBatchValue;
            this.IsColorType() ? (c[0] = d.getR(), c[1] = d.getG(), c[2] = d.getB()) : c[0] = d
        }
        IsSetTo1InBatch(d) {
            return this._lastBatchValue[0] === Math.fround(d)
        }
        IsSetTo2InBatch(d, c) {
            const f = this._lastBatchValue;
            return f[0] === Math.fround(d) && f[1] === Math.fround(c)
        }
        SetBatch1(d) {
            this._lastBatchValue[0] = d
        }
        SetBatch2(d, c) {
            const f = this._lastBatchValue;
            f[0] = d;
            f[1] = c
        }
    }
} {
    "use strict";
    const e = self.C3,
        a = self.glMatrix,
        b = a.vec4,
        d = a.mat4;
    e.Gfx.BatchState = class {
        constructor(c) {
            this.renderer = c;
            this.currentMV = d.create();
            this.currentMatP = d.create();
            this.currentFramebufferNoDepth = this.currentFramebuffer = null;
            this.isDepthSamplingEnabled = !1;
            this.currentColor = b.fromValues(1, 1, 1, 1);
            this.currentShader = null;
            this.pointTexCoords = new e.Rect;
            this.clearColor = e.New(e.Color, 0, 0, 0, 0)
        }
    };
    e.Gfx.WebGLBatchJob = class {
        constructor(c) {
            const f = new ArrayBuffer(96);
            this._type = 0;
            this._batchState = c;
            this._gl =
                c.renderer.GetContext();
            this._indexCount = this._startIndex = 0;
            this._texParam = null;
            this._mat4param = new Float32Array(f, 0, 16);
            this._colorParam = new Float32Array(f, 64, 4);
            this._srcOriginRect = new Float32Array(f, 80, 4);
            this._shaderParams = []
        }
        InitQuad(c, f) {
            this._type = 1;
            this._startIndex = c;
            this._indexCount = f
        }
        DoQuad() {
            const c = this._gl;
            c.drawElements(c.TRIANGLES, this._indexCount, c.UNSIGNED_SHORT, this._startIndex)
        }
        InitSetTexture(c) {
            this._type = 2;
            this._texParam = c
        }
        DoSetTexture() {
            const c = this._gl,
                f = this._texParam;
            c.bindTexture(c.TEXTURE_2D,
                f ? f._GetTexture() : null)
        }
        InitSetColor(c) {
            this._type = 3;
            c.writeToTypedArray(this._colorParam, 0)
        }
        DoSetColor() {
            const c = this._colorParam,
                f = this._batchState;
            b.copy(f.currentColor, c);
            f.currentShader.UpdateColor(c)
        }
        InitSetGradientColor(c) {
            this._type = 20;
            c.writeToTypedArray(this._colorParam, 0)
        }
        DoSetGradientColor() {
            const c = this._colorParam,
                f = this._batchState.currentShader;
            f._uColor2.IsUsed() && f._uColor2.Update4f(c[0], c[1], c[2], c[3])
        }
        InitSetBlend(c, f) {
            this._type = 4;
            this._startIndex = c;
            this._indexCount = f
        }
        DoSetBlend() {
            this._gl.blendFunc(this._startIndex,
                this._indexCount)
        }
        InitSetViewport(c, f, k, h) {
            this._type = 5;
            const l = this._colorParam;
            l[0] = c;
            l[1] = f;
            l[2] = k;
            l[3] = h
        }
        DoSetViewport() {
            const c = this._colorParam;
            this._gl.viewport(c[0], c[1], c[2], c[3])
        }
        InitSetProjection(c) {
            this._type = 6;
            d.copy(this._mat4param, c)
        }
        DoSetProjection() {
            const c = this._batchState,
                f = c.renderer._allShaderPrograms,
                k = c.currentShader,
                h = this._mat4param;
            for (let l = 0, n = f.length; l < n; ++l) {
                const u = f[l];
                u === k ? u.UpdateMatP(h, !0) : u.SetMatPStale()
            }
            d.copy(c.currentMatP, h)
        }
        InitSetModelView(c) {
            this._type =
                7;
            d.copy(this._mat4param, c)
        }
        DoSetModelView() {
            const c = this._batchState,
                f = c.renderer._allShaderPrograms,
                k = c.currentShader,
                h = this._mat4param;
            for (let l = 0, n = f.length; l < n; ++l) {
                const u = f[l];
                u === k ? u.UpdateMatMV(h, !0) : u.SetMatMVStale()
            }
            d.copy(c.currentMV, h)
        }
        InitSetRenderTarget(c) {
            this._type = 8;
            this._texParam = c
        }
        DoSetRenderTarget() {
            const c = this._gl,
                f = this._texParam,
                k = this._batchState;
            f ? (k.currentFramebuffer = f._GetFramebuffer(), k.currentFramebufferNoDepth = f._GetFramebufferNoDepth(), k.isDepthSamplingEnabled && k.currentFramebufferNoDepth ?
                c.bindFramebuffer(c.FRAMEBUFFER, k.currentFramebufferNoDepth) : c.bindFramebuffer(c.FRAMEBUFFER, k.currentFramebuffer)) : (k.currentFramebuffer = null, k.currentFramebufferNoDepth = null, c.bindFramebuffer(c.FRAMEBUFFER, null))
        }
        InitClearSurface(c) {
            this._type = 9;
            c.writeToTypedArray(this._mat4param, 0)
        }
        InitClearSurface2(c, f, k, h) {
            this._type = 9;
            const l = this._mat4param;
            l[0] = c;
            l[1] = f;
            l[2] = k;
            l[3] = h
        }
        DoClearSurface() {
            const c = this._gl;
            var f = this._mat4param;
            const k = this._batchState.clearColor,
                h = f[0],
                l = f[1],
                n = f[2];
            f = f[3];
            k.equalsRgba(h,
                l, n, f) || (c.clearColor(h, l, n, f), k.setRgba(h, l, n, f));
            c.clear(c.COLOR_BUFFER_BIT)
        }
        InitSetPointTexCoords(c) {
            this._type = 14;
            c.writeToTypedArray(this._mat4param, 0)
        }
        DoSetPointTextureCoords() {
            const c = this._mat4param;
            this._batchState.pointTexCoords.set(c[0], c[1], c[2], c[3])
        }
        InitPoints(c, f) {
            this._type = 10;
            this._startIndex = c;
            this._indexCount = 1;
            this._mat4param[0] = f
        }
        DoPoints() {
            const c = this._gl,
                f = this._batchState,
                k = f.renderer._spPoints;
            c.useProgram(k._shaderProgram);
            k.UpdateMatP(f.currentMatP, !1);
            k.UpdateMatMV(f.currentMV,
                !1);
            var h = f.pointTexCoords;
            k._uPointTexStart.IsUsed() && k._uPointTexStart.Update2f(h.getLeft(), h.getTop());
            k._uPointTexEnd.IsUsed() && k._uPointTexEnd.Update2f(h.getRight(), h.getBottom());
            h = this._mat4param[0];
            k._uZElevation.IsUsed() && k._uZElevation.Update1f(h);
            k._uColor.IsUsed() && (h = f.currentColor, k._uColor.Update4f(h[0], h[1], h[2], h[3]));
            c.drawArrays(c.POINTS, this._startIndex / 4, this._indexCount);
            c.useProgram(f.currentShader._shaderProgram)
        }
        InitSetProgram(c) {
            this._type = 11;
            this._texParam = c
        }
        DoSetProgram() {
            var c =
                this._gl;
            const f = this._batchState,
                k = this._texParam;
            f.currentShader = k;
            c.useProgram(k._shaderProgram);
            k.UpdateMatP(f.currentMatP, !1);
            k.UpdateMatMV(f.currentMV, !1);
            k._uColor.IsUsed() && (c = f.currentColor, k._uColor.Update4f(c[0], c[1], c[2], c[3]))
        }
        InitSetProgramParameters() {
            this._type = 12
        }
        DoSetProgramParameters() {
            const c = this._batchState.currentShader;
            c._hasAnyOptionalUniforms && this._DoSetOptionalUniformProgramParameters(c);
            c._uCustomParameters.length && this._DoUpdateCustomProgramParameters(c)
        }
        _DoSetOptionalUniformProgramParameters(c) {
            const f =
                this._gl,
                k = this._mat4param,
                h = this._colorParam,
                l = this._srcOriginRect;
            if (c._uSamplerBack.IsUsed()) {
                const n = this._batchState.renderer,
                    u = this._texParam;
                n._lastTexture1 !== u && (f.activeTexture(f.TEXTURE1), f.bindTexture(f.TEXTURE_2D, u ? u._GetTexture() : null), n._lastTexture1 = u, f.activeTexture(f.TEXTURE0))
            }
            c._uPixelSize.IsUsed() && c._uPixelSize.Update2f(k[0], k[1]);
            c._uDestStart.IsUsed() && c._uDestStart.Update2f(k[2], k[3]);
            c._uDestEnd.IsUsed() && c._uDestEnd.Update2f(k[4], k[5]);
            c._uDevicePixelRatio.IsUsed() && c._uDevicePixelRatio.Update1f(this._indexCount);
            c._uLayerScale.IsUsed() && c._uLayerScale.Update1f(k[6]);
            c._uLayerAngle.IsUsed() && c._uLayerAngle.Update1f(k[7]);
            c._uSrcStart.IsUsed() && c._uSrcStart.Update2f(k[12], k[13]);
            c._uSrcEnd.IsUsed() && c._uSrcEnd.Update2f(k[14], k[15]);
            c._uSrcOriginStart.IsUsed() && c._uSrcOriginStart.Update2f(l[0], l[1]);
            c._uSrcOriginEnd.IsUsed() && c._uSrcOriginEnd.Update2f(l[2], l[3]);
            c._uLayoutStart.IsUsed() && c._uLayoutStart.Update2f(h[0], h[1]);
            c._uLayoutEnd.IsUsed() && c._uLayoutEnd.Update2f(h[2], h[3]);
            c._uSeconds.IsUsed() && c._uSeconds.Update1f(this._startIndex)
        }
        _DoUpdateCustomProgramParameters(c) {
            c =
                c._uCustomParameters;
            const f = this._shaderParams;
            for (let k = 0, h = c.length; k < h; ++k) {
                const l = c[k],
                    n = f[k];
                l.IsColorType() ? l.Update3f(n.getR(), n.getG(), n.getB()) : l.Update1f(n)
            }
        }
        InitInvalidateFramebuffer(c) {
            this._type = 13;
            this._texParam = c
        }
        DoInvalidateFramebuffer() {
            const c = this._gl,
                f = this._texParam,
                k = this._batchState.currentFramebuffer;
            f !== k && c.bindFramebuffer(c.FRAMEBUFFER, f);
            c.invalidateFramebuffer(c.FRAMEBUFFER, [c.COLOR_ATTACHMENT0]);
            f !== k && c.bindFramebuffer(c.FRAMEBUFFER, k)
        }
        InitBlitFramebuffer(c, f, k) {
            this._type =
                16;
            const h = this._mat4param,
                l = this._batchState.renderer;
            h[0] = c.GetWidth();
            h[1] = c.GetHeight();
            h[2] = f ? f.GetWidth() : l.GetWidth();
            h[3] = f ? f.GetHeight() : l.GetHeight();
            h[4] = c.IsLinearSampling() ? 1 : 0;
            h[5] = "stretch" === k;
            k = this._shaderParams;
            e.clearArray(k);
            k.push(c._GetFramebuffer());
            k.push(f ? f._GetFramebuffer() : null)
        }
        DoBlitFramebuffer() {
            var c = this._mat4param,
                f = this._shaderParams;
            const k = this._gl;
            var h = c[0],
                l = c[1],
                n = c[2];
            const u = c[3],
                w = 0 !== c[4];
            c = 0 !== c[5];
            const q = f[1];
            k.bindFramebuffer(k.READ_FRAMEBUFFER, f[0]);
            k.bindFramebuffer(k.DRAW_FRAMEBUFFER, q);
            c ? k.blitFramebuffer(0, 0, h, l, 0, 0, n, u, k.COLOR_BUFFER_BIT, w ? k.LINEAR : k.NEAREST) : (f = Math.min(h, n), h = Math.min(l, u), n = Math.max(l - u, 0), l = Math.max(u - l, 0), k.blitFramebuffer(0, n, f, h + n, 0, l, f, h + l, k.COLOR_BUFFER_BIT, k.NEAREST))
        }
        InitStartQuery(c) {
            this._type = 17;
            this._texParam = c
        }
        DoStartQuery() {
            this._texParam.BeginTimeElapsed();
            this._texParam = null
        }
        InitEndQuery(c) {
            this._type = 18;
            this._texParam = c
        }
        DoEndQuery() {
            this._texParam.EndTimeElapsed();
            this._texParam = null
        }
        InitSetEllipseParams(c,
            f, k) {
            this._type = 19;
            const h = this._mat4param;
            h[0] = c;
            h[1] = f;
            h[2] = k
        }
        DoSetEllipseParams() {
            const c = this._batchState.currentShader,
                f = this._mat4param;
            c._uPixelSize.IsUsed() && c._uPixelSize.Update2f(f[0], f[1]);
            c._uOutlineThickness.IsUsed() && c._uOutlineThickness.Update1f(f[2])
        }
        InitSetTilemapInfo(c, f, k, h, l, n, u) {
            this._type = 15;
            const w = this._mat4param;
            c.writeToTypedArray(w, 0);
            w[4] = 1 / f;
            w[5] = 1 / k;
            w[6] = h / f;
            w[7] = l / k;
            w[8] = n / f;
            w[9] = u / k
        }
        DoSetTilemapInfo() {
            const c = this._batchState.currentShader,
                f = this._mat4param;
            c._uSrcStart.IsUsed() &&
                c._uSrcStart.Update2f(f[0], f[1]);
            c._uPixelSize.IsUsed() && c._uPixelSize.Update2f(f[4], f[5]);
            c._uTileSize.IsUsed() && c._uTileSize.Update2f(f[6], f[7]);
            c._uTileSpacing.IsUsed() && c._uTileSpacing.Update2f(f[8], f[9])
        }
        InitClearDepth(c) {
            this._type = 21;
            this._startIndex = c ? 1 : 0
        }
        DoClearDepth() {
            const c = this._gl,
                f = 0 !== this._startIndex;
            f || c.depthMask(!0);
            c.clear(c.DEPTH_BUFFER_BIT);
            f || c.depthMask(!1)
        }
        InitSetDepthEnabled(c) {
            this._type = 22;
            this._startIndex = c ? 1 : 0
        }
        DoSetDepthEnabled() {
            const c = this._gl;
            0 === this._startIndex ?
                (c.disable(c.DEPTH_TEST), c.depthMask(!1)) : (c.enable(c.DEPTH_TEST), c.depthMask(!0))
        }
        InitSetDepthSamplingEnabled(c) {
            this._type = 23;
            this._startIndex = c ? 1 : 0
        }
        DoSetDepthSamplingEnabled() {
            const c = this._gl,
                f = this._batchState,
                k = f.renderer,
                h = 0 !== this._startIndex;
            f.isDepthSamplingEnabled = h;
            c.activeTexture(c.TEXTURE2);
            h ? (f.currentFramebufferNoDepth && c.bindFramebuffer(c.FRAMEBUFFER, f.currentFramebufferNoDepth), c.bindTexture(c.TEXTURE_2D, k._GetDepthBuffer())) : (c.bindTexture(c.TEXTURE_2D, null), f.currentFramebufferNoDepth &&
                c.bindFramebuffer(c.FRAMEBUFFER, f.currentFramebuffer));
            c.activeTexture(c.TEXTURE0)
        }
        InitCoplanarStartStencilPass() {
            this._type = 24
        }
        DoCoplanarStartStencilPass() {
            const c = this._gl;
            c.clear(c.STENCIL_BUFFER_BIT);
            c.enable(c.STENCIL_TEST);
            c.stencilFunc(c.ALWAYS, 1, 1);
            c.stencilOp(c.KEEP, c.KEEP, c.REPLACE);
            c.colorMask(!1, !1, !1, !1)
        }
        InitCoplanarStartColorPass() {
            this._type = 25
        }
        DoCoplanarStartColorPass() {
            const c = this._gl;
            c.colorMask(!0, !0, !0, !0);
            c.stencilFunc(c.EQUAL, 1, 1);
            c.stencilOp(c.KEEP, c.KEEP, c.KEEP)
        }
        InitCoplanarRestore() {
            this._type =
                26
        }
        DoCoplanarRestore() {
            const c = this._gl;
            c.disable(c.STENCIL_TEST)
        }
        Run() {
            switch (this._type) {
                case 1:
                    this.DoQuad();
                    break;
                case 2:
                    this.DoSetTexture();
                    break;
                case 3:
                    this.DoSetColor();
                    break;
                case 4:
                    this.DoSetBlend();
                    break;
                case 5:
                    this.DoSetViewport();
                    break;
                case 6:
                    this.DoSetProjection();
                    break;
                case 7:
                    this.DoSetModelView();
                    break;
                case 8:
                    this.DoSetRenderTarget();
                    break;
                case 9:
                    this.DoClearSurface();
                    break;
                case 10:
                    this.DoPoints();
                    break;
                case 11:
                    this.DoSetProgram();
                    break;
                case 12:
                    this.DoSetProgramParameters();
                    break;
                case 13:
                    this.DoInvalidateFramebuffer();
                    break;
                case 14:
                    this.DoSetPointTextureCoords();
                    break;
                case 15:
                    this.DoSetTilemapInfo();
                    break;
                case 16:
                    this.DoBlitFramebuffer();
                    break;
                case 17:
                    this.DoStartQuery();
                    break;
                case 18:
                    this.DoEndQuery();
                    break;
                case 19:
                    this.DoSetEllipseParams();
                    break;
                case 20:
                    this.DoSetGradientColor();
                    break;
                case 21:
                    this.DoClearDepth();
                    break;
                case 22:
                    this.DoSetDepthEnabled();
                    break;
                case 23:
                    this.DoSetDepthSamplingEnabled();
                    break;
                case 24:
                    this.DoCoplanarStartStencilPass();
                    break;
                case 25:
                    this.DoCoplanarStartColorPass();
                    break;
                case 26:
                    this.DoCoplanarRestore()
            }
        }
    }
} {
    "use strict";
    const e = self.C3,
        a = {
            timeout: 60
        },
        b = new e.Color(0, 0, 0, 1),
        d = new Set(["left", "center", "right"]),
        c = new Set(["top", "center", "bottom"]),
        f = new Set(["word", "character"]),
        k = new Set;
    e.FontManager && e.FontManager.addEventListener("fontload", q => {
        q = q.font.GetName();
        for (const t of k)(t.IsBBCodeEnabled() || e.equalsNoCase(t.GetFontName(), q)) && t._SetTextChanged()
    });

    function h(q, t, p, r, x, y) {
        t ? "Gecko" === e.Platform.BrowserEngine ? q.strokeText(p, r, x, y) : q.strokeText(p, r, x) : "Gecko" === e.Platform.BrowserEngine ? q.fillText(p,
            r, x, y) : q.fillText(p, r, x)
    }

    function l(q, t, p, r, x, y) {
        t ? q.strokeRect(p, r, x, y) : q.fillRect(p, r, x, y)
    }

    function n(q) {
        return 4 / 3 * q
    }
    let u = !1,
        w = !1;
    e.Gfx.RendererText = class {
        constructor(q, t) {
            t = Object.assign({}, a, t);
            this._renderer = q;
            this._fontName = "Arial";
            this._fontSize = 16;
            this._fontSizeScale = 1;
            this._lineHeight = 0;
            this._isItalic = this._isBold = !1;
            this._colorStr = "black";
            this._isBBcodeEnabled = !1;
            this.onloadfont = null;
            this._alreadyLoadedFonts = new Set;
            this._horizontalAlign = "left";
            this._verticalAlign = "top";
            this._text = "";
            this._bbString = null;
            this._wrappedText = e.New(e.WordWrap);
            this._wrapMode = "word";
            this._isUpdating = this._textChanged = !1;
            this._isAsync = !0;
            this._drawMaxCharCount = -1;
            this._height = this._width = this._cssHeight = this._cssWidth = this._drawCharCount = 0;
            this._zoom = 1;
            this._changed = !1;
            this._measureContextTop = this._measureContext = this._textContext = this._textCanvas = null;
            this._lastCanvasHeight = this._lastCanvasWidth = -1;
            this._lastTextCanvasFillStyle = this._lastMeasureCanvasFont = this._lastTextCanvasFont = "";
            this._lastTextCanvasLineWidth =
                this._lastTextCanvasOpacity = 1;
            this._measureTextCallback = (p, r) => this._MeasureText(p, r);
            this._texture = null;
            this._textureHeight = this._textureWidth = 0;
            this._rcTex = new e.Rect;
            this._scaleFactor = 1;
            this._needToRecreateTexture = !1;
            this._textureTimeout = new e.IdleTimeout(() => {
                this.ReleaseTexture();
                this._SetTextCanvasSize(8, 8)
            }, t.timeout);
            this.ontextureupdate = null;
            this._wasReleased = !1;
            k.add(this)
        }
        Release() {
            this.onloadfont = null;
            this._alreadyLoadedFonts.clear();
            this._measureTextCallback = this._measureContextTop = this._measureContext =
                this._textContext = this._textCanvas = this._bbString = null;
            this._textureTimeout.Release();
            this.ontextureupdate = null;
            this.ReleaseTexture();
            this._wrappedText.Clear();
            this._renderer = this._wrappedText = null;
            this._wasReleased = !0;
            k.delete(this)
        }
        _SetChanged() {
            this._changed = !0
        }
        _SetTextChanged() {
            this._SetChanged();
            this._wrappedText.Clear();
            this._textChanged = !0
        }
        SetIsAsync(q) {
            this._isAsync = !!q
        }
        IsAsync() {
            return this._isAsync
        }
        SetBBCodeEnabled(q) {
            q = !!q;
            this._isBBcodeEnabled !== q && (q = (this._isBBcodeEnabled = q) ? "alphabetic" :
                "top", this._textContext && (this._textContext.textBaseline = q), this._measureContext && (this._measureContext.textBaseline = q), this._SetTextChanged())
        }
        IsBBCodeEnabled() {
            return this._isBBcodeEnabled
        }
        SetFontName(q) {
            q || (q = "serif");
            this._fontName !== q && (this._fontName = q, this._SetTextChanged())
        }
        GetFontName() {
            return this._fontName
        }
        SetFontSize(q) {
            .1 > q && (q = .1);
            this._fontSize !== q && (this._fontSize = q, this._SetTextChanged())
        }
        SetFontSizeScale(q) {
            this._fontSizeScale !== q && (this._fontSizeScale = q, this._SetTextChanged())
        }
        SetLineHeight(q) {
            this._lineHeight !==
                q && (this._lineHeight = q, this._SetChanged())
        }
        SetBold(q) {
            q = !!q;
            this._isBold !== q && (this._isBold = q, this._SetTextChanged())
        }
        SetItalic(q) {
            q = !!q;
            this._isItalic !== q && (this._isItalic = q, this._SetTextChanged())
        }
        SetDrawMaxCharacterCount(q) {
            q = Math.floor(q);
            this._drawMaxCharCount !== q && (this._drawMaxCharCount = q, this._SetChanged())
        }
        GetDrawMaxCharacterCount() {
            return this._drawMaxCharCount
        }
        _GetStyleTag(q, t) {
            for (let p = q.length - 1; 0 <= p; --p) {
                const r = q[p];
                if (r.tag === t) return r
            }
            return null
        }
        _HasStyleTag(q, t) {
            return !!this._GetStyleTag(q,
                t)
        }
        _GetFontString(q, t) {
            let p = [];
            (this._isBold || this._HasStyleTag(t, "b")) && p.push("bold");
            (this._isItalic || this._HasStyleTag(t, "i")) && p.push("italic");
            var r = this._GetStyleTag(t, "size");
            r = (r ? parseFloat(r.param) : this._fontSize) * this._fontSizeScale;
            q ? p.push(r + "pt") : p.push(r * this._scaleFactor * this._zoom * self.devicePixelRatio + "pt");
            q = this._fontName;
            (t = this._GetStyleTag(t, "font")) && t.param && (q = t.param, this.onloadfont && !this._alreadyLoadedFonts.has(q) && (this.onloadfont(q), this._alreadyLoadedFonts.add(q)));
            q && p.push('"' + q + '"');
            return p.join(" ")
        }
        SetColor(q) {
            q instanceof e.Color && (q = q.getCssRgb());
            this._colorStr !== q && (this._colorStr = q, this._SetChanged())
        }
        SetColorRgb(q, t, p) {
            b.setRgb(q, t, p);
            this.SetColor(b)
        }
        SetHorizontalAlignment(q) {
            if (!d.has(q)) throw Error("invalid horizontal alignment");
            this._horizontalAlign !== q && (this._horizontalAlign = q, this._SetChanged())
        }
        SetVerticalAlignment(q) {
            if (!c.has(q)) throw Error("invalid vertical alignment");
            this._verticalAlign !== q && (this._verticalAlign = q, this._SetChanged())
        }
        SetWordWrapMode(q) {
            if (!f.has(q)) throw Error("invalid word wrap mode");
            this._wrapMode !== q && (this._wrapMode = q, this._SetTextChanged())
        }
        SetText(q) {
            this._text !== q && (this._text = q, this._SetTextChanged())
        }
        SetSize(q, t, p) {
            "undefined" === typeof p && (p = 1);
            if (!(0 >= q || 0 >= q || this._cssWidth === q && this._cssHeight === t && this._zoom === p)) {
                1 === this._zoom !== (1 === p) && (this._needToRecreateTexture = !0);
                var r = this._cssWidth,
                    x = this._zoom;
                this._cssWidth = q;
                this._cssHeight = t;
                this._zoom = p;
                q = self.devicePixelRatio;
                this._width = this._cssWidth * this._zoom * q;
                this._height = this._cssHeight * this._zoom * q;
                q = Math.max(this._width,
                    this._height);
                t = Math.min(this._renderer.GetMaxTextureSize(), 2048);
                p = 1;
                q > t && (p = t / q, this._width = Math.min(this._width * p, t), this._height = Math.min(this._height * p, t));
                this._scaleFactor = p;
                0 < this._textureWidth && 0 < this._textureHeight && this._zoom === x && this._rcTex.set(0, 0, this._width / this._textureWidth, this._height / this._textureHeight);
                this._cssWidth !== r ? this._SetTextChanged() : this._SetChanged()
            }
        }
        GetWidth() {
            return this._width
        }
        GetHeight() {
            return this._height
        }
        GetTextWidth() {
            this._MaybeWrapText();
            return this._wrappedText.GetMaxLineWidth()
        }
        GetTextHeight() {
            this._MaybeWrapText();
            return this._wrappedText.GetTotalLineHeight() + this._wrappedText.GetLineCount() * (this._lineHeight + 4) - this._lineHeight
        }
        GetTexture() {
            this._textureTimeout.Reset();
            this._MaybeUpdate();
            return this._texture
        }
        _MaybeUpdate() {
            this._texture && !this._changed && !this._textChanged || this._isUpdating || 0 >= this._width || 0 >= this._height || (this._changed = !1, this._isUpdating = !0, this._isAsync ? e.Asyncify(() => this._DoUpdate()) : this._DoUpdate())
        }
        _DoUpdate() {
            this._wasReleased || (this._SetTextCanvasSize(Math.ceil(this._width), Math.ceil(this._height)),
                this._MaybeWrapText(), this._DrawTextToCanvas(), this._UpdateTexture(), this._textureTimeout.Reset(), this._isUpdating = !1)
        }
        _SetTextCanvasSize(q, t) {
            this._textCanvas || (this._textCanvas = e.CreateCanvas(16, 16));
            let p = !1;
            if (this._lastCanvasWidth !== q || this._lastCanvasHeight !== t) this._lastCanvasWidth = q, this._lastCanvasHeight = t, this._textCanvas.width = q, this._textCanvas.height = t, p = !0;
            this._textContext || (this._textContext = this._textCanvas.getContext("2d"), p = !0);
            p ? (this._textContext.textBaseline = this._isBBcodeEnabled ?
                "alphabetic" : "top", this._textContext.font = this._lastTextCanvasFont, this._textContext.fillStyle = this._lastTextCanvasFillStyle, this._textContext.strokeStyle = this._lastTextCanvasFillStyle, this._textContext.globalAlpha = this._lastTextCanvasOpacity, this._textContext.lineWidth = this._lastTextCanvasLineWidth) : this._textContext.clearRect(0, 0, q, t)
        }
        _MaybeCreateMeasureContext() {
            this._measureContext || (this._measureContext = e.CreateCanvas(16, 16).getContext("2d"), this._measureContextTop = e.CreateCanvas(16, 16).getContext("2d"),
                this._measureContext.textBaseline = this._isBBcodeEnabled ? "alphabetic" : "top", this._measureContextTop.textBaseline = "top")
        }
        _SetMeasureFontString(q) {
            this._lastMeasureCanvasFont !== q && (this._lastMeasureCanvasFont = q, this._measureContext.font = q, this._measureContextTop.font = q)
        }
        _SupportsFontBoundingBoxMeasurements() {
            if (!u) {
                u = !0;
                this._MaybeCreateMeasureContext();
                const q = this._measureContext.measureText("test");
                w = "number" === typeof q.fontBoundingBoxAscent && "number" === typeof q.fontBoundingBoxDescent
            }
            return w
        }
        _MaybeWrapText() {
            this._textChanged &&
                (this._MaybeCreateMeasureContext(), !this._isBBcodeEnabled || this._bbString && this._bbString.toString() === this._text || (this._bbString = new e.BBString(this._text, {
                    noEscape: !0
                })), this._wrappedText.WordWrap(this._isBBcodeEnabled ? this._bbString.toFragmentList() : this._text, this._measureTextCallback, this._cssWidth, this._wrapMode, 0), this._textChanged = !1)
        }
        _MeasureText(q, t) {
            this._SetMeasureFontString(this._GetFontString(!0, t));
            t = this._GetStyleTag(t, "size");
            t = (t ? parseFloat(t.param) : this._fontSize) * this._fontSizeScale;
            const p = this._measureContext.measureText(q);
            let r = 0;
            this._isBBcodeEnabled && this._SupportsFontBoundingBoxMeasurements() && (q = this._measureContextTop.measureText(q), r = p.fontBoundingBoxAscent - q.fontBoundingBoxAscent);
            return {
                width: p.width,
                height: n(t),
                fontBoundingBoxAscent: p.fontBoundingBoxAscent || 0,
                fontBoundingBoxDescent: p.fontBoundingBoxDescent || 0,
                topToAlphabeticDistance: r
            }
        }
        _SetDrawFontString(q) {
            this._lastTextCanvasFont !== q && (this._lastTextCanvasFont = q, this._textContext.font = q)
        }
        _SetDrawCanvasColor(q) {
            this._lastTextCanvasFillStyle !==
                q && (this._lastTextCanvasFillStyle = q, this._textContext.fillStyle = q, this._textContext.strokeStyle = q)
        }
        _SetDrawCanvasOpacity(q) {
            this._lastTextCanvasOpacity !== q && (this._lastTextCanvasOpacity = q, this._textContext.globalAlpha = q)
        }
        _SetDrawCanvasLineWith(q) {
            this._lastTextCanvasLineWidth !== q && (this._lastTextCanvasLineWidth = q, this._textContext.lineWidth = q)
        }
        _DrawTextToCanvas() {
            this._drawCharCount = 0;
            const q = this._scaleFactor * this._zoom * self.devicePixelRatio,
                t = (4 + this._lineHeight) * q;
            var p = 0;
            const r = this._wrappedText.GetLines();
            if (0 !== r.length) {
                var x = this._isBBcodeEnabled && this._SupportsFontBoundingBoxMeasurements(),
                    y = r[0].height * q;
                "center" === this._verticalAlign ? (p = r.reduce((E, G) => E + G.height * q + t, 0) - t, p = Math.max(this._height / 2 - p / 2, 0), x && (y = r[0].topToAlphabeticDistance * q)) : "bottom" === this._verticalAlign && (p = r.reduce((E, G) => E + G.height * q + t, 0) - this._lineHeight * q, x = x ? r.at(-1).fontBoundingBoxDescent * q : 0, p = this._height - p - x - 2);
                for (let E = 0, G = r.length; E < G; ++E) {
                    x = r[E];
                    const A = x.height * q,
                        F = p;
                    if (this._isBBcodeEnabled) {
                        if (p += 0 === E ? y : A,
                            0 < E && p > this._height - 4 * q) break
                    } else if (0 < E && p >= this._height - A) break;
                    0 <= F && this._DrawTextLine(x, p, q);
                    this._isBBcodeEnabled || (p += A);
                    p += t
                }
            }
        }
        _DrawTextLine(q, t, p) {
            let r = 0;
            "center" === this._horizontalAlign ? r = (this._width - q.width * p) / 2 : "right" === this._horizontalAlign && (r = this._width - q.width * p);
            for (const x of q.fragments) this._DrawTextFragment(x, r, t, p, q.height), r += x.width * p
        }
        _DrawTextFragment(q, t, p, r, x) {
            const y = this._textContext,
                E = x / 16;
            x = q.width * r;
            const G = q.height * r,
                A = q.height / 16;
            var F = (4 + this._lineHeight) * r,
                J = q.styles;
            q = q.text;
            if (-1 !== this._drawMaxCharCount) {
                if (this._drawCharCount >= this._drawMaxCharCount) return;
                this._drawCharCount + q.length > this._drawMaxCharCount && (q = q.substr(0, this._drawMaxCharCount - this._drawCharCount), x = this._MeasureText(q, J).width * r);
                this._drawCharCount += q.length
            }
            var B = this._GetStyleTag(J, "background");
            const I = this._HasStyleTag(J, "u"),
                L = this._HasStyleTag(J, "s");
            if ((!e.IsStringAllWhitespace(q) || B || I || L) && !this._HasStyleTag(J, "hide")) {
                var P = this._GetStyleTag(J, "offsetx");
                t += P ? parseFloat(P.param) *
                    r : 0;
                P = this._GetStyleTag(J, "offsety");
                p += P ? parseFloat(P.param) * r : 0;
                B && (this._SetDrawCanvasColor(B.param), y.fillRect(t, p - G, x, G + F));
                F = this._GetStyleTag(J, "color");
                this._SetDrawCanvasColor(F ? F.param : this._colorStr);
                B = this._GetStyleTag(J, "opacity");
                this._SetDrawCanvasOpacity(B ? parseFloat(B.param) / 100 : 1);
                B = (B = this._GetStyleTag(J, "linethickness")) ? parseFloat(B.param) : 1;
                (P = this._HasStyleTag(J, "stroke")) && this._SetDrawCanvasLineWith(.5 * A * B * this._scaleFactor * this._zoom * self.devicePixelRatio);
                this._SetDrawFontString(this._GetFontString(!1,
                    J));
                h(y, P, q, t, p, x);
                !P && (this._SetDrawCanvasLineWith(.5 * A * B * this._scaleFactor * this._zoom * self.devicePixelRatio), J = this._GetStyleTag(J, "outline")) && (this._SetDrawCanvasColor(J.param), h(y, !0, q, t, p, x));
                this._SetDrawCanvasColor(F ? F.param : this._colorStr);
                I && l(y, P, t, p + r * E, x, r * E * B);
                L && (r *= A, y.fillRect(t, p - G / 4 + r / 2 - r * B / 2, x, r * B))
            }
        }
        _UpdateTexture() {
            if (!this._renderer.IsContextLost() && (this._textureWidth = Math.ceil(this._width), this._textureHeight = Math.ceil(this._height), this._rcTex.set(0, 0, this._width / this._textureWidth,
                    this._height / this._textureHeight), this._needToRecreateTexture && (this.ReleaseTexture(), this._needToRecreateTexture = !1), this._texture || (this._texture = this._renderer.CreateDynamicTexture(this._textureWidth, this._textureHeight, {
                    mipMap: 1 === this._zoom,
                    mipMapQuality: "high"
                })), this._renderer.UpdateTexture(this._textCanvas, this._texture), this.ontextureupdate)) this.ontextureupdate()
        }
        GetTexRect() {
            return this._rcTex
        }
        ReleaseTexture() {
            this._texture && (this._renderer.IsContextLost() || this._renderer.DeleteTexture(this._texture),
                this._texture = null)
        }
        static OnContextLost() {
            for (const q of k) q.ReleaseTexture()
        }
        static GetAll() {
            return k.values()
        }
    }
} {
    "use strict";
    const e = self.C3;
    class a {
        constructor(b) {
            this._gl = b.GetContext();
            this._version = b.GetWebGLVersionNumber();
            this._timerExt = b._GetDisjointTimerQueryExtension();
            this._query = null;
            this._hasResult = this._isActive = !1;
            this._result = 0;
            this._query = 1 === this._version ? this._timerExt.createQueryEXT() : this._gl.createQuery()
        }
        Release() {
            this._DeleteQueryObject();
            this._timerExt = this._gl = null;
            this._hasResult = !1
        }
        _DeleteQueryObject() {
            this._query && (1 === this._version ? this._timerExt.deleteQueryEXT(this._query) : this._gl.deleteQuery(this._query),
                this._query = null)
        }
        BeginTimeElapsed() {
            if (this._isActive) throw Error("query already active");
            1 === this._version ? this._timerExt.beginQueryEXT(this._timerExt.TIME_ELAPSED_EXT, this._query) : this._gl.beginQuery(this._timerExt.TIME_ELAPSED_EXT, this._query);
            this._isActive = !0
        }
        EndTimeElapsed() {
            if (!this._isActive) throw Error("query not active");
            1 === this._version ? this._timerExt.endQueryEXT(this._timerExt.TIME_ELAPSED_EXT) : this._gl.endQuery(this._timerExt.TIME_ELAPSED_EXT);
            this._isActive = !1
        }
        CheckForResult() {
            if (this._query &&
                !this._hasResult && !this._isActive) {
                var b = 1 === this._version ? this._timerExt.getQueryObjectEXT(this._query, this._timerExt.QUERY_RESULT_AVAILABLE_EXT) : this._gl.getQueryParameter(this._query, this._gl.QUERY_RESULT_AVAILABLE);
                var d = this._gl.getParameter(this._timerExt.GPU_DISJOINT_EXT);
                b && !d && (this._result = 1 === this._version ? this._timerExt.getQueryObjectEXT(this._query, this._timerExt.QUERY_RESULT_EXT) : this._gl.getQueryParameter(this._query, this._gl.QUERY_RESULT), this._result /= 1E9, this._hasResult = !0);
                (b ||
                    d) && this._DeleteQueryObject()
            }
        }
        HasResult() {
            return this._hasResult
        }
        GetResult() {
            if (!this._hasResult) throw Error("no result available");
            return this._result
        }
    }
    e.Gfx.WebGLTimeElapsedQuery = class {
        constructor(b) {
            this._renderer = b;
            this._frameNumber = b.GetFrameNumber();
            this._isActive = !1;
            this._parentQuery = null;
            this._isNested = !1;
            this._realQuery = null;
            this._queries = []
        }
        Release() {
            for (const b of this._queries) b instanceof a && b.Release();
            e.clearArray(this._queries);
            this._renderer = this._realQuery = this._parentQuery = null
        }
        BeginTimeElapsed() {
            if (this._isActive) throw Error("query already active");
            const b = this._renderer._GetTimeQueryStack();
            0 < b.length ? (this._isNested = !0, this._parentQuery = b.at(-1), this._parentQuery._EndReal(), this._parentQuery._queries.push(this)) : (this._isNested = !1, this._parentQuery = null);
            this._isActive = !0;
            b.push(this);
            this._StartReal()
        }
        EndTimeElapsed() {
            if (!this._isActive) throw Error("query not active");
            if (this._renderer._GetTimeQueryStack().pop() !== this) throw Error("can only end most nested query");
            this._isActive = !1;
            this._EndReal();
            this._parentQuery && (this._parentQuery._StartReal(),
                this._parentQuery = null)
        }
        _StartReal() {
            this._realQuery = e.New(a, this._renderer);
            this._queries.push(this._realQuery);
            this._realQuery.BeginTimeElapsed()
        }
        _EndReal() {
            this._realQuery.EndTimeElapsed();
            this._realQuery = null
        }
        CheckForResult() {
            for (const b of this._queries) b.CheckForResult()
        }
        IsNested() {
            return this._isNested
        }
        HasResult() {
            return this._queries.every(b => b.HasResult())
        }
        GetResult() {
            return this._queries.reduce((b, d) => b + d.GetResult(), 0)
        }
        GetFrameNumber() {
            return this._frameNumber
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Gfx.WebGLQueryResultBuffer = class {
        constructor(a, b = 1E3) {
            this._renderer = a;
            this._maxQueries = b;
            this._buffer = [];
            this._renderer._AddQueryResultBuffer(this)
        }
        Release() {
            this.Clear();
            this._renderer._RemoveQueryResultBuffer(this);
            this._renderer = null
        }
        Clear() {
            for (const a of this._buffer) a.Release();
            e.clearArray(this._buffer)
        }
        AddTimeElapsedQuery() {
            const a = new e.Gfx.WebGLTimeElapsedQuery(this._renderer);
            this._buffer.push(a);
            this._buffer.length > this._maxQueries && this._buffer.shift().Release();
            return a
        }
        CheckForResults(a) {
            for (const b of this._buffer) {
                if (b.GetFrameNumber() >= a) break;
                if (b.IsNested()) break;
                b.CheckForResult()
            }
        }
        GetFrameRangeResultSum(a, b) {
            if (b <= a) return NaN;
            let d = 0;
            for (const c of this._buffer) {
                if (c.GetFrameNumber() >= b) break;
                if (!(c.GetFrameNumber() < a))
                    if (c.HasResult()) d += c.GetResult();
                    else return NaN
            }
            return d
        }
        DeleteAllBeforeFrameNumber(a) {
            for (let b = 0, d = this._buffer.length; b < d; ++b) {
                const c = this._buffer[b];
                if (c.GetFrameNumber() < a) c.Release();
                else {
                    0 < b && this._buffer.splice(0, b);
                    break
                }
            }
        }
    }
} {
    "use strict";
    const e = self.C3,
        a = self.glMatrix,
        b = a.vec4,
        d = a.mat4,
        c = {
            powerPreference: "default",
            enableGpuProfiling: !0,
            alpha: !1,
            lowLatency: !1,
            depth: !1,
            canSampleDepth: !1,
            maxWebGLVersion: 2,
            failIfMajorPerformanceCaveat: !1
        },
        f = new Set(["default", "low-power", "high-performance"]),
        k = new e.Quad(0, 0, 1, 0, 1, 1, 0, 1),
        h = d.create(),
        l = d.create(),
        n = new e.Quad,
        u = new e.Rect;
    let w = null;
    e.isDebug && (self.debug_lose_context = function () {
            w ? w.loseContext() : console.warn("WEBGL_lose_context not supported")
        }, self.debug_restore_context =
        function () {
            w ? w.restoreContext() : console.warn("WEBGL_lose_context not supported")
        });
    const q = new Set;
    let t = -1;

    function p() {
        t = -1;
        for (const r of q) r.checkFunc() && (r.resolve(), q.delete(r));
        0 < q.size && (t = self.requestAnimationFrame(p))
    }
    e.Gfx.WebGLRenderer = class extends e.Gfx.RendererBase {
        constructor(r, x) {
            super();
            x = Object.assign({}, c, x);
            if (!f.has(x.powerPreference)) throw Error("invalid power preference");
            const y = {
                alpha: !!x.alpha,
                depth: !1,
                antialias: !1,
                powerPreference: x.powerPreference,
                failIfMajorPerformanceCaveat: !!x.failIfMajorPerformanceCaveat
            };
            x.lowLatency && (y.desynchronized = !0, y.preserveDrawingBuffer = !0);
            let E = null,
                G = 0;
            2 <= x.maxWebGLVersion && (E = r.getContext("webgl2", y), G = 2);
            E || (E = r.getContext("webgl", y), G = 1);
            if (!E) throw Error("failed to initialise WebGL context");
            this._gl = E;
            this._attribs = E.getContextAttributes();
            x.lowLatency && !this._attribs.desynchronized && console.info("[WebGLRenderer] Low-latency mode specified but is not supported here");
            this._versionString = E.getParameter(E.VERSION);
            this._version = G;
            this._viewport = b.create();
            this._didChangeTransform = !1;
            this._bbProjectionMatrix = d.create();
            this._usesDepthBuffer = !!x.depth;
            this._canSampleDepth = !(!x.depth || !x.canSampleDepth);
            this._isDepthEnabled = this._usesDepthBuffer;
            this._isDepthSamplingEnabled = !1;
            this._depthBuffer = null;
            this._isAutoSizeDepthBuffer = !0;
            this._depthBufferHeight = this._depthBufferWidth = 0;
            this._pointBuffer = this._indexBuffer = this._texcoordBuffer = this._vertexBuffer = null;
            this._vertexData = new Float32Array(8E3 * this.GetNumVertexComponents());
            this._indexData = new Uint16Array(12E3);
            this._texcoordData =
                new Float32Array(16E3);
            this._pointData = new Float32Array(32E3);
            this._lastVertexPtr = this._pointPtr = this._texPtr = this._vertexPtr = 0;
            this._spDeviceTransformTextureFill = this._lastProgram = null;
            this._batch = [];
            this._topOfBatch = this._batchPtr = 0;
            this._currentRenderTarget = null;
            this._lastPointZ = 0;
            this._batchState = e.New(e.Gfx.BatchState, this);
            this._lastColor = e.New(e.Color, 1, 1, 1, 1);
            this._lastTexture1 = this._lastTexture0 = null;
            this._lastDestBlend = this._lastSrcBlend = 0;
            this._lastPointTexCoords = new e.Rect;
            this._maxTextureSize = -1;
            this._highpPrecision = this._maxPointSize = this._minPointSize = 0;
            this._unmaskedRenderer = this._unmaskedVendor = "(unavailable)";
            this._extensions = [];
            this._isInitialisingAfterContextRestored = !1;
            this._depthTextureExt = this._anisotropicExt = this._parallelShaderCompileExt = null;
            this._maxAnisotropy = 0;
            this._isGpuProfilingEnabled = !!x.enableGpuProfiling;
            this._timerExt = null;
            this._allQueryResultBuffers = new Set;
            this._timeQueryStack = [];
            this.FillIndexBufferData(this._indexData)
        }
        IsWebGL() {
            return !0
        }
        async InitState() {
            super.InitState();
            var r = this._gl,
                x = this.GetNumVertexComponents();
            this._lastColor.setRgba(1, 1, 1, 1);
            this._lastTexture1 = this._lastTexture0 = null;
            this._pointPtr = this._vertexPtr = 0;
            this._lastVertexPtr = 8E3 * x - 4 * x;
            e.clearArray(this._batch);
            this._topOfBatch = this._batchPtr = 0;
            this._currentRenderTarget = this._lastProgram = null;
            this._lastPointTexCoords.set(0, 0, 1, 1);
            this._lastPointZ = 0;
            x = this._batchState;
            x.currentShader = null;
            x.currentFramebuffer = null;
            x.currentFramebufferNoDepth = null;
            b.set(x.currentColor, 1, 1, 1, 1);
            x.clearColor.setRgba(0,
                0, 0, 0);
            x.pointTexCoords.set(0, 0, 1, 1);
            r.clearColor(0, 0, 0, 0);
            r.clear(r.COLOR_BUFFER_BIT);
            r.enable(r.BLEND);
            r.blendFunc(r.ONE, r.ONE_MINUS_SRC_ALPHA);
            this._lastSrcBlend = r.ONE;
            this._lastDestBlend = r.ONE_MINUS_SRC_ALPHA;
            this._InitBlendModes(r);
            r.disable(r.CULL_FACE);
            r.disable(r.STENCIL_TEST);
            r.disable(r.DITHER);
            this._usesDepthBuffer ? (r.enable(r.DEPTH_TEST), r.depthMask(!0), r.depthFunc(r.LEQUAL)) : (r.disable(r.DEPTH_TEST), r.depthMask(!1));
            this._isDepthEnabled = this._usesDepthBuffer;
            this._isDepthSamplingEnabled = !1;
            this._pointBuffer = r.createBuffer();
            r.bindBuffer(r.ARRAY_BUFFER, this._pointBuffer);
            r.bufferData(r.ARRAY_BUFFER, this._pointData.byteLength, r.DYNAMIC_DRAW);
            this._vertexBuffer = r.createBuffer();
            r.bindBuffer(r.ARRAY_BUFFER, this._vertexBuffer);
            r.bufferData(r.ARRAY_BUFFER, this._vertexData.byteLength, r.DYNAMIC_DRAW);
            this._texcoordBuffer = r.createBuffer();
            r.bindBuffer(r.ARRAY_BUFFER, this._texcoordBuffer);
            r.bufferData(r.ARRAY_BUFFER, this._texcoordData.byteLength, r.DYNAMIC_DRAW);
            this._indexBuffer = r.createBuffer();
            r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
            r.bufferData(r.ELEMENT_ARRAY_BUFFER, this._indexData, r.STATIC_DRAW);
            r.activeTexture(r.TEXTURE0);
            r.bindTexture(r.TEXTURE_2D, null);
            this._maxTextureSize = r.getParameter(r.MAX_TEXTURE_SIZE);
            x = r.getParameter(r.ALIASED_POINT_SIZE_RANGE);
            this._minPointSize = x[0];
            this._maxPointSize = x[1];
            x = r.getShaderPrecisionFormat(r.VERTEX_SHADER, r.HIGH_FLOAT);
            const y = r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.HIGH_FLOAT);
            this._highpPrecision = x && y ? Math.min(x.precision,
                y.precision) : 0;
            2048 < this._maxPointSize && (this._maxPointSize = 2048);
            this._extensions = r.getSupportedExtensions();
            if (x = r.getExtension("WEBGL_debug_renderer_info")) this._unmaskedVendor = r.getParameter(x.UNMASKED_VENDOR_WEBGL), this._unmaskedRenderer = r.getParameter(x.UNMASKED_RENDERER_WEBGL);
            this._parallelShaderCompileExt = r.getExtension("KHR_parallel_shader_compile");
            e.isDebug && (w = r.getExtension("WEBGL_lose_context"));
            if (this._isGpuProfilingEnabled)
                if (1 === this.GetWebGLVersionNumber()) {
                    if ("Chromium" !== e.Platform.BrowserEngine ||
                        81 <= e.Platform.BrowserVersionNumber || "undefined" !== typeof document) this._timerExt = r.getExtension("EXT_disjoint_timer_query")
                } else this._timerExt = r.getExtension("EXT_disjoint_timer_query_webgl2") || r.getExtension("EXT_disjoint_timer_query");
            this._maxAnisotropy = (this._anisotropicExt = r.getExtension("EXT_texture_filter_anisotropic")) ? r.getParameter(this._anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;
            if (2 > this.GetWebGLVersionNumber() && this._usesDepthBuffer && this._canSampleDepth && (this._depthTextureExt =
                    r.getExtension("WEBGL_depth_texture"), !this._depthTextureExt)) throw Error("no depth texture support");
            r = e.Gfx.WebGLShaderProgram;
            x = r.GetDefaultVertexShaderSource(!1);
            r = [
                [r.GetTextureFillFragmentShaderSource(), x, "<default>"],
                [r.GetTextureFillFragmentShaderSource(), x, "<default-device-transform>"],
                [r.GetPointFragmentShaderSource(this._version), r.GetPointVertexShaderSource(this._version), "<point>"],
                [r.GetColorFillFragmentShaderSource(), x, "<fill>"],
                [r.GetLinearGradientFillFragmentShaderSource(), x, "<lineargradient>"],
                [r.GetHardEllipseFillFragmentShaderSource(), x, "<hardellipse>"],
                [r.GetHardEllipseOutlineFragmentShaderSource(), x, "<hardellipseoutline>"],
                [r.GetSmoothEllipseFillFragmentShaderSource(), x, "<smoothellipse>"],
                [r.GetSmoothEllipseOutlineFragmentShaderSource(), x, "<smoothellipseoutline>"],
                [r.GetSmoothLineFillFragmentShaderSource(), x, "<smoothline>"],
                [r.GetTilemapFragmentShaderSource(), r.GetDefaultVertexShaderSource(!0), "<tilemap>"]
            ];
            r = await Promise.all(r.map(E => this.CreateShaderProgram({
                src: E[0]
            }, E[1], E[2])));
            this._spTextureFill = r[0];
            this._spDeviceTransformTextureFill = r[1];
            this._spPoints = r[2];
            this._spColorFill = r[3];
            this._spLinearGradientFill = r[4];
            this._spHardEllipseFill = r[5];
            this._spHardEllipseOutline = r[6];
            this._spSmoothEllipseFill = r[7];
            this._spSmoothEllipseOutline = r[8];
            this._spSmoothLineFill = r[9];
            this._spTilemapFill = r[10];
            this.SetTextureFillMode()
        }
        async CreateShaderProgram(r, x, y) {
            r = await e.Gfx.WebGLShaderProgram.Create(this, r, x, y);
            this._AddShaderProgram(r);
            return r
        }
        ResetLastProgram() {
            this._lastProgram =
                null
        }
        SetSize(r, x, y) {
            if (this._width !== r || this._height !== x || y) {
                this.EndBatch();
                y = this._gl;
                var E = this._batchState;
                this._width = r;
                this._height = x;
                this._SetViewport(0, 0, r, x);
                this.CalculatePerspectiveMatrix(this._bbProjectionMatrix, r / x);
                this.SetProjectionMatrix(this._bbProjectionMatrix);
                this._spDeviceTransformTextureFill && (y.useProgram(this._spDeviceTransformTextureFill.GetShaderProgram()), this._spDeviceTransformTextureFill._UpdateDeviceTransformUniforms(this._matP), this._lastProgram = this._spDeviceTransformTextureFill,
                    this._batchState.currentShader = this._spDeviceTransformTextureFill);
                y.bindTexture(y.TEXTURE_2D, null);
                y.activeTexture(y.TEXTURE1);
                y.bindTexture(y.TEXTURE_2D, null);
                y.activeTexture(y.TEXTURE0);
                this._lastTexture1 = this._lastTexture0 = null;
                this._usesDepthBuffer && this._isAutoSizeDepthBuffer && this._SetDepthBufferSize(this._width, this._height);
                this._currentRenderTarget && this._currentRenderTarget._Resize(this._width, this._height);
                y.bindFramebuffer(y.FRAMEBUFFER, null);
                this._currentRenderTarget = null;
                E.currentFramebuffer =
                    null;
                E.currentFramebufferNoDepth = null
            }
        }
        _SetDepthBufferSize(r, x) {
            const y = this._gl;
            this._depthBuffer && this._depthBufferWidth === r && this._depthBufferHeight === x || (this._canSampleDepth ? (this._depthBuffer && y.deleteTexture(this._depthBuffer), this._depthBuffer = y.createTexture(), y.bindTexture(y.TEXTURE_2D, this._depthBuffer), y.texParameteri(y.TEXTURE_2D, y.TEXTURE_MAG_FILTER, y.NEAREST), y.texParameteri(y.TEXTURE_2D, y.TEXTURE_MIN_FILTER, y.NEAREST), y.texParameteri(y.TEXTURE_2D, y.TEXTURE_WRAP_S, y.CLAMP_TO_EDGE),
                y.texParameteri(y.TEXTURE_2D, y.TEXTURE_WRAP_T, y.CLAMP_TO_EDGE), 2 <= this.GetWebGLVersionNumber() ? y.texImage2D(y.TEXTURE_2D, 0, y.DEPTH24_STENCIL8, r, x, 0, y.DEPTH_STENCIL, y.UNSIGNED_INT_24_8, null) : this._depthTextureExt && y.texImage2D(y.TEXTURE_2D, 0, y.DEPTH_STENCIL, r, x, 0, y.DEPTH_STENCIL, this._depthTextureExt.UNSIGNED_INT_24_8_WEBGL, null), y.bindTexture(y.TEXTURE_2D, null)) : (this._depthBuffer && y.deleteRenderbuffer(this._depthBuffer), this._depthBuffer = y.createRenderbuffer(), y.bindRenderbuffer(y.RENDERBUFFER, this._depthBuffer),
                y.renderbufferStorage(y.RENDERBUFFER, 2 <= this._version ? y.DEPTH24_STENCIL8 : y.DEPTH_STENCIL, r, x), y.bindRenderbuffer(y.RENDERBUFFER, null)), this._depthBufferWidth = r, this._depthBufferHeight = x)
        }
        SetFixedSizeDepthBuffer(r, x) {
            this._usesDepthBuffer && (this._isAutoSizeDepthBuffer = !1, this._SetDepthBufferSize(r, x))
        }
        SetAutoSizeDepthBuffer() {
            this._usesDepthBuffer && (this._isAutoSizeDepthBuffer = !0, this._SetDepthBufferSize(this._width, this._height))
        }
        _SetViewport(r, x, y, E) {
            const G = this._viewport;
            if (G[0] !== r || G[1] !== x ||
                G[2] !== y || G[3] !== E) this.PushBatch().InitSetViewport(r, x, y, E), b.set(G, r, x, y, E), this._topOfBatch = 0
        }
        SetProjectionMatrix(r) {
            d.exactEquals(this._matP, r) || (this.PushBatch().InitSetProjection(r), d.copy(this._matP, r), this._topOfBatch = 0, this._didChangeTransform = !0)
        }
        SetDefaultRenderTargetProjectionState() {
            let r, x;
            var y = this._currentRenderTarget;
            null === y ? (r = this._bbProjectionMatrix, x = this.GetWidth(), y = this.GetHeight()) : (r = y.GetProjectionMatrix(), x = y.GetWidth(), y = y.GetHeight());
            this.SetProjectionMatrix(r);
            this._SetViewport(0,
                0, x, y)
        }
        SetModelViewMatrix(r) {
            d.exactEquals(this._matMV, r) || (this.PushBatch().InitSetModelView(r), d.copy(this._matMV, r), this._topOfBatch = 0, this._didChangeTransform = !0)
        }
        ResetDidChangeTransformFlag() {
            this._didChangeTransform = !1
        }
        DidChangeTransform() {
            return this._didChangeTransform
        }
        GetBatchState() {
            return this._batchState
        }
        PushBatch() {
            const r = this._batch;
            this._batchPtr === r.length && r.push(new e.Gfx.WebGLBatchJob(this._batchState));
            return r[this._batchPtr++]
        }
        EndBatch() {
            0 === this._batchPtr || this.IsContextLost() ||
                (this._WriteBuffers(), this._ExecuteBatch(), this._topOfBatch = this._pointPtr = this._texPtr = this._vertexPtr = this._batchPtr = 0)
        }
        _WriteBuffers() {
            const r = this._gl;
            0 < this._pointPtr && (r.bindBuffer(r.ARRAY_BUFFER, this._pointBuffer), r.bufferSubData(r.ARRAY_BUFFER, 0, this._pointData.subarray(0, this._pointPtr)));
            0 < this._vertexPtr && (r.bindBuffer(r.ARRAY_BUFFER, this._vertexBuffer), r.bufferSubData(r.ARRAY_BUFFER, 0, this._vertexData.subarray(0, this._vertexPtr)), r.bindBuffer(r.ARRAY_BUFFER, this._texcoordBuffer), r.bufferSubData(r.ARRAY_BUFFER,
                0, this._texcoordData.subarray(0, this._texPtr)))
        }
        _ExecuteBatch() {
            const r = this._batch;
            for (let x = 0, y = this._batchPtr; x < y; ++x) r[x].Run()
        }
        GetOpacity() {
            return this._lastColor.getA()
        }
        SetColorRgba(r, x, y, E) {
            const G = this._lastColor;
            G.equalsRgba(r, x, y, E) || (G.setRgba(r, x, y, E), this.PushBatch().InitSetColor(G), this._topOfBatch = 0, this._currentStateGroup = null)
        }
        SetOpacity(r) {
            const x = this._lastColor;
            x.getA() !== r && (x.setA(r), this.PushBatch().InitSetColor(x), this._topOfBatch = 0, this._currentStateGroup = null)
        }
        SetColor(r) {
            const x =
                this._lastColor;
            x.equals(r) || (x.set(r), this.PushBatch().InitSetColor(x), this._topOfBatch = 0, this._currentStateGroup = null)
        }
        ResetColor() {
            this.SetColorRgba(1, 1, 1, 1)
        }
        GetColor() {
            return this._lastColor
        }
        SetTexture(r) {
            r !== this._lastTexture0 && (this.PushBatch().InitSetTexture(r), this._lastTexture0 = r, this._topOfBatch = 0)
        }
        _ResetLastTexture() {
            this._lastTexture0 = null
        }
        SetBlendMode(r) {
            r = this._GetBlendByIndex(r);
            this._SetBlend(r[0], r[1])
        }
        SetNamedBlendMode(r) {
            r = this.GetNamedBlend(r);
            this._SetBlend(r.srcBlend, r.destBlend)
        }
        _SetBlend(r,
            x) {
            if (r !== this._lastSrcBlend || x !== this._lastDestBlend) this.PushBatch().InitSetBlend(r, x), this._lastSrcBlend = r, this._lastDestBlend = x, this._topOfBatch = 0, this._currentStateGroup = null
        }
        IsPremultipliedAlphaBlend() {
            return this._lastSrcBlend === this._gl.ONE && this._lastDestBlend === this._gl.ONE_MINUS_SRC_ALPHA
        }
        SetAlphaBlend() {
            this._SetBlend(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA)
        }
        SetNoPremultiplyAlphaBlend() {
            this._SetBlend(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA)
        }
        SetCopyBlend() {
            this._SetBlend(this._gl.ONE,
                this._gl.ZERO)
        }
        Rect(r) {
            this.Rect2(r.getLeft(), r.getTop(), r.getRight(), r.getBottom())
        }
        Rect2(r, x, y, E) {
            this.Quad2(r, x, y, x, y, E, r, E)
        }
        _ExtendQuadBatch() {
            let r = this._vertexPtr;
            r >= this._lastVertexPtr && (this.EndBatch(), r = 0);
            1 === this._topOfBatch ? this._batch[this._batchPtr - 1]._indexCount += 6 : (this.PushBatch().InitQuad(r, 6), this._topOfBatch = 1)
        }
        _WriteQuadToVertexBuffer(r) {
            r.writeToTypedArray3D(this._vertexData, this._vertexPtr, this._baseZ + this._currentZ);
            this._vertexPtr += 12
        }
        Quad(r) {
            this._ExtendQuadBatch();
            this._WriteQuadToVertexBuffer(r);
            k.writeToTypedArray(this._texcoordData, this._texPtr);
            this._texPtr += 8
        }
        Quad2(r, x, y, E, G, A, F, J) {
            this._ExtendQuadBatch();
            const B = this._vertexData;
            let I = this._vertexPtr;
            const L = this._baseZ + this._currentZ;
            B[I++] = r;
            B[I++] = x;
            B[I++] = L;
            B[I++] = y;
            B[I++] = E;
            B[I++] = L;
            B[I++] = G;
            B[I++] = A;
            B[I++] = L;
            B[I++] = F;
            B[I++] = J;
            B[I++] = L;
            this._vertexPtr = I;
            k.writeToTypedArray(this._texcoordData, this._texPtr);
            this._texPtr += 8
        }
        Quad3(r, x) {
            this._ExtendQuadBatch();
            this._WriteQuadToVertexBuffer(r);
            x.writeAsQuadToTypedArray(this._texcoordData,
                this._texPtr);
            this._texPtr += 8
        }
        Quad4(r, x) {
            this._ExtendQuadBatch();
            this._WriteQuadToVertexBuffer(r);
            x.writeToTypedArray(this._texcoordData, this._texPtr);
            this._texPtr += 8
        }
        Quad3D(r, x, y, E, G, A, F, J, B, I, L, P, S) {
            this._ExtendQuadBatch();
            const U = this._vertexData;
            let V = this._vertexPtr;
            const Z = this._baseZ + this._currentZ;
            U[V++] = r;
            U[V++] = x;
            U[V++] = Z + y;
            U[V++] = E;
            U[V++] = G;
            U[V++] = Z + A;
            U[V++] = F;
            U[V++] = J;
            U[V++] = Z + B;
            U[V++] = I;
            U[V++] = L;
            U[V++] = Z + P;
            this._vertexPtr = V;
            S.writeAsQuadToTypedArray(this._texcoordData, this._texPtr);
            this._texPtr +=
                8
        }
        Quad3D2(r, x, y, E, G, A, F, J, B, I, L, P, S) {
            this._ExtendQuadBatch();
            const U = this._vertexData;
            let V = this._vertexPtr;
            const Z = this._baseZ + this._currentZ;
            U[V++] = r;
            U[V++] = x;
            U[V++] = Z + y;
            U[V++] = E;
            U[V++] = G;
            U[V++] = Z + A;
            U[V++] = F;
            U[V++] = J;
            U[V++] = Z + B;
            U[V++] = I;
            U[V++] = L;
            U[V++] = Z + P;
            this._vertexPtr = V;
            S.writeToTypedArray(this._texcoordData, this._texPtr);
            this._texPtr += 8
        }
        FullscreenQuad(r, x) {
            d.copy(h, this._matP);
            d.copy(l, this._matMV);
            this.SetDefaultRenderTargetProjectionState();
            const [y, E] = this.GetRenderTargetSize(this._currentRenderTarget);
            var G = this.CalculateLookAtModelView2(0, 0, this.GetDefaultCameraZ() * self.devicePixelRatio, 0, 0, 0, E);
            this.SetModelViewMatrix(G);
            if ("crop" === r && this._currentRenderTarget && x) {
                r = this._width / 2;
                G = this._height / 2;
                const J = x.GetWidth();
                x = x.GetHeight();
                var A = this._currentRenderTarget.GetWidth(),
                    F = this._currentRenderTarget.GetHeight();
                A = Math.min(A, J);
                const B = Math.min(F, x),
                    I = Math.max(x - F, 0);
                F = Math.max(F - x, 0);
                u.set(-r, G - F, -r + A, G - B - F);
                n.setFromRect(u);
                u.set(0, I, A, B + I);
                u.divide(J, x);
                this.Quad3(n, u)
            } else r = y / 2, G = E / 2,
                this.Rect2(-r, G, r, -G);
            this.SetProjectionMatrix(h);
            this.SetModelViewMatrix(l)
        }
        StartRenderingPoints(r) {
            this._lastPointTexCoords.equals(r) || (this._lastPointTexCoords.copy(r), this.PushBatch().InitSetPointTexCoords(r), this._topOfBatch = 0)
        }
        FinishRenderingPoints() {}
        Point(r, x, y, E) {
            7996 <= this._pointPtr && this.EndBatch();
            let G = this._pointPtr;
            var A = this._baseZ + this._currentZ;
            2 === this._topOfBatch && this._lastPointZ === A ? this._batch[this._batchPtr - 1]._indexCount++ : (this.PushBatch().InitPoints(G, A), this._topOfBatch =
                2, this._lastPointZ = A);
            A = this._pointData;
            A[G++] = r;
            A[G++] = x;
            A[G++] = y;
            A[G++] = E;
            this._pointPtr = G
        }
        SetProgram(r) {
            this._lastProgram !== r && (this.PushBatch().InitSetProgram(r), this._lastProgram = r, this._topOfBatch = 0, this._currentStateGroup = null)
        }
        SetDeviceTransformTextureFillMode() {
            this.SetProgram(this._spDeviceTransformTextureFill)
        }
        SetGradientColor(r) {
            this.PushBatch().InitSetGradientColor(r);
            this._topOfBatch = 0
        }
        SetEllipseParams(r, x, y = 1) {
            this.PushBatch().InitSetEllipseParams(r, x, y);
            this._topOfBatch = 0
        }
        SetTilemapInfo(r,
            x, y, E, G, A, F) {
            if (this._lastProgram !== this._spTilemapFill) throw Error("must set tilemap fill mode first");
            this.PushBatch().InitSetTilemapInfo(r, x, y, E, G, A, F);
            this._topOfBatch = 0
        }
        SetProgramParameters(r, x, y, E, G, A, F, J, B, I, L, P) {
            const S = this._lastProgram;
            var U = S._hasAnyOptionalUniforms;
            const V = !!P.length;
            if (U && !S.AreOptionalUniformsAlreadySetInBatch(x, y, E, G, A, F, J, B, I, L) || V && !S.AreCustomParametersAlreadySetInBatch(P)) {
                var Z = this.PushBatch();
                Z.InitSetProgramParameters();
                U && (S.SetOptionalUniformsInBatch(x, y,
                    E, G, A, F, J, B, I, L), U = Z._mat4param, U[0] = A, U[1] = F, x.writeToTypedArray(U, 2), U[6] = B, U[7] = I, y.writeToTypedArray(U, 12), x = Z._colorParam, G.writeToTypedArray(x, 0), G = x[1], x[1] = x[3], x[3] = G, E.writeToTypedArray(Z._srcOriginRect, 0), Z._startIndex = L, Z._indexCount = J, S._uSamplerBack.IsUsed() ? Z._texParam = r ? r.GetTexture() : null : Z._texParam = null);
                V && (S.SetCustomParametersInBatch(P), e.shallowAssignArray(Z._shaderParams, P));
                this._topOfBatch = 0
            }
        }
        ClearRgba(r, x, y, E) {
            this.PushBatch().InitClearSurface2(r, x, y, E);
            this._topOfBatch =
                0
        }
        Clear(r) {
            this.PushBatch().InitClearSurface(r);
            this._topOfBatch = 0
        }
        Start() {}
        Finish() {
            super.Finish();
            this._gl.flush()
        }
        ClearDepth() {
            this._usesDepthBuffer && this._currentRenderTarget && this._currentRenderTarget.HasDepthBuffer() && (this.PushBatch().InitClearDepth(this._isDepthEnabled), this._topOfBatch = 0)
        }
        SetDepthEnabled(r) {
            r = !!r;
            this._isDepthEnabled !== r && this._usesDepthBuffer && (this._isDepthEnabled = r, this.PushBatch().InitSetDepthEnabled(r), this._topOfBatch = 0)
        }
        IsDepthEnabled() {
            return this._isDepthEnabled
        }
        _GetDepthBuffer() {
            return this._depthBuffer
        }
        _CanSampleDepth() {
            return this._canSampleDepth
        }
        SetDepthSamplingEnabled(r) {
            r = !!r;
            if (this._canSampleDepth && this._isDepthSamplingEnabled !== r) {
                if (r && this.IsDepthEnabled()) throw Error("depth still enabled");
                this._isDepthSamplingEnabled = r;
                this.PushBatch().InitSetDepthSamplingEnabled(r);
                this._topOfBatch = 0
            }
        }
        CheckForQueryResults() {
            for (const r of this._allQueryResultBuffers) r.CheckForResults(this._frameNumber)
        }
        IsContextLost() {
            return !this._gl || this._gl.isContextLost() || this._isInitialisingAfterContextRestored
        }
        OnContextLost() {
            super.OnDeviceOrContextLost();
            e.Gfx.WebGLRendererTexture.OnContextLost();
            e.Gfx.WebGLRenderTarget.OnContextLost();
            e.Gfx.RendererText.OnContextLost();
            for (const r of this._allQueryResultBuffers) r.Clear();
            this._extensions = [];
            this._depthTextureExt = this._anisotropicExt = this._parallelShaderCompileExt = this._timerExt = null;
            this._maxAnisotropy = 0;
            this._unmaskedRenderer = this._unmaskedVendor = "(unavailable)";
            this._depthBuffer = this._spDeviceTransformTextureFill = this._lastProgram = null;
            for (const r of this._stateGroups.values()) r.OnContextLost()
        }
        async OnContextRestored() {
            this._isInitialisingAfterContextRestored = !0;
            await this.InitState();
            this._isInitialisingAfterContextRestored = !1;
            for (const r of this._stateGroups.values()) r.OnContextRestored(this);
            this.SetSize(this._width, this._height, !0)
        }
        CreateStaticTexture(r, x) {
            if (this.IsContextLost()) throw Error("context lost");
            this.EndBatch();
            const y = e.New(e.Gfx.WebGLRendererTexture, this);
            y._CreateStatic(r, x);
            return y
        }
        CreateStaticTextureAsync(r, x) {
            if (this.IsContextLost()) return Promise.reject("context lost");
            x = Object.assign({}, x);
            const y = x.wrapX && "clamp-to-edge" !== x.wrapX ||
                x.wrapY && "clamp-to-edge" !== x.wrapY;
            if (!e.Supports.ImageBitmapOptions || !this.SupportsNPOTTextures() && y) return e.Supports.ImageBitmap ? createImageBitmap(r).then(E => e.Asyncify(() => this.CreateStaticTexture(E, x))) : r instanceof Blob ? e.BlobToImage(r, !0).then(E => this.CreateStaticTextureAsync(E, x)) : "undefined" !== typeof HTMLImageElement && r instanceof HTMLImageElement && "function" === typeof r.decode ? r.decode().then(() => e.Asyncify(() => this.CreateStaticTexture(r, x))) : e.Asyncify(() => this.CreateStaticTexture(r, x));
            x.premultiplyAlpha = !1;
            return createImageBitmap(r, {
                premultiplyAlpha: "premultiply"
            }).then(E => e.Asyncify(() => this.CreateStaticTexture(E, x)))
        }
        CreateDynamicTexture(r, x, y) {
            this.EndBatch();
            const E = e.New(e.Gfx.WebGLRendererTexture, this);
            E._CreateDynamic(r, x, y);
            return E
        }
        UpdateTexture(r, x, y) {
            this.EndBatch();
            x._Update(r, y)
        }
        DeleteTexture(r) {
            r && (r.SubtractReference(), 0 < r.GetReferenceCount() || (this.EndBatch(), r === this._lastTexture0 && (this._gl.bindTexture(this._gl.TEXTURE_2D, null), this._lastTexture0 = null), r === this._lastTexture1 &&
                (this._gl.activeTexture(this._gl.TEXTURE1), this._gl.bindTexture(this._gl.TEXTURE_2D, null), this._gl.activeTexture(this._gl.TEXTURE0), this._lastTexture1 = null), r._Delete()))
        }
        CreateRenderTarget(r) {
            let x = this._width,
                y = this._height,
                E = !0;
            r && ("number" === typeof r.width && (x = r.width, E = !1), "number" === typeof r.height && (y = r.height, E = !1));
            if (0 >= x || 0 >= y) throw Error("invalid size");
            this.EndBatch();
            const G = e.New(e.Gfx.WebGLRenderTarget, this);
            G._Create(x, y, Object.assign({
                isDefaultSize: E
            }, r));
            this._currentRenderTarget =
                null;
            this._batchState.currentFramebuffer = null;
            this._batchState.currentFramebufferNoDepth = null;
            return G
        }
        SetRenderTarget(r, x = !0) {
            r !== this._currentRenderTarget && (r && r.IsDefaultSize() && r._Resize(this._width, this._height), this.PushBatch().InitSetRenderTarget(r), this._currentRenderTarget = r, this._topOfBatch = 0, x && this.SetDefaultRenderTargetProjectionState())
        }
        GetRenderTarget() {
            return this._currentRenderTarget
        }
        GetRenderTargetSize(r) {
            return r ? [r.GetWidth(), r.GetHeight()] : [this._width, this._height]
        }
        CopyRenderTarget(r,
            x = "stretch") {
            2 > this._version || this._currentRenderTarget && 0 < this._currentRenderTarget.GetMultisampling() ? (this.SetCopyBlend(), this.ResetColor(), this.DrawRenderTarget(r, x)) : (this.PushBatch().InitBlitFramebuffer(r, this._currentRenderTarget, x), this._topOfBatch = 0)
        }
        DrawRenderTarget(r, x = "stretch") {
            r = r.GetTexture();
            if (!r) throw Error("not a texture-backed render target");
            this.SetTexture(r);
            this.FullscreenQuad(x, r)
        }
        InvalidateRenderTarget(r) {
            2 > this._version || (this.PushBatch().InitInvalidateFramebuffer(r._GetFramebuffer()),
                this._topOfBatch = 0)
        }
        DeleteRenderTarget(r) {
            this.SetRenderTarget(null);
            this.EndBatch();
            const x = r.GetTexture();
            x === this._lastTexture0 && (this._gl.bindTexture(this._gl.TEXTURE_2D, null), this._lastTexture0 = null);
            x === this._lastTexture1 && (this._gl.activeTexture(this._gl.TEXTURE1), this._gl.bindTexture(this._gl.TEXTURE_2D, null), this._gl.activeTexture(this._gl.TEXTURE0), this._lastTexture1 = null);
            r._Delete()
        }
        async ReadBackRenderTargetToImageData(r, x, y) {
            this.EndBatch();
            const E = this._currentRenderTarget;
            if (r) {
                var G =
                    r.GetWidth();
                var A = r.GetHeight();
                var F = r._GetFramebuffer()
            } else G = this.GetWidth(), A = this.GetHeight(), F = null;
            let J = r = 0;
            var B = G,
                I = A;
            y && (r = e.clamp(Math.floor(y.getLeft()), 0, G - 1), J = e.clamp(Math.floor(y.getTop()), 0, A - 1), B = y.width(), B = 0 === B ? G - r : e.clamp(Math.floor(B), 0, G - r), I = y.height(), I = 0 === I ? A - J : e.clamp(Math.floor(I), 0, A - J), J = A - (J + I));
            const L = this._gl;
            L.bindFramebuffer(L.FRAMEBUFFER, F);
            A = () => {
                L.bindFramebuffer(L.FRAMEBUFFER, null);
                this._currentRenderTarget = null;
                this._batchState.currentFramebuffer = null;
                this._batchState.currentFramebufferNoDepth = null;
                this.SetRenderTarget(E)
            };
            if (!x && 2 <= this.GetWebGLVersionNumber()) {
                L.bindFramebuffer(L.READ_FRAMEBUFFER, F);
                F = L.createBuffer();
                y = B * I * 4;
                G = L.PIXEL_PACK_BUFFER;
                L.bindBuffer(G, F);
                L.bufferData(G, y, L.STREAM_READ);
                L.readPixels(r, J, B, I, L.RGBA, L.UNSIGNED_BYTE, 0);
                L.bindFramebuffer(L.READ_FRAMEBUFFER, null);
                L.bindBuffer(G, null);
                A();
                const P = L.fenceSync(L.SYNC_GPU_COMMANDS_COMPLETE, 0);
                await this._WaitForObjectReady(() => L.getSyncParameter(P, L.SYNC_STATUS) === L.SIGNALED);
                L.deleteSync(P);
                x = new ImageData(B, I);
                L.bindBuffer(G, F);
                L.getBufferSubData(G, 0, new Uint8Array(x.data.buffer), 0, y);
                L.bindBuffer(G, null);
                L.deleteBuffer(F)
            } else x = new ImageData(B, I), L.readPixels(r, J, B, I, L.RGBA, L.UNSIGNED_BYTE, new Uint8Array(x.data.buffer)), A();
            return x
        }
        CoplanarStartStencilPass() {
            this.SetDepthEnabled(!0);
            this.PushBatch().InitCoplanarStartStencilPass();
            this._topOfBatch = 0
        }
        CoplanarStartColorPass() {
            this.SetDepthEnabled(!1);
            this.PushBatch().InitCoplanarStartColorPass();
            this._topOfBatch = 0
        }
        CoplanarRestoreStandardRendering() {
            this.SetDepthEnabled(!0);
            this.PushBatch().InitCoplanarRestore();
            this._topOfBatch = 0
        }
        StartQuery(r) {
            this.SupportsGPUProfiling() && (this.PushBatch().InitStartQuery(r), this._topOfBatch = 0)
        }
        EndQuery(r) {
            this.SupportsGPUProfiling() && (this.PushBatch().InitEndQuery(r), this._topOfBatch = 0)
        }
        _WaitForObjectReady(r) {
            const x = new Promise(y => q.add({
                resolve: y,
                checkFunc: r
            })); - 1 === t && (t = self.requestAnimationFrame(p));
            return x
        }
        IsDesynchronized() {
            return !!this._attribs.desynchronized
        }
        GetEstimatedBackBufferMemoryUsage() {
            return this._width * this._height *
                (this._attribs.alpha ? 4 : 3)
        }
        GetEstimatedRenderBufferMemoryUsage() {
            let r = 0;
            for (const x of e.Gfx.WebGLRenderTarget.allRenderTargets()) x.GetTexture() || (r += x.GetEstimatedMemoryUsage());
            return r
        }
        GetEstimatedTextureMemoryUsage() {
            let r = 0;
            for (const x of e.Gfx.WebGLRendererTexture.allTextures()) r += x.GetEstimatedMemoryUsage();
            return r
        }
        GetEstimatedTotalMemoryUsage() {
            return this.GetEstimatedBackBufferMemoryUsage() + this.GetEstimatedRenderBufferMemoryUsage() + this.GetEstimatedTextureMemoryUsage()
        }
        GetWebGLVersionString() {
            return this._versionString
        }
        GetWebGLVersionNumber() {
            return this._version
        }
        GetDisplayName() {
            return "webgl" +
                this.GetWebGLVersionNumber()
        }
        SupportsNPOTTextures() {
            return 2 <= this.GetWebGLVersionNumber()
        }
        GetMaxTextureSize() {
            return this._maxTextureSize
        }
        GetMinPointSize() {
            return this._minPointSize
        }
        GetMaxPointSize() {
            return this._maxPointSize
        }
        SupportsHighP() {
            return 0 !== this._highpPrecision
        }
        GetHighPPrecision() {
            return this._highpPrecision
        }
        GetUnmaskedVendor() {
            return this._unmaskedVendor
        }
        GetUnmaskedRenderer() {
            return this._unmaskedRenderer
        }
        GetExtensions() {
            return this._extensions
        }
        SupportsGPUProfiling() {
            return !!this._timerExt
        }
        _GetDisjointTimerQueryExtension() {
            return this._timerExt
        }
        _GetParallelShaderCompileExtension() {
            return this._parallelShaderCompileExt
        }
        _GetAnisotropicExtension() {
            return this._anisotropicExt
        }
        _GetMaxAnisotropy() {
            return this._maxAnisotropy
        }
        _AddQueryResultBuffer(r) {
            this._allQueryResultBuffers.add(r)
        }
        _RemoveQueryResultBuffer(r) {
            this._allQueryResultBuffers.delete(r)
        }
        _GetTimeQueryStack() {
            return this._timeQueryStack
        }
        GetContext() {
            return this._gl
        }
        _InitBlendModes(r) {
            this._InitBlendModeData([
                ["normal",
                    r.ONE, r.ONE_MINUS_SRC_ALPHA
                ],
                ["additive", r.ONE, r.ONE],
                ["xor", r.ONE, r.ONE_MINUS_SRC_ALPHA],
                ["copy", r.ONE, r.ZERO],
                ["destination-over", r.ONE_MINUS_DST_ALPHA, r.ONE],
                ["source-in", r.DST_ALPHA, r.ZERO],
                ["destination-in", r.ZERO, r.SRC_ALPHA],
                ["source-out", r.ONE_MINUS_DST_ALPHA, r.ZERO],
                ["destination-out", r.ZERO, r.ONE_MINUS_SRC_ALPHA],
                ["source-atop", r.DST_ALPHA, r.ONE_MINUS_SRC_ALPHA],
                ["destination-atop", r.ONE_MINUS_DST_ALPHA, r.SRC_ALPHA]
            ])
        }
        CreateRendererText() {
            return e.New(e.Gfx.RendererText, this)
        }
        CreateWebGLText() {
            return this.CreateRendererText()
        }
    }
} {
    "use strict";
    const e = {
        getDrawSize: null,
        getRenderTarget: null,
        releaseRenderTarget: null,
        getTime: null,
        redraw: null
    };
    self.C3.Gfx.EffectChainManager = class {
        constructor(a) {
            a = Object.assign({}, e, a);
            this._cbGetDrawSize = a.getDrawSize;
            this._cbGetRenderTarget = a.getRenderTarget;
            this._cbReleaseRenderTarget = a.releaseRenderTarget;
            this._cbGetTime = a.getTime;
            this._cbRedraw = a.redraw
        }
        GetDrawSize(a) {
            return this._cbGetDrawSize ? this._cbGetDrawSize(a) : [a.GetWidth(), a.GetHeight()]
        }
        GetRenderTarget(a) {
            return this._cbGetRenderTarget(a)
        }
        ReleaseRenderTarget(a,
            b) {
            this._cbReleaseRenderTarget(a, b)
        }
        GetTime() {
            return this._cbGetTime()
        }
        Redraw(a) {
            this._cbRedraw(a)
        }
    }
} {
    "use strict";
    const e = self.C3,
        a = self.glMatrix.mat4,
        b = e.New(e.Rect),
        d = e.New(e.Rect),
        c = e.New(e.Rect),
        f = e.New(e.Rect),
        k = a.create(),
        h = a.create(),
        l = {
            drawContent: null,
            getSourceTextureInfo: null,
            getShaderParameters: null,
            invalidateRenderTargets: !1
        },
        n = {
            indexMap: null,
            forcePreDraw: !1,
            forcePostDraw: !1,
            is3D: !1,
            isSourceTextureRotated: !1,
            isRotatedOrNegativeSizeInstance: !1,
            useFullSurface: !1
        },
        u = {
            contentObject: null,
            contextObject: null,
            blendMode: 0,
            devicePixelRatio: 1,
            layerScale: 1,
            layerAngle: 0,
            layoutRect: null,
            drawSurfaceRect: null,
            drawContentHook: null,
            compositOffX: 0,
            compositOffY: 0,
            updateOwnProjection: !1
        };
    e.Gfx.EffectChain = class {
        constructor(w, q) {
            q = Object.assign({}, l, q);
            this._manager = w;
            this._cbDrawContent = q.drawContent;
            this._cbGetSourceTextureInfo = q.getSourceTextureInfo;
            this._cbGetShaderParameters = q.getShaderParameters;
            this._cbDrawContentHook = null;
            this._shaderProgramList = [];
            this._shaderProgramIndices = [];
            this._steps = [];
            this._blendMode = 0;
            this._isSourceTextureRotated = this._useFullSurface = this._canUseFastPath = this._depthEnabledAtStart =
                this._didChangeTransform = this._isAnyShaderDepthSampling = this._isAnyShaderAnimated = !1;
            this._numTempSurfacesRequired = 0;
            this._renderTargets = [null, null, null];
            this._invalidateRenderTargets = !!q.invalidateRenderTargets;
            this._drawHeight = this._drawWidth = this._boxExtendVertical = this._boxExtendHorizontal = 0;
            this._contextObject = this._contentObject = null;
            this._layoutRect = e.New(e.Rect);
            this._drawSurfaceRect = e.New(e.Rect);
            this._rcTexOriginal = e.New(e.Rect);
            this._rcTexBounce = e.New(e.Rect);
            this._rcTexDest = e.New(e.Rect);
            this._layerScale = this._devicePixelRatio = 1;
            this._time = this._layerAngle = 0;
            this._destRenderTarget = null;
            this._compositOffY = this._compositOffX = 0;
            this._updateOwnProjection = !1;
            this._projectionMatrix = a.create();
            this._modelViewMatrix = a.create()
        }
        Release() {
            e.clearArray(this._steps);
            e.clearArray(this._shaderProgramList);
            e.clearArray(this._shaderProgramIndices);
            this._cbGetShaderParameters = this._cbGetSourceTextureInfo = this._cbDrawContent = this._contextObject = this._contentObject = null
        }
        BuildSteps(w, q) {
            q = Object.assign({},
                n, q);
            e.clearArray(this._steps);
            this._boxExtendVertical = this._boxExtendHorizontal = 0;
            this._isAnyShaderDepthSampling = this._isAnyShaderAnimated = !1;
            this._numTempSurfacesRequired = 0;
            this._isSourceTextureRotated = !!q.isSourceTextureRotated;
            this._useFullSurface = !!q.useFullSurface;
            e.shallowAssignArray(this._shaderProgramList, w);
            if (0 !== w.length) {
                if (q.indexMap) {
                    if (q.indexMap.length !== w.length) throw Error("incorrect indexMap length");
                    e.shallowAssignArray(this._shaderProgramIndices, q.indexMap)
                } else {
                    e.clearArray(this._shaderProgramIndices);
                    for (let r = 0, x = w.length; r < x; ++r) this._shaderProgramIndices.push(r)
                }
                for (var t of w) this._boxExtendHorizontal += t.GetBoxExtendHorizontal(), this._boxExtendVertical += t.GetBoxExtendVertical(), t.IsAnimated() && (this._isAnyShaderAnimated = !0), t.UsesDepth() && (this._isAnyShaderDepthSampling = !0);
                if (1 !== w.length || w[0].BlendsBackground() || w[0].UsesCrossSampling() || !q.useFullSurface && w[0].ExtendsBox() || q.forcePreDraw || w[0].MustPreDraw() || q.forcePostDraw || q.is3D || !this._useFullSurface && w[0].UsesDepth()) {
                    this._canUseFastPath = !1;
                    t = this._ShouldPreDraw(w[0], q);
                    q = this._ShouldPostDraw(w.at(-1), q);
                    var p = 0;
                    t && (this._numTempSurfacesRequired = 1, this._steps.push(e.New(e.Gfx.EffectChain.Step.PreDraw, this, -1, 1)), p = 1);
                    for (let r = 0, x = w.length; r < x; ++r) 0 !== r || t ? (w = 1 === p ? 2 : 1, r !== x - 1 || q || (w = 0), this._numTempSurfacesRequired = Math.max(this._numTempSurfacesRequired, w), this._steps.push(e.New(e.Gfx.EffectChain.Step.Bounce, this, p, w, r)), p = w) : (this._numTempSurfacesRequired = 1, this._steps.push(e.New(e.Gfx.EffectChain.Step.FirstBounce, this, -1, 1, r)),
                        p = 1);
                    q && this._steps.push(e.New(e.Gfx.EffectChain.Step.PostDraw, this, p, 0))
                } else this._canUseFastPath = !0
            }
        }
        _ShouldPreDraw(w, q) {
            return q.forcePreDraw || q.is3D || !this._useFullSurface && w.UsesDepth() || w.MustPreDraw() || w.BlendsBackground() && (q.isRotatedOrNegativeSizeInstance || w.GetRenderer().IsWebGL() && q.isSourceTextureRotated) || 0 !== this._boxExtendHorizontal || 0 !== this._boxExtendVertical
        }
        _ShouldPostDraw(w, q) {
            return q.forcePostDraw || w.BlendsBackground() || w.UsesCrossSampling()
        }
        Render(w, q, t) {
            t = Object.assign({},
                u, t);
            w.IsWebGPU() && null === q && (q = w.GetBackbufferRenderTarget());
            this._destRenderTarget = q;
            this._contentObject = t.contentObject;
            this._contextObject = t.contextObject;
            this._blendMode = t.blendMode;
            this._devicePixelRatio = t.devicePixelRatio;
            this._layerScale = t.layerScale;
            this._layerAngle = t.layerAngle;
            this._time = this._manager.GetTime();
            this._didChangeTransform = !1;
            w.ResetDidChangeTransformFlag();
            this._isAnyShaderAnimated && this._Redraw();
            if (this._canUseFastPath) this._Render_FastPath(w, t);
            else {
                var [p, r] = this._manager.GetDrawSize(w);
                this._SetDrawSize(w, p, r);
                this._CalculateRectangles(t);
                w.ResetColor();
                w.SetBaseZ(0);
                w.SetCurrentZ(0);
                this._cbDrawContentHook = t.drawContentHook;
                this._compositOffX = t.compositOffX || 0;
                this._compositOffY = t.compositOffY || 0;
                this._updateOwnProjection = !!t.updateOwnProjection;
                this._OnBeforeStartEffectChain(w);
                this._renderTargets[0] = q;
                this._renderTargets[1] = 1 <= this._numTempSurfacesRequired ? this._GetRenderTarget() : null;
                this._renderTargets[2] = 2 === this._numTempSurfacesRequired ? this._GetRenderTarget() : null;
                for (const x of this._steps) q =
                    this._GetRenderTargetForId(x.GetSrcTargetId()), t = this._GetRenderTargetForId(x.GetDestTargetId()), w.IsWebGPU() ? x.Run_WebGPU(w, q, t) : x.Run_WebGL(w, q, t);
                this._renderTargets[1] && this._ReleaseRenderTarget(this._renderTargets[1]);
                this._renderTargets[2] && this._ReleaseRenderTarget(this._renderTargets[2]);
                this._renderTargets.fill(null);
                this._OnAfterEndEffectChain(w);
                this._cbDrawContentHook = this._contextObject = this._contentObject = this._destRenderTarget = null
            }
        }
        _SetDrawSize(w, q, t) {
            if (0 >= q || 0 >= t) throw Error("invalid draw size");
            this._drawWidth === q && this._drawHeight === t || this._CalculateDeviceTransformMatrices(w, q, t, 0, 0, this._projectionMatrix, this._modelViewMatrix);
            this._drawWidth = q;
            this._drawHeight = t
        }
        _CalculateDeviceTransformMatrices(w, q, t, p, r, x, y) {
            p = q / 2 + p;
            r = t / 2 + r;
            w.CalculatePerspectiveMatrix(x, q / t);
            w = w.CalculateLookAtModelView2(p, r, w.GetDefaultCameraZ() * self.devicePixelRatio, p, r, 0, t);
            a.copy(y, w)
        }
        _CalculateRectangles(w) {
            this._layoutRect.copy(w.layoutRect);
            w.drawSurfaceRect ? this._drawSurfaceRect.copy(w.drawSurfaceRect) : this._drawSurfaceRect.set(0,
                0, this._drawWidth, this._drawHeight);
            this._rcTexOriginal.copy(this._drawSurfaceRect);
            this._rcTexOriginal.divide(this._drawWidth, this._drawHeight);
            w = w.layerScale * w.devicePixelRatio;
            this._drawSurfaceRect.inflate(this._boxExtendHorizontal * w, this._boxExtendVertical * w);
            this._rcTexDest.copy(this._drawSurfaceRect);
            this._rcTexDest.divide(this._drawWidth, this._drawHeight);
            this._drawSurfaceRect.clamp(0, 0, this._drawWidth, this._drawHeight);
            this._rcTexBounce.copy(this._drawSurfaceRect);
            this._rcTexBounce.divide(this._drawWidth,
                this._drawHeight)
        }
        _OnBeforeStartEffectChain(w) {
            this._depthEnabledAtStart = w.IsDepthEnabled();
            this._useFullSurface && (w.SetDepthEnabled(!1), this._isAnyShaderDepthSampling && w.SetDepthSamplingEnabled(!0));
            w.IsWebGPU() && !this._useFullSurface && (b.copy(this._drawSurfaceRect), b.roundOuter(), w.SetScissorRect(b.getLeft(), b.getTop(), b.width(), b.height()))
        }
        _OnAfterEffectChainDrawContent(w) {
            w.ResetColor();
            this._useFullSurface || (w.SetDepthEnabled(!1), this._isAnyShaderDepthSampling && w.SetDepthSamplingEnabled(!0));
            w.IsWebGPU() && w.SetNormalizedCoordsProgramVariant(!0)
        }
        _OnAfterEndEffectChain(w) {
            w.SetDepthSamplingEnabled(!1);
            w.SetDepthEnabled(this._depthEnabledAtStart);
            w.IsWebGPU() && !this._useFullSurface && w.RemoveScissorRect();
            w.IsWebGPU() && w.SetNormalizedCoordsProgramVariant(!1);
            this._didChangeTransform = w.DidChangeTransform()
        }
        _ClampRcTexDest() {
            this._rcTexDest.clamp(0, 0, 1, 1)
        }
        _GetRenderTargetForId(w) {
            return 0 > w ? null : this._renderTargets[w]
        }
        _GetRenderTarget() {
            return this._manager.GetRenderTarget(this)
        }
        _GetDestRenderTarget() {
            return this._destRenderTarget
        }
        _ReleaseRenderTarget(w) {
            this._manager.ReleaseRenderTarget(w,
                this)
        }
        _GetShaderProgramAt(w) {
            return this._shaderProgramList[w]
        }
        _DrawContent(w) {
            this._cbDrawContentHook ? this._cbDrawContentHook(this, w, () => this._cbDrawContent(w, this)) : this._cbDrawContent(w, this);
            this._canUseFastPath || this._OnAfterEffectChainDrawContent(w)
        }
        _IsRenderTargetSameSizeAndOffset(w) {
            if (this._useFullSurface) return !0;
            if (0 !== this._compositOffX || 0 !== this._compositOffY) return !1;
            const [q, t] = w.GetRenderTargetSize(w.GetRenderTarget());
            return q !== this._drawWidth || t !== this._drawHeight ? !1 : !0
        }
        _SetDeviceTransform(w,
            q) {
            let t = this._projectionMatrix,
                p = this._modelViewMatrix;
            if (q && !this._IsRenderTargetSameSizeAndOffset(w)) {
                t = k;
                p = h;
                const [r, x] = w.GetRenderTargetSize(w.GetRenderTarget());
                this._CalculateDeviceTransformMatrices(w, r, x, this._compositOffX, this._compositOffY, t, p);
                w.IsWebGPU() && !this._useFullSurface && w.RemoveScissorRect()
            }
            w.SetProjectionMatrix(t);
            w.SetModelViewMatrix(p)
        }
        _Redraw() {
            this._manager.Redraw(this)
        }
        _GetShaderParameters(w) {
            return this._cbGetShaderParameters(this._shaderProgramIndices[w])
        }
        _SetProgramParameters(w,
            q) {
            let t = this._rcTexDest,
                p = this._rcTexBounce,
                r = this._rcTexOriginal;
            w.IsWebGL() && (d.copy(t), d.flipAround(1), t = d, c.copy(p), c.flipAround(1), p = c, f.copy(r), f.flipAround(1), r = f);
            this._DoSetProgramParameters(w, q, p, r, t, 1 / this._drawWidth, 1 / this._drawHeight)
        }
        _SetFirstBounceProgramParameters(w, q) {
            let t = this._rcTexBounce,
                p = this._rcTexOriginal,
                r = 1 / this._drawWidth,
                x = 1 / this._drawHeight;
            if (this._cbGetSourceTextureInfo) {
                let {
                    srcTexRect: E,
                    srcWidth: G,
                    srcHeight: A
                } = this._cbGetSourceTextureInfo(this._contentObject);
                E ||
                    (b.set(0, 0, 0, 0), E = b);
                G || (G = this._drawWidth);
                A || (A = this._drawHeight);
                p = t = E;
                r = 1 / G;
                x = 1 / A
            } else w.IsWebGL() && (c.copy(t), c.flipAround(1), t = c, f.copy(p), f.flipAround(1), p = f);
            let y = this._rcTexDest;
            w.IsWebGL() && (y = d, y.copy(this._rcTexDest), y.flipAround(1));
            this._DoSetProgramParameters(w, q, t, p, y, r, x);
            w.IsWebGPU() && this._shaderProgramList[0].BlendsBackground() && w.SetProgramParameter_IsSrcTexRotated(this._isSourceTextureRotated)
        }
        _DoSetProgramParameters(w, q, t, p, r, x, y) {
            q = this._GetShaderParameters(q);
            w.SetProgramParameters(this._destRenderTarget,
                r, t, p, this._layoutRect, x, y, this._devicePixelRatio, this._layerScale, this._layerAngle, this._time, q)
        }
        _Render_FastPath(w, q) {
            var t = this._shaderProgramList[0];
            const p = w.IsDepthEnabled(),
                r = t.UsesDepth();
            r && (w.SetDepthEnabled(!1), w.SetDepthSamplingEnabled(!0), this._rcTexDest.set(0, 0, 1, 1), this._rcTexOriginal.set(0, 0, 1, 1));
            w.SetProgram(t);
            w.SetBlendMode(this._blendMode);
            w.SetRenderTarget(this._destRenderTarget);
            let x;
            this._rcTexOriginal.set(0, 0, 1, 1);
            if (t.UsesAnySrcRectOrPixelSize() && this._cbGetSourceTextureInfo) {
                const {
                    srcTexRect: y,
                    srcWidth: E,
                    srcHeight: G
                } = this._cbGetSourceTextureInfo(this._contentObject);
                y && this._rcTexOriginal.copy(y);
                t = Number.isFinite(E) ? 1 / E : 0;
                x = Number.isFinite(G) ? 1 / G : 0
            } else {
                const [y, E] = this._manager.GetDrawSize(w);
                t = 1 / y;
                x = 1 / E
            }
            q.layoutRect ? this._layoutRect.copy(q.layoutRect) : this._layoutRect.set(0, 0, 0, 0);
            q = this._GetShaderParameters(0);
            w.SetProgramParameters(null, this._rcTexDest, this._rcTexOriginal, this._rcTexOriginal, this._layoutRect, t, x, this._devicePixelRatio, this._layerScale, this._layerAngle, this._time, q);
            w.SetBaseZ(0);
            this._DrawContent(w);
            r && (w.SetDepthSamplingEnabled(!1), w.SetDepthEnabled(p))
        }
        IsFastPath() {
            return this._canUseFastPath
        }
        UseFullSurface() {
            return this._useFullSurface
        }
        GetContentObject() {
            return this._contentObject
        }
        GetContextObject() {
            return this._contextObject
        }
        _GetBlendMode() {
            return this._blendMode
        }
        _UpdateOwnProjection() {
            return this._updateOwnProjection
        }
        DidChangeTransform() {
            return this._didChangeTransform
        }
        _GetDrawSurfaceRect() {
            return this._drawSurfaceRect
        }
        _GetRcTexBounce() {
            return this._rcTexBounce
        }
        _ShouldInvalidateRenderTargets() {
            return this._invalidateRenderTargets
        }
        async DebugLogRenderTargetContents(w,
            q, t) {}
    }
}
"use strict";
self.C3.Gfx.EffectChain.Step = class {
    constructor(e, a, b, d = -1) {
        this._effectChain = e;
        this._srcTargetId = a;
        this._destTargetId = b;
        this._index = d
    }
    GetEffectChain() {
        return this._effectChain
    }
    GetSrcTargetId() {
        return this._srcTargetId
    }
    GetDestTargetId() {
        return this._destTargetId
    }
    GetIndex() {
        return this._index
    }
    GetShaderProgram() {
        return this.GetEffectChain()._GetShaderProgramAt(this.GetIndex())
    }
    Run_WebGL(e, a, b) {}
    Run_WebGPU(e, a, b) {}
}; {
    "use strict";
    const e = self.C3;
    e.Gfx.EffectChain.Step.PreDraw = class extends e.Gfx.EffectChain.Step {
        constructor(a, b, d, c) {
            super(a, b, d, c)
        }
        Run_WebGL(a, b, d) {
            b = this.GetEffectChain();
            a.SetAlphaBlend();
            a.SetTextureFillMode();
            a.SetRenderTarget(d, b._UpdateOwnProjection());
            a.ClearRgba(0, 0, 0, 0);
            b._DrawContent(a);
            b._ClampRcTexDest()
        }
        Run_WebGPU(a, b, d) {
            b = this.GetEffectChain();
            a.SetAlphaBlend();
            a.SetTextureFillMode();
            a.SetRenderTarget(d, !1);
            a.ClearRgba(0, 0, 0, 0);
            b._DrawContent(a);
            b._ClampRcTexDest()
        }
    }
} {
    "use strict";
    const e = self.C3,
        a = e.New(e.Rect),
        b = e.New(e.Quad);
    e.Gfx.EffectChain.Step.PostDraw = class extends e.Gfx.EffectChain.Step {
        constructor(d, c, f, k) {
            super(d, c, f, k)
        }
        Run_WebGL(d, c, f) {
            const k = this.GetEffectChain();
            d.SetTextureFillMode();
            d.SetRenderTarget(f);
            k._SetDeviceTransform(d, !0);
            d.SetBlendMode(k._GetBlendMode());
            d.SetTexture(c.GetTexture());
            b.setFromRect(k._GetDrawSurfaceRect());
            a.copy(k._GetRcTexBounce());
            a.flipAround(1);
            d.Quad3(b, a);
            k._ShouldInvalidateRenderTargets() && d.InvalidateRenderTarget(c)
        }
        Run_WebGPU(d,
            c, f) {
            const k = this.GetEffectChain();
            d.SetTextureFillMode();
            d.SetRenderTarget(f, !1);
            k._IsRenderTargetSameSizeAndOffset(d) ? b.setFromRect(k._GetRcTexBounce()) : (d.SetNormalizedCoordsProgramVariant(!1), k._SetDeviceTransform(d, !0), b.setFromRect(k._GetDrawSurfaceRect()));
            d.SetBackTexture(null);
            d.SetBlendMode(k._GetBlendMode());
            d.SetTexture(c.GetTexture());
            k.UseFullSurface() ? d.FullscreenQuad() : d.Quad3(b, k._GetRcTexBounce())
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Gfx.EffectChain.Step.FirstBounce = class extends e.Gfx.EffectChain.Step {
        constructor(a, b, d, c) {
            super(a, b, d, c)
        }
        Run_WebGL(a, b, d) {
            b = this.GetEffectChain();
            a.SetRenderTarget(d, b._UpdateOwnProjection());
            a.ClearRgba(0, 0, 0, 0);
            a.SetCopyBlend();
            a.SetProgram(this.GetShaderProgram());
            b._SetFirstBounceProgramParameters(a, this.GetIndex());
            b._DrawContent(a);
            b._ClampRcTexDest()
        }
        Run_WebGPU(a, b, d) {
            b = this.GetEffectChain();
            a.SetRenderTarget(d, !1);
            a.ClearRgba(0, 0, 0, 0);
            a.SetCopyBlend();
            a.SetProgram(this.GetShaderProgram());
            b._SetFirstBounceProgramParameters(a, this.GetIndex());
            b._DrawContent(a);
            b._ClampRcTexDest()
        }
    }
} {
    "use strict";
    const e = self.C3,
        a = e.New(e.Rect),
        b = e.New(e.Quad);
    e.Gfx.EffectChain.Step.Bounce = class extends e.Gfx.EffectChain.Step {
        constructor(d, c, f, k) {
            super(d, c, f, k)
        }
        Run_WebGL(d, c, f) {
            const k = this.GetEffectChain();
            d.SetRenderTarget(f);
            (f = 0 === this.GetDestTargetId()) ? d.SetBlendMode(k._GetBlendMode()): (d.ClearRgba(0, 0, 0, 0), d.SetCopyBlend());
            d.SetProgram(this.GetShaderProgram());
            k._SetProgramParameters(d, this.GetIndex());
            d.SetTexture(c.GetTexture());
            k._SetDeviceTransform(d, f);
            b.setFromRect(k._GetDrawSurfaceRect());
            a.copy(k._GetRcTexBounce());
            a.flipAround(1);
            d.Quad3(b, a);
            k._ShouldInvalidateRenderTargets() && d.InvalidateRenderTarget(c)
        }
        Run_WebGPU(d, c, f) {
            const k = this.GetEffectChain();
            d.SetRenderTarget(f, !1);
            0 === this.GetDestTargetId() ? (d.SetBlendMode(k._GetBlendMode()), d.SetBackTexture(null), k._IsRenderTargetSameSizeAndOffset(d) ? b.setFromRect(k._GetRcTexBounce()) : (d.SetNormalizedCoordsProgramVariant(!1), k._SetDeviceTransform(d, !0), b.setFromRect(k._GetDrawSurfaceRect()))) : (d.ClearRgba(0, 0, 0, 0), d.SetCopyBlend(), b.setFromRect(k._GetRcTexBounce()));
            d.SetProgram(this.GetShaderProgram());
            k._SetProgramParameters(d, this.GetIndex());
            d.SetTexture(c.GetTexture());
            k.UseFullSurface() ? d.FullscreenQuad() : d.Quad3(b, k._GetRcTexBounce())
        }
    }
} {
    "use strict";
    const e = self.C3,
        a = self.C3X;
    let b = null;
    const d = new Set;

    function c(l, n) {
        const u = l[0] - n[0];
        return 0 !== u ? u : l[1] - n[1]
    }
    const f = [],
        k = [];
    let h = !1;
    self.IRuntime = class {
        constructor(l, n) {
            b = l;
            Object.defineProperties(this, {
                assets: {
                    value: b.GetAssetManager().GetIAssetManager(),
                    writable: !1
                },
                objects: {
                    value: n,
                    writable: !1
                },
                globalVars: {
                    value: {},
                    writable: !1
                },
                projectName: {
                    value: b.GetProjectName(),
                    writable: !1
                },
                projectVersion: {
                    value: b.GetProjectVersion(),
                    writable: !1
                },
                storage: {
                    value: new self.IStorage(b),
                    writable: !1
                },
                isInWorker: {
                    value: b.IsInWorker(),
                    writable: !1
                }
            });
            b.UserScriptDispatcher().addEventListener("keydown", u => {
                d.has(u.key) ? u.stopPropagation() : d.add(u.key)
            });
            b.UserScriptDispatcher().addEventListener("keyup", u => d.delete(u.key));
            b.Dispatcher().addEventListener("window-blur", () => d.clear());
            b.IsInWorker() && (self.alert = u => {
                h || (h = !0, console.warn("[Construct 3] alert() was called from a Web Worker, because the project 'Use worker' setting is enabled. This method is not normally available in a Web Worker. Construct has implemented the alert for you, but note that other features may be missing in worker mode. You may wish to disable 'Use worker', or use a more convenient function like console.log(). For more information please refer to the scripting section of the manual."));
                return this.alert(u)
            })
        }
        _InitGlobalVars(l) {
            Object.defineProperties(this.globalVars, l)
        }
        addEventListener(l, n) {
            b.UserScriptDispatcher().addEventListener(l, n)
        }
        removeEventListener(l, n) {
            b.UserScriptDispatcher().removeEventListener(l, n)
        }
        callFunction(l, ...n) {
            a.RequireString(l);
            const u = b.GetEventSheetManager(),
                w = u.GetFunctionBlockByName(l);
            if (!w) throw Error(`cannot find function name '${l}'`);
            if (!w.IsEnabled()) return w.GetDefaultReturnValue();
            if (n.length < w.GetFunctionParameterCount()) throw Error(`not enough function parameters passed for '${l}' (${n.length} passed, ${w.GetFunctionParameterCount()} expected)`);
            const q = w.GetEventBlock();
            l = null;
            var t = u.GetCurrentEvent();
            t && (t = t.GetSolModifiersIncludingParents(), 0 < t.length && (l = t, u.PushCleanSol(t)));
            n = q.RunAsExpressionFunctionCall(q.GetSolModifiersIncludingParents(), w.GetReturnType(), w.GetDefaultReturnValue(), ...n);
            l && u.PopSol(l);
            return n
        }
        setReturnValue(l) {
            const n = b.GetEventStack().GetCurrentExpFuncStackFrame();
            if (!n) throw Error("not in a function which returns a value");
            switch (n.GetFunctionReturnType()) {
                case 1:
                    "number" === typeof l && n.SetFunctionReturnValue(l);
                    break;
                case 2:
                    "string" === typeof l && n.SetFunctionReturnValue(l);
                    break;
                case 3:
                    "number" !== typeof l && "string" !== typeof l || n.SetFunctionReturnValue(l)
            }
        }
        get dt() {
            return b.GetDt()
        }
        get gameTime() {
            return b.GetGameTime()
        }
        get wallTime() {
            return b.GetWallTime()
        }
        random() {
            return b.Random()
        }
        get layout() {
            return b.GetMainRunningLayout().GetILayout()
        }
        getLayout(l) {
            const n = b.GetLayoutManager();
            if ("number" === typeof l || "string" === typeof l) l = n.GetLayout(l);
            else throw new TypeError("expected string or number");
            if (!l) throw Error("invalid layout");
            return l.GetILayout()
        }
        getAllLayouts() {
            return b.GetLayoutManager().GetAllLayouts().map(l => l.GetILayout())
        }
        goToLayout(l) {
            const n = b.GetLayoutManager();
            if ("number" === typeof l || "string" === typeof l) l = n.GetLayout(l);
            else throw new TypeError("expected string or number");
            if (!l) throw Error("invalid layout");
            n.IsPendingChangeMainLayout() || n.ChangeMainLayout(l)
        }
        get keyboard() {
            const l = b._GetCommonScriptInterfaces().keyboard;
            if (!l) throw Error("runtime.keyboard used but Keyboard object missing - add it to your project first");
            return l
        }
        get mouse() {
            const l = b._GetCommonScriptInterfaces().mouse;
            if (!l) throw Error("runtime.mouse used but Mouse object missing - add it to your project first");
            return l
        }
        get touch() {
            const l = b._GetCommonScriptInterfaces().touch;
            if (!l) throw Error("runtime.touch used but Touch object missing - add it to your project first");
            return l
        }
        invokeDownload(l, n) {
            a.RequireString(l);
            a.RequireString(n);
            b.InvokeDownload(l, n)
        }
        getInstanceByUid(l) {
            a.RequireFiniteNumber(l);
            return (l = b.GetInstanceByUID(l)) ? l.GetInterfaceClass() :
                null
        }
        sortZOrder(l, n) {
            a.RequireFunction(n);
            const u = b.GetCurrentLayout();
            for (var w of l) {
                l = b._UnwrapIWorldInstance(w);
                var q = l.GetWorldInfo();
                f.push([q.GetLayer().GetIndex(), q.GetZIndex()]);
                k.push(l)
            }
            if (0 !== f.length) {
                f.sort(c);
                k.sort((t, p) => n(t.GetInterfaceClass(), p.GetInterfaceClass()));
                w = !1;
                for (let t = 0, p = f.length; t < p; ++t) {
                    l = k[t];
                    q = u.GetLayerByIndex(f[t][0]);
                    const r = f[t][1],
                        x = q._GetInstances();
                    x[r] !== l && (x[r] = l, l.GetWorldInfo()._SetLayer(q), q.SetZIndicesChanged(), w = !0)
                }
                w && b.UpdateRender();
                e.clearArray(f);
                e.clearArray(k)
            }
        }
        alert(l) {
            return b.PostComponentMessageToDOMAsync("runtime", "alert", {
                message: l + (b.IsInWorker() ? " [via Web Worker]" : "")
            })
        }
    }
} {
    "use strict";
    const e = self.C3;
    let a = null;
    self.IAssetManager = class {
        constructor(b) {
            a = b;
            Object.defineProperties(this, {
                isWebMOpusSupported: {
                    value: a.IsAudioFormatSupported("audio/webm; codecs=opus"),
                    writable: !1
                }
            })
        }
        fetchText(b) {
            return a.FetchText(b)
        }
        fetchJson(b) {
            return a.FetchJson(b)
        }
        fetchBlob(b) {
            return a.FetchBlob(b)
        }
        fetchArrayBuffer(b) {
            return a.FetchArrayBuffer(b)
        }
        getProjectFileUrl(b) {
            return a.GetProjectFileUrl(b)
        }
        getMediaFileUrl(b) {
            e.IsRelativeURL(b) && (b = b.toLowerCase());
            return a.GetMediaFileUrl(b, a.GetMediaSubfolder())
        }
        get mediaFolder() {
            return a.GetMediaSubfolder()
        }
        async decodeWebMOpus(b,
            d) {
            if (this.isWebMOpusSupported) throw Error("decodeWebMOpus(): not supported because WebM Opus is supported by the platform");
            d = await a.GetRuntime()._WasmDecodeWebMOpus(d);
            d = new Float32Array(d);
            b = b.createBuffer(1, d.length, 48E3);
            b.getChannelData(0).set(d);
            return b
        }
        loadScripts(...b) {
            return a.LoadScripts(...b)
        }
        compileWebAssembly(b) {
            return a.CompileWebAssembly(b)
        }
        loadStyleSheet(b) {
            return a.LoadStyleSheet(b)
        }
    }
} {
    "use strict";
    const e = self.C3X;
    self.IStorage = class {
        constructor(a) {
            this._storage = a._GetProjectStorage()
        }
        getItem(a) {
            e.RequireString(a);
            return this._storage.getItem(a)
        }
        setItem(a, b) {
            e.RequireString(a);
            return this._storage.setItem(a, b)
        }
        removeItem(a) {
            e.RequireString(a);
            return this._storage.removeItem(a)
        }
        clear() {
            return this._storage.clear()
        }
        keys() {
            return this._storage.keys()
        }
    }
} {
    "use strict";
    const e = self.C3X,
        a = new WeakMap;
    self.IObjectClass = class {
        constructor(b) {
            a.set(this, b);
            Object.defineProperties(this, {
                name: {
                    value: b.GetName(),
                    writable: !1
                }
            });
            b.GetRuntime()._MapScriptInterface(this, b)
        }
        addEventListener(b, d) {
            e.RequireString(b);
            e.RequireFunction(d);
            a.get(this).UserScriptDispatcher().addEventListener(b, d)
        }
        removeEventListener(b, d) {
            e.RequireString(b);
            e.RequireFunction(d);
            a.get(this).UserScriptDispatcher().removeEventListener(b, d)
        }
        getAllInstances() {
            return a.get(this).GetInstances().map(b =>
                b.GetInterfaceClass())
        }
        getFirstInstance() {
            const b = a.get(this).GetInstances();
            return 0 < b.length ? b[0].GetInterfaceClass() : null
        }
        getPickedInstances() {
            return a.get(this).GetCurrentSol().GetInstances().map(b => b.GetInterfaceClass())
        }
        getFirstPickedInstance() {
            const b = a.get(this).GetCurrentSol().GetInstances();
            return 0 < b.length ? b[0].GetInterfaceClass() : null
        }* instances() {
            for (const b of a.get(this).GetInstances()) yield b.GetInterfaceClass()
        }* pickedInstances() {
            for (const b of a.get(this).GetCurrentSol().GetInstances()) yield b.GetInterfaceClass()
        }
        setInstanceClass(b) {
            e.RequireFunction(b);
            if (0 < a.get(this).GetInstanceCount()) throw Error("setInstanceClass() called too late, because instances have already been created - call in runOnStartup");
            a.get(this)._SetUserScriptInstanceClass(b)
        }
        createInstance(b, d, c, f) {
            e.RequireNumber(d);
            e.RequireNumber(c);
            if ("number" !== typeof b && "string" !== typeof b) throw new TypeError("invalid layer parameter");
            const k = a.get(this),
                h = k.GetRuntime();
            b = h.GetMainRunningLayout().GetLayer(b);
            if (!b) throw Error("invalid layer");
            d = h.CreateInstance(k, b, d, c, f);
            f && b.SortAndAddInstancesByZIndex(d);
            f = h.GetEventSheetManager();
            f.BlockFlushingInstances(!0);
            d._TriggerOnCreatedOnSelfAndRelated();
            f.BlockFlushingInstances(!1);
            return d.GetInterfaceClass()
        }
    }
} {
    "use strict";
    const e = self.C3X,
        a = new WeakMap;
    self.ILayout = class {
        constructor(b) {
            a.set(this, b);
            const d = [],
                c = b.GetEffectList(),
                f = c.GetAllEffectTypes().length;
            for (let k = 0; k < f; ++k) d.push(new self.IEffectInstance(c, k));
            Object.defineProperties(this, {
                name: {
                    value: b.GetName(),
                    writable: !1
                },
                index: {
                    value: b.GetIndex(),
                    writable: !1
                },
                effects: {
                    value: d,
                    writable: !1
                }
            })
        }
        addEventListener(b, d) {
            e.RequireString(b);
            e.RequireFunction(d);
            a.get(this).UserScriptDispatcher().addEventListener(b, d)
        }
        removeEventListener(b, d) {
            e.RequireString(b);
            e.RequireFunction(d);
            a.get(this).UserScriptDispatcher().removeEventListener(b, d)
        }
        get width() {
            return a.get(this).GetWidth()
        }
        set width(b) {
            a.get(this).SetWidth(b)
        }
        get height() {
            return a.get(this).GetHeight()
        }
        set height(b) {
            a.get(this).SetHeight(b)
        }
        set scale(b) {
            e.RequireFiniteNumber(b);
            a.get(this).SetScale(b)
        }
        get scale() {
            return a.get(this).GetScale()
        }
        set angle(b) {
            e.RequireFiniteNumber(b);
            a.get(this).SetAngle(b)
        }
        get angle() {
            return a.get(this).GetAngle()
        }
        set scrollX(b) {
            e.RequireNumber(b);
            a.get(this).SetScrollX(b)
        }
        get scrollX() {
            return a.get(this).GetScrollX()
        }
        set scrollY(b) {
            e.RequireNumber(b);
            a.get(this).SetScrollY(b)
        }
        get scrollY() {
            return a.get(this).GetScrollY()
        }
        scrollTo(b, d) {
            e.RequireNumber(b);
            e.RequireNumber(d);
            const c = a.get(this);
            c.SetScrollX(b);
            c.SetScrollY(d)
        }
        getLayer(b) {
            const d = a.get(this);
            if ("number" === typeof b || "string" === typeof b) b = d.GetLayer(b);
            else throw new TypeError("expected string or number");
            return b ? b.GetILayer() : null
        }
        getAllLayers() {
            return a.get(this).GetLayers().map(b => b.GetILayer())
        }
        setVanishingPoint(b, d) {
            e.RequireFiniteNumber(b);
            e.RequireFiniteNumber(d);
            a.get(this).SetVanishingPointXY(b,
                d)
        }
        getVanishingPoint() {
            return a.get(this)._GetVanishingPoint()
        }
        set projection(b) {
            e.RequireString(b);
            const d = a.get(this);
            if ("perspective" === b) d.SetPerspectiveProjection();
            else if ("orthographic" === b) d.SetOrthographicProjection();
            else throw Error("invalid projection");
        }
        get projection() {
            return a.get(this).IsOrthographicProjection() ? "orthographic" : "perspective"
        }
    }
} {
    "use strict";
    const e = self.C3,
        a = self.C3X,
        b = new WeakMap,
        d = new Map([
            ["normal", 0],
            ["additive", 1],
            ["copy", 3],
            ["destination-over", 4],
            ["source-in", 5],
            ["destination-in", 6],
            ["source-out", 7],
            ["destination-out", 8],
            ["source-atop", 9],
            ["destination-atop", 10]
        ]),
        c = new Map([...d.entries()].map(k => [k[1], k[0]])),
        f = e.New(e.Color);
    self.ILayer = class {
        constructor(k) {
            b.set(this, k);
            const h = [],
                l = k.GetEffectList(),
                n = l.GetAllEffectTypes().length;
            for (let u = 0; u < n; ++u) h.push(new self.IEffectInstance(l, u));
            Object.defineProperties(this, {
                name: {
                    value: k.GetName(),
                    writable: !1
                },
                index: {
                    value: k.GetIndex(),
                    writable: !1
                },
                layout: {
                    value: k.GetLayout().GetILayout(),
                    writable: !1
                },
                effects: {
                    value: h,
                    writable: !1
                }
            })
        }
        static _Unwrap(k) {
            return b.get(k)
        }
        get isVisible() {
            return b.get(this).IsVisible()
        }
        set isVisible(k) {
            b.get(this).SetVisible(k)
        }
        get opacity() {
            return b.get(this).GetOpacity()
        }
        set opacity(k) {
            k = e.clamp(+k, 0, 1);
            isNaN(k) || b.get(this).SetOpacity(k)
        }
        set scale(k) {
            a.RequireFiniteNumber(k);
            b.get(this).SetOwnScale(k)
        }
        get scale() {
            return b.get(this).GetOwnScale()
        }
        set scaleRate(k) {
            a.RequireFiniteNumber(k);
            b.get(this).SetScaleRate(k)
        }
        get scaleRate() {
            return b.get(this).GetScaleRate()
        }
        set angle(k) {
            a.RequireFiniteNumber(k);
            b.get(this).SetAngle(k)
        }
        get angle() {
            return b.get(this).GetOwnAngle()
        }
        set parallaxX(k) {
            a.RequireFiniteNumber(k);
            b.get(this).SetParallaxX(k)
        }
        get parallaxX() {
            return b.get(this).GetParallaxX()
        }
        set parallaxY(k) {
            a.RequireFiniteNumber(k);
            b.get(this).SetParallaxY(k)
        }
        get parallaxY() {
            return b.get(this).GetParallaxY()
        }
        set zElevation(k) {
            a.RequireFiniteNumber(k);
            b.get(this).SetZElevation(k)
        }
        get zElevation() {
            return b.get(this).GetZElevation()
        }
        set isTransparent(k) {
            b.get(this).SetTransparent(k)
        }
        get isTransparent() {
            return b.get(this).IsTransparent()
        }
        set isForceOwnTexture(k) {
            b.get(this).SetForceOwnTexture(k)
        }
        get isForceOwnTexture() {
            return b.get(this).IsForceOwnTexture()
        }
        set blendMode(k) {
            a.RequireString(k);
            k = d.get(k);
            if ("number" !== typeof k) throw Error("invalid blend mode");
            b.get(this).SetBlendMode(k)
        }
        get blendMode() {
            return c.get(b.get(this).GetBlendMode())
        }
        set backgroundColor(k) {
            a.RequireArray(k);
            if (3 > k.length) throw Error("expected 3 elements");
            f.setRgb(k[0], k[1], k[2]);
            k = b.get(this);
            const h = k.GetBackgroundColor();
            h.equalsIgnoringAlpha(f) || (h.copyRgb(f), k.GetRuntime().UpdateRender())
        }
        get backgroundColor() {
            const k = b.get(this).GetBackgroundColor();
            return [k.getR(), k.getG(), k.getB()]
        }
        set scrollX(k) {
            a.RequireNumber(k);
            const h = b.get(this);
            h.SetOwnScrollPositionEnabled(!0);
            h.SetScrollX(k)
        }
        get scrollX() {
            return b.get(this).GetScrollX()
        }
        set scrollY(k) {
            a.RequireNumber(k);
            const h = b.get(this);
            h.SetOwnScrollPositionEnabled(!0);
            h.SetScrollY(k)
        }
        get scrollY() {
            return b.get(this).GetScrollY()
        }
        scrollTo(k, h) {
            a.RequireNumber(k);
            a.RequireNumber(h);
            const l = b.get(this);
            l.SetOwnScrollPositionEnabled(!0);
            l.SetScrollX(k);
            l.SetScrollY(h)
        }
        restoreScrollPosition() {
            b.get(this).SetOwnScrollPositionEnabled(!1)
        }
        getViewport() {
            return b.get(this).GetViewport().toDOMRect()
        }
        cssPxToLayer(k,
            h, l = 0) {
            a.RequireNumber(k);
            a.RequireNumber(h);
            a.RequireNumber(l);
            const n = b.get(this),
                u = n.GetRuntime();
            return n.CanvasCssToLayer(k - u.GetCanvasClientX(), h - u.GetCanvasClientY(), l)
        }
        layerToCssPx(k, h, l = 0) {
            a.RequireNumber(k);
            a.RequireNumber(h);
            a.RequireNumber(l);
            const n = b.get(this),
                u = n.GetRuntime(),
                [w, q] = n.LayerToCanvasCss(k, h, l);
            return [w + u.GetCanvasClientX(), q + u.GetCanvasClientY()]
        }
    }
} {
    "use strict";
    const e = self.C3,
        a = self.C3X,
        b = new WeakMap,
        d = new WeakMap;

    function c(k) {
        let h = d.get(k);
        if (h) return h;
        h = e.New(e.Event.Dispatcher);
        d.set(k, h);
        return h
    }
    let f = null;
    self.IInstance = class {
        constructor() {
            b.set(this, f);
            const k = {
                runtime: {
                    value: f.GetRuntime().GetIRuntime(),
                    writable: !1
                },
                objectType: {
                    value: f.GetObjectClass().GetIObjectClass(),
                    writable: !1
                },
                uid: {
                    value: f.GetUID(),
                    writable: !1
                }
            };
            f._GetInstVarsScriptDescriptor(k);
            f._GetBehaviorsScriptDescriptor(k);
            Object.defineProperties(this, k);
            f.GetRuntime()._MapScriptInterface(this,
                f)
        }
        static _Init(k) {
            f = k
        }
        static _GetInitInst() {
            return f
        }
        _Release() {
            const k = d.get(this);
            k && (k.Release(), d.delete(this));
            b.delete(this)
        }
        addEventListener(k, h, l) {
            a.RequireString(k);
            a.RequireFunction(h);
            c(this).addEventListener(k, h, l)
        }
        removeEventListener(k, h, l) {
            a.RequireString(k);
            a.RequireFunction(h);
            c(this).removeEventListener(k, h, l)
        }
        dispatchEvent(k) {
            c(this).dispatchEvent(k)
        }
        destroy() {
            const k = b.get(this);
            k.GetRuntime().DestroyInstance(k)
        }
    }
} {
    "use strict";
    const e = self.C3,
        a = self.C3X,
        b = self.IInstance,
        d = self.ILayer,
        c = new WeakMap,
        f = new Map([
            ["normal", 0],
            ["additive", 1],
            ["copy", 3],
            ["destination-over", 4],
            ["source-in", 5],
            ["destination-in", 6],
            ["source-out", 7],
            ["destination-out", 8],
            ["source-atop", 9],
            ["destination-atop", 10]
        ]),
        k = new Map([...f.entries()].map(l => [l[1], l[0]])),
        h = e.New(e.Color);
    self.IWorldInstance = class l extends b {
        constructor() {
            super();
            var n = b._GetInitInst();
            c.set(this, n);
            const u = [];
            var w = n.GetWorldInfo();
            if (n = w.GetInstanceEffectList()) {
                w =
                    w.GetObjectClass().GetEffectList().GetAllEffectTypes().length;
                for (let q = 0; q < w; ++q) u.push(new self.IEffectInstance(n, q))
            }
            Object.defineProperties(this, {
                effects: {
                    value: u,
                    writable: !1
                }
            })
        }
        get layout() {
            return c.get(this).GetWorldInfo().GetLayout().GetILayout()
        }
        get layer() {
            return c.get(this).GetWorldInfo().GetLayer().GetILayer()
        }
        get x() {
            return c.get(this).GetWorldInfo().GetX()
        }
        set x(n) {
            n = +n;
            const u = c.get(this).GetWorldInfo();
            isNaN(n) || u.GetX() === n || (u.SetX(n), u.SetBboxChanged())
        }
        get y() {
            return c.get(this).GetWorldInfo().GetY()
        }
        set y(n) {
            n = +n;
            const u = c.get(this).GetWorldInfo();
            isNaN(n) || u.GetY() === n || (u.SetY(n), u.SetBboxChanged())
        }
        get zElevation() {
            return c.get(this).GetWorldInfo().GetZElevation()
        }
        set zElevation(n) {
            n = +n;
            const u = c.get(this),
                w = u.GetWorldInfo();
            isNaN(n) || w.GetZElevation() === n || (w.SetZElevation(n), u.GetRuntime().UpdateRender())
        }
        get totalZElevation() {
            return c.get(this).GetWorldInfo().GetTotalZElevation()
        }
        get width() {
            return c.get(this).GetWorldInfo().GetWidth()
        }
        set width(n) {
            n = +n;
            const u = c.get(this).GetWorldInfo();
            isNaN(n) ||
                u.GetWidth() === n || (u.SetWidth(n), u.SetBboxChanged())
        }
        get height() {
            return c.get(this).GetWorldInfo().GetHeight()
        }
        set height(n) {
            n = +n;
            const u = c.get(this).GetWorldInfo();
            isNaN(n) || u.GetHeight() === n || (u.SetHeight(n), u.SetBboxChanged())
        }
        get angle() {
            return c.get(this).GetWorldInfo().GetAngle()
        }
        set angle(n) {
            n = e.clampAngle(+n);
            const u = c.get(this).GetWorldInfo();
            isNaN(n) || u.GetAngle() === n || (u.SetAngle(n), u.SetBboxChanged())
        }
        get angleDegrees() {
            return e.toDegrees(this.angle)
        }
        set angleDegrees(n) {
            this.angle = e.toRadians(n)
        }
        getBoundingBox() {
            return c.get(this).GetWorldInfo().GetBoundingBox().toDOMRect()
        }
        getBoundingQuad() {
            return c.get(this).GetWorldInfo().GetBoundingQuad().toDOMQuad()
        }
        get isVisible() {
            return c.get(this).GetWorldInfo().IsVisible()
        }
        set isVisible(n) {
            n = !!n;
            const u = c.get(this),
                w = u.GetWorldInfo();
            w.IsVisible() !== n && (w.SetVisible(n), u.GetRuntime().UpdateRender())
        }
        get opacity() {
            return c.get(this).GetWorldInfo().GetOpacity()
        }
        set opacity(n) {
            n = e.clamp(+n, 0, 1);
            const u = c.get(this),
                w = u.GetWorldInfo();
            isNaN(n) || w.GetOpacity() === n || (w.SetOpacity(n), u.GetRuntime().UpdateRender())
        }
        set colorRgb(n) {
            a.RequireArray(n);
            if (3 > n.length) throw Error("expected 3 elements");
            h.setRgb(n[0], n[1], n[2]);
            n = c.get(this);
            const u = n.GetWorldInfo();
            u.GetUnpremultipliedColor().equalsIgnoringAlpha(h) ||
                (u.SetUnpremultipliedColor(h), n.GetRuntime().UpdateRender())
        }
        get colorRgb() {
            const n = c.get(this).GetWorldInfo().GetUnpremultipliedColor();
            return [n.getR(), n.getG(), n.getB()]
        }
        set blendMode(n) {
            a.RequireString(n);
            n = f.get(n);
            if ("number" !== typeof n) throw Error("invalid blend mode");
            const u = c.get(this);
            u.GetWorldInfo().SetBlendMode(n);
            u.GetRuntime().UpdateRender()
        }
        get blendMode() {
            return k.get(c.get(this).GetWorldInfo().GetBlendMode())
        }
        moveToTop() {
            c.get(this).GetWorldInfo().ZOrderMoveToTop()
        }
        moveToBottom() {
            c.get(this).GetWorldInfo().ZOrderMoveToBottom()
        }
        moveToLayer(n) {
            a.RequireInstanceOf(n,
                d);
            n = d._Unwrap(n);
            if (!n) throw Error("invalid layer");
            c.get(this).GetWorldInfo().ZOrderMoveToLayer(n)
        }
        moveAdjacentToInstance(n, u) {
            a.RequireInstanceOf(n, l);
            c.get(this).GetWorldInfo().ZOrderMoveAdjacentToInstance(c.get(n), u)
        }
        get zIndex() {
            return c.get(this).GetWorldInfo().GetZIndex()
        }
        containsPoint(n, u) {
            a.RequireNumber(n);
            a.RequireNumber(u);
            return c.get(this).GetWorldInfo().ContainsPoint(+n, +u)
        }
        testOverlap(n) {
            a.RequireInstanceOf(n, l);
            const u = c.get(this);
            n = c.get(n);
            return u.GetRuntime().GetCollisionEngine().TestOverlap(u,
                n)
        }
        testOverlapSolid() {
            var n = c.get(this);
            return (n = n.GetRuntime().GetCollisionEngine().TestOverlapSolid(n)) ? n.GetInterfaceClass() : null
        }
        getParent() {
            const n = c.get(this).GetParent();
            return n ? n.GetInterfaceClass() : null
        }
        getTopParent() {
            const n = c.get(this).GetTopParent();
            return n ? n.GetInterfaceClass() : null
        }* parents() {
            for (const n of c.get(this).parents()) yield n.GetInterfaceClass()
        }
        getChildCount() {
            return c.get(this).GetChildCount()
        }
        getChildAt(n) {
            return (n = c.get(this).GetChildAt(n)) ? n.GetInterfaceClass() : null
        }* children() {
            for (const n of c.get(this).children()) yield n.GetInterfaceClass()
        }* allChildren() {
            for (const n of c.get(this).allChildren()) yield n.GetInterfaceClass()
        }
        addChild(n,
            u) {
            a.RequireInstanceOf(n, l);
            a.RequireOptionalObject(u);
            u || (u = {});
            const w = c.get(this);
            n = c.get(n);
            w.AddChild(n, u)
        }
        removeChild(n) {
            a.RequireInstanceOf(n, l);
            const u = c.get(this);
            n = c.get(n);
            u.RemoveChild(n)
        }
        removeFromParent() {
            const n = c.get(this);
            n.HasParent() && n.GetParent().RemoveChild(n)
        }
        createMesh(n, u) {
            a.RequireFiniteNumber(n);
            a.RequireFiniteNumber(u);
            c.get(this).GetWorldInfo().CreateMesh(n, u)
        }
        releaseMesh() {
            const n = c.get(this).GetWorldInfo();
            n.ReleaseMesh();
            n.SetBboxChanged()
        }
        setMeshPoint(n, u, w) {
            a.RequireFiniteNumber(n);
            a.RequireFiniteNumber(u);
            a.RequireObject(w);
            const q = c.get(this).GetWorldInfo();
            q.SetMeshPoint(n, u, w) && q.SetBboxChanged()
        }
        getMeshSize() {
            var n = c.get(this).GetWorldInfo();
            if (!n.HasMesh()) return [0, 0];
            n = n.GetSourceMesh();
            return [n.GetHSize(), n.GetVSize()]
        }
    }
} {
    "use strict";
    const e = self.C3X,
        a = new WeakMap;
    self.IDOMInstance = class extends self.IWorldInstance {
        constructor() {
            super();
            a.set(this, self.IInstance._GetInitInst())
        }
        getElement() {
            return a.get(this).GetSdkInstance()._GetElementInDOMMode()
        }
        focus() {
            a.get(this).GetSdkInstance().FocusElement()
        }
        blur() {
            a.get(this).GetSdkInstance().BlurElement()
        }
        setCssStyle(b, d) {
            e.RequireString(b);
            a.get(this).GetSdkInstance().SetElementCSSStyle(b, d)
        }
    }
} {
    "use strict";
    const e = self.C3,
        a = self.C3X,
        b = new WeakMap,
        d = new WeakMap;

    function c(k) {
        let h = d.get(k);
        if (h) return h;
        h = e.New(e.Event.Dispatcher);
        d.set(k, h);
        return h
    }
    let f = null;
    self.IBehaviorInstance = class {
        constructor() {
            b.set(this, f);
            const k = {
                runtime: {
                    value: f.GetRuntime().GetIRuntime(),
                    writable: !1
                },
                behavior: {
                    value: f.GetBehavior().GetIBehavior(),
                    writable: !1
                }
            };
            Object.defineProperties(this, k)
        }
        static _Init(k) {
            f = k
        }
        static _GetInitInst() {
            return f
        }
        get instance() {
            return b.get(this).GetObjectInstance().GetInterfaceClass()
        }
        _Release() {
            const k =
                d.get(this);
            k && (k.Release(), d.delete(this));
            b.delete(this)
        }
        addEventListener(k, h, l) {
            a.RequireString(k);
            a.RequireFunction(h);
            c(this).addEventListener(k, h, l)
        }
        removeEventListener(k, h, l) {
            a.RequireString(k);
            a.RequireFunction(h);
            c(this).removeEventListener(k, h, l)
        }
        dispatchEvent(k) {
            c(this).dispatchEvent(k)
        }
    }
} {
    "use strict";
    const e = new WeakMap;
    self.IBehavior = class {
        constructor(a) {
            e.set(this, a);
            a = {
                runtime: {
                    value: a.GetRuntime().GetIRuntime(),
                    writable: !1
                }
            };
            Object.defineProperties(this, a)
        }
        getAllInstances() {
            return e.get(this).GetInstances().map(a => a.GetInterfaceClass())
        }
    }
} {
    "use strict";
    const e = self.C3,
        a = self.C3X,
        b = new WeakMap;
    self.IEffectInstance = class {
        constructor(d, c) {
            b.set(this, d);
            Object.defineProperties(this, {
                index: {
                    value: c,
                    writable: !1
                }
            })
        }
        get name() {
            return b.get(this).GetAllEffectTypes()[this.index].GetName()
        }
        get isActive() {
            return b.get(this).IsEffectIndexActive(this.index)
        }
        set isActive(d) {
            d = !!d;
            const c = b.get(this);
            c.IsEffectIndexActive(this.index) !== d && (c.SetEffectIndexActive(this.index, d), c.UpdateActiveEffects(), c.GetRuntime().UpdateRender())
        }
        setParameter(d, c) {
            a.RequireFiniteNumber(d);
            d = Math.floor(+d);
            const f = b.get(this);
            var k = f.GetEffectParametersForIndex(this.index);
            if (0 > d || d >= k.length) throw new RangeError("invalid effect parameter index");
            const h = k[d];
            if (h instanceof e.Color) {
                if (!Array.isArray(c) || 3 > c.length) throw new TypeError("expected array with 3 elements");
                d = c[0];
                k = c[1];
                c = c[2];
                if (h.equalsRgb(d, k, c)) return;
                h.setRgb(d, k, c)
            } else {
                if ("number" !== typeof c) throw new TypeError("expected number");
                if (h === c) return;
                k[d] = c
            }
            f.IsEffectIndexActive(this.index) && f.GetRuntime().UpdateRender()
        }
        getParameter(d) {
            a.RequireFiniteNumber(d);
            d = Math.floor(+d);
            const c = b.get(this).GetEffectParametersForIndex(this.index);
            if (0 > d || d >= c.length) throw new RangeError("invalid effect parameter index");
            d = c[d];
            return d instanceof e.Color ? [d.getR(), d.getG(), d.getB()] : d
        }
    }
} {
    "use strict";
    const e = self.C3,
        a = new Set(["local", "remote"]),
        b = new Map([
            ["mp4", "video/mp4"],
            ["webm", "video/webm"],
            ["m4a", "audio/mp4"],
            ["mp3", "audio/mpeg"],
            ["js", "application/javascript"],
            ["wasm", "application/wasm"],
            ["svg", "image/svg+xml"],
            ["html", "text/html"]
        ]);

    function d(f) {
        if (!f) return "";
        f = f.split(".");
        if (2 > f.length) return "";
        f = f.at(-1).toLowerCase();
        return b.get(f) || ""
    }

    function c(f) {
        return new Promise((k, h) => {
            const l = document.createElement("script");
            l.onload = k;
            l.onerror = h;
            l.async = !1;
            l.type = "module";
            l.src = f;
            document.head.appendChild(l)
        })
    }
    e.AssetManager = class extends e.DefendedBase {
        constructor(f, k) {
            super();
            var h = k.exportType;
            this._runtime = f;
            this._localUrlBlobs = new Map;
            this._localBlobUrlCache = new Map;
            this._localBlobSWUrls = new Map;
            this._isCordova = "cordova" === h;
            this._isiOSCordova = !!k.isiOSCordova;
            this._isFileProtocol = !!k.isFileProtocol;
            this._swClientId = k.swClientId;
            this._supportedAudioFormats = k.supportedAudioFormats || {};
            this._audioFiles = new Map;
            this._preloadSounds = !1;
            this._iconsSubfolder = this._fontsSubfolder =
                this._mediaSubfolder = "";
            this._defaultLoadPolicy = "html5" === h || "scirra-arcade" === h || "instant-games" === h ? "remote" : "local";
            this._allAssets = [];
            this._assetsByUrl = new Map;
            this._webFonts = [];
            this._loadPromises = [];
            this._hasFinishedInitialLoad = !1;
            this._lastLoadProgress = this._assetSizeLoaded = this._totalAssetSizeToLoad = 0;
            this._hasHadErrorLoading = !1;
            this._loadingRateLimiter = e.New(e.RateLimiter, () => this._FireLoadingProgressEvent(), 50);
            this._promiseThrottle = new e.PromiseThrottle(Math.max(e.hardwareConcurrency, 8));
            if (f = k.previewImageBlobs) {
                (h = k.previewProjectFileBlobs) && Object.assign(f, h);
                (h = k.projectData) && (f["data.json"] = h);
                for (const [l, n] of Object.entries(f)) this._localUrlBlobs.set(l.toLowerCase(), n)
            }
            if (k = k.previewProjectFileSWUrls)
                for (const [l, n] of Object.entries(k)) this._localBlobSWUrls.set(l, n);
            this._iAssetManager = new self.IAssetManager(this)
        }
        Release() {
            this._localUrlBlobs.clear();
            for (const f of this._localBlobUrlCache.values()) f.startsWith("blob:") && URL.revokeObjectURL(f);
            this._localBlobUrlCache.clear();
            for (const f of this._allAssets) f.Release();
            e.clearArray(this._allAssets);
            this._assetsByUrl.clear();
            e.clearArray(this._loadPromises);
            this._runtime = null
        }
        GetRuntime() {
            return this._runtime
        }
        _SetMediaSubfolder(f) {
            this._mediaSubfolder = f
        }
        GetMediaSubfolder() {
            return this._mediaSubfolder
        }
        _SetFontsSubfolder(f) {
            this._fontsSubfolder = f
        }
        GetFontsSubfolder() {
            return this._fontsSubfolder
        }
        _SetIconsSubfolder(f) {
            this._iconsSubfolder = f
        }
        GetIconsSubfolder() {
            return this._iconsSubfolder
        }
        IsFileProtocol() {
            return this._isFileProtocol
        }
        _HasLocalUrlBlob(f) {
            return this._localUrlBlobs.has(f.toLowerCase())
        }
        _GetLocalUrlBlob(f) {
            return this._localUrlBlobs.get(f.toLowerCase()) ||
                null
        }
        GetLocalUrlAsBlobUrl(f) {
            if (!this._HasLocalUrlBlob(f)) return f;
            f = f.toLowerCase();
            var k = this._localBlobUrlCache.get(f);
            k || (k = this._GetLocalUrlBlob(f), k = URL.createObjectURL(k), this._localBlobUrlCache.set(f, k));
            return k
        }
        FetchBlob(f, k) {
            k = k || this._defaultLoadPolicy;
            const h = this._GetLocalUrlBlob(f);
            if (h) return Promise.resolve(h);
            if (e.IsRelativeURL(f)) {
                const l = f.toLowerCase();
                return this._isCordova && this._isFileProtocol ? this.CordovaFetchLocalFileAsBlob(l) : "local" === k ? this._promiseThrottle.Add(() => e.FetchBlob(l)) :
                    e.FetchBlob(l)
            }
            return e.FetchBlob(f)
        }
        FetchArrayBuffer(f) {
            const k = this._GetLocalUrlBlob(f);
            if (k) return e.BlobToArrayBuffer(k);
            if (e.IsRelativeURL(f)) {
                const h = f.toLowerCase();
                return this._isCordova && this._isFileProtocol ? this.CordovaFetchLocalFileAsArrayBuffer(h) : "local" === this._defaultLoadPolicy ? this._promiseThrottle.Add(() => e.FetchArrayBuffer(h)) : e.FetchArrayBuffer(h)
            }
            return e.FetchArrayBuffer(f)
        }
        FetchText(f) {
            const k = this._GetLocalUrlBlob(f);
            if (k) return e.BlobToString(k);
            if (e.IsRelativeURL(f)) {
                const h =
                    f.toLowerCase();
                return this._isCordova && this._isFileProtocol ? this.CordovaFetchLocalFileAsText(h) : "local" === this._defaultLoadPolicy ? this._promiseThrottle.Add(() => e.FetchText(h)) : e.FetchText(h)
            }
            return e.FetchText(f)
        }
        async FetchJson(f) {
            f = await this.FetchText(f);
            return JSON.parse(f)
        }
        _CordovaFetchLocalFileAs(f, k) {
            return this._runtime.PostComponentMessageToDOMAsync("runtime", "cordova-fetch-local-file", {
                filename: f,
                as: k
            })
        }
        CordovaFetchLocalFileAsText(f) {
            return this._CordovaFetchLocalFileAs(f, "text")
        }
        async CordovaFetchLocalFileAsBlob(f) {
            const k =
                await this._CordovaFetchLocalFileAs(f, "buffer");
            f = d(f);
            return new Blob([k], {
                type: f
            })
        }
        async CordovaFetchLocalFileAsBlobURL(f) {
            f = f.toLowerCase();
            var k = this._localBlobUrlCache.get(f);
            if (k) return k;
            k = await this.CordovaFetchLocalFileAsBlob(f);
            k = URL.createObjectURL(k);
            this._localBlobUrlCache.set(f, k);
            return k
        }
        CordovaFetchLocalFileAsArrayBuffer(f) {
            return this._CordovaFetchLocalFileAs(f, "buffer")
        }
        GetMediaFileUrl(f) {
            return this._HasLocalUrlBlob(f) ? this.GetLocalUrlAsBlobUrl(f) : this._mediaSubfolder + f.toLowerCase()
        }
        GetProjectFileUrl(f,
            k = "") {
            if (e.IsAbsoluteURL(f)) {
                if (k) throw Error("cannot specify subfolder with remote URL");
                return Promise.resolve(f)
            }
            return this._HasLocalUrlBlob(f) ? Promise.resolve(this.GetLocalUrlAsBlobUrl(f)) : this._isCordova && this._isFileProtocol ? this.CordovaFetchLocalFileAsBlobURL(k + f) : Promise.resolve(k + f.toLowerCase())
        }
        GetProjectFileIframeUrl(f) {
            if (e.IsAbsoluteURL(f)) return Promise.resolve(f);
            var k = f.indexOf("?"),
                h = -1 === k ? "" : f.substr(k);
            k = -1 === k ? f : f.substr(0, k);
            return this._HasLocalUrlBlob(k) ? (f = this._localBlobSWUrls.get(k) ||
                this.GetLocalUrlAsBlobUrl(k), !f.startsWith("blob:") && this._swClientId && (f = new URL(f), h = new URLSearchParams(h), h.set("__c3_client_id", this._swClientId), f.search = h.toString(), f = f.toString()), Promise.resolve(f)) : this._isCordova && this._isFileProtocol ? this.CordovaFetchLocalFileAsBlobURL(k) : Promise.resolve(f.toLowerCase())
        }
        LoadProjectFileUrl(f) {
            return this.GetProjectFileUrl(f)
        }
        LoadImage(f) {
            if (f.loadPolicy && !a.has(f.loadPolicy)) throw Error("invalid load policy");
            let k = this._assetsByUrl.get(f.url);
            if (k) return k;
            k = e.New(e.ImageAsset, this, {
                url: f.url,
                size: f.size || 0,
                loadPolicy: f.loadPolicy || this._defaultLoadPolicy
            });
            this._allAssets.push(k);
            this._assetsByUrl.set(k.GetURL(), k);
            this._hasFinishedInitialLoad || (this._totalAssetSizeToLoad += k.GetSize(), this._loadPromises.push(k.Load().then(() => this._AddLoadedSize(k.GetSize()))));
            return k
        }
        async WaitForAllToLoad() {
            try {
                await Promise.all(this._loadPromises), this._lastLoadProgress = 1
            } catch (f) {
                console.error("Error loading: ", f), this._hasHadErrorLoading = !0, this._FireLoadingProgressEvent()
            }
        }
        SetInitialLoadFinished() {
            this._hasFinishedInitialLoad = !0
        }
        HasHadErrorLoading() {
            return this._hasHadErrorLoading
        }
        _AddLoadedSize(f) {
            this._assetSizeLoaded += f;
            this._loadingRateLimiter.Call()
        }
        _FireLoadingProgressEvent() {
            const f = e.New(e.Event, "loadingprogress");
            this._lastLoadProgress = e.clamp(this._assetSizeLoaded / this._totalAssetSizeToLoad, 0, 1);
            f.progress = this._lastLoadProgress;
            this._runtime.Dispatcher().dispatchEvent(f)
        }
        GetLoadProgress() {
            return this._lastLoadProgress
        }
        _SetWebFonts(f) {
            e.shallowAssignArray(this._webFonts, f);
            this._webFonts.length && this._loadPromises.push(this._LoadWebFonts())
        }
        _LoadWebFonts() {
            if ("undefined" ===
                typeof FontFace) return Promise.resolve();
            const f = [];
            for (const [k, h, l] of this._webFonts) this._totalAssetSizeToLoad += l, f.push(this._LoadWebFont(k, h).then(() => this._AddLoadedSize(l)));
            return Promise.all(f)
        }
        async _LoadWebFont(f, k) {
            try {
                const h = await this.GetProjectFileUrl(k, this._fontsSubfolder),
                    l = new FontFace(f, `url('${h}')`);
                this._runtime.IsInWorker() ? self.fonts.add(l) : document.fonts.add(l);
                await l.load()
            } catch (h) {
                console.warn(`[C3 runtime] Failed to load web font '${f}': `, h)
            }
        }
        IsAudioFormatSupported(f) {
            return !!this._supportedAudioFormats[f]
        }
        _SetAudioFiles(f,
            k) {
            this._preloadSounds = !!k;
            for (const [h, l, n] of f) this._audioFiles.set(h, {
                fileName: h,
                formats: l.map(u => ({
                    type: u[0],
                    fileExtension: u[1],
                    fullName: h + u[1],
                    fileSize: u[2]
                })),
                isMusic: n
            })
        }
        GetPreferredAudioFile(f) {
            f = this._audioFiles.get(f.toLowerCase());
            if (!f) return null;
            let k = null;
            for (const h of f.formats)
                if (k || "audio/webm; codecs=opus" !== h.type || (k = h), this.IsAudioFormatSupported(h.type)) return h;
            return k
        }
        GetProjectAudioFileUrl(f) {
            return (f = this.GetPreferredAudioFile(f)) ? {
                url: this.GetMediaFileUrl(f.fullName),
                type: f.type
            } : null
        }
        GetAudioToPreload() {
            if (this._preloadSounds) {
                const f = [];
                for (const k of this._audioFiles.values()) {
                    if (k.isMusic) continue;
                    const h = this.GetPreferredAudioFile(k.fileName);
                    h && f.push({
                        originalUrl: k.fileName,
                        url: this.GetMediaFileUrl(h.fullName),
                        type: h.type,
                        fileSize: h.fileSize
                    })
                }
                return f
            }
            return []
        }
        GetIAssetManager() {
            return this._iAssetManager
        }
        async LoadScripts(...f) {
            const k = await Promise.all(f.map(h => this.GetProjectFileUrl(h)));
            this._runtime.IsInWorker() ? 1 === f.length ? (f = f[0], await self.c3_import((e.IsRelativeURL(f) ?
                "./" : "") + f)) : (f = f.map(h => `import "${e.IsRelativeURL(h)?"./":""}${h}";`).join("\n"), f = URL.createObjectURL(new Blob([f], {
                type: "application/javascript"
            })), await self.c3_import(f)) : await Promise.all(k.map(h => c(h)))
        }
        async CompileWebAssembly(f) {
            if (WebAssembly.compileStreaming) return f = await this.GetProjectFileUrl(f), await WebAssembly.compileStreaming(fetch(f));
            f = await e.FetchArrayBuffer(f);
            return await WebAssembly.compile(f)
        }
        async LoadStyleSheet(f) {
            f = await this.GetProjectFileUrl(f);
            return await this._runtime.PostComponentMessageToDOMAsync("runtime",
                "add-stylesheet", {
                    url: f
                })
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Asset = class extends e.DefendedBase {
        constructor(a, b) {
            super();
            this._assetManager = a;
            this._runtime = a.GetRuntime();
            this._url = b.url;
            this._size = b.size;
            this._loadPolicy = b.loadPolicy;
            this._blob = null;
            this._isLoaded = !1;
            this._loadPromise = null
        }
        Release() {
            this._blob = this._runtime = this._assetManager = this._loadPromise = null
        }
        GetURL() {
            return this._url
        }
        GetSize() {
            return this._size
        }
        Load() {
            return "local" === this._loadPolicy || this._blob ? (this._isLoaded = !0, Promise.resolve()) : this._loadPromise ?
                this._loadPromise : this._loadPromise = this._assetManager.FetchBlob(this._url, this._loadPolicy).then(a => {
                    this._isLoaded = !0;
                    this._loadPromise = null;
                    return this._blob = a
                }).catch(a => console.error("Error loading resource: ", a))
        }
        IsLoaded() {
            return this._isLoaded
        }
        GetBlob() {
            return this._blob ? Promise.resolve(this._blob) : this._loadPromise ? this._loadPromise : this._assetManager.FetchBlob(this._url, this._loadPolicy)
        }
    }
} {
    "use strict";
    const e = self.C3,
        a = new e.PromiseThrottle,
        b = new Set;
    e.ImageAsset = class extends e.Asset {
        constructor(d, c) {
            super(d, c);
            this._webglTexture = this._texturePromise = null;
            this._refCount = 0;
            this._imageHeight = this._imageWidth = -1;
            b.add(this)
        }
        Release() {
            this.ReleaseTexture();
            if (0 !== this._refCount) throw Error("released image asset which still has texture references");
            this._texturePromise = null;
            b.delete(this);
            super.Release()
        }
        static OnWebGLContextLost() {
            for (const d of b) d._texturePromise = null, d._webglTexture =
                null, d._refCount = 0
        }
        LoadStaticTexture(d, c) {
            c = c || {};
            this._refCount++;
            if (this._webglTexture) return Promise.resolve(this._webglTexture);
            if (this._texturePromise) return this._texturePromise;
            c.anisotropy = this._runtime.GetCanvasManager().GetTextureAnisotropy();
            return this._texturePromise = this.GetBlob().then(f => a.Add(() => d.CreateStaticTextureAsync(f, c).then(k => {
                this._texturePromise = null;
                if (0 === this._refCount) return d.DeleteTexture(k), null;
                this._webglTexture = k;
                this._imageWidth = k.GetWidth();
                this._imageHeight =
                    k.GetHeight();
                return this._webglTexture
            }))).catch(f => {
                console.error("Failed to load texture: ", f);
                throw f;
            })
        }
        ReleaseTexture() {
            if (0 >= this._refCount) throw Error("texture released too many times");
            this._refCount--;
            0 === this._refCount && this._webglTexture && (this._webglTexture.GetRenderer().DeleteTexture(this._webglTexture), this._webglTexture = null)
        }
        GetTexture() {
            return this._webglTexture
        }
        GetWidth() {
            return this._imageWidth
        }
        GetHeight() {
            return this._imageHeight
        }
        async LoadToDrawable() {
            const d = await this.GetBlob();
            return e.Supports.ImageBitmapOptions ? await createImageBitmap(d, {
                premultiplyAlpha: "none"
            }) : e.Supports.ImageBitmap ? await createImageBitmap(d) : await e.BlobToImage(d)
        }
    }
} {
    "use strict";
    const e = self.C3;

    function a(b, d) {
        return b.GetWorldInfo()._GetLastCachedZIndex() - d.GetWorldInfo()._GetLastCachedZIndex()
    }
    e.RenderCell = class extends e.DefendedBase {
        constructor(b, d, c) {
            super();
            this._grid = b;
            this._x = d;
            this._y = c;
            this._instances = [];
            this._isSorted = !0;
            this._pendingRemoval = new Set;
            this._isAnyPendingRemoval = !1
        }
        Release() {
            e.clearArray(this._instances);
            this._pendingRemoval.clear();
            this._grid = null
        }
        Reset() {
            e.clearArray(this._instances);
            this._isSorted = !0;
            this._pendingRemoval.clear();
            this._isAnyPendingRemoval = !1
        }
        SetChanged() {
            this._isSorted = !1
        }
        IsEmpty() {
            if (!this._instances.length) return !0;
            if (this._instances.length > this._pendingRemoval.size) return !1;
            this._FlushPending();
            return !0
        }
        Insert(b) {
            this._pendingRemoval.has(b) ? (this._pendingRemoval.delete(b), 0 === this._pendingRemoval.size && (this._isAnyPendingRemoval = !1)) : (this._instances.push(b), this._isSorted = 1 === this._instances.length)
        }
        Remove(b) {
            this._pendingRemoval.add(b);
            this._isAnyPendingRemoval = !0;
            50 <= this._pendingRemoval.size && this._FlushPending()
        }
        _FlushPending() {
            this._isAnyPendingRemoval &&
                (this._instances.length === this._pendingRemoval.size ? this.Reset() : (e.arrayRemoveAllInSet(this._instances, this._pendingRemoval), this._pendingRemoval.clear(), this._isAnyPendingRemoval = !1))
        }
        _EnsureSorted() {
            this._isSorted || (this._instances.sort(a), this._isSorted = !0)
        }
        Dump(b) {
            this._FlushPending();
            this._EnsureSorted();
            this._instances.length && b.push(this._instances)
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.RenderGrid = class extends e.DefendedBase {
        constructor(a, b) {
            super();
            this._cellWidth = a;
            this._cellHeight = b;
            this._cells = e.New(e.PairMap)
        }
        Release() {
            this._cells.Release();
            this._cells = null
        }
        GetCell(a, b, d) {
            let c = this._cells.Get(a, b);
            return c ? c : d ? (c = e.New(e.RenderCell, this, a, b), this._cells.Set(a, b, c), c) : null
        }
        XToCell(a) {
            return Math.floor(a / this._cellWidth)
        }
        YToCell(a) {
            return Math.floor(a / this._cellHeight)
        }
        Update(a, b, d) {
            if (b)
                for (let c = b.getLeft(), f = b.getRight(); c <= f; ++c)
                    for (let k =
                            b.getTop(), h = b.getBottom(); k <= h; ++k) {
                        if (d && d.containsPoint(c, k)) continue;
                        const l = this.GetCell(c, k, !1);
                        l && (l.Remove(a), l.IsEmpty() && this._cells.Delete(c, k))
                    }
            if (d)
                for (let c = d.getLeft(), f = d.getRight(); c <= f; ++c)
                    for (let k = d.getTop(), h = d.getBottom(); k <= h; ++k) b && b.containsPoint(c, k) || this.GetCell(c, k, !0).Insert(a)
        }
        QueryRange(a, b) {
            let d = this.XToCell(a.getLeft());
            const c = this.YToCell(a.getTop()),
                f = this.XToCell(a.getRight());
            for (a = this.YToCell(a.getBottom()); d <= f; ++d)
                for (let k = c; k <= a; ++k) {
                    const h = this.GetCell(d,
                        k, !1);
                    h && h.Dump(b)
                }
        }
        MarkRangeChanged(a) {
            let b = a.getLeft();
            const d = a.getTop(),
                c = a.getRight();
            for (a = a.getBottom(); b <= c; ++b)
                for (let f = d; f <= a; ++f) {
                    const k = this.GetCell(b, f, !1);
                    k && k.SetChanged()
                }
        }
    }
} {
    "use strict";
    const e = self.C3,
        a = new e.Rect,
        b = new e.Quad,
        d = [];
    new e.Rect;
    new e.Rect;
    const c = self.glMatrix,
        f = c.vec3,
        k = c.vec4,
        h = c.mat4,
        l = h.create(),
        n = f.create(),
        u = k.create(),
        w = f.create(),
        q = f.create(),
        t = f.create(),
        p = e.New(e.Vector2);
    e.New(e.Rect);

    function r(A, F) {
        return A.GetWorldInfo()._GetLastCachedZIndex() - F.GetWorldInfo()._GetLastCachedZIndex()
    }

    function x(A, F) {
        return A.GetWorldInfo().GetZElevation() - F.GetWorldInfo().GetZElevation()
    }
    const y = [],
        E = [],
        G = [];
    e.Layer = class extends e.DefendedBase {
        constructor(A,
            F, J) {
            super();
            this._layout = A;
            this._runtime = A.GetRuntime();
            this._parentLayer = F;
            this._name = J[0];
            this._index = -1;
            this._sid = J[2];
            this._isVisible = !!J[3];
            this._backgroundColor = e.New(e.Color);
            this._backgroundColor.setFromJSON(J[4].map(I => I / 255));
            this._isTransparent = !!J[5];
            this._parallaxX = J[6];
            this._parallaxY = J[7];
            this._color = e.New(e.Color, 1, 1, 1, J[8]);
            this._premultipliedColor = e.New(e.Color);
            this._isForceOwnTexture = J[9];
            this._renderAs3d = J[17];
            this._useCameraDistanceDrawOrder = J[18];
            this._useRenderCells = J[10];
            this._scaleRate = J[11];
            this._blendMode = J[12];
            this._curRenderTarget = null;
            this._scale = 1;
            this._zElevation = J[16];
            this._scrollY = this._scrollX = this._angle = 0;
            this._hasOwnScrollPosition = !1;
            this._viewport = e.New(e.Rect);
            this._viewportZ0 = e.New(e.Rect);
            this._viewport3D = e.New(e.Rect);
            this._projectionMatrix = h.create();
            this._isProjectionMatrixChanged = !0;
            this._modelViewMatrix = h.create();
            this._isMVMatrixChanged = !0;
            this._viewFrustum = e.New(e.Gfx.ViewFrustum);
            this._isViewFrustumChanged = !0;
            this._startupInitialInstances = [];
            this._initialInstancesData = J[14];
            this._initialInstances = [];
            this._createdGlobalUids = [];
            this._initialUIDsToInstanceData = new Map;
            this._instances = [];
            this._anyInstanceZElevated = this._zIndicesUpToDate = !1;
            const B = this._runtime.GetCanvasManager();
            this._effectList = e.New(e.EffectList, this, J[15]);
            this._effectChain = e.New(e.Gfx.EffectChain, B.GetEffectChainManager(), {
                drawContent: (I, L) => {
                    L = L.GetContentObject();
                    const P = L.GetRenderTarget();
                    I.SetColor(L.GetPremultipliedColor());
                    I.DrawRenderTarget(P);
                    I.InvalidateRenderTarget(P);
                    B.ReleaseAdditionalRenderTarget(P)
                },
                getShaderParameters: I => this.GetEffectList().GetEffectParametersForIndex(I)
            });
            this._wasDefaultColor = this._needsRebuildEffectChainSteps = !0;
            this._renderGrid = null;
            this._lastRenderList = [];
            this._isRenderListUpToDate = !1;
            this._lastRenderCells = e.New(e.Rect, 0, 0, -1, -1);
            this._curRenderCells = e.New(e.Rect, 0, 0, -1, -1);
            this._iLayer = new self.ILayer(this);
            this._UpdatePremultipliedColor();
            this.UsesRenderCells() && (this._renderGrid = e.New(e.RenderGrid, this._runtime.GetOriginalViewportWidth(),
                this._runtime.GetOriginalViewportHeight()));
            this._subLayers = J[19].map(I => e.New(e.Layer, this._layout, this, I))
        }
        _Init() {
            for (const A of this._initialInstancesData) {
                const F = this._runtime.GetObjectClassByIndex(A[1]);
                this._layout._AddInitialObjectClass(F);
                F.GetDefaultInstanceData() || (F.SetDefaultInstanceData(A), F._SetDefaultLayerIndex(this._index));
                this._initialInstances.push(A);
                this._initialUIDsToInstanceData.set(A[2], A)
            }
            e.shallowAssignArray(this._startupInitialInstances, this._initialInstances);
            this._initialInstancesData =
                null
        }
        Release() {
            this._runtime = this._layout = null
        }
        GetInitialInstanceData(A) {
            return this._initialUIDsToInstanceData.get(A)
        }
        CreateInitialInstances(A) {
            const F = this._layout.IsFirstVisit();
            let J = 0;
            const B = this._initialInstances;
            for (let L = 0, P = B.length; L < P; ++L) {
                var I = B[L];
                const S = this._runtime.GetObjectClassByIndex(I[1]);
                let U = !0;
                if (!S.HasPersistBehavior() || F) I = this._runtime.CreateInstanceFromData(I, this, !0), A.push(I), S.IsGlobal() && (U = !1, this._createdGlobalUids.push(I.GetUID()));
                U && (B[J] = B[L], ++J)
            }
            e.truncateArray(B,
                J);
            this._runtime.FlushPendingInstances();
            this.SetZIndicesChanged()
        }
        _AddInstance(A, F) {
            const J = A.GetWorldInfo();
            if (J.GetLayer() !== this) throw Error("instance added to wrong layer");
            this._instances.push(A);
            0 !== J.GetZElevation() && (this._anyInstanceZElevated = !0);
            F && this.UsesRenderCells() && A.GetWorldInfo().SetBboxChanged();
            this.SetZIndicesChanged()
        }
        _MaybeAddInstance(A) {
            this._instances.includes(A) || (this._instances.push(A), 0 !== A.GetWorldInfo().GetZElevation() && (this._anyInstanceZElevated = !0), this.SetZIndicesChanged())
        }
        _PrependInstance(A,
            F) {
            const J = A.GetWorldInfo();
            if (J.GetLayer() !== this) throw Error("instance added to wrong layer");
            this._instances.unshift(A);
            0 !== J.GetZElevation() && (this._anyInstanceZElevated = !0);
            this.SetZIndicesChanged();
            F && this.UsesRenderCells() && A.GetWorldInfo().SetBboxChanged()
        }
        _RemoveInstance(A, F) {
            const J = this._instances.indexOf(A);
            0 > J || (F && this.UsesRenderCells() && A.GetWorldInfo()._RemoveFromRenderCells(), this._instances.splice(J, 1), this.SetZIndicesChanged(), this._MaybeResetAnyInstanceZElevatedFlag())
        }
        _SetAnyInstanceZElevated() {
            this._anyInstanceZElevated = !0
        }
        _MaybeResetAnyInstanceZElevatedFlag() {
            0 === this._instances.length && (this._anyInstanceZElevated = !1)
        }
        _SortInstancesByLastCachedZIndex(A) {
            if (A) {
                A = new Set;
                for (var F of this._instances) {
                    var J = F.GetWorldInfo()._GetLastCachedZIndex();
                    0 <= J && A.add(J)
                }
                F = -1;
                for (const B of this._instances)
                    if (J = B.GetWorldInfo(), !(0 <= J._GetLastCachedZIndex())) {
                        for (++F; A.has(F);) ++F;
                        J._SetZIndex(F)
                    }
            }
            this._instances.sort(r)
        }
        _Start() {}
        _End() {
            for (const A of this._instances) A.GetObjectClass().IsGlobal() || this._runtime.DestroyInstance(A);
            this._runtime.FlushPendingInstances();
            e.clearArray(this._instances);
            this._anyInstanceZElevated = !1;
            this.SetZIndicesChanged()
        }
        RecreateInitialObjects(A, F, J, B, I) {
            const L = this._runtime.GetEventSheetManager(),
                P = this._runtime.GetAllObjectClasses(),
                S = A.IsFamily(),
                U = [];
            for (const ma of this._initialInstances) {
                var V = ma[0];
                if (F.containsPoint(V[0], V[1])) {
                    V = P[ma[1]];
                    if (V !== A)
                        if (S) {
                            if (!A.FamilyHasMember(V)) continue
                        } else continue;
                    V = this;
                    var Z = this._runtime.GetCurrentLayout();
                    this.GetLayout() !== Z && ((V = Z.GetLayerByName(this.GetName())) ||
                        (V = Z.GetLayerByIndex(this.GetIndex())));
                    Z = this._runtime.CreateInstanceFromData(ma, V, !1, void 0, void 0, !1, I);
                    V.SortAndAddInstancesByZIndex(Z);
                    V = Z.GetWorldInfo();
                    V.OffsetXY(J, B);
                    V.SetBboxChanged();
                    L.BlockFlushingInstances(!0);
                    Z._TriggerOnCreatedOnSelfAndRelated();
                    L.BlockFlushingInstances(!1);
                    U.push(Z)
                }
            }
            return U
        }
        GetInstanceCount() {
            return this._instances.length
        }
        GetLayout() {
            return this._layout
        }
        GetName() {
            return this._name
        }
        _SetIndex(A) {
            this._index = A
        }
        GetIndex() {
            return this._index
        }
        GetSID() {
            return this._sid
        }
        GetRuntime() {
            return this._runtime
        }
        GetDevicePixelRatio() {
            return this._runtime.GetDevicePixelRatio()
        }
        GetEffectList() {
            return this._effectList
        }
        GetEffectChain() {
            this._MaybeRebuildEffectChainSteps();
            return this._effectChain
        }
        _MaybeRebuildEffectChainSteps() {
            const A = this.HasDefaultColor();
            if (this._needsRebuildEffectChainSteps || A !== this._wasDefaultColor) {
                var F = this.GetEffectList().GetActiveEffectTypes();
                this._effectChain.BuildSteps(F.map(J => J.GetShaderProgram()), {
                    indexMap: F.map(J => J.GetIndex()),
                    forcePreDraw: !A,
                    useFullSurface: !0
                });
                this._needsRebuildEffectChainSteps = !1;
                this._wasDefaultColor = A
            }
        }
        UpdateActiveEffects() {
            this.GetEffectList().UpdateActiveEffects();
            this._needsRebuildEffectChainSteps = !0
        }
        UsesRenderCells() {
            return this._useRenderCells &&
                !this._useCameraDistanceDrawOrder
        }
        GetRenderGrid() {
            return this._renderGrid
        }
        SetRenderListStale() {
            this._isRenderListUpToDate = !1
        }
        IsVisible() {
            for (const A of this.selfAndParentLayers())
                if (!A._IsVisibleFlagSet()) return !1;
            return !0
        }
        _IsVisibleFlagSet() {
            return this._isVisible
        }
        SetVisible(A) {
            A = !!A;
            this._isVisible !== A && (this._isVisible = A, this._runtime.UpdateRender())
        }
        SetOwnScrollPositionEnabled(A) {
            A = !!A;
            if (this._hasOwnScrollPosition !== A) {
                if (this._hasOwnScrollPosition = A) A = this.GetLayout(), this._scrollX = A.GetScrollX(),
                    this._scrollY = A.GetScrollY();
                this._SetMVMatrixChanged();
                this._runtime.UpdateRender()
            }
        }
        IsOwnScrollPositionEnabled() {
            return this._hasOwnScrollPosition
        }
        SetScrollX(A) {
            var F = this.GetLayout();
            const J = F.GetScrollLeftBound();
            F = F.GetScrollRightBound();
            A > F && (A = F);
            A < J && (A = J);
            this._scrollX !== A && (this._scrollX = A, this.IsOwnScrollPositionEnabled() && (this._SetMVMatrixChanged(), this._runtime.UpdateRender()))
        }
        SetScrollY(A) {
            var F = this.GetLayout();
            const J = F.GetScrollTopBound();
            F = F.GetScrollBottomBound();
            A > F && (A = F);
            A <
                J && (A = J);
            this._scrollY !== A && (this._scrollY = A, this.IsOwnScrollPositionEnabled() && (this._SetMVMatrixChanged(), this._runtime.UpdateRender()))
        }
        GetScrollX() {
            return this.IsOwnScrollPositionEnabled() ? this._scrollX : this.GetLayout().GetScrollX()
        }
        GetScrollY() {
            return this.IsOwnScrollPositionEnabled() ? this._scrollY : this.GetLayout().GetScrollY()
        }
        GetViewport() {
            return this._viewport
        }
        GetViewport3D() {
            return this._viewport3D
        }
        _GetVanishingPoint() {
            const A = this.GetLayout();
            return [A.GetVanishingPointX(), A.GetVanishingPointY()]
        }
        GetViewportForZ(A,
            F) {
            var J = this._viewportZ0;
            if (0 === A) F.copy(J);
            else {
                let P = J.midX(),
                    S = J.midY();
                var B = this.Get2DScaleFactorToZ(A);
                const U = J.width() / B;
                J = J.height() / B;
                const [V, Z] = this._GetVanishingPoint();
                if (.5 !== V || .5 !== Z) {
                    const ma = this.GetCameraZ();
                    var I = this._runtime,
                        L = 100 / ma;
                    B = (V - .5) * I.GetViewportWidth() / L;
                    I = (Z - .5) * I.GetViewportHeight() / L;
                    L = this.GetAngle();
                    0 !== L && (p.set(B, I), p.rotate(L), B = p.getX(), I = p.getY());
                    A = e.unlerp(ma, 0, A);
                    P += e.lerp(B, 0, A);
                    S += e.lerp(I, 0, A)
                }
                F.set(P - U / 2, S - J / 2, P + U / 2, S + J / 2)
            }
        }
        GetOpacity() {
            return this._color.getA()
        }
        SetOpacity(A) {
            A =
                e.clamp(A, 0, 1);
            this._color.getA() !== A && (this._color.setA(A), this._UpdatePremultipliedColor(), this._runtime.UpdateRender())
        }
        _UpdatePremultipliedColor() {
            this._premultipliedColor.copy(this._color);
            this._premultipliedColor.premultiply()
        }
        GetPremultipliedColor() {
            return this._premultipliedColor
        }
        HasDefaultColor() {
            return this._color.equalsRgba(1, 1, 1, 1)
        }
        GetScaleRate() {
            return this._scaleRate
        }
        SetScaleRate(A) {
            this._scaleRate !== A && (this._scaleRate = A, this._SetMVMatrixChanged(), this._runtime.UpdateRender())
        }
        GetParallaxX() {
            return this._parallaxX
        }
        GetParallaxY() {
            return this._parallaxY
        }
        SetParallax(A,
            F) {
            if (this._parallaxX !== A || this._parallaxY !== F)
                if (this._parallaxX = A, this._parallaxY = F, this._SetMVMatrixChanged(), this._runtime.UpdateRender(), 1 !== this._parallaxX || 1 !== this._parallaxY)
                    for (const J of this._instances) J.GetObjectClass()._SetAnyInstanceParallaxed(!0)
        }
        SetParallaxX(A) {
            this.SetParallax(A, this.GetParallaxY())
        }
        SetParallaxY(A) {
            this.SetParallax(this.GetParallaxX(), A)
        }
        SetZElevation(A) {
            this._zElevation !== A && (this._zElevation = A, this._runtime.UpdateRender())
        }
        GetZElevation() {
            return this._zElevation
        }
        SetAngle(A) {
            A =
                e.clampAngle(A);
            this._angle !== A && (this._angle = A, this._SetMVMatrixChanged(), this._runtime.UpdateRender())
        }
        GetAngle() {
            return e.clampAngle(this._layout.GetAngle() + this._angle)
        }
        GetOwnAngle() {
            return this._angle
        }
        HasInstances() {
            return 0 < this._instances.length
        }
        _GetInstances() {
            return this._instances
        }
        _GetInstancesInDrawOrder() {
            return this.RendersIn3DMode() && this._useCameraDistanceDrawOrder ? (e.shallowAssignArray(G, this._GetInstances()), G.sort((A, F) => this._SortInstancesByCameraDistance(A, F)), G) : this._GetInstances()
        }
        _AppendAllInstancesIncludingSubLayersInDrawOrder(A) {
            e.appendArray(A,
                this._GetInstancesInDrawOrder());
            for (const F of this._subLayers) F.IsVisible() && 0 < F.GetOpacity() && F._AppendAllInstancesIncludingSubLayersInDrawOrder(A)
        }
        _SortInstancesByCameraDistance(A, F) {
            var J = this.GetLayout().Get3DCameraPosition(),
                B = J[0],
                I = J[1];
            J = J[2];
            var L = A.GetWorldInfo();
            const P = F.GetWorldInfo();
            F = L.GetX() - B;
            A = L.GetY() - I;
            L = L.GetZElevation() - J;
            B = P.GetX() - B;
            I = P.GetY() - I;
            J = P.GetZElevation() - J;
            return B * B + I * I + J * J - (F * F + A * A + L * L)
        }
        GetBackgroundColor() {
            return this._backgroundColor
        }
        IsTransparent() {
            return this._isTransparent
        }
        SetTransparent(A) {
            A = !!A;
            this._isTransparent !== A && (this._isTransparent = A, this._runtime.UpdateRender())
        }
        IsForceOwnTexture() {
            return this._isForceOwnTexture
        }
        SetForceOwnTexture(A) {
            A = !!A;
            this._isForceOwnTexture !== A && (this._isForceOwnTexture = A, this._runtime.UpdateRender())
        }
        RendersIn2DMode() {
            return !this.GetRuntime().Uses3DFeatures() || !this._renderAs3d
        }
        RendersIn3DMode() {
            return !this.RendersIn2DMode()
        }
        Has3DCamera() {
            return this.RendersIn3DMode() && this.GetLayout().Is3DCameraEnabled()
        }
        SelfAndAllSubLayersHave3DCamera() {
            if (!this.Has3DCamera()) return !1;
            for (const A of this._subLayers)
                if (!A.SelfAndAllSubLayersHave3DCamera()) return !1;
            return !0
        }
        SetBlendMode(A) {
            this._blendMode !== A && (this._blendMode = A, this._runtime.UpdateRender())
        }
        GetBlendMode() {
            return this._blendMode
        }
        IsRootLayer() {
            return !this._parentLayer
        }
        GetParentLayer() {
            return this._parentLayer
        }
        GetSubLayers() {
            return this._subLayers
        }
        HasAnySubLayers() {
            return 0 < this._subLayers.length
        }
        HasAnyVisibleSubLayer() {
            for (const A of this._subLayers)
                if (A.ShouldDraw()) return !0;
            return !1
        }* selfAndAllSubLayers() {
            for (const A of this._subLayers) yield* A.selfAndAllSubLayers();
            yield this
        }* parentLayers() {
            let A = this.GetParentLayer();
            for (; A;) yield A, A = A.GetParentLayer()
        }* selfAndParentLayers() {
            yield this;
            yield* this.parentLayers()
        }
        IsTransformCompatibleWith(A) {
            return this === A || this._parallaxX === A._parallaxX && this._parallaxY === A._parallaxY && this._scale === A._scale && this._scaleRate === A._scaleRate && this._angle === A._angle && this.GetScrollX() === A.GetScrollX() && this.GetScrollY() === A.GetScrollY()
        }
        SaveTransform() {
            return {
                parallaxX: this.GetParallaxX(),
                parallaxY: this.GetParallaxY(),
                scale: this.GetOwnScale(),
                scaleRate: this.GetScaleRate(),
                angle: this.GetOwnAngle(),
                hasOwnScroll: this.IsOwnScrollPositionEnabled(),
                scrollX: this.GetScrollX(),
                scrollY: this.GetScrollY()
            }
        }
        RestoreTransform(A) {
            this.SetParallax(A.parallaxX, A.parallaxY);
            this.SetOwnScale(A.scale);
            this.SetScaleRate(A.scaleRate);
            this.SetAngle(A.angle);
            this.SetOwnScrollPositionEnabled(A.hasOwnScroll);
            this.SetScrollX(A.scrollX);
            this.SetScrollY(A.scrollY)
        }
        _RemoveAllInstancesInSet(A) {
            0 !== A.size && 0 < e.arrayRemoveAllInSet(this._instances, A) && (this._MaybeResetAnyInstanceZElevatedFlag(),
                this.SetZIndicesChanged())
        }
        SetZIndicesChanged() {
            this._isRenderListUpToDate = this._zIndicesUpToDate = !1
        }
        _UpdateZIndices() {
            if (!this._zIndicesUpToDate) {
                this._instances.sort(x);
                if (this.UsesRenderCells())
                    for (let A = 0, F = this._instances.length; A < F; ++A) {
                        const J = this._instances[A].GetWorldInfo();
                        J._SetZIndex(A);
                        this._renderGrid.MarkRangeChanged(J.GetRenderCellRange())
                    } else
                        for (let A = 0, F = this._instances.length; A < F; ++A) this._instances[A].GetWorldInfo()._SetZIndex(A);
                this._zIndicesUpToDate = !0
            }
        }
        MoveInstanceAdjacent(A,
            F, J) {
            var B = A.GetWorldInfo();
            F = F.GetWorldInfo();
            if (B.GetLayer() !== this || F.GetLayer() !== this) throw Error("can't arrange Z order unless both objects on this layer");
            B = B.GetZIndex();
            F = F.GetZIndex();
            if (B === F + (J ? 1 : -1)) return !1;
            e.arrayRemove(this._instances, B);
            B < F && F--;
            J && F++;
            F === this._instances.length ? this._instances.push(A) : this._instances.splice(F, 0, A);
            this.SetZIndicesChanged();
            return !0
        }
        _MergeSortedZArrays(A, F) {
            const J = [];
            let B = 0,
                I = 0,
                L = A.length,
                P = F.length;
            for (; B < L && I < P;) {
                const S = A[B],
                    U = F[I];
                S.GetWorldInfo()._GetLastCachedZIndex() <
                    U.GetWorldInfo()._GetLastCachedZIndex() ? (J.push(S), ++B) : (J.push(U), ++I)
            }
            for (; B < L; ++B) J.push(A[B]);
            for (; I < P; ++I) J.push(F[I]);
            return J
        }
        _MergeAllSortedZArrays_pass(A) {
            const F = [],
                J = A.length;
            for (let B = 0; B < J - 1; B += 2) F.push(this._MergeSortedZArrays(A[B], A[B + 1]));
            1 === J % 2 && F.push(A[J - 1]);
            return F
        }
        _MergeAllSortedZArrays(A) {
            for (; 1 < A.length;) A = this._MergeAllSortedZArrays_pass(A);
            return A[0]
        }
        _GetRenderCellInstancesToDraw() {
            this._UpdateZIndices();
            e.clearArray(d);
            this._renderGrid.QueryRange(this._viewport, d);
            return d.length ?
                1 === d.length ? d[0] : this._MergeAllSortedZArrays(d) : []
        }
        ShouldDraw() {
            return this.IsVisible() && 0 < this.GetOpacity() && this._DrawsAnyContentInSelfOrSubLayers()
        }
        _DrawsAnyContentInSelfOrSubLayers() {
            if (this.HasInstances() || !this.IsTransparent()) return !0;
            for (const A of this._subLayers)
                if (A._DrawsAnyContentInSelfOrSubLayers()) return !0;
            return !1
        }
        UsesOwnTexture() {
            return this.IsForceOwnTexture() || !this.HasDefaultColor() || 0 !== this.GetBlendMode() || this._effectList.HasAnyActiveEffect()
        }
        SelfOrAnySubLayerUsesOwnTexture() {
            if (this.UsesOwnTexture()) return !0;
            for (const A of this._subLayers)
                if (A.SelfOrAnySubLayerUsesOwnTexture()) return !0;
            return !1
        }
        GetRenderTarget() {
            return this._curRenderTarget
        }
        Get2DScaleFactorToZ(A) {
            if (this._layout.IsOrthographicProjection()) return 1; {
                const F = this.GetCameraZ();
                return F / (F - A)
            }
        }
        GetCameraZ() {
            return 100 / this.GetNormalScale()
        }
        _SetMVMatrixChanged() {
            this._isViewFrustumChanged = this._isMVMatrixChanged = !0
        }
        _GetModelViewMatrix(A) {
            this._isMVMatrixChanged && (this._CalculateModelViewMatrix(A, this._modelViewMatrix, 0, 0, null), this._isMVMatrixChanged = !1);
            return this._modelViewMatrix
        }
        GetCameraPosition() {
            if (this.Has3DCamera()) {
                const A = this.GetLayout().Get3DCameraPosition();
                return [A[0], A[1], A[2]]
            }
            return this._Get2DCameraPosition()
        }
        _Get2DCameraPosition(A = 0, F = 0) {
            var J = this._runtime,
                B = this.GetLayout(),
                I = J.GetRenderScale(),
                L = J.GetParallaxXOrigin(),
                P = J.GetParallaxYOrigin();
            L = (this.GetScrollX() - L) * this._parallaxX + L;
            P = (this.GetScrollY() - P) * this._parallaxY + P;
            J.IsPixelRoundingEnabled() && (L = Math.round(L), P = Math.round(P));
            A = (L + A) * I;
            F = (P + F) * I;
            B = B.IsOrthographicProjection() ?
                100 : this.GetCameraZ();
            const [S, U] = this._GetVanishingPoint();
            if (.5 !== S || .5 !== U) L = 100 / B, P = (S - .5) * J.GetViewportWidth() * I / L, J = (U - .5) * J.GetViewportHeight() * I / L, I = this.GetAngle(), 0 !== I && (p.set(P, J), p.rotate(I), P = p.getX(), J = p.getY()), A += P, F += J;
            return [A, F, B]
        }
        _CalculateModelViewMatrix(A, F, J, B, I) {
            const L = this._runtime;
            var P = this.GetLayout();
            const S = L.GetRenderScale();
            if (this.Has3DCamera()) {
                f.copy(w, P.Get3DCameraPosition());
                f.copy(q, P.Get3DCameraLookAt());
                f.copy(t, P.Get3DCameraUpVector());
                J = L.GetParallaxXOrigin();
                B = L.GetParallaxYOrigin();
                P = q[0] - w[0];
                const U = q[1] - w[1],
                    V = q[2] - w[2];
                w[0] = (w[0] - J) * this._parallaxX + J;
                w[1] = (w[1] - B) * this._parallaxY + B;
                w[2] *= Math.max(this._parallaxX, this._parallaxY);
                q[0] = w[0] + P;
                q[1] = w[1] + U;
                q[2] = w[2] + V;
                f.set(n, S, S, 1);
                f.multiply(w, w, n);
                f.multiply(q, q, n)
            } else {
                const [U, V, Z] = this._Get2DCameraPosition(J, B);
                f.set(w, U, V, Z);
                f.set(q, U, V, Z - 100);
                J = this.GetAngle();
                0 === J ? f.set(t, 0, 1, 0) : f.set(t, Math.sin(J), Math.cos(J), 0)
            }
            A.CalculateLookAtModelView(F, w, q, t, I || L.GetCanvasManager().GetDrawHeight());
            1 !==
                S && (f.set(n, S, S, 1), h.scale(F, F, n))
        }
        _SetProjectionMatrixChanged() {
            this._isViewFrustumChanged = this._isProjectionMatrixChanged = !0
        }
        _GetProjectionMatrix(A) {
            this._isProjectionMatrixChanged && (this._CalculateProjectionMatrix(A), this._isProjectionMatrixChanged = !1);
            return this._projectionMatrix
        }
        _CalculateProjectionMatrix(A) {
            var F = this._runtime.GetCanvasManager();
            const [J, B] = this._GetVanishingPoint();
            if (this._layout.IsOrthographicProjection()) A.CalculateOrthographicMatrix(this._projectionMatrix, F.GetDrawWidth(),
                F.GetDrawHeight());
            else if (.5 === J && .5 === B) h.copy(this._projectionMatrix, F.GetDefaultProjectionMatrix());
            else {
                const I = F.GetDrawWidth();
                F = F.GetDrawHeight();
                A.CalculatePerspectiveMatrix(this._projectionMatrix, I / F, J, B)
            }
        }
        _SetTransform(A, F = !0, J = 0, B = 0, I = 0) {
            F && A.SetProjectionMatrix(this._GetProjectionMatrix(A));
            0 === J && 0 === B && 0 === I ? F = this._GetModelViewMatrix(A) : (this._CalculateModelViewMatrix(A, l, J, B, I), F = l);
            A.SetModelViewMatrix(F)
        }
        PrepareForDraw(A) {
            this._SetTransform(A);
            A.SetBaseZ(this.GetZElevation())
        }
        Draw(A,
            F, J) {
            var B = this._runtime.GetCanvasManager();
            const I = this.UsesOwnTexture();
            var L = null;
            let P = null;
            if (this._runtime.IsGPUProfiling())
                if (A.IsWebGL()) {
                    const S = B.GetLayerTimingsBuffer(this);
                    S && (P = S.AddTimeElapsedQuery(), A.StartQuery(P))
                } else A.IsWebGPU() && A.WriteTimestamp(2 * (this.GetIndex() + 1));
            I ? (L = {
                    sampling: this._runtime.GetSampling()
                }, "low" === B.GetCurrentFullscreenScalingQuality() && (L.width = B.GetDrawWidth(), L.height = B.GetDrawHeight()), this._curRenderTarget = L = this._runtime.GetAdditionalRenderTarget(L),
                A.SetRenderTarget(L), this.IsTransparent() && A.ClearRgba(0, 0, 0, 0)) : (this._curRenderTarget = F, A.SetRenderTarget(F));
            this.IsTransparent() || A.Clear(this._backgroundColor);
            this._layout._DrawLayerList(A, this._curRenderTarget, this._subLayers, I && this.IsTransparent());
            this._SetTransform(A);
            A.SetBaseZ(this.GetZElevation());
            A.SetDepthEnabled(this.RendersIn3DMode());
            this.GetNormalScale() > Number.EPSILON && (this._UpdateZIndices(), B = this.UsesRenderCells() && 0 === this.GetZElevation() && !this._anyInstanceZElevated, this.Has3DCamera() ?
                this._DrawInstances_3DCamera(A) : B ? this._DrawInstances_RenderCells(A) : this._DrawInstances(A, this._GetInstancesInDrawOrder()));
            A.SetBaseZ(0);
            A.SetCurrentZ(0);
            I && (A.SetDepthEnabled(!1), this._DrawLayerOwnTextureToRenderTarget(A, L, F, J));
            P && A.EndQuery(P);
            this._runtime.IsGPUProfiling() && A.IsWebGPU() && A.WriteTimestamp(2 * (this.GetIndex() + 1) + 1);
            this._curRenderTarget = null
        }
        _DrawInstances(A, F) {
            const J = this._viewport,
                B = this._curRenderTarget,
                I = this.GetLayout().IsOrthographicProjection(),
                L = this.GetLayout().HasVanishingPointOutsideViewport();
            let P = null;
            for (let S = 0, U = F.length; S < U; ++S) {
                const V = F[S];
                if (V === P) continue;
                P = V;
                const Z = V.GetWorldInfo();
                Z.IsVisible() && Z.IsInViewport(J, L, I) && this._DrawInstanceMaybeWithEffects(V, Z, A, B)
            }
        }
        _DrawInstances_3DCamera(A) {
            const F = this._curRenderTarget,
                J = this._GetViewFrustum(),
                B = this._GetInstancesInDrawOrder();
            for (let S = 0, U = B.length; S < U;) {
                var I = B[S],
                    L = I.GetWorldInfo();
                if (!L.IsVisible() || !L.IsInViewport3D(J)) {
                    ++S;
                    continue
                }(!I.RendersToOwnZPlane() || 0 < L.GetDepth()) && E.push(I);
                var P = I.GetWorldInfo().GetTotalZElevation();
                y.push(I);
                let V = S + 1;
                for (; V < U; ++V) {
                    const Z = B[V],
                        ma = Z.GetWorldInfo();
                    if (ma.IsVisible() && ma.IsInViewport3D(J)) {
                        if (ma.GetTotalZElevation() !== P) break;
                        Z.RendersToOwnZPlane() ? (0 < ma.GetDepth() && E.push(Z), y.push(Z)) : E.push(Z)
                    }
                }
                if (1 !== y.length || y[0].MustMitigateZFighting()) {
                    this._DrawCoplanarInstances_3DCamera(A, y);
                    for (let Z = 0, ma = E.length; Z < ma; ++Z) I = E[Z], L = I.GetWorldInfo(), L._SetDrawNonBackFacesOnly(!0), this._DrawInstanceMaybeWithEffects(I, L, A, F), L._SetDrawNonBackFacesOnly(!1)
                } else {
                    this._DrawInstanceMaybeWithEffects(I,
                        L, A, F);
                    for (let Z = 0, ma = E.length; Z < ma; ++Z) L = E[Z], L !== I && (P = L.GetWorldInfo(), P.GetLayer()._DrawInstanceMaybeWithEffects(L, P, A, F))
                }
                S = V;
                e.clearArray(y);
                e.clearArray(E)
            }
        }
        _DrawCoplanarInstances_3DCamera(A, F) {
            const J = this._curRenderTarget;
            A.CoplanarStartStencilPass();
            for (let L = 0, P = F.length; L < P; ++L) {
                var B = F[L],
                    I = B.GetWorldInfo();
                I._SetDrawBackFaceOnly(!0);
                this._DrawInstance(B, I, A)
            }
            A.CoplanarStartColorPass();
            for (let L = 0, P = F.length; L < P; ++L) B = F[L], I = B.GetWorldInfo(), this._DrawInstanceMaybeWithEffects(B, I, A, J),
                I._SetDrawBackFaceOnly(!1);
            A.CoplanarRestoreStandardRendering()
        }
        _DrawInstances_RenderCells(A) {
            var F = this._renderGrid;
            const J = this._curRenderCells,
                B = this._lastRenderCells,
                I = this._viewport;
            J.set(F.XToCell(I.getLeft()), F.YToCell(I.getTop()), F.XToCell(I.getRight()), F.YToCell(I.getBottom()));
            this._isRenderListUpToDate && J.equals(B) ? F = this._lastRenderList : (F = this._GetRenderCellInstancesToDraw(), this._isRenderListUpToDate = !0, B.copy(J));
            this._DrawInstances(A, F);
            F !== this._lastRenderList && e.shallowAssignArray(this._lastRenderList,
                F)
        }
        _DrawInstanceMaybeWithEffects(A, F, J, B) {
            F.HasAnyActiveEffect() ? this._DrawInstanceWithEffectsAndRestore(A, F, J, B) : this._DrawInstance(A, F, J)
        }
        _DrawInstance(A, F, J) {
            F = F.GetRendererStateGroup();
            J.GetCurrentStateGroup() !== F && F.Apply();
            A.Draw(J)
        }
        _DrawInstanceWithEffectsAndRestore(A, F, J, B) {
            this._DrawInstanceWithEffects(A, F, J, B, null) && this._SetTransform(J)
        }
        _DrawInstanceWithEffects(A, F, J, B, I) {
            const L = F.GetInstanceEffectList().GetEffectChain();
            L.Render(J, B, {
                contentObject: A,
                blendMode: F.GetBlendMode(),
                devicePixelRatio: this._runtime.GetEffectDevicePixelRatioParam(),
                layerScale: this._runtime.GetEffectLayerScaleParam() * this.GetNormalScale(),
                layerAngle: this.GetAngle(),
                layoutRect: F.GetBoundingBox(),
                drawSurfaceRect: L.IsFastPath() ? null : this._InstanceBoxToDrawSurface(F),
                drawContentHook: I && I.drawContentHook,
                compositOffX: I && I.compositOffX,
                compositOffY: I && I.compositOffY,
                updateOwnProjection: I && I.updateOwnProjection
            });
            J.SetBaseZ(this.GetZElevation());
            return L.DidChangeTransform()
        }
        _DrawLayerOwnTextureToRenderTarget(A, F, J, B) {
            const I = this._effectList.GetActiveEffectTypes(),
                L = this._runtime;
            0 === I.length ? (A.SetRenderTarget(J), A.SetTextureFillMode(), B && 0 === this._blendMode && this.HasDefaultColor() ? A.CopyRenderTarget(F) : (A.SetBlendMode(this._blendMode), A.SetColor(this._premultipliedColor), A.DrawRenderTarget(F)), A.InvalidateRenderTarget(F), L.ReleaseAdditionalRenderTarget(F)) : this.GetEffectChain().Render(A, J, {
                contentObject: this,
                blendMode: this.GetBlendMode(),
                devicePixelRatio: L.GetEffectDevicePixelRatioParam(),
                layerScale: L.GetEffectLayerScaleParam() * this.GetNormalScale(),
                layerAngle: this.GetAngle(),
                layoutRect: this.GetViewport(),
                drawSurfaceRect: null,
                invalidateRenderTargets: !0
            })
        }
        GetOwnScale() {
            return this._scale
        }
        SetOwnScale(A) {
            this._scale !== A && (this._scale = A, this._layout.BoundScrolling(), this._SetMVMatrixChanged(), this._runtime.UpdateRender())
        }
        GetRenderScale() {
            return this.GetNormalScale() * this._runtime.GetRenderScale()
        }
        GetDisplayScale() {
            return this.GetNormalScale() * this._runtime.GetDisplayScale()
        }
        GetNormalScale() {
            return (this._scale * this._layout.GetScale() - 1) * this._scaleRate + 1
        }
        UpdateViewport() {
            var A =
                this._runtime.GetParallaxXOrigin(),
                F = this._runtime.GetParallaxYOrigin(),
                J = (this.GetScrollX() - A) * this._parallaxX + A,
                B = (this.GetScrollY() - F) * this._parallaxY + F;
            A = this.GetNormalScale();
            F = this._runtime.GetViewportWidth() / A;
            A = this._runtime.GetViewportHeight() / A;
            J -= F / 2;
            let I = B - A / 2;
            this._runtime.IsPixelRoundingEnabled() && (J = Math.round(J), I = Math.round(I));
            B = this._viewportZ0;
            B.set(J, I, J + F, I + A);
            F = this.GetAngle();
            0 !== F && (a.copy(B), a.offset(-B.midX(), -B.midY()), b.setFromRotatedRect(a, F), b.getBoundingBox(a), a.offset(B.midX(),
                B.midY()), B.copy(a));
            F = this._zElevation;
            this.GetViewportForZ(F, this._viewport);
            this.Has3DCamera() ? this.CalculateViewport3D(F, this._viewport3D) : this._viewport3D.copy(this._viewport)
        }
        CalculateViewport3D(A, F) {
            var J = this._runtime.GetCanvasManager(),
                B = J.GetCssWidth();
            J = J.GetCssHeight();
            const [I, L] = this.CanvasCssToLayer(0, 0, A), [P, S] = this.CanvasCssToLayer(B, 0, A), [U, V] = this.CanvasCssToLayer(B, J, A), [Z, ma] = this.CanvasCssToLayer(0, J, A);
            A = Math.min(I, P, U, Z);
            B = Math.min(L, S, V, ma);
            J = Math.max(I, P, U, Z);
            let va = Math.max(L,
                S, V, ma);
            isFinite(A) || (A = -Infinity);
            isFinite(B) || (B = -Infinity);
            isFinite(J) || (J = Infinity);
            isFinite(va) || (va = Infinity);
            F.set(A, B, J, va)
        }
        CanvasCssToLayer(A, F, J = 0) {
            return this._CanvasToLayer(A, F, J, this.GetDisplayScale())
        }
        DrawSurfaceToLayer(A, F, J = 0) {
            return this._CanvasToLayer(A, F, J, this.GetRenderScale() * this.GetDevicePixelRatio())
        }
        _CanvasToLayer(A, F, J, B) {
            var I = this._runtime,
                L = I.GetRenderer();
            const P = this.GetNormalScale(),
                S = I.GetViewportWidth() / P;
            I = I.GetViewportHeight() / P;
            k.set(u, 0, 0, S, I);
            A /= B;
            F = u[3] - F / B;
            B = this._GetProjectionMatrix(L);
            L = this._GetModelViewMatrix(L);
            return e.Gfx.UnprojectScreenToWorldZ(A, F, J, L, B, u, n) ? [n[0], n[1]] : [NaN, NaN]
        }
        CanvasCssToLayer_DefaultTransform(A, F) {
            const J = this._scale,
                B = this._scaleRate,
                I = this._parallaxX,
                L = this._parallaxY,
                P = this._angle;
            this._parallaxY = this._parallaxX = this._scaleRate = this._scale = 1;
            this._angle = 0;
            this._SetMVMatrixChanged();
            A = this.CanvasCssToLayer(A, F);
            this._scale = J;
            this._scaleRate = B;
            this._parallaxX = I;
            this._parallaxY = L;
            this._angle = P;
            this._SetMVMatrixChanged();
            return A
        }
        LayerToCanvasCss(A, F, J = 0) {
            return this._LayerToCanvas(A, F, J, this.GetDisplayScale())
        }
        LayerToDrawSurface(A, F, J = 0) {
            return this._LayerToCanvas(A, F, J, this.GetRenderScale() * this.GetDevicePixelRatio())
        }
        _LayerToCanvas(A, F, J, B) {
            var I = this._runtime,
                L = I.GetRenderer();
            const P = this.GetNormalScale();
            var S = I.GetViewportWidth() / P;
            I = I.GetViewportHeight() / P;
            k.set(u, 0, 0, S, I);
            S = this._GetProjectionMatrix(L);
            L = this._GetModelViewMatrix(L);
            return e.Gfx.Project(A, F, J, L, S, u, n) ? [n[0] * B, (u[3] - n[1]) * B] : [NaN, NaN]
        }
        _GetLayerToDrawSurfaceScale(A,
            F) {
            A *= this.GetRenderScale() * this.GetDevicePixelRatio();
            0 !== F && (A *= this.Get2DScaleFactorToZ(F));
            return A
        }
        _InstanceBoxToDrawSurface(A) {
            var F = A.GetBoundingBox(),
                J = A.GetTotalZElevation();
            A = A.GetDepth();
            const B = J + A,
                I = F.getLeft(),
                L = F.getTop(),
                P = F.getRight();
            F = F.getBottom();
            if (this.Has3DCamera()) {
                if (this._IsPointBehindNearPlane(I, L, J) || this._IsPointBehindNearPlane(P, L, J) || this._IsPointBehindNearPlane(P, F, J) || this._IsPointBehindNearPlane(I, F, J) || 0 < A && (this._IsPointBehindNearPlane(I, L, B) || this._IsPointBehindNearPlane(P,
                        L, B) || this._IsPointBehindNearPlane(P, F, B) || this._IsPointBehindNearPlane(I, F, B))) return null
            } else if (B >= this.GetCameraZ()) return null;
            let [S, U] = this.LayerToDrawSurface(I, L, J), [V, Z] = this.LayerToDrawSurface(P, F, J);
            if (0 !== this.GetAngle() || 0 < A) {
                const [ma, va] = this.LayerToDrawSurface(P, L, J), [Na, Ea] = this.LayerToDrawSurface(I, F, J);
                if (0 < A) {
                    const [Ia, Ma] = this.LayerToDrawSurface(I, L, B), [Fa, ya] = this.LayerToDrawSurface(P, L, B), [na, Va] = this.LayerToDrawSurface(P, F, B), [xa, Ga] = this.LayerToDrawSurface(I, F, B);
                    J = Math.min(S,
                        V, ma, Na, Ia, Fa, na, xa);
                    V = Math.max(S, V, ma, Na, Ia, Fa, na, xa);
                    S = J;
                    J = Math.min(U, Z, va, Ea, Ma, ya, Va, Ga);
                    Z = Math.max(U, Z, va, Ea, Ma, ya, Va, Ga);
                    U = J
                } else J = Math.min(S, V, ma, Na), V = Math.max(S, V, ma, Na), S = J, J = Math.min(U, Z, va, Ea), Z = Math.max(U, Z, va, Ea), U = J
            }
            a.set(S, U, V, Z);
            return a
        }
        _GetViewFrustum() {
            this._isViewFrustumChanged && (this._UpdateViewFrustum(), this._isViewFrustumChanged = !1);
            return this._viewFrustum
        }
        _UpdateViewFrustum() {
            var A = this._runtime.GetRenderer();
            const F = this._GetProjectionMatrix(A);
            A = this._GetModelViewMatrix(A);
            this._viewFrustum.CalculatePlanes(A, F)
        }
        _IsPointBehindNearPlane(A, F, J) {
            return this._GetViewFrustum().IsBehindNearPlane(A, F, J)
        }
        _SaveToJson() {
            return {
                s: this.GetOwnScale(),
                a: this.GetOwnAngle(),
                vl: this._viewport.getLeft(),
                vt: this._viewport.getTop(),
                vr: this._viewport.getRight(),
                vb: this._viewport.getBottom(),
                v: this._IsVisibleFlagSet(),
                bc: this._backgroundColor.toJSON(),
                t: this.IsTransparent(),
                sx: this._scrollX,
                sy: this._scrollY,
                hosp: this._hasOwnScrollPosition,
                px: this.GetParallaxX(),
                py: this.GetParallaxY(),
                c: this._color.toJSON(),
                sr: this.GetScaleRate(),
                fx: this._effectList.SaveToJson(),
                cg: this._createdGlobalUids
            }
        }
        _LoadFromJson(A) {
            this._scale = A.s;
            this._angle = A.a;
            this._viewport.set(A.vl, A.vt, A.vr, A.vb);
            this._isVisible = !!A.v;
            this._backgroundColor.setFromJSON(A.bc);
            this._isTransparent = !!A.t;
            A.hasOwnProperty("sx") && (this._scrollX = A.sx);
            A.hasOwnProperty("sy") && (this._scrollY = A.sy);
            A.hasOwnProperty("hosp") && (this._hasOwnScrollPosition = !!A.hosp);
            this._parallaxX = A.px;
            this._parallaxY = A.py;
            this._color.setFromJSON(A.c);
            this._scaleRate =
                A.sr;
            e.shallowAssignArray(this._createdGlobalUids, A.cg);
            e.shallowAssignArray(this._initialInstances, this._startupInitialInstances);
            const F = new Set(this._createdGlobalUids);
            let J = 0;
            for (let B = 0, I = this._initialInstances.length; B < I; ++B) F.has(this._initialInstances[B][2]) || (this._initialInstances[J] = this._initialInstances[B], ++J);
            e.truncateArray(this._initialInstances, J);
            this._effectList.LoadFromJson(A.fx);
            this._needsRebuildEffectChainSteps = !0;
            this._SortInstancesByLastCachedZIndex(!1);
            this.SetZIndicesChanged()
        }
        GetILayer() {
            return this._iLayer
        }
        SortAndAddInstancesByZIndex(A) {
            if (!this._instances.includes(A))
                if (A.HasChildren()) {
                    var F = [...A.allChildren()];
                    F.push(A);
                    F.sort((B, I) => {
                        B = B.GetWorldInfo().GetSceneGraphZIndex();
                        I = I.GetWorldInfo().GetSceneGraphZIndex();
                        return B - I
                    });
                    for (var J of F)
                        if (J.IsInContainer())
                            for (const B of J.siblings()) F.includes(B) || (A = [...B.allChildren()], A.push(B), A.sort((I, L) => {
                                I = I.GetWorldInfo().GetSceneGraphZIndex();
                                L = L.GetWorldInfo().GetSceneGraphZIndex();
                                return I - L
                            }), A && A.length && F.splice(F.length, 0, ...A));
                    for (const B of F) this._AddInstance(B, !0)
                } else if (this._AddInstance(A, !0), A.IsInContainer())
                for (F of A.siblings())
                    if (J = [...F.allChildren()], J.push(F), J.sort((B, I) => {
                            B = B.GetWorldInfo().GetSceneGraphZIndex();
                            I = I.GetWorldInfo().GetSceneGraphZIndex();
                            return B - I
                        }), J && J.length)
                        for (const B of J) this._AddInstance(B, !0)
        }
    }
} {
    "use strict";
    const e = self.C3,
        a = self.C3Debugger;
    e.New(e.Rect);
    e.New(e.Rect);
    const b = e.New(e.Rect),
        d = e.New(e.Color),
        c = self.glMatrix.vec3,
        f = [],
        k = [],
        h = [],
        l = [];

    function n(q, t, p, r) {
        return q[0] === Math.fround(t) && q[1] === Math.fround(p) && q[2] === Math.fround(r)
    }
    let u = null;

    function w(q, t) {
        u !== q && (q.PrepareForDraw(t), u = q)
    }
    e.Layout = class extends e.DefendedBase {
        constructor(q, t, p) {
            super();
            this._layoutManager = q;
            this._runtime = q.GetRuntime();
            this._name = p[0];
            this._originalWidth = p[1];
            this._originalHeight = p[2];
            this._width =
                p[1];
            this._height = p[2];
            this._isUnboundedScrolling = !!p[3];
            this._isOrthographicProjection = !!p[4];
            this._vanishingPointX = p[5];
            this._vanishingPointY = p[6];
            this._eventSheetName = p[7];
            this._eventSheet = null;
            this._sid = p[8];
            this._index = t;
            this._scrollY = this._scrollX = 0;
            this._scale = 1;
            this._angle = 0;
            this._initialObjectClasses = new Set;
            this._textureLoadedTypes = new Set;
            this._textureLoadPendingPromises = new Set;
            this._createdInstances = [];
            this._initialNonWorld = [];
            this._is3dCameraEnabled = !1;
            this._cam3dposition = c.create();
            this._cam3dlook = c.create();
            this._cam3dup = c.create();
            this._rootLayers = [];
            this._allLayersFlat = [];
            this._layersByName = new Map;
            this._layersBySid = new Map;
            const r = this._runtime.GetCanvasManager();
            this._effectList = e.New(e.EffectList, this, p[11]);
            this._effectChain = e.New(e.Gfx.EffectChain, r.GetEffectChainManager(), {
                drawContent: (x, y) => {
                    y = y.GetContentObject().GetRenderTarget();
                    x.ResetColor();
                    x.DrawRenderTarget(y);
                    x.InvalidateRenderTarget(y);
                    r.ReleaseAdditionalRenderTarget(y)
                },
                getShaderParameters: x => this.GetEffectList().GetEffectParametersForIndex(x)
            });
            this._needsRebuildEffectChainSteps = !0;
            this._wasFullScreenQualityLow = !1;
            this._curRenderTarget = null;
            this._persistData = {};
            this._isFirstVisit = !0;
            this._iLayout = new self.ILayout(this);
            this._userScriptDispatcher = e.New(e.Event.Dispatcher);
            for (const x of p[9]) this._rootLayers.push(e.New(e.Layer, this, null, x));
            this._allLayersFlat = [...this.allLayers()];
            for (let x = 0, y = this._allLayersFlat.length; x < y; ++x) q = this._allLayersFlat[x], q._SetIndex(x), q._Init(), this._layersByName.set(q.GetName().toLowerCase(), q), this._layersBySid.set(q.GetSID(),
                q);
            for (const x of p[10]) {
                p = this._runtime.GetObjectClassByIndex(x[1]);
                if (!p) throw Error("missing nonworld object class");
                p.GetDefaultInstanceData() || p.SetDefaultInstanceData(x);
                this._initialNonWorld.push(x);
                this._AddInitialObjectClass(p)
            }
        }
        Release() {
            for (const q of this._allLayersFlat) q.Release();
            e.clearArray(this._allLayersFlat);
            this._textureLoadPendingPromises.clear();
            this._runtime = this._layoutManager = this._eventSheet = null
        }
        GetRuntime() {
            return this._runtime
        }
        GetName() {
            return this._name
        }
        GetSID() {
            return this._sid
        }
        GetIndex() {
            return this._index
        }
        GetEffectList() {
            return this._effectList
        }
        GetEffectChain() {
            this._MaybeRebuildEffectChainSteps();
            return this._effectChain
        }
        _MaybeRebuildEffectChainSteps() {
            const q = "low" === this._runtime.GetCanvasManager().GetCurrentFullscreenScalingQuality();
            if (this._needsRebuildEffectChainSteps || this._wasFullScreenQualityLow !== q) {
                var t = this.GetEffectList().GetActiveEffectTypes();
                this._effectChain.BuildSteps(t.map(p => p.GetShaderProgram()), {
                    indexMap: t.map(p => p.GetIndex()),
                    forcePostDraw: q,
                    useFullSurface: !0
                });
                this._needsRebuildEffectChainSteps = !1;
                this._wasFullScreenQualityLow = q
            }
        }
        UpdateActiveEffects() {
            this.GetEffectList().UpdateActiveEffects();
            this._needsRebuildEffectChainSteps = !0
        }
        GetMinLayerScale() {
            let q = this._allLayersFlat[0].GetNormalScale();
            for (let t = 1, p = this._allLayersFlat.length; t < p; ++t) {
                const r = this._allLayersFlat[t];
                if (0 !== r.GetParallaxX() || 0 !== r.GetParallaxY()) q = Math.min(q, r.GetNormalScale())
            }
            return q
        }
        _GetScrollBoundMarginHorizontal() {
            return .5 * this._runtime.GetViewportWidth() / this.GetMinLayerScale()
        }
        _GetScrollBoundMarginVertical() {
            return .5 * this._runtime.GetViewportHeight() / this.GetMinLayerScale()
        }
        GetScrollLeftBound() {
            return this.IsUnboundedScrolling() ?
                -Infinity : this._GetScrollBoundMarginHorizontal()
        }
        GetScrollRightBound() {
            return this.IsUnboundedScrolling() ? Infinity : this.GetWidth() - this._GetScrollBoundMarginHorizontal()
        }
        GetScrollTopBound() {
            return this.IsUnboundedScrolling() ? -Infinity : this._GetScrollBoundMarginVertical()
        }
        GetScrollBottomBound() {
            return this.IsUnboundedScrolling() ? Infinity : this.GetHeight() - this._GetScrollBoundMarginVertical()
        }
        SetScrollX(q) {
            const t = this.GetScrollLeftBound(),
                p = this.GetScrollRightBound();
            q > p && (q = p);
            q < t && (q = t);
            this._scrollX !==
                q && (this._scrollX = q, this._SetAllLayersMVChanged(), this._runtime.UpdateRender())
        }
        GetScrollX() {
            return this._scrollX
        }
        SetScrollY(q) {
            const t = this.GetScrollTopBound(),
                p = this.GetScrollBottomBound();
            q > p && (q = p);
            q < t && (q = t);
            this._scrollY !== q && (this._scrollY = q, this._SetAllLayersMVChanged(), this._runtime.UpdateRender())
        }
        GetScrollY() {
            return this._scrollY
        }
        IsUnboundedScrolling() {
            return this._isUnboundedScrolling
        }
        BoundScrolling() {
            this.SetScrollX(this.GetScrollX());
            this.SetScrollY(this.GetScrollY());
            for (const q of this._allLayersFlat) q.IsOwnScrollPositionEnabled() &&
                (q.SetScrollX(q.GetScrollX()), q.SetScrollY(q.GetScrollY()))
        }
        SetVanishingPointXY(q, t) {
            if (this._vanishingPointX !== q || this._vanishingPointY !== t) this._vanishingPointX = q, this._vanishingPointY = t, this.IsPerspectiveProjection() && (this._SetAllLayersProjectionChanged(), this._SetAllLayersMVChanged(), this._runtime.UpdateRender())
        }
        GetVanishingPointX() {
            return this.IsOrthographicProjection() ? .5 : this._vanishingPointX
        }
        GetVanishingPointY() {
            return this.IsOrthographicProjection() ? .5 : this._vanishingPointY
        }
        HasVanishingPointOutsideViewport() {
            const q =
                this.GetVanishingPointX(),
                t = this.GetVanishingPointY();
            return 0 > q || 1 < q || 0 > t || 1 < t
        }
        SetPerspectiveProjection() {
            this._isOrthographicProjection && (this._isOrthographicProjection = !1, this._SetAllLayersProjectionChanged(), this._SetAllLayersMVChanged(), this._runtime.UpdateRender())
        }
        SetOrthographicProjection() {
            this._isOrthographicProjection || (this._isOrthographicProjection = !0, this._SetAllLayersProjectionChanged(), this._SetAllLayersMVChanged(), this._runtime.UpdateRender())
        }
        IsOrthographicProjection() {
            return this._isOrthographicProjection
        }
        IsPerspectiveProjection() {
            return !this.IsOrthographicProjection()
        }
        Set3DCameraEnabled(q) {
            q = !!q;
            this._is3dCameraEnabled !== q && (this._is3dCameraEnabled = q, this._SetAllLayersMVChanged(), this._runtime.UpdateRender())
        }
        Is3DCameraEnabled() {
            return this._is3dCameraEnabled
        }
        Set3DCameraOrientation(q, t, p, r, x, y, E, G, A) {
            n(this._cam3dposition, q, t, p) && n(this._cam3dlook, r, x, y) && n(this._cam3dup, E, G, A) || (c.set(this._cam3dposition, q, t, p), c.set(this._cam3dlook, r, x, y), c.set(this._cam3dup, E, G, A), this.Set3DCameraChanged())
        }
        Set3DCameraChanged() {
            this._SetAllLayersMVChanged();
            this._runtime.UpdateRender()
        }
        Get3DCameraPosition() {
            return this._cam3dposition
        }
        Get3DCameraLookAt() {
            return this._cam3dlook
        }
        Get3DCameraUpVector() {
            return this._cam3dup
        }
        GetScale() {
            return this._scale
        }
        SetScale(q) {
            this._scale !==
                q && (this._scale = q, this._SetAllLayersMVChanged(), this.BoundScrolling(), this._runtime.UpdateRender())
        }
        SetAngle(q) {
            q = e.clampAngle(q);
            this._angle !== q && (this._angle = q, this._SetAllLayersMVChanged(), this._runtime.UpdateRender())
        }
        GetAngle() {
            return this._angle
        }
        GetWidth() {
            return this._width
        }
        SetWidth(q) {
            !isFinite(q) || 1 > q || (this._width = q)
        }
        GetHeight() {
            return this._height
        }
        SetHeight(q) {
            !isFinite(q) || 1 > q || (this._height = q)
        }
        GetEventSheet() {
            return this._eventSheet
        }* allLayers() {
            for (const q of this._rootLayers) yield* q.selfAndAllSubLayers()
        }
        GetLayers() {
            return this._allLayersFlat
        }
        GetLayerCount() {
            return this._allLayersFlat.length
        }
        GetLayer(q) {
            return "number" ===
                typeof q ? this.GetLayerByIndex(q) : this.GetLayerByName(q.toString())
        }
        GetLayerByIndex(q) {
            q = e.clamp(Math.floor(q), 0, this._allLayersFlat.length - 1);
            return this._allLayersFlat[q]
        }
        GetLayerByName(q) {
            return this._layersByName.get(q.toLowerCase()) || null
        }
        GetLayerBySID(q) {
            return this._layersBySid.get(q) || null
        }
        _SetAllLayersProjectionChanged() {
            for (const q of this._allLayersFlat) q._SetProjectionMatrixChanged()
        }
        _SetAllLayersMVChanged() {
            for (const q of this._allLayersFlat) q._SetMVMatrixChanged()
        }
        SaveTransform() {
            return {
                scrollX: this.GetScrollX(),
                scrollY: this.GetScrollY(),
                scale: this.GetScale(),
                angle: this.GetAngle(),
                vpX: this.GetVanishingPointX(),
                vpY: this.GetVanishingPointY()
            }
        }
        RestoreTransform(q) {
            this.SetScrollX(q.scrollX);
            this.SetScrollY(q.scrollY);
            this.SetScale(q.scale);
            this.SetAngle(q.angle);
            this.SetVanishingPointXY(q.vpX, q.vpY)
        }
        GetLayoutBackgroundColor() {
            let q = this._rootLayers.filter(t => t.ShouldDraw())[0];
            for (; q;) {
                if (!q.IsTransparent()) return d.copyRgb(q.GetBackgroundColor()), d.setA(1), d;
                if (q.UsesOwnTexture()) return d.setRgba(0, 0, 0, 0), d;
                q = q.GetSubLayers().filter(t => t.ShouldDraw())[0]
            }
            d.setRgba(0, 0, 0, 0);
            return d
        }
        IsFirstVisit() {
            return this._isFirstVisit
        }
        _GetInitialObjectClasses() {
            return [...this._initialObjectClasses]
        }
        _AddInitialObjectClass(q) {
            if (q.IsInContainer())
                for (const t of q.GetContainer().GetObjectTypes()) this._initialObjectClasses.add(t);
            else this._initialObjectClasses.add(q)
        }
        _GetTextureLoadedObjectTypes() {
            return [...this._textureLoadedTypes]
        }
        _Load(q, t) {
            if (q === this || !t) return Promise.resolve();
            q && (e.CopySet(this._textureLoadedTypes,
                q._textureLoadedTypes), q._textureLoadedTypes.clear());
            q = [];
            for (const p of this._initialObjectClasses) this._textureLoadedTypes.has(p) || (q.push(p.LoadTextures(t)), this._textureLoadedTypes.add(p));
            return Promise.all(q)
        }
        async MaybeLoadTexturesFor(q) {
            if (q.IsFamily()) throw Error("cannot load textures for family");
            var t = this._runtime.GetRenderer();
            !t || t.IsContextLost() || this._textureLoadedTypes.has(q) || (this._textureLoadedTypes.add(q), t = q.LoadTextures(t), this._AddPendingTextureLoadPromise(t), await t, q.OnDynamicTextureLoadComplete(),
                this._runtime.UpdateRender())
        }
        _AddPendingTextureLoadPromise(q) {
            this._textureLoadPendingPromises.add(q);
            q.then(() => this._textureLoadPendingPromises.delete(q)).catch(() => this._textureLoadPendingPromises.delete(q))
        }
        WaitForPendingTextureLoadsToComplete() {
            return Promise.all([...this._textureLoadPendingPromises])
        }
        MaybeUnloadTexturesFor(q) {
            if (q.IsFamily() || 0 < q.GetInstanceCount()) throw Error("cannot unload textures");
            const t = this._runtime.GetRenderer();
            t && this._textureLoadedTypes.has(q) && (this._textureLoadedTypes.delete(q),
                q.ReleaseTextures(t))
        }
        _Unload(q, t) {
            if (q !== this && t)
                for (const p of this._textureLoadedTypes) p.IsGlobal() || q._initialObjectClasses.has(p) || (p.ReleaseTextures(), this._textureLoadedTypes.delete(p))
        }
        _OnWebGLContextLost() {
            this._textureLoadedTypes.clear()
        }
        async _StartRunning(q) {
            const t = this._runtime,
                p = this._layoutManager,
                r = t.GetEventSheetManager();
            this._eventSheetName && (this._eventSheet = r.GetEventSheetByName(this._eventSheetName), this._eventSheet._UpdateDeepIncludes());
            p._SetMainRunningLayout(this);
            this._width =
                this._originalWidth;
            this._height = this._originalHeight;
            this._scrollX = t.GetOriginalViewportWidth() / 2;
            this._scrollY = t.GetOriginalViewportHeight() / 2;
            this.BoundScrolling();
            this._MoveGlobalObjectsToThisLayout(q);
            this._runtime.SetUsingCreatePromises(!0);
            this._CreateInitialInstances();
            this._isFirstVisit || this._CreatePersistedInstances();
            this._CreateAndLinkContainerInstances(this._createdInstances);
            this._CreateInitialNonWorldInstances();
            p.ClearPendingChangeLayout();
            t.FlushPendingInstances();
            this._runtime.SetUsingCreatePromises(!1);
            const x = this._runtime.GetCreatePromises();
            await Promise.all(x);
            e.clearArray(x);
            if (!t.IsLoadingState()) {
                for (const y of this._createdInstances) y.SetupInitialSceneGraphConnections();
                for (const y of this._createdInstances) y._TriggerOnCreated()
            }
            e.clearArray(this._createdInstances);
            await Promise.all([...this._initialObjectClasses].map(y => y.PreloadTexturesWithInstances(this._runtime.GetRenderer())));
            q && (t.Dispatcher().dispatchEvent(new e.Event("beforefirstlayoutstart")), await t.DispatchUserScriptEventAsyncWait(new e.Event("beforeprojectstart")));
            await this.DispatchUserScriptEventAsyncWait(new e.Event("beforelayoutstart"));
            t.IsLoadingState() || await t.TriggerAsync(e.Plugins.System.Cnds.OnLayoutStart, null, null);
            await this.DispatchUserScriptEventAsyncWait(new e.Event("afterlayoutstart"));
            q && (t.Dispatcher().dispatchEvent(new e.Event("afterfirstlayoutstart")), await t.DispatchUserScriptEventAsyncWait(new e.Event("afterprojectstart")));
            r._RunQueuedTriggers(p);
            await this.WaitForPendingTextureLoadsToComplete();
            this._SetAllLayersProjectionChanged();
            this._SetAllLayersMVChanged();
            this._isFirstVisit = !1
        }
        _MoveGlobalObjectsToThisLayout(q) {
            for (const p of this._runtime.GetAllObjectClasses())
                if (!p.IsFamily() && p.IsWorldType())
                    for (const r of p.GetInstances()) {
                        const x = r.GetWorldInfo();
                        var t = x.GetLayer();
                        t = e.clamp(t.GetIndex(), 0, this._allLayersFlat.length - 1);
                        t = this._allLayersFlat[t];
                        x._SetLayer(t);
                        t._MaybeAddInstance(r)
                    }
            if (!q)
                for (const p of this._allLayersFlat) p._SortInstancesByLastCachedZIndex(!1)
        }
        _CreateInitialInstances() {
            for (const q of this._allLayersFlat) q.CreateInitialInstances(this._createdInstances),
                q.UpdateViewport(), q._Start()
        }
        _CreatePersistedInstances() {
            let q = !1;
            for (const [p, r] of Object.entries(this._persistData)) {
                const x = this._runtime.GetObjectClassBySID(parseInt(p, 10));
                if (x && !x.IsFamily() && x.HasPersistBehavior()) {
                    for (const y of r) {
                        var t = null;
                        if (x.IsWorldType() && (t = this.GetLayerBySID(y.w.l), !t)) continue;
                        t = this._runtime.CreateInstanceFromData(x, t, !1, 0, 0, !0);
                        t.LoadFromJson(y);
                        q = !0;
                        this._createdInstances.push(t)
                    }
                    e.clearArray(r)
                }
            }
            for (const p of this._allLayersFlat) p._SortInstancesByLastCachedZIndex(!0),
                p.SetZIndicesChanged();
            q && (this._runtime.FlushPendingInstances(), this._runtime._RefreshUidMap())
        }
        _CreateAndLinkContainerInstances(q) {
            for (const p of q) {
                if (!p.IsInContainer()) continue;
                const r = p.GetWorldInfo(),
                    x = p.GetIID();
                for (const y of p.GetObjectClass().GetContainer().objectTypes())
                    if (y !== p.GetObjectClass()) {
                        var t = y.GetInstances();
                        t.length > x ? p._AddSibling(t[x]) : (t = r ? this._runtime.CreateInstanceFromData(y, r.GetLayer(), !0, r.GetX(), r.GetY(), !0) : this._runtime.CreateInstanceFromData(y, null, !0, 0, 0, !0),
                            this._runtime.FlushPendingInstances(), y._UpdateIIDs(), p._AddSibling(t), q.push(t))
                    }
            }
        }
        _CreateInitialNonWorldInstances() {
            for (const q of this._initialNonWorld) this._runtime.GetObjectClassByIndex(q[1]).IsInContainer() || this._runtime.CreateInstanceFromData(q, null, !0)
        }
        _CreateGlobalNonWorlds() {
            const q = [],
                t = this._initialNonWorld;
            let p = 0;
            for (let r = 0, x = t.length; r < x; ++r) {
                const y = t[r],
                    E = this._runtime.GetObjectClassByIndex(y[1]);
                E.IsGlobal() ? E.IsInContainer() && E.GetContainer().HasAnyWorldType() || q.push(this._runtime.CreateInstanceFromData(y,
                    null, !0)) : (t[p] = y, ++p)
            }
            e.truncateArray(t, p);
            this._runtime.FlushPendingInstances();
            this._CreateAndLinkContainerInstances(q)
        }
        RecreateInitialObjects(q, t, p, r, x, y) {
            if (p) return p.RecreateInitialObjects(q, t, r, x, y);
            p = [];
            for (const E of this._allLayersFlat) p.push(E.RecreateInitialObjects(q, t, r, x, y));
            return p.flat()
        }
        async _StopRunning() {
            const q = this._layoutManager;
            this._runtime.IsLoadingState() || await this._runtime.TriggerAsync(e.Plugins.System.Cnds.OnLayoutEnd, null, null);
            q.SetIsEndingLayout(!0);
            this._runtime.GetEventSheetManager().ClearAllScheduledWaits();
            this._isFirstVisit || this._SavePersistData();
            for (const t of this._allLayersFlat) t._End();
            for (const t of this._runtime.GetAllObjectClasses())
                if (!(t.IsGlobal() || t.IsWorldType() || t.GetPlugin().IsSingleGlobal() || t.IsFamily())) {
                    for (const p of t.GetInstances()) this._runtime.DestroyInstance(p);
                    this._runtime.FlushPendingInstances()
                } q.SetIsEndingLayout(!1);
            q.GetMainRunningLayout() === this && q._SetMainRunningLayout(null)
        }
        _SaveInstanceToPersist(q) {
            const t = q.GetObjectClass().GetSID().toString();
            this._persistData.hasOwnProperty(t) ||
                (this._persistData[t] = []);
            this._persistData[t].push(q.SaveToJson())
        }
        _SavePersistData() {
            for (const q of this._allLayersFlat) {
                q._UpdateZIndices();
                for (const t of q._GetInstances()) {
                    const p = t.GetObjectClass();
                    !p.IsGlobal() && p.HasPersistBehavior() && this._SaveInstanceToPersist(t)
                }
            }
        }
        ResetPersistData() {
            this._persistData = {};
            this._isFirstVisit = !0
        }
        GetRenderTarget() {
            return this._curRenderTarget
        }
        UsesOwnTexture() {
            const q = this._runtime,
                t = q.GetRenderer().IsWebGL();
            return "low" === q.GetCanvasManager().GetCurrentFullscreenScalingQuality() ||
                t && q.UsesAnyBackgroundBlending() || "low-latency" === q.GetCompositingMode() || this._effectList.HasAnyActiveEffect() || t && q.Uses3DFeatures()
        }
        Draw(q) {
            const t = this._runtime.GetCanvasManager(),
                p = this.UsesOwnTexture();
            if (p) {
                "low-latency" !== this._runtime.GetCompositingMode() && (q.SetRenderTarget(null), q.ClearRgba(0, 0, 0, 0));
                const r = {
                    sampling: this._runtime.GetSampling(),
                    isSampled: q.IsWebGPU() || this._runtime.UsesAnyBackgroundBlending() || this._effectList.HasAnyActiveEffect()
                };
                "low" === t.GetCurrentFullscreenScalingQuality() &&
                    (r.width = t.GetDrawWidth(), r.height = t.GetDrawHeight());
                this._curRenderTarget = this._runtime.GetAdditionalRenderTarget(r)
            } else this._curRenderTarget = null;
            q.SetRenderTarget(this._curRenderTarget);
            q.Clear(this.GetLayoutBackgroundColor());
            this._runtime.Uses3DFeatures() && q.ClearDepth();
            for (const r of this._allLayersFlat) r.UpdateViewport();
            this._DrawLayerList(q, this._curRenderTarget, this._rootLayers, !0);
            p && (q.SetDepthEnabled(!1), this._DrawLayoutOwnTextureToRenderTarget(q, this._curRenderTarget));
            this._curRenderTarget =
                null
        }
        _DrawLayerList(q, t, p, r) {
            p = p.filter(x => x.ShouldDraw());
            for (let x = 0, y = p.length; x < y;) {
                const E = p[x];
                if (E.SelfAndAllSubLayersHave3DCamera() && !E.SelfOrAnySubLayerUsesOwnTexture()) {
                    f.push(E);
                    for (let G = x + 1; G < y; ++G) {
                        const A = p[G];
                        if (A.SelfAndAllSubLayersHave3DCamera() && !A.SelfOrAnySubLayerUsesOwnTexture()) f.push(p[G]);
                        else break
                    }
                    if (2 <= f.length || 1 === f.length && f[0].HasAnyVisibleSubLayer()) {
                        this._Draw3DLayers(q, t, f);
                        x += f.length;
                        e.clearArray(f);
                        continue
                    }
                    e.clearArray(f)
                }
                E.Draw(q, t, r && 0 === x);
                ++x
            }
        }
        _DrawLayoutOwnTextureToRenderTarget(q,
            t) {
            const p = this._effectList.GetActiveEffectTypes(),
                r = this._runtime;
            0 === p.length ? (q.SetRenderTarget(null), q.SetTextureFillMode(), q.CopyRenderTarget(t), q.InvalidateRenderTarget(t), r.ReleaseAdditionalRenderTarget(t)) : (b.set(0, 0, r.GetViewportWidth(), r.GetViewportHeight()), this.GetEffectChain().Render(q, null, {
                contentObject: this,
                blendMode: 3,
                devicePixelRatio: this._runtime.GetEffectDevicePixelRatioParam(),
                layerScale: this._runtime.GetEffectLayerScaleParam() * this.GetScale(),
                layerAngle: this.GetAngle(),
                layoutRect: b,
                drawSurfaceRect: null,
                invalidateRenderTargets: !0
            }))
        }
        _Draw3DLayers(q, t, p) {
            p[0].IsTransparent() || (d.copyRgb(p[0].GetBackgroundColor()), d.setA(1), q.Clear(d));
            var r = this._runtime.GetCanvasManager();
            q.SetDepthEnabled(!0);
            for (var x of p) x._UpdateZIndices(), x._AppendAllInstancesIncludingSubLayersInDrawOrder(k);
            p = p[0];
            x = null;
            if (this._runtime.IsGPUProfiling())
                if (q.IsWebGL()) {
                    if (r = r.GetLayerTimingsBuffer(p)) x = r.AddTimeElapsedQuery(), q.StartQuery(x)
                } else q.IsWebGPU() && q.WriteTimestamp(2 * (p.GetIndex() + 1));
            for (let F =
                    0, J = k.length; F < J;) {
                var y = k[F],
                    E = y.GetWorldInfo(),
                    G = E.GetLayer();
                if (E.IsVisible() && E.IsInViewport3D(G._GetViewFrustum())) {
                    (!y.RendersToOwnZPlane() || 0 < E.GetDepth()) && l.push(y);
                    var A = y.GetWorldInfo().GetTotalZElevation();
                    h.push(y);
                    for (r = F + 1; r < J; ++r) {
                        const B = k[r],
                            I = B.GetWorldInfo();
                        if (I.IsVisible() && I.IsInViewport3D(I.GetLayer()._GetViewFrustum())) {
                            if (I.GetTotalZElevation() !== A) break;
                            B.RendersToOwnZPlane() ? (0 < I.GetDepth() && l.push(B), h.push(B)) : l.push(B)
                        }
                    }
                    if (1 !== h.length || h[0].MustMitigateZFighting()) {
                        this._Draw3DLayersCoplanarInstances(q,
                            t, h);
                        for (let B = 0, I = l.length; B < I; ++B) y = l[B], E = y.GetWorldInfo(), G = E.GetLayer(), E._SetDrawNonBackFacesOnly(!0), w(G, q), G._DrawInstanceMaybeWithEffects(y, E, q, t), E._SetDrawNonBackFacesOnly(!1)
                    } else {
                        w(G, q);
                        G._DrawInstanceMaybeWithEffects(y, E, q, t);
                        for (let B = 0, I = l.length; B < I; ++B) E = l[B], E !== y && (G = E.GetWorldInfo(), A = G.GetLayer(), w(A, q), A._DrawInstanceMaybeWithEffects(E, G, q, t))
                    }
                    F = r;
                    e.clearArray(h);
                    e.clearArray(l)
                } else ++F
            }
            x && q.EndQuery(x);
            this._runtime.IsGPUProfiling() && q.IsWebGPU() && q.WriteTimestamp(2 * (p.GetIndex() +
                1) + 1);
            e.clearArray(k);
            u = null
        }
        _Draw3DLayersCoplanarInstances(q, t, p) {
            q.CoplanarStartStencilPass();
            for (let E = 0, G = p.length; E < G; ++E) {
                var r = p[E],
                    x = r.GetWorldInfo(),
                    y = x.GetLayer();
                x._SetDrawBackFaceOnly(!0);
                w(y, q);
                y._DrawInstance(r, x, q)
            }
            q.CoplanarStartColorPass();
            for (let E = 0, G = p.length; E < G; ++E) r = p[E], x = r.GetWorldInfo(), y = x.GetLayer(), w(y, q), y._DrawInstanceMaybeWithEffects(r, x, q, t), x._SetDrawBackFaceOnly(!1);
            q.CoplanarRestoreStandardRendering()
        }
        _SaveToJson() {
            const q = {
                sx: this.GetScrollX(),
                sy: this.GetScrollY(),
                s: this.GetScale(),
                a: this.GetAngle(),
                w: this.GetWidth(),
                h: this.GetHeight(),
                ortho: this.IsOrthographicProjection(),
                vpX: this.GetVanishingPointX(),
                vpY: this.GetVanishingPointY(),
                fv: this._isFirstVisit,
                persist: this._persistData,
                fx: this._effectList.SaveToJson(),
                layers: {}
            };
            for (const t of this._allLayersFlat) q.layers[t.GetSID().toString()] = t._SaveToJson();
            return q
        }
        _LoadFromJson(q) {
            this._scrollX = q.sx;
            this._scrollY = q.sy;
            this._scale = q.s;
            this._angle = q.a;
            this._width = q.w;
            this._height = q.h;
            this._isOrthographicProjection = !!q.ortho;
            q.hasOwnProperty("vpX") && (this._vanishingPointX = q.vpX);
            q.hasOwnProperty("vpY") && (this._vanishingPointY = q.vpY);
            this._isFirstVisit = !!q.fv;
            this._persistData = q.persist;
            this._effectList.LoadFromJson(q.fx);
            this._needsRebuildEffectChainSteps = !0;
            for (const [t, p] of Object.entries(q.layers)) q = parseInt(t, 10), (q = this.GetLayerBySID(q)) && q._LoadFromJson(p);
            this._SetAllLayersProjectionChanged();
            this._SetAllLayersMVChanged()
        }
        GetILayout() {
            return this._iLayout
        }
        UserScriptDispatcher() {
            return this._userScriptDispatcher
        }
        DispatchUserScriptEvent(q) {
            q.layout =
                this.GetILayout();
            var t = this._runtime;
            (t = t.IsDebug() && !t.GetEventSheetManager().IsInEventEngine()) && a.StartMeasuringScriptTime();
            this._userScriptDispatcher.dispatchEvent(q);
            t && a.AddScriptTime()
        }
        DispatchUserScriptEventAsyncWait(q) {
            q.layout = this.GetILayout();
            return this._userScriptDispatcher.dispatchEventAndWaitAsync(q)
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.LayoutManager = class extends e.DefendedBase {
        constructor(a) {
            super();
            this._runtime = a;
            this._allLayouts = [];
            this._layoutsByName = new Map;
            this._layoutsBySid = new Map;
            this._mainRunningLayout = null;
            this._runningSubLayouts = [];
            this._firstLayout = null;
            this._isEndingLayout = 0;
            this._pendingChangeLayout = null
        }
        Release() {
            this._pendingChangeLayout = this._firstLayout = this._mainRunningLayout = this._runtime = null;
            e.clearArray(this._allLayouts);
            this._layoutsByName.clear();
            this._layoutsBySid.clear();
            e.clearArray(this._runningSubLayouts)
        }
        Create(a) {
            a = e.New(e.Layout, this, this._allLayouts.length, a);
            this._allLayouts.push(a);
            this._layoutsByName.set(a.GetName().toLowerCase(), a);
            this._layoutsBySid.set(a.GetSID(), a)
        }
        GetRuntime() {
            return this._runtime
        }
        SetFirstLayout(a) {
            this._firstLayout = a
        }
        GetFirstLayout() {
            if (this._firstLayout) return this._firstLayout;
            if (this._allLayouts.length) return this._allLayouts[0];
            throw Error("no first layout");
        }
        GetLayoutByName(a) {
            return this._layoutsByName.get(a.toLowerCase()) ||
                null
        }
        GetLayoutBySID(a) {
            return this._layoutsBySid.get(a) || null
        }
        GetLayoutByIndex(a) {
            a = e.clamp(Math.floor(a), 0, this._allLayouts.length - 1);
            return this._allLayouts[a]
        }
        GetLayout(a) {
            return "number" === typeof a ? this.GetLayoutByIndex(a) : this.GetLayoutByName(a.toString())
        }
        GetAllLayouts() {
            return this._allLayouts
        }
        _SetMainRunningLayout(a) {
            this._mainRunningLayout = a
        }
        GetMainRunningLayout() {
            return this._mainRunningLayout
        }
        _AddRunningSubLayout(a) {
            if (this._runningSubLayouts.includes(a)) throw Error("layout already running");
            this._runningSubLayouts.push(a)
        }
        _RemoveRunningSubLayout(a) {
            a = this._runningSubLayouts.indexOf(a);
            if (-1 === a) throw Error("layout not running");
            this._runningSubLayouts.splice(a, 1)
        }* runningLayouts() {
            this._mainRunningLayout && (yield this._mainRunningLayout);
            this._runningSubLayouts.length && (yield* this._runningSubLayouts)
        }
        IsLayoutRunning(a) {
            return this._mainRunningLayout === a || this._runningSubLayouts.includes(a)
        }
        SetIsEndingLayout(a) {
            if (a) this._isEndingLayout++;
            else {
                if (0 >= this._isEndingLayout) throw Error("already unset");
                this._isEndingLayout--
            }
        }
        IsEndingLayout() {
            return 0 < this._isEndingLayout
        }
        ChangeMainLayout(a) {
            this._pendingChangeLayout = a
        }
        ClearPendingChangeLayout() {
            this._pendingChangeLayout = null
        }
        IsPendingChangeMainLayout() {
            return !!this._pendingChangeLayout
        }
        GetPendingChangeMainLayout() {
            return this._pendingChangeLayout
        }
        SetAllLayerProjectionChanged() {
            const a = this.GetMainRunningLayout();
            a && a._SetAllLayersProjectionChanged()
        }
        SetAllLayerMVChanged() {
            const a = this.GetMainRunningLayout();
            a && a._SetAllLayersMVChanged()
        }
    }
} {
    "use strict";
    const e = self.C3,
        a = /<(.+?)>/g;
    e.TimelineManager = class extends e.DefendedBase {
        constructor(b) {
            super();
            this._runtime = b;
            this._timelineDataManager = e.New(e.TimelineDataManager);
            this._pluginInstance = null;
            this._timelines = [];
            this._timelinesByName = new Map;
            this._objectClassToTimelineMap = new Map;
            this._timelinesCreatedByTemplate = new Map;
            this._scheduledTimelines = [];
            this._playingTimelines = [];
            this._markedForRemovalTimelines = [];
            this._isTickingTimelines = this._changingLayout = this._hasRuntimeListeners = !1;
            this._tickFunc = () => this._OnTick();
            this._tick2Func = () => this._OnTick2();
            this._beforeLayoutChange = () => this._OnBeforeChangeLayout();
            this._layoutChange = () => this._OnAfterChangeLayout();
            this._instanceDestroy = d => this._OnInstanceDestroy(d.instance);
            this._afterLoad = d => this._OnAfterLoad();
            this._destroyedWhileLoadingState = [];
            this._renderChange = 0
        }
        Release() {
            this.RemoveRuntimeListeners();
            this._afterLoad = this._instanceDestroy = this._layoutChange = this._beforeLayoutChange = this._tick2Func = this._tickFunc = null;
            for (const b of this._timelines) b.Stop(),
                b.Release();
            e.clearArray(this._timelines);
            this._timelines = null;
            this._timelineDataManager.Release();
            this._timelineDataManager = null;
            e.clearArray(this._scheduledTimelines);
            this._scheduledTimelines = null;
            e.clearArray(this._playingTimelines);
            this._playingTimelines = null;
            e.clearArray(this._markedForRemovalTimelines);
            this._markedForRemovalTimelines = null;
            this._timelinesByName.clear();
            this._timelinesByName = null;
            this._objectClassToTimelineMap.clear();
            this._objectClassToTimelineMap = null;
            this._timelinesCreatedByTemplate.clear();
            this._timelinesCreatedByTemplate = null;
            e.clearArray(this._destroyedWhileLoadingState);
            this._runtime = this._destroyedWhileLoadingState = null
        }
        AddRuntimeListeners() {
            const b = this._runtime.Dispatcher();
            b.addEventListener("pretick", this._tickFunc);
            b.addEventListener("tick2", this._tick2Func);
            b.addEventListener("beforelayoutchange", this._beforeLayoutChange);
            b.addEventListener("layoutchange", this._layoutChange);
            b.addEventListener("instancedestroy", this._instanceDestroy);
            b.addEventListener("afterload", this._afterLoad)
        }
        RemoveRuntimeListeners() {
            const b =
                this._runtime.Dispatcher();
            b.removeEventListener("pretick", this._tickFunc);
            b.removeEventListener("tick2", this._tick2Func);
            b.removeEventListener("beforelayoutchange", this._beforeLayoutChange);
            b.removeEventListener("layoutchange", this._layoutChange);
            b.removeEventListener("instancedestroy", this._instanceDestroy);
            b.removeEventListener("afterload", this._afterLoad)
        }
        Create(b) {
            this._timelineDataManager.Add(b);
            b = e.TimelineState.CreateInitial(b, this);
            this.Add(b);
            this.SetTimelineObjectClassesToMap(b);
            this._timelinesCreatedByTemplate.set(b.GetName(),
                0)
        }
        CreateFromTemplate(b) {
            var d = this.GetTimelineDataManager();
            b = b.GetTemplateName();
            d = d.Get(b);
            d = e.TimelineState.CreateFromTemplate(`${b}:${this._timelinesCreatedByTemplate.get(b)}`, d, this);
            this._IncreaseTemplateTimelinesCount(b);
            this.Add(d);
            return d
        }
        _IncreaseTemplateTimelinesCount(b) {
            this._timelinesCreatedByTemplate.set(b, this._timelinesCreatedByTemplate.get(b) + 1)
        }
        _SetCreatedTemplateTimelinesCount() {
            for (const b of this._timelines) {
                if (b.IsTemplate()) continue;
                const d = b.GetTemplateName();
                this._IncreaseTemplateTimelinesCount(d)
            }
        }
        _ClearCreatedTemplateTimelinesCount() {
            for (const b of this._timelinesCreatedByTemplate.keys()) this._timelinesCreatedByTemplate.set(b,
                0)
        }
        Add(b) {
            this._timelines.push(b);
            this._timelinesByName.set(b.GetName().toLowerCase(), b)
        }
        Remove(b) {
            b.Removed();
            b.IsTemplate() || (e.arrayFindRemove(this._timelines, b), e.arrayFindRemove(this._scheduledTimelines, b), e.arrayFindRemove(this._playingTimelines, b), e.arrayFindRemove(this._markedForRemovalTimelines, b), this._timelinesByName.delete(b.GetName().toLowerCase()), this.RemoveTimelineFromObjectClassMap(b), b.IsReleased() || b.Release())
        }
        Trigger(b) {
            this._runtime.Trigger(b, this._pluginInstance, null)
        }
        GetRuntime() {
            return this._runtime
        }
        GetTimelineDataManager() {
            return this._timelineDataManager
        }
        SetPluginInstance(b) {
            this._pluginInstance =
                b
        }
        GetPluginInstance() {
            return this._pluginInstance
        }* GetTimelines() {
            for (const b of this._timelines) yield b
        }
        SetTimelineObjectClassToMap(b, d) {
            this._objectClassToTimelineMap.has(b) || this._objectClassToTimelineMap.set(b, new Set);
            this._objectClassToTimelineMap.get(b).add(d)
        }
        SetTimelineObjectClassesToMap(b) {
            for (const d of b.GetObjectClasses()) this.SetTimelineObjectClassToMap(d, b)
        }
        RemoveTimelineFromObjectClassMap(b) {
            for (const [d, c] of this._objectClassToTimelineMap.entries()) c.has(b) && (c.delete(b), 0 === c.size &&
                this._objectClassToTimelineMap.delete(d))
        }
        GetTimelinesForObjectClass(b) {
            if (this._objectClassToTimelineMap.has(b)) return this._objectClassToTimelineMap.get(b)
        }
        GetTimelineOfTemplateForInstances(b, d) {
            if (d)
                for (const c of this._timelines)
                    if (d.every(f => c.HasTrackInstance(f.instance, f.trackId)) && c.GetName().includes(b.GetName())) return c
        }
        GetTimelineByName(b) {
            return this._timelinesByName.get(b.toLowerCase()) || null
        }
        GetScheduledOrPlayingTimelineByName(b) {
            for (const d of this._scheduledTimelines)
                if (d.GetName() ===
                    b) return d;
            for (const d of this._playingTimelines)
                if (d.GetName() === b) return d;
            return null
        }* GetTimelinesByName(b) {
            if (a.test(b)) {
                a.lastIndex = 0;
                let c;
                var d = new Set;
                do
                    if (c = a.exec(b)) {
                        const f = c[1].split(",");
                        for (const k of f) d.add(k)
                    } while (c);
                for (const f of d.values())(b = this.GetTimelineByName(f)) && (yield b);
                d.clear()
            } else(d = this.GetTimelineByName(b)) && (yield d)
        }* GetTimelinesByTags(b) {
            for (const d of this._timelines) d.HasTags(b) && (yield d)
        }
        AddScheduledTimeline(b) {
            this._scheduledTimelines.includes(b) || this._scheduledTimelines.push(b);
            this._MaybeEnableRuntimeListeners()
        }
        RemovePlayingTimeline(b) {
            e.arrayFindRemove(this._playingTimelines, b);
            this._MaybeDisableRuntimeListeners()
        }
        ScheduleTimeline(b) {
            this._playingTimelines.includes(b) ? (b.SetPlaying(!0), b.SetScheduled(!1), b.SetMarkedForRemoval(!1)) : (b.SetPlaying(!1), b.SetScheduled(!0), b.SetMarkedForRemoval(!1), this._scheduledTimelines.includes(b) || this._scheduledTimelines.push(b));
            this._MaybeEnableRuntimeListeners()
        }
        DeScheduleTimeline(b) {
            b.SetPlaying(!1);
            b.SetScheduled(!1);
            b.ResolvePlayPromise();
            e.arrayFindRemove(this._scheduledTimelines, b);
            this._MaybeDisableRuntimeListeners()
        }
        CompleteTimeline(b) {
            b.SetPlaying(!1);
            b.SetScheduled(!1);
            b.SetMarkedForRemoval(!0);
            this._markedForRemovalTimelines.push(b);
            e.arrayFindRemove(this._playingTimelines, b)
        }
        CompleteTimelineBeforeChangeOfLayout(b) {
            b.SetPlaying(!1);
            b.SetScheduled(!1);
            b.SetMarkedForRemoval(!1);
            b.SetPlaybackRate(1);
            e.arrayFindRemove(this._playingTimelines, b)
        }
        CompleteTimelineAndResolve(b) {
            this.CompleteTimeline(b);
            b.ResolvePlayPromise()
        }
        _OnTick() {
            if (!this.GetRuntime().IsLoadingState() &&
                this._hasRuntimeListeners && !this._changingLayout) {
                for (this._isTickingTimelines = !0; this._scheduledTimelines.length;) {
                    var b = this._scheduledTimelines.pop();
                    b.SetInitialState();
                    0 !== b.GetRenderChange() && (this._renderChange = 1);
                    this._playingTimelines.push(b)
                }
                b = this._runtime._GetDtFast();
                var d = this._runtime.GetDt1(),
                    c = this._runtime.GetTimeScale();
                for (let f = this._playingTimelines.length - 1; 0 <= f; f--) this._playingTimelines[f].Tick(b, c, d);
                this._isTickingTimelines = !1;
                0 !== this._renderChange && this.GetRuntime().UpdateRender()
            }
        }
        _OnTick2() {
            if (!this.GetRuntime().IsLoadingState() &&
                this._hasRuntimeListeners && !this._changingLayout) {
                var b;
                for (let d = 0, c = this._markedForRemovalTimelines.length; d < c; d++) {
                    const f = this._markedForRemovalTimelines[d];
                    b || (b = new Set);
                    f.Removed();
                    this._MaybeExecuteTimelineFinishTriggers(f);
                    b.add(f)
                }
                if (b) {
                    e.arrayRemoveAllInSet(this._markedForRemovalTimelines, b);
                    this._renderChange = 0;
                    for (let d = 0, c = this._playingTimelines.length; d < c; d++)
                        if (0 !== this._playingTimelines[d].GetRenderChange()) {
                            this._renderChange = 1;
                            break
                        }
                }
                this._MaybeDisableRuntimeListeners()
            }
        }
        _MaybeExecuteTimelineFinishTriggers(b) {
            b.IsReleased() ||
                b.HasValidTracks() && b.IsComplete() && b.InitialStateSet() && b.FinishTriggers()
        }
        _MaybeEnableRuntimeListeners() {
            this._hasRuntimeListeners || (this._hasRuntimeListeners = !0)
        }
        _MaybeDisableRuntimeListeners() {
            this._markedForRemovalTimelines.length || this._playingTimelines.length || this._scheduledTimelines.length || this._isTickingTimelines || (this._hasRuntimeListeners = !1)
        }
        _OnBeforeChangeLayout() {
            for (this._changingLayout = !0; this._scheduledTimelines.length;) this.DeScheduleTimeline(this._scheduledTimelines.pop());
            const b =
                new Set;
            for (const d of this._playingTimelines) d._OnBeforeChangeLayout() && (d.Removed(), b.add(d));
            e.arrayRemoveAllInSet(this._playingTimelines, b);
            b.clear();
            for (const d of this._markedForRemovalTimelines) d._OnBeforeChangeLayout() && (d.Removed(), b.add(d));
            e.arrayRemoveAllInSet(this._markedForRemovalTimelines, b);
            this._MaybeDisableRuntimeListeners();
            for (const d of this._timelines) d.CleanCaches()
        }
        _OnAfterChangeLayout() {
            this._changingLayout = !1
        }
        _OnInstanceDestroy(b) {
            var d = b.GetObjectClass();
            if (d = this.GetTimelinesForObjectClass(d))
                if (this._runtime.IsLoadingState()) this._destroyedWhileLoadingState.push(b);
                else
                    for (const c of d) c.IsTemplate() || (c.IsReleased() ? this.Remove(c) : c.HasValidTracks() || (this._MaybeExecuteTimelineFinishTriggers(c), this.Remove(c)))
        }
        _OnAfterLoad() {
            for (const b of this._destroyedWhileLoadingState) this._OnInstanceDestroy(b);
            e.clearArray(this._destroyedWhileLoadingState)
        }
        _SaveToJson() {
            return {
                timelinesJson: this._SaveTimelinesToJson(),
                scheduledTimelinesJson: this._SaveScheduledTimelinesToJson(),
                playingTimelinesJson: this._SavePlayingTimelinesToJson(),
                markedForRemovalTimelinesJson: this._SaveMarkedForRemovalTimelinesToJson(),
                hasRuntimeListeners: this._hasRuntimeListeners,
                changingLayout: this._changingLayout,
                isTickingTimelines: this._isTickingTimelines
            }
        }
        _LoadFromJson(b) {
            b && (this._ClearCreatedTemplateTimelinesCount(), this._LoadTimelinesFromJson(b.timelinesJson), this._LoadScheduledTimelinesFromJson(b.scheduledTimelinesJson), this._LoadPlayingTimelinesFromJson(b.playingTimelinesJson), this._LoadMarkedForRemovalTimelinesFromJson(b.markedForRemovalTimelinesJson), this._hasRuntimeListeners = !b.hasRuntimeListeners, this._changingLayout = !!b.changingLayout, this._isTickingTimelines = !!b.isTickingTimelines, this._SetCreatedTemplateTimelinesCount(), this._MaybeEnableRuntimeListeners(), this._MaybeDisableRuntimeListeners())
        }
        _SaveTimelinesToJson() {
            return this._timelines.map(b => b._SaveToJson())
        }
        _LoadTimelinesFromJson(b) {
            for (const d of b) {
                b = this.GetTimelineByName(d.name);
                if (!b) {
                    b = this._GetTemplateNameFromJson(d);
                    if (!b) continue;
                    b = this.GetTimelineByName(b);
                    b = this.CreateFromTemplate(b)
                }
                b._LoadFromJson(d);
                b.HasTracks() || this.Remove(b)
            }
        }
        _GetTemplateNameFromJson(b) {
            return (b =
                b.name.split(":")) && 2 === b.length ? b[0] : null
        }
        _SaveScheduledTimelinesToJson() {
            return this._SaveTimelines(this._scheduledTimelines)
        }
        _LoadScheduledTimelinesFromJson(b) {
            this._LoadTimelines(b, this._scheduledTimelines)
        }
        _SavePlayingTimelinesToJson() {
            return this._SaveTimelines(this._playingTimelines)
        }
        _LoadPlayingTimelinesFromJson(b) {
            this._LoadTimelines(b, this._playingTimelines)
        }
        _SaveMarkedForRemovalTimelinesToJson() {
            return this._SaveTimelines(this._markedForRemovalTimelines)
        }
        _LoadMarkedForRemovalTimelinesFromJson(b) {
            this._LoadTimelines(b,
                this._markedForRemovalTimelines)
        }
        _IsTimelineInJson(b, d) {
            for (const c of d)
                if (c === b.GetName()) return !0;
            return !1
        }
        _SaveTimelines(b) {
            return b.map(d => d.GetName())
        }
        _LoadTimelines(b, d) {
            var c = new Set;
            for (const f of d) this._IsTimelineInJson(f, b) || c.add(f);
            e.arrayRemoveAllInSet(d, c);
            c = f => k => k.GetName() === f;
            for (const f of b)(b = this.GetTimelineByName(f)) && (d.find(c(f)) || d.push(b))
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.TimelineState = class extends e.DefendedBase {
        constructor(a, b, d) {
            super();
            this._runtime = d.GetRuntime();
            this._timelineManager = d;
            this._timelineDataItem = b;
            this._name = a;
            this._tracks = [];
            this._tracksLength = 0;
            this._beforeAndAfterTracks = null;
            this._beforeAndAfterTracksLength = 0;
            this.CreateTrackStates();
            this._playResolve = this._playPromise = null;
            this._playheadTime = 0;
            this._playbackRate = 1;
            this._pingPongState = 0;
            this._currentRepeatCount = 1;
            this._initialStateSet = this._isScheduled = this._isPlaying = !1;
            this._complete = !0;
            this._markedForRemoval = this._released = !1;
            this._completedTick = -1;
            this._firstTick = this._finishedTriggers = this._isTemplate = this._implicitPause = !1;
            this._lastDelta = NaN;
            this._tags = [""];
            this._stringTags = "";
            this._tagsChanged = !1;
            this._hasNestedContent = this._renderChange = 0
        }
        static CreateInitial(a, b) {
            var d = b.GetTimelineDataManager();
            const c = d.GetNameId();
            d = d.Get(a[c]);
            a = e.New(e.TimelineState, a[c], d, b);
            a.SetIsTemplate(!0);
            return a
        }
        static CreateFromTemplate(a, b, d) {
            return e.New(e.TimelineState,
                a, b, d)
        }
        Release() {
            if (!this.IsReleased()) {
                this._timelineManager.DeScheduleTimeline(this);
                this._timelineManager.CompleteTimelineAndResolve(this);
                for (const a of this._tracks) a.Release();
                e.clearArray(this._tracks);
                this._timelineDataItem = this._timelineManager = this._runtime = this._tracks = null;
                this._released = !0;
                this._playResolve = this._playPromise = null
            }
        }
        CreateTrackStates() {
            for (const a of this._timelineDataItem.GetTrackData().trackDataItems()) this._tracksLength = this._tracks.push(e.TrackState.Create(this, a))
        }
        GetTimelineManager() {
            return this._timelineManager
        }
        GetRuntime() {
            return this._runtime
        }
        GetTracks() {
            return this._tracks
        }
        GetSimilarPropertyTracks(a,
            b, d) {
            if (this._hasNestedContent) {
                var c;
                for (let k = 0; k < this._tracks.length; k++) {
                    var f = this._tracks[k];
                    a === f.GetInstance() && (f = f.GetPropertyTrack(d)) && b.constructor === f.GetSourceAdapter().constructor && (c || (c = []), c.push(f))
                }
                return c
            }
        }
        HasTracks() {
            return !!this._tracks.length
        }
        GetTrackById(a) {
            for (const b of this._tracks)
                if (e.equalsNoCase(b.GetId(), a)) return b;
            return null
        }
        GetTrackByName(a) {
            for (const b of this._tracks)
                if (!b.IsInstanceTrack() && e.equalsNoCase(b.GetName(), a)) return b;
            return null
        }
        SetName(a) {
            this._name =
                a
        }
        GetName() {
            return this._name
        }
        GetTimelineDataItem() {
            return this._timelineDataItem
        }
        GetTemplateName() {
            return this._timelineDataItem.GetName()
        }
        GetTotalTime() {
            return this._timelineDataItem.GetTotalTime()
        }
        SetTotalTime(a) {
            this._timelineDataItem.SetTotalTime(a)
        }
        GetStep() {
            return this._timelineDataItem.GetStep()
        }
        SetStep(a) {
            this._timelineDataItem.SetStep(a)
        }
        GetInterpolationMode() {
            return this._timelineDataItem.GetInterpolationMode()
        }
        SetInterpolationMode(a) {
            this._timelineDataItem.SetInterpolationMode(a)
        }
        GetResultMode() {
            return this._timelineDataItem.GetResultMode()
        }
        SetResultMode(a) {
            this._timelineDataItem.GetResultMode(a)
        }
        SetEase(a) {
            for (const b of this.GetTracks()) b.SetEase(a)
        }
        GetLoop() {
            return this._timelineDataItem.GetLoop()
        }
        SetLoop(a) {
            return this._timelineDataItem.SetLoop(a)
        }
        GetPingPong() {
            return this._timelineDataItem.GetPingPong()
        }
        SetPingPong(a) {
            return this._timelineDataItem.SetPingPong(a)
        }
        GetRepeatCount() {
            return this._timelineDataItem.GetRepeatCount()
        }
        SetPlaybackRate(a) {
            return this._playbackRate =
                a
        }
        GetPlaybackRate() {
            return this._playbackRate
        }
        IsForwardPlayBack() {
            return this.IsPlaying() ? 0 < this._playbackRate : !0
        }
        GetPlayPromise() {
            return this._playPromise ? this._playPromise : this._playPromise = new Promise(a => {
                this._playResolve = a
            })
        }
        ResolvePlayPromise() {
            this._playPromise && (this._playResolve(), this._playResolve = this._playPromise = null)
        }
        SetTags(a) {
            this._tags = e.TimelineState._GetTagArray(a);
            this._tagsChanged = !0
        }
        GetTags() {
            return this._tags
        }
        GetStringTags() {
            this._tagsChanged && (this._stringTags = this._tags.join(" "));
            this._tagsChanged = !1;
            return this._stringTags
        }
        HasTags(a) {
            return this._tags && this._tags.length ? (a = e.TimelineState._GetTagArray(a)) && a.length ? a.every(e.TimelineState._HasTag, this) : !1 : !1
        }
        OnStarted() {
            e.Plugins.Timeline.Cnds.SetTriggerTimeline(this);
            this._timelineManager.Trigger(e.Plugins.Timeline.Cnds.OnTimelineStarted);
            this._timelineManager.Trigger(e.Plugins.Timeline.Cnds.OnTimelineStartedByName);
            this._timelineManager.Trigger(e.Plugins.Timeline.Cnds.OnTimelineStartedByTags);
            this._timelineManager.Trigger(e.Plugins.Timeline.Cnds.OnAnyTimelineStarted);
            e.Plugins.Timeline.Cnds.SetTriggerTimeline(null)
        }
        OnCompleted() {
            this._completedTick = this._runtime.GetTickCount()
        }
        FinishTriggers() {
            this._finishedTriggers || (this._finishedTriggers = !0, e.Plugins.Timeline.Cnds.SetTriggerTimeline(this), this._timelineManager.Trigger(e.Plugins.Timeline.Cnds.OnTimelineFinished), this._timelineManager.Trigger(e.Plugins.Timeline.Cnds.OnTimelineFinishedByName), this._timelineManager.Trigger(e.Plugins.Timeline.Cnds.OnTimelineFinishedByTags), this._timelineManager.Trigger(e.Plugins.Timeline.Cnds.OnAnyTimelineFinished),
                e.Plugins.Timeline.Cnds.SetTriggerTimeline(null))
        }
        SetPlaying(a) {
            this._isPlaying = a
        }
        IsCompletedTick() {
            return this._completedTick === this._runtime.GetTickCount()
        }
        IsPlaying(a = !1) {
            return this.IsCompletedTick() || this.IsScheduled() && !a ? !0 : this._isPlaying
        }
        _IsPlaying() {
            return this.IsPlaying(!0)
        }
        IsPaused() {
            return this._IsPaused()
        }
        _IsPaused() {
            return this.IsReleased() || this.IsScheduled() || this._IsPlaying() || this.IsComplete() ? !1 : !0
        }
        SetScheduled(a) {
            this._isScheduled = a
        }
        IsScheduled() {
            return this._isScheduled
        }
        SetComplete(a) {
            this._complete =
                a;
            a = this.GetTime();
            if (0 >= a || a >= this.GetTotalTime()) this._complete = !0
        }
        IsComplete() {
            return this._complete
        }
        IsReleased() {
            return this._released
        }
        SetMarkedForRemoval(a) {
            this._markedForRemoval = a
        }
        IsMarkedForRemoval() {
            return this._markedForRemoval
        }
        SetImplicitPause(a) {
            this._implicitPause = a
        }
        IsImplicitPause() {
            return this._implicitPause
        }
        SetIsTemplate(a) {
            this._isTemplate = !!a
        }
        IsTemplate() {
            return this._isTemplate
        }
        InitialStateSet() {
            return this._initialStateSet
        }
        GetTime() {
            return this._playheadTime
        }
        SetTime(a) {
            const b =
                this.GetTime();
            this._SetTime(a);
            this.SetComplete(!1);
            this.IsComplete() || this.SetImplicitPause(!0);
            if (this._IsPlaying() || this.IsScheduled() || !this._initialStateSet) this._IsPlaying() || this.IsScheduled() || this._initialStateSet ? this._IsPlaying() ? this.Stop() : this.IsScheduled() && (this._timelineManager.DeScheduleTimeline(this), this.SetInitialStateFromSetTime()) : this.SetInitialStateFromSetTime();
            this._SetUpdateStateBefore();
            this._Interpolate(a, !1, !0, !0, b);
            this._SetUpdateStateAfter();
            this._renderChange && this.GetRuntime().UpdateRender();
            this._OnSetTime()
        }
        _SetTime(a) {
            0 > a ? this._playheadTime = 0 : a >= this.GetTotalTime() ? this._playheadTime = this.GetTotalTime() : this._playheadTime = a
        }
        _OnSetTime() {
            e.Plugins.Timeline && this.constructor === e.TimelineState && (e.Plugins.Timeline.Cnds.SetTriggerTimeline(this), this._timelineManager.Trigger(e.Plugins.Timeline.Cnds.OnTimeSet), this._timelineManager.Trigger(e.Plugins.Timeline.Cnds.OnTimeSetByName), this._timelineManager.Trigger(e.Plugins.Timeline.Cnds.OnTimeSetByTags), e.Plugins.Timeline.Cnds.SetTriggerTimeline(null))
        }
        _CanResume() {
            if (!this.GetLoop())
                if (this.GetPingPong() &&
                    1 === this._pingPongState)
                    if (this.IsForwardPlayBack()) {
                        if (this.GetTime() >= this.GetTotalTime()) return !1
                    } else {
                        if (0 >= this.GetTime()) return !1
                    }
            else if (!this.GetLoop() && !this.GetPingPong())
                if (this.IsForwardPlayBack()) {
                    if (this.GetTime() >= this.GetTotalTime()) return !1
                } else if (0 >= this.GetTime()) return !1;
            return !0
        }
        Resume() {
            this.IsReleased() || this._CanResume() && this.Play(!0)
        }
        Play(a = !1) {
            return this.IsReleased() || this.IsScheduled() ? !1 : this._IsPlaying() && this.IsCompletedTick() ? this._SchedulePlayingTimeline() : this._IsPlaying() ||
                !this.IsComplete() && !a && !this.IsImplicitPause() ? !1 : this._ScheduleStoppedTimeline()
        }
        _SchedulePlayingTimeline() {
            this.SetImplicitPause(!1);
            this._timelineManager.RemovePlayingTimeline(this);
            this._timelineManager.ScheduleTimeline(this);
            this.GetPlayPromise();
            return !0
        }
        _ScheduleStoppedTimeline() {
            this.SetImplicitPause(!1);
            this._timelineManager.ScheduleTimeline(this);
            this.GetPlayPromise();
            return !0
        }
        Stop(a = !1) {
            this.IsReleased() || (this.SetComplete(a), this._timelineManager.CompleteTimeline(this), this.IsComplete() &&
                this.ResolvePlayPromise())
        }
        Reset(a = !0, b = !1) {
            if (!this.IsReleased()) {
                if (!this._IsPlaying() && this.IsScheduled()) return this._timelineManager.DeScheduleTimeline(this);
                if (!this.IsComplete()) {
                    this.Stop(!0);
                    this.IsForwardPlayBack() ? this._SetTime(0) : this._SetTime(this.GetTotalTime());
                    var d = this.GetTime();
                    this._SetUpdateStateBefore();
                    b ? this._InterpolateBeforeChangeLayout(d) : this._Interpolate(d, !1, !1, !0);
                    a && this._OnSetTime();
                    this._SetUpdateStateAfter();
                    this._renderChange && a && this.GetRuntime().UpdateRender()
                }
            }
        }
        ResetBeforeChangeLayout() {
            this.Reset(!1,
                !0)
        }
        _InterpolateBeforeChangeLayout(a) {
            this._Interpolate(a, !1, !1, !0, NaN, !1, !0)
        }
        _OnBeforeChangeLayout() {
            if (this.IsReleased()) return !0;
            if (this.HasValidGlobalTracks()) return !1;
            this._timelineManager.CompleteTimelineBeforeChangeOfLayout(this);
            this.ResetBeforeChangeLayout();
            return !0
        }
        SetInitialStateFromSetTime() {
            this.SetInitialState(!0)
        }
        SetInitialState(a) {
            if (!this.IsMarkedForRemoval()) {
                if (a) {
                    this._firstTick = this._initialStateSet = !0;
                    this._SetUpdateStateBefore();
                    for (const b of this._tracks) b.SetInitialState()
                } else if (this.SetPlaying(!0),
                    this.SetScheduled(!1), this.OnStarted(), this.IsComplete()) {
                    this._completedTick = -1;
                    this._pingPongState = 0;
                    this._currentRepeatCount = 1;
                    this._finishedTriggers = this._complete = !1;
                    this._firstTick = this._initialStateSet = !0;
                    this.IsForwardPlayBack() ? this._SetTime(0) : this._SetTime(this.GetTotalTime());
                    this._SetUpdateStateBefore();
                    for (const b of this._tracks) b.SetInitialState()
                } else {
                    this._firstTick = !0;
                    this._SetUpdateStateBefore();
                    for (const b of this._tracks) b.SetResumeState()
                }
                this._SetUpdateStateAfter()
            }
        }
        GetRenderChange() {
            return this._renderChange
        }
        _SetUpdateStateBefore() {
            this._hasNestedContent =
                0;
            for (const a of this._tracks) a.IsNested() && (this._hasNestedContent = 1)
        }
        _SetUpdateStateAfter() {
            this._renderChange = 0;
            for (const a of this._tracks) a._SetUpdateState(), 0 === this._renderChange && 1 === a.GetRenderChange() && (this._renderChange = 1), this._beforeAndAfterTracks || 1 !== a.GetNeedsBeforeAndAfter() || (this._beforeAndAfterTracks || (this._beforeAndAfterTracks = []), this._beforeAndAfterTracksLength = this._beforeAndAfterTracks.push(a))
        }
        Tick(a, b, d) {
            if (0 !== a || 0 !== this._lastDelta) {
                this._lastDelta = a;
                d = this._playheadTime;
                b = d + a * b * this._playbackRate;
                a = this._timelineDataItem._totalTime;
                this._playheadTime = 0 > b ? 0 : b >= a ? a : b;
                var c = !1;
                b = this.GetLoop();
                var f = this.GetPingPong();
                b || f ? b && !f ? 0 < this._playbackRate ? this._playheadTime >= a && this._SetTime(0) : 0 >= this._playheadTime && this._SetTime(a) : !b && f ? 0 < this._playbackRate ? this._playheadTime >= a && (this._SetTime(a), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), 1 === this._pingPongState ? this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._pingPongState = 0) : c = !0 :
                        0 === this._pingPongState && (this._pingPongState = 1)) : 0 >= this._playheadTime && (this._SetTime(0), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), 1 === this._pingPongState ? this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._pingPongState = 0) : c = !0 : 0 === this._pingPongState && (this._pingPongState = 1)) : b && f && (0 < this._playbackRate ? this._playheadTime >= a && (this._SetTime(a), this.SetPlaybackRate(-1 * this.GetPlaybackRate())) : 0 >= this._playheadTime && (this._SetTime(0), this.SetPlaybackRate(-1 * this.GetPlaybackRate()))) :
                    0 < this._playbackRate ? this._playheadTime >= a && (this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._SetTime(0)) : (this._SetTime(a), c = !0)) : 0 >= this._playheadTime && (this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._SetTime(a)) : (this._SetTime(0), c = !0));
                b = this._tracksLength;
                if (c) {
                    for (c = 0; c < b; c++) this._tracks[c].SetEndState();
                    this.Stop(!0);
                    this.OnCompleted()
                } else {
                    f = this._beforeAndAfterTracksLength;
                    for (c = 0; c < f; c++) this._beforeAndAfterTracks[c].BeforeInterpolate();
                    if (1 === this._hasNestedContent)
                        for (c = 0; c < b; c++) {
                            const k = this._tracks[c],
                                h = k.GetStartOffset(),
                                l = d - h;
                            0 > this._playheadTime - h && 0 < l ? (this._playheadTime = 0 > h ? 0 : h >= a ? a : h, k.Interpolate(h, !0, !1, !1, this._firstTick, !1)) : k.Interpolate(this._playheadTime, !0, !1, !1, this._firstTick, !1)
                        } else
                            for (c = 0; c < b; c++) this._tracks[c].Interpolate(this._playheadTime, !0, !1, !1, this._firstTick, !1);
                    for (c = 0; c < f; c++) this._beforeAndAfterTracks[c].AfterInterpolate();
                    this._firstTick && (this._firstTick = !1)
                }
            }
        }
        _Interpolate(a, b = !1, d = !1, c = !1,
            f = NaN, k = !1, h = !1) {
            for (var l of this._tracks) l.BeforeInterpolate();
            for (const n of this._tracks) {
                l = a;
                if ("number" === typeof f) {
                    const u = this.GetTime() - n.GetStartOffset(),
                        w = f - n.GetStartOffset();
                    0 > u && 0 < w && (l = n.GetStartOffset(), this._SetTime(l))
                }
                n.Interpolate(l, b, d, c, this._firstTick, h)
            }
            for (const n of this._tracks) n.AfterInterpolate();
            this._firstTick && k && (this._firstTick = !1)
        }
        AddTrack() {
            var a = this._timelineDataItem.GetTrackData().AddEmptyTrackDataItem();
            a = e.TrackState.Create(this, a);
            this._tracksLength = this._tracks.push(a);
            return a
        }
        Removed() {
            if (!this.IsReleased())
                for (const a of this._tracks) a.TimelineRemoved()
        }
        CleanCaches() {
            for (const a of this._tracks) a.CleanCaches()
        }
        ClearTrackInstances() {
            for (const a of this._tracks) a.ClearInstance()
        }
        SetTrackInstance(a, b) {
            if (b)
                for (const d of this._tracks)
                    if (d.IsInstanceTrack()) {
                        if (a) {
                            if (d.GetId() !== a) continue
                        } else if (d.HasInstance()) continue;
                        d.SetInstance(b);
                        this._timelineManager.SetTimelineObjectClassToMap(b.GetObjectClass(), this);
                        break
                    }
        }
        HasTrackInstance(a, b) {
            for (const d of this._tracks)
                if (d.IsInstanceTrack())
                    if (b) {
                        if (b ===
                            d.GetId() && a === d.GetInstance()) return !0
                    } else if (a === d.GetInstance()) return !0;
            return !1
        }
        HasValidTracks() {
            return this._tracks.some(a => a.IsInstanceTrack() ? a.CanInstanceBeValid() : !0)
        }
        HasValidGlobalTracks() {
            return this._tracks.some(a => a.IsInstanceTrack() ? a.CanInstanceBeValid() ? (a = a.GetObjectClass()) ? a.IsGlobal() : !1 : !1 : !1)
        }
        GetPropertyTrack(a) {
            for (const b of this.GetTracks())
                for (const d of b.GetPropertyTracks())
                    if (d.GetPropertyName() === a) return d
        }
        GetTrackFromInstance(a) {
            for (const b of this._tracks)
                if (a ===
                    b.GetInstance()) return b;
            return null
        }
        GetKeyframeWithTags(a) {
            a = a ? a.split(" ") : [];
            a = [...(new Set(a.map(b => b.toLowerCase().trim()))).values()];
            for (const b of this.GetTracks())
                for (const d of b.GetKeyframeDataItems())
                    if (a.every(c => d.HasTag(c))) return d
        }
        GetObjectClasses() {
            const a = [];
            for (const b of this.GetTracks()) a.push(b.GetObjectClass());
            return a.filter(b => b)
        }
        _SaveToJson() {
            return {
                tracksJson: this._SaveTracksToJson(),
                name: this._name,
                playheadTime: this.GetTime(),
                playbackRate: this._playbackRate,
                pingPongState: this._pingPongState,
                currentRepeatCount: this._currentRepeatCount,
                isPlaying: this._isPlaying,
                isScheduled: this._isScheduled,
                initialStateSet: this._initialStateSet,
                finishedTriggers: this._finishedTriggers,
                complete: this._complete,
                released: this._released,
                markedForRemoval: this._markedForRemoval,
                completedTick: this._completedTick,
                implicitPause: this._implicitPause,
                isTemplate: this._isTemplate,
                tags: this._tags.join(" "),
                stringTags: this._stringTags,
                tagsChanged: this._tagsChanged,
                firstTick: this._firstTick
            }
        }
        _LoadFromJson(a) {
            a && (this._LoadTracksFromJson(a.tracksJson),
                this._name = a.name, this._playheadTime = a.playheadTime, this._playbackRate = a.playbackRate, this._pingPongState = a.pingPongState, this._currentRepeatCount = a.currentRepeatCount, this._isPlaying = !!a.isPlaying, this._isScheduled = !!a.isScheduled, this._initialStateSet = !!a.initialStateSet, this._finishedTriggers = a.hasOwnProperty("finishedTriggers") ? !!a.finishedTriggers : !1, this._complete = !!a.complete, this._released = !!a.released, this._markedForRemoval = !!a.markedForRemoval, this._completedTick = a.completedTick, this._implicitPause = !!a.implicitPause, this._isTemplate = !!a.isTemplate, this._tags = a.tags.split(" "), this._stringTags = a.stringTags, this._tagsChanged = !!a.tagsChanged, this._firstTick = !!a.firstTick)
        }
        _SaveTracksToJson() {
            return this._tracks.map(a => a._SaveToJson())
        }
        _LoadTracksFromJson(a) {
            a.forEach((b, d) => {
                this._tracks[d]._LoadFromJson(b)
            });
            this._tracks.filter(b => b.CanInstanceBeValid())
        }
        static _HasTag(a) {
            const b = this.GetTags();
            return "" === a ? 1 === b.length && "" === b[0] : b.includes(a)
        }
        static _GetTagArray(a) {
            if (e.IsArray(a)) return a.slice(0);
            if (e.IsString(a)) return a.split(" ")
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.TrackState = class extends e.DefendedBase {
        constructor(a, b) {
            super();
            this._timeline = a;
            this._trackDataItem = b;
            this._trackData = b.GetTrackData();
            this._objectClassIndex = this._instanceUid = NaN;
            this._worldInfo = this._instance = null;
            this._isNested = 0 < b.GetStartOffset();
            this._endStateOfNestedSet = this._initialStateOfNestedSet = !1;
            this._lastKeyframeDataItem = null;
            this._keyframeDataItems = this._trackDataItem.GetKeyframeData().GetKeyframeDataItemArray();
            this._propertyTracks = [];
            this.CreatePropertyTrackStates();
            this._needsBeforeAndAfter = this._renderChange = this._worldInfoChange = 0
        }
        static Create(a, b) {
            return e.New(e.TrackState, a, b)
        }
        Release() {
            this._keyframeDataItems = null;
            for (const a of this._propertyTracks) a.Release();
            e.clearArray(this._propertyTracks);
            this._lastKeyframeDataItem = this._trackDataItem = this._worldInfo = this._instance = this._timeline = this._propertyTracks = null
        }
        CreatePropertyTrackStates() {
            for (const a of this._trackDataItem.GetPropertyTrackData().propertyTrackDataItems()) this._propertyTracks.push(e.PropertyTrackState.Create(this,
                a))
        }
        TimelineRemoved() {
            for (const a of this._propertyTracks) a.TimelineRemoved()
        }
        CleanCaches() {
            for (const a of this._propertyTracks) a.CleanCaches();
            this._worldInfo = this._instance = null
        }
        GetTimeline() {
            return this._timeline
        }
        GetRuntime() {
            return this._timeline.GetRuntime()
        }
        GetKeyframeDataItems() {
            return this._keyframeDataItems ? this._keyframeDataItems : this._keyframeDataItems = this._trackDataItem.GetKeyframeData().GetKeyframeDataItemArray()
        }
        GetPropertyTracks() {
            return this._propertyTracks
        }
        GetPropertyTrack(a) {
            for (let b =
                    0; b < this._propertyTracks.length; b++) {
                const d = this._propertyTracks[b];
                if (d.GetPropertyName() === a) return d
            }
        }
        MaybeGetInstance() {
            this._instance || this.GetInstance()
        }
        IsInstanceValid() {
            return this._instance ? !this._instance.IsDestroyed() : !1
        }
        CanInstanceBeValid() {
            if (!this.IsInstanceTrack()) return !1;
            var a = this.GetInstanceUID();
            return (a = this.GetRuntime().GetInstanceByUID(a)) ? !a.IsDestroyed() : !1
        }
        GetObjectClass() {
            if (this.IsInstanceTrack()) {
                var a = this.GetObjectClassIndex();
                if (-1 !== a) return this.GetRuntime().GetObjectClassByIndex(a)
            }
        }
        ClearInstance() {
            this._instance =
                null;
            this._instanceUid = -1;
            this._worldInfo = null;
            this._objectClassIndex = -1
        }
        HasInstance() {
            return !!this._instance
        }
        GetInstance() {
            if (this._instance && this.IsInstanceValid()) return this._instance;
            const a = this.GetInstanceUID();
            return this._instance = this.GetRuntime().GetInstanceByUID(a)
        }
        SetInstance(a) {
            if (this._instance !== a) {
                this.CleanCaches();
                this._instance = a;
                this._objectClassIndex = a.GetObjectClass().GetIndex();
                this._instanceUid = a.GetUID();
                this._worldInfo = a.GetWorldInfo();
                for (const k of this.propertyTrackItems()) {
                    const h =
                        k.sourceAdapter;
                    switch (k.propertyTrack.GetSourceAdapterId()) {
                        case "instance-variable":
                            h.GetEditorIndex();
                            var b = a.GetObjectClass(),
                                d = b.GetInstanceVariableIndexByName(k.name),
                                c = b.GetInstanceVariableName(d);
                            b = b.GetInstanceVariableType(d);
                            c === k.name && b === k.type && h.UpdateInstanceVariableIndex(d);
                            break;
                        case "behavior":
                            var f = k.behaviorType;
                            d = this.GetObjectClass();
                            c = a.GetObjectClass();
                            b = h.GetBehaviorType(c);
                            f && b && (f = f.GetName(), d.GetBehaviorIndexByName(f), c.GetBehaviorIndexByName(f), h.GetEditorIndex(), h.UpdateBehaviorTypeSid(b.GetSID()))
                    }
                }
            }
        }* propertyTrackItems() {
            for (const d of this._propertyTracks) {
                var a =
                    d.GetSourceAdapter(),
                    b = this.GetObjectClass();
                const c = {
                    propertyTrack: d,
                    sourceAdapter: a
                };
                switch (d.GetSourceAdapterId()) {
                    case "world-instance":
                        c.property = d.GetPropertyName();
                        break;
                    case "instance-variable":
                        a = a.GetEditorIndex();
                        c.name = b.GetInstanceVariableName(a);
                        c.type = b.GetInstanceVariableType(a);
                        break;
                    case "effect":
                        b = b.GetEffectList();
                        a = a.GetEffectType(b);
                        c.effectType = a;
                        break;
                    case "behavior":
                        a = a.GetBehaviorType(b);
                        c.behaviorType = a;
                        break;
                    case "plugin":
                        c.plugin = b.GetPlugin()
                }
                yield c
            }
        }
        GetWorldInfo() {
            if (this._worldInfo &&
                this.IsInstanceValid()) return this._worldInfo;
            const a = this.GetInstance();
            a && (this._worldInfo = a.GetWorldInfo());
            return this._worldInfo
        }
        GetTrackDataItem() {
            return this._trackDataItem
        }
        GetInstanceUID() {
            return this._instanceUid ? this._instanceUid : this._trackDataItem.GetInstanceUID()
        }
        SetInstanceUID(a) {
            this._trackDataItem.SetInstanceUID(a)
        }
        GetInterpolationMode() {
            return this._trackDataItem.GetInterpolationMode()
        }
        SetInterpolationMode(a) {
            this._trackDataItem.SetInterpolationMode(a)
        }
        GetResultMode() {
            return this._trackDataItem.GetResultMode()
        }
        GetId() {
            return this._trackDataItem.GetId()
        }
        GetStartOffset() {
            return this._trackDataItem.GetStartOffset()
        }
        GetLocalTotalTime() {
            return this._trackDataItem.GetLocalTotalTime()
        }
        SetLocalTotalTime(a) {
            this._trackDataItem.SetLocalTotalTime(a)
        }
        SetResultMode(a) {
            this._trackDataItem.SetResultMode(a)
        }
        SetEase(a) {
            for (const b of this.GetKeyframeDataItems()) b.SetEase(a);
            for (const b of this.GetPropertyTracks()) b.SetEase(a)
        }
        GetEnable() {
            return this._trackDataItem.GetEnable()
        }
        SetEnable(a) {
            this._trackDataItem.SetEnable(a)
        }
        GetObjectClassIndex() {
            return isNaN(this._objectClassIndex) ? this._trackDataItem.GetObjectClassIndex() : this._objectClassIndex
        }
        SetObjectClassIndex(a) {
            this._trackDataItem.SetObjectClassIndex(a)
        }
        SetOriginalWidth(a) {
            this._trackDataItem.SetOriginalWidth(a)
        }
        GetOriginalWidth() {
            const a = this.GetInstance();
            return a && a.GetSdkInstance().IsOriginalSizeKnown() ? a.GetSdkInstance().GetOriginalWidth() :
                this._trackDataItem.GetOriginalWidth()
        }
        SetOriginalHeight(a) {
            this._trackDataItem.SetOriginalHeight(a)
        }
        GetOriginalHeight() {
            const a = this.GetInstance();
            return a && a.GetSdkInstance().IsOriginalSizeKnown() ? a.GetSdkInstance().GetOriginalHeight() : this._trackDataItem.GetOriginalHeight()
        }
        GetType() {
            return this._trackDataItem.GetType()
        }
        GetName() {
            return this._trackDataItem.GetName()
        }
        IsInstanceTrack() {
            return 0 === this.GetType()
        }
        IsValueTrack() {
            return 1 === this.GetType()
        }
        IsAudioTrack() {
            return 2 === this.GetType()
        }
        GetWorldInfoChange() {
            return this._worldInfoChange
        }
        GetRenderChange() {
            return this._renderChange
        }
        GetNeedsBeforeAndAfter() {
            return this._needsBeforeAndAfter
        }
        IsNested() {
            return this._isNested
        }
        SetInitialState() {
            this.MaybeGetInstance();
            if (this.IsInstanceValid() || !this.IsInstanceTrack()) {
                var a = this.GetTimeline().IsForwardPlayBack() ? 0 : this.GetLocalTotalTime();
                for (const b of this._propertyTracks) b.SetInitialState(a), 0 === this._worldInfoChange && 1 === b.GetWorldInfoChange() && (this._worldInfoChange = 1), 0 === this._renderChange && 1 === b.GetRenderChange() && (this._renderChange = 1);
                this._needsBeforeAndAfter = 0;
                this._propertyTracks.some(b => b.GetNeedsBeforeAndAfter()) && (this._needsBeforeAndAfter = 1);
                this._lastKeyframeDataItem = this._GetLastKeyFrameBeforeTime(a);
                this._endStateOfNestedSet = this._initialStateOfNestedSet = !1;
                this.Interpolate(a)
            }
        }
        SetResumeState() {
            this.MaybeGetInstance();
            if (this.IsInstanceValid() || !this.IsInstanceTrack()) {
                this._timeline.IsForwardPlayBack();
                var a = this._timeline.GetTime() - this.GetStartOffset();
                this._lastKeyframeDataItem = this._GetLastKeyFrameBeforeTime(a);
                for (const b of this._propertyTracks) b.SetResumeState(a)
            }
        }
        SetEndState() {
            if (!(this.GetTimeline().IsComplete() || (this.MaybeGetInstance(), !this.IsInstanceValid() && this.IsInstanceTrack() ||
                    this._isNested))) {
                const a = this._timeline.GetTime(),
                    b = this.GetStartOffset() + this.GetLocalTotalTime();
                a >= b ? this.Interpolate(this.GetLocalTotalTime(), !0, !1, !0) : 0 >= a && this.Interpolate(0, !0, !1, !0)
            }
        }
        _SetUpdateState() {
            for (let a = 0, b = this._propertyTracks.length; a < b; a++) {
                const d = this._propertyTracks[a];
                d._SetUpdateState();
                0 === this._worldInfoChange && 1 === d.GetWorldInfoChange() && (this._worldInfoChange = 1);
                0 === this._renderChange && 1 === d.GetRenderChange() && (this._renderChange = 1)
            }
        }
        BeforeInterpolate() {
            const a = this._propertyTracks.length;
            for (let b = 0; b < a; b++) this._propertyTracks[b].BeforeInterpolate()
        }
        Interpolate(a, b = !1, d = !1, c = !1, f = !1, k = !1) {
            this._instance || this.GetInstance();
            const h = this._instance && !this._instance.IsDestroyed(),
                l = 0 === this._trackDataItem._type;
            if (!(!h && l || k && l && this.GetObjectClass().IsGlobal() || (a -= this.GetStartOffset(), 0 > a))) {
                this.MaybeSetInitialStateOfNestedTrack(a, b);
                this.MaybeTriggerKeyframeReachedConditions(a, b, f);
                for (let n = 0, u = this._propertyTracks.length; n < u; n++) this._propertyTracks[n].Interpolate(a, d, c);
                this.MaybeSetEndStateOfNestedTrack(a,
                    b);
                0 !== this._worldInfoChange && (this._worldInfo || (this._worldInfo = this._instance.GetWorldInfo()), this._worldInfo && this._worldInfo.SetBboxChanged())
            }
        }
        AfterInterpolate() {
            const a = this._propertyTracks.length;
            for (let b = 0; b < a; b++) this._propertyTracks[b].AfterInterpolate()
        }
        MaybeSetInitialStateOfNestedTrack(a, b) {
            if (b && this._isNested && !this._initialStateOfNestedSet) {
                if (this.GetTimeline().IsForwardPlayBack()) {
                    if (0 > a) return;
                    for (const d of this._propertyTracks) d.Interpolate(0, !1, !0)
                } else {
                    if (a > this.GetLocalTotalTime()) return;
                    for (const d of this._propertyTracks) d.Interpolate(this.GetLocalTotalTime(), !1, !0)
                }
                for (const d of this._propertyTracks) d.SetInitialState();
                this._initialStateOfNestedSet = !0
            }
        }
        MaybeSetEndStateOfNestedTrack(a, b) {
            if (b && this._isNested && !this._endStateOfNestedSet)
                if (this.GetTimeline().IsForwardPlayBack()) {
                    if (a >= this.GetLocalTotalTime()) {
                        for (const d of this._propertyTracks) d.Interpolate(this.GetLocalTotalTime(), !1, !0);
                        this._endStateOfNestedSet = !0
                    }
                } else if (0 >= a) {
                for (const d of this._propertyTracks) d.Interpolate(0,
                    !1, !0);
                this._endStateOfNestedSet = !0
            }
        }
        MaybeTriggerKeyframeReachedConditions(a, b, d) {
            if (!d && b && e.Plugins.Timeline) {
                b = this.GetTimeline();
                d = this._lastKeyframeDataItem.GetNext();
                var c = this._lastKeyframeDataItem.GetTime(),
                    f = d ? d.GetTime() : b.GetTotalTime();
                if (a <= c || a >= f) this._lastKeyframeDataItem = this._trackData.GetFirstKeyFrameDataItemLowerOrEqualThan(a, this._trackDataItem), b.IsForwardPlayBack() ? d && this.OnKeyframeReached(this._lastKeyframeDataItem) : this._lastKeyframeDataItem.GetNext() && this.OnKeyframeReached(this._lastKeyframeDataItem)
            }
        }
        _GetLastKeyFrameBeforeTime(a) {
            const b =
                this._trackData.GetKeyFrameDataItemAtTime(a, this._trackDataItem);
            return b ? b : this._trackData.GetFirstKeyFrameDataItemLowerOrEqualThan(a, this._trackDataItem)
        }
        OnKeyframeReached(a) {
            const b = this.GetTimeline();
            e.Plugins.Timeline.Cnds.SetTriggerTimeline(b);
            e.Plugins.Timeline.Cnds.SetTriggerKeyframe(a);
            a = b.GetTimelineManager();
            a.Trigger(e.Plugins.Timeline.Cnds.OnAnyKeyframeReached);
            a.Trigger(e.Plugins.Timeline.Cnds.OnKeyframeReached);
            e.Plugins.Timeline.Cnds.SetTriggerTimeline(null);
            e.Plugins.Timeline.Cnds.SetTriggerKeyframe(null)
        }
        AddKeyframe() {
            return this._trackDataItem.GetKeyframeData().AddEmptyKeyframeDataItem()
        }
        AddPropertyTrack() {
            var a =
                this._trackDataItem.GetPropertyTrackData().AddEmptyPropertyTrackDataItem();
            a = e.PropertyTrackState.Create(this, a);
            this._propertyTracks.push(a);
            return a
        }
        DeleteKeyframes(a) {
            this._trackDataItem.GetKeyframeData().DeleteKeyframeDataItems(a)
        }
        DeletePropertyKeyframes(a) {
            for (const b of this._propertyTracks) b.DeletePropertyKeyframes(a)
        }
        SaveState() {
            for (const a of this._propertyTracks) a.SaveState()
        }
        CompareInitialStateWithCurrent() {
            this.MaybeGetInstance();
            if (this.IsInstanceValid() || !this.IsInstanceTrack())
                for (const a of this._propertyTracks) a.CompareInitialStateWithCurrent()
        }
        CompareSaveStateWithCurrent() {
            this.MaybeGetInstance();
            if (this.IsInstanceValid() || !this.IsInstanceTrack()) {
                var a = !1;
                for (const b of this._propertyTracks) {
                    const d = b.CompareSaveStateWithCurrent();
                    !a && d && (a = !0)
                }
                a && (a = this.AddKeyframe(), a.SetTime(this.GetTimeline().GetTime()), a.SetEase("noease"), a.SetEnable(!0), a.SetTags(""))
            }
        }
        _SaveToJson() {
            var a = this.GetInstance();
            a = a ? a.GetUID() : this.GetInstanceUID();
            return {
                propertyTracksJson: this._SavePropertyTracksToJson(),
                lastKeyframeDataItemJson: this._SaveLastKeyframeDataItemToJson(),
                initialStateOfNestedSet: this._initialStateOfNestedSet,
                endStateOfNestedSet: this._endStateOfNestedSet,
                instanceUid: a
            }
        }
        _LoadFromJson(a) {
            a && (this._LoadPropertyTracksFromJson(a.propertyTracksJson), this._LoadLastKeyframeDataItemFromJson(a.lastKeyframeDataItemJson), this._LoadInstanceFromJson(a.instanceUid), this._initialStateOfNestedSet = !1, a.hasOwnProperty.initialStateOfNestedSet && (this._initialStateOfNestedSet = a.initialStateOfNestedSet), this._endStateOfNestedSet = !1, a.hasOwnProperty.endStateOfNestedSet && (this._endStateOfNestedSet = a.endStateOfNestedSet))
        }
        _SaveLastKeyframeDataItemToJson() {
            return this._trackDataItem.GetKeyframeData().GetKeyframeDataItemIndex(this._lastKeyframeDataItem)
        }
        _SavePropertyTracksToJson() {
            return this._propertyTracks.map(a =>
                a._SaveToJson())
        }
        _LoadPropertyTracksFromJson(a) {
            a.forEach((b, d) => {
                this._propertyTracks[d]._LoadFromJson(b)
            })
        }
        _LoadInstanceFromJson(a) {
            if (e.IsFiniteNumber(a) && (a = this.GetRuntime().GetInstanceByUID(a))) {
                var b = this.GetTimeline();
                b.ClearTrackInstances();
                b.SetTrackInstance(this._trackDataItem.GetId(), a)
            }
        }
        _LoadLastKeyframeDataItemFromJson(a) {
            this._lastKeyframeDataItem = this._trackDataItem.GetKeyframeData().GetKeyframeDataItemFromIndex(a)
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.PropertyTrackState = class extends e.DefendedBase {
        constructor(a, b) {
            super();
            this._track = a;
            this._propertyTrackDataItem = b;
            this._propertyTrackData = b.GetPropertyTrackData();
            this._needsBeforeAndAfter = this._renderChange = this._worldInfoChange = 0;
            this._sourceAdapter = this.GetSourceAdapter();
            this._propertyKeyframeDataItems = this._propertyTrackDataItem.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray();
            this._absoluteValueObject = this._lastPropertyKeyframeDataItem = null
        }
        static Create(a,
            b) {
            return e.New(e.PropertyTrackState, a, b)
        }
        Release() {
            this._track = null;
            this._sourceAdapter && (this._sourceAdapter.Release(), this._sourceAdapter = null);
            this._propertyTrackData = this._propertyTrackDataItem = this._propertyKeyframeDataItems = null
        }
        GetWorldInfoChange() {
            return this._worldInfoChange
        }
        GetRenderChange() {
            return this._renderChange
        }
        GetNeedsBeforeAndAfter() {
            return this._needsBeforeAndAfter
        }
        HasAbsoluteValueObject() {
            return !!this._absoluteValueObject
        }
        SetAbsoluteValueObject(a) {
            this._absoluteValueObject = a
        }
        GetAbsoluteValueObject() {
            return this._absoluteValueObject
        }
        GetTrack() {
            return this._track
        }
        GetPropertyTrackDataItem() {
            return this._propertyTrackDataItem
        }
        GetPropertyTrackData() {
            return this._propertyTrackData
        }
        GetTimeline() {
            return this._track.GetTimeline()
        }
        GetRuntime() {
            return this._track.GetRuntime()
        }
        GetInstance() {
            return this._track.GetInstance()
        }
        GetSourceAdapter() {
            if (this._sourceAdapter) return this._sourceAdapter;
            let a;
            switch (this._propertyTrackDataItem.GetSourceAdapterId()) {
                case "behavior":
                    a = new e.PropertyTrackState.BehaviorSourceAdapter(this);
                    break;
                case "effect":
                    a = new e.PropertyTrackState.EffectSourceAdapter(this);
                    this._renderChange = 1;
                    break;
                case "instance-variable":
                    a = new e.PropertyTrackState.InstanceVariableSourceAdapter(this);
                    break;
                case "plugin":
                    a = new e.PropertyTrackState.PluginSourceAdapter(this);
                    this._renderChange = 1;
                    break;
                case "world-instance":
                    a = new e.PropertyTrackState.PropertySourceAdapter(this);
                    this._worldInfoChange =
                        this._renderChange = 1;
                    break;
                case "value":
                    a = new e.PropertyTrackState.ValueSourceAdapter(this);
                    break;
                case "audio":
                    a = new e.PropertyTrackState.AudioSourceAdapter(this)
            }
            return this._sourceAdapter = a
        }
        GetSourceAdapterId() {
            return this._propertyTrackDataItem.GetSourceAdapterId()
        }
        SetSourceAdapterId(a) {
            this._propertyTrackDataItem.SetSourceAdapterId(a)
        }
        GetSourceAdapterArgs() {
            return this._propertyTrackDataItem.GetSourceAdapterArguments()
        }
        SetSourceAdapterArgs(a) {
            this._propertyTrackDataItem.SetSourceAdapterArguments(a)
        }
        GetSourceAdapterValue() {
            return this.GetSourceAdapter().GetValue()
        }
        GetPropertyName() {
            return this._propertyTrackDataItem.GetProperty()
        }
        SetPropertyName(a) {
            this._propertyTrackDataItem.SetProperty(a)
        }
        GetPropertyType() {
            return this._propertyTrackDataItem.GetType()
        }
        SetPropertyType(a) {
            this._propertyTrackDataItem.SetType(a)
        }
        GetPropertyKeyframeType() {
            return this.GetPropertyTrackData().GetFirstPropertyKeyframeDataItem(this._propertyTrackDataItem).GetType()
        }
        GetMin() {
            return this._propertyTrackDataItem.GetMin()
        }
        SetMin(a) {
            this._propertyTrackDataItem.SetMin(a)
        }
        GetMax() {
            return this._propertyTrackDataItem.GetMax()
        }
        SetMax(a) {
            this._propertyTrackDataItem.SetMax(a)
        }
        GetEnable() {
            return this._propertyTrackDataItem.GetEnable()
        }
        SetEnable(a) {
            this._propertyTrackDataItem.SetEnable(a)
        }
        GetInterpolationMode() {
            return this._propertyTrackDataItem.GetInterpolationMode()
        }
        SetInterpolationMode(a) {
            this._propertyTrackDataItem.SetInterpolationMode(a)
        }
        GetResultMode() {
            return this._propertyTrackDataItem.GetResultMode()
        }
        SetResultMode(a) {
            this._propertyTrackDataItem.SetResultMode(a)
        }
        SetEase(a) {
            for (const b of this.GetPropertyKeyframeDataItems()) b.SetEase(a)
        }
        CanHavePropertyKeyframes() {
            return this._propertyTrackDataItem.CanHavePropertyKeyframes()
        }
        GetPropertyKeyframeDataItems() {
            return this._propertyKeyframeDataItems ?
                this._propertyKeyframeDataItems : this._propertyKeyframeDataItems = this._propertyTrackDataItem.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray()
        }* GetPropertyKeyframeValues() {
            for (const a of this.GetPropertyKeyframeDataItems()) yield a.GetValueWithResultMode()
        }
        TimelineRemoved() {
            this.GetSourceAdapter().TimelineRemoved()
        }
        CleanCaches() {
            this.GetSourceAdapter().CleanCaches()
        }
        GetCurrentState() {
            return this.GetSourceAdapter().GetCurrentState()
        }
        SetInitialState(a) {
            this.GetSourceAdapter().SetInitialState();
            this._lastPropertyKeyframeDataItem = this._GetLastPropertyKeyFrameBeforeTime(a);
            this._SetUpdateState()
        }
        SetResumeState(a) {
            this.GetSourceAdapter().SetResumeState();
            this._lastPropertyKeyframeDataItem = this._GetLastPropertyKeyFrameBeforeTime(a)
        }
        _SetUpdateState() {
            var a = this.GetTrack();
            this._needsBeforeAndAfter = 0;
            if (a.IsInstanceTrack()) {
                var b = this.GetTimeline();
                a = a.GetInstance();
                const d = this.GetSourceAdapter(),
                    c = this.GetPropertyName();
                d.MayNeedBeforeAndAfterInterpolate() ? (b = b.GetSimilarPropertyTracks(a, d,
                    c)) && b.length && (this._needsBeforeAndAfter = 1) : this._needsBeforeAndAfter = 0
            }
        }
        _GetLastPropertyKeyFrameBeforeTime(a) {
            const b = this.GetTimeline(),
                d = this._propertyTrackData.GetPropertyKeyFrameDataItemAtTime(a, this._propertyTrackDataItem);
            return d ? d : b.IsForwardPlayBack() ? this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a, this._propertyTrackDataItem) : this._propertyTrackData.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(a, this._propertyTrackDataItem)
        }
        BeforeInterpolate() {
            this._sourceAdapter.BeforeInterpolate()
        }
        Interpolate(a,
            b = !1, d = !1) {
            let c;
            if (b) var f = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a, this._propertyTrackDataItem);
            else {
                if (this._lastPropertyKeyframeDataItem) {
                    var k = this.GetTimeline();
                    const h = this._lastPropertyKeyframeDataItem.GetNext();
                    f = this._lastPropertyKeyframeDataItem.GetTime();
                    k = h ? h.GetTime() : k.GetTotalTime();
                    if (a <= f || a >= k) this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a, this._propertyTrackDataItem)
                } else this._lastPropertyKeyframeDataItem =
                    this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a, this._propertyTrackDataItem);
                f = this._lastPropertyKeyframeDataItem
            }
            f && (c = f.GetNext());
            this._sourceAdapter.Interpolate(a, f, c, b, d)
        }
        GetInterpolatedValue(a) {
            if (this._lastPropertyKeyframeDataItem) {
                var b = this.GetTimeline();
                const c = this._lastPropertyKeyframeDataItem.GetNext();
                var d = this._lastPropertyKeyframeDataItem.GetTime();
                b = c ? c.GetTime() : b.GetTotalTime();
                if (a <= d || a >= b) this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a,
                    this._propertyTrackDataItem)
            } else this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a, this._propertyTrackDataItem);
            d = this._lastPropertyKeyframeDataItem;
            b = d.GetNext();
            return this._sourceAdapter.GetInterpolatedValue(a, d, b)
        }
        AfterInterpolate() {
            this._sourceAdapter.AfterInterpolate()
        }
        static GetStartPropertyKeyframeForTime(a, b) {
            const d = b.GetPropertyTrackDataItem();
            return b._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a, d)
        }
        static GetEndPropertyKeyframeForTime(a,
            b) {
            const d = b.GetPropertyTrackDataItem();
            return b._propertyTrackData.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(a, d)
        }
        AddPropertyKeyframe() {
            const a = this._propertyTrackDataItem.GetPropertyKeyframeData().AddEmptyPropertyKeyframeDataItem();
            this._lastPropertyKeyframeDataItem = null;
            return a
        }
        DeletePropertyKeyframes(a) {
            this._lastPropertyKeyframeDataItem = null;
            this._propertyTrackDataItem.GetPropertyKeyframeData().DeletePropertyKeyframeDataItems(a)
        }
        SaveState() {
            this.GetSourceAdapter().SaveState()
        }
        CompareInitialStateWithCurrent() {
            if (this.GetSourceAdapter().CompareInitialStateWithCurrent()) {
                const a =
                    this._propertyTrackData.GetFirstPropertyKeyframeDataItem(this._propertyTrackDataItem),
                    b = this.GetSourceAdapter().GetCurrentState();
                a.SetAbsoluteValue(b)
            }
        }
        CompareSaveStateWithCurrent() {
            const a = this.GetSourceAdapter().CompareSaveStateWithCurrent();
            a && this.AddPropertyKeyframeAtCurrentTime();
            this.GetSourceAdapter().ClearSaveState();
            return a
        }
        AddPropertyKeyframeAtCurrentTime() {
            const a = this.GetTimeline().GetTime(),
                b = this.GetSourceAdapter(),
                d = e.PropertyTrackState.GetStartPropertyKeyframeForTime(a, this),
                c =
                this.AddPropertyKeyframe();
            c.SetType(d.GetType());
            c.SetTime(a);
            c.SetEase(d.GetEase());
            c.SetEnable(!0);
            c.SetValue(b.GetValueAtTime());
            c.SetAbsoluteValue(b.GetCurrentState())
        }
        _SaveToJson() {
            return {
                sourceAdapterJson: this.GetSourceAdapter()._SaveToJson()
            }
        }
        _LoadFromJson(a) {
            a && this.GetSourceAdapter()._LoadFromJson(a.sourceAdapterJson)
        }
    }
} {
    "use strict";
    const e = self.C3.PropertyTrackState;
    e.PropertySourceAdapter = class {
        constructor(a) {
            this._propertyTrack = a;
            this._propertyAdapter = null;
            this.GetPropertyAdapter()
        }
        Release() {
            this._propertyAdapter && (this._propertyAdapter.Release(), this._propertyAdapter = null);
            this._propertyTrack = null
        }
        MayNeedBeforeAndAfterInterpolate() {
            return this._propertyAdapter.MayNeedBeforeAndAfterInterpolate()
        }
        GetPropertyTrack() {
            return this._propertyTrack
        }
        TimelineRemoved() {
            this._propertyAdapter && this._propertyAdapter.TimelineRemoved()
        }
        CleanCaches() {
            this._propertyAdapter &&
                this._propertyAdapter.CleanCaches()
        }
        GetPropertyAdapter() {
            return this._propertyAdapter ? this._propertyAdapter : this._propertyAdapter = this._CreatePropertyAdapter()
        }
        GetEditorIndex() {}
        GetIndex() {
            return this.GetEditorIndex()
        }
        GetTarget() {}
        SetInitialState() {
            this.GetPropertyAdapter().SetInitialState()
        }
        SetResumeState() {
            this.GetPropertyAdapter().SetResumeState()
        }
        BeforeInterpolate() {
            this._propertyAdapter.BeforeChangeProperty()
        }
        Interpolate(a, b, d, c, f) {
            let k;
            switch (this._propertyTrack.GetPropertyKeyframeType()) {
                case "numeric":
                    k =
                        e.NumericTypeAdapter.Interpolate(a, b, d, this._propertyTrack);
                    break;
                case "angle":
                    k = e.AngleTypeAdapter.Interpolate(a, b, d, this._propertyTrack);
                    break;
                case "boolean":
                    k = e.BooleanTypeAdapter.Interpolate(a, b, d, this._propertyTrack);
                    break;
                case "color":
                    k = e.ColorTypeAdapter.Interpolate(a, b, d, this._propertyTrack);
                    break;
                case "text":
                    k = e.TextTypeAdapter.Interpolate(a, b, d, this._propertyTrack)
            }
            this._propertyAdapter.ChangeProperty(a, k, b, d, c, f)
        }
        GetInterpolatedValue(a, b, d) {
            switch (this._propertyTrack.GetPropertyKeyframeType()) {
                case "numeric":
                    return e.NumericTypeAdapter.Interpolate(a,
                        b, d, this._propertyTrack);
                case "angle":
                    return e.AngleTypeAdapter.Interpolate(a, b, d, this._propertyTrack);
                case "boolean":
                    return e.BooleanTypeAdapter.Interpolate(a, b, d, this._propertyTrack);
                case "color":
                    return e.ColorTypeAdapter.Interpolate(a, b, d, this._propertyTrack);
                case "text":
                    return e.TextTypeAdapter.Interpolate(a, b, d, this._propertyTrack)
            }
        }
        AfterInterpolate() {
            this._propertyAdapter.AfterChangeProperty()
        }
        SaveState() {
            this.GetPropertyAdapter().SetSaveState()
        }
        ClearSaveState() {
            this.GetPropertyAdapter().ClearSaveState()
        }
        GetCurrentState() {
            return this.GetPropertyAdapter().GetCurrentState()
        }
        CompareInitialStateWithCurrent() {
            return this.GetPropertyAdapter().CompareInitialStateWithCurrent()
        }
        CompareSaveStateWithCurrent() {
            return this.GetPropertyAdapter().CompareSaveStateWithCurrent()
        }
        GetValueAtTime() {
            const a =
                this._propertyTrack,
                b = a.GetTrack().GetTimeline().GetTime(),
                d = e.GetStartPropertyKeyframeForTime(b, a),
                c = d.GetNext();
            switch (a.GetPropertyKeyframeType()) {
                case "numeric":
                    return e.NumericTypeAdapter.Interpolate(b, d, c, a);
                case "angle":
                    return e.AngleTypeAdapter.Interpolate(b, d, c, a);
                case "boolean":
                    return e.BooleanTypeAdapter.Interpolate(b, d, c, a);
                case "color":
                    return e.ColorTypeAdapter.Interpolate(b, d, c, a);
                case "text":
                    return e.TextTypeAdapter.Interpolate(b, d, c, a)
            }
        }
        _CreatePropertyAdapter() {
            const a = this._propertyTrack;
            switch (a.CanHavePropertyKeyframes() ? a.GetPropertyKeyframeType() : "") {
                case "combo":
                case "boolean":
                case "text":
                case "string":
                    return new e.PropertyInterpolationAdapter.NoInterpolationAdapter(this);
                case "numeric":
                case "number":
                case "angle":
                    return "combo" === this._propertyTrack.GetPropertyType() ? new e.PropertyInterpolationAdapter.NoInterpolationAdapter(this) : new e.PropertyInterpolationAdapter.NumericInterpolationAdapter(this);
                case "color":
                case "offsetColor":
                    return new e.PropertyInterpolationAdapter.ColorInterpolationAdapter(this);
                default:
                    return new e.PropertyInterpolationAdapter.NumericInterpolationAdapter(this)
            }
        }
        _SaveToJson() {
            return {
                propertyAdapterJson: this.GetPropertyAdapter()._SaveToJson()
            }
        }
        _LoadFromJson(a) {
            a && this.GetPropertyAdapter()._LoadFromJson(a.propertyAdapterJson)
        }
    }
} {
    "use strict";
    const e = self.C3;
    class a extends e.PropertyTrackState.PropertySourceAdapter {
        constructor(b) {
            super(b);
            this._updatedIndex = NaN
        }
        GetEditorIndex() {
            return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[0]
        }
        GetIndex() {
            return this._updatedIndex ? this._updatedIndex : super.GetIndex()
        }
        GetTarget() {
            return this._propertyTrack.GetTrack().GetInstance()
        }
        UpdateInstanceVariableIndex(b) {
            this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[0] !== b && (this._updatedIndex =
                b)
        }
        Interpolate(b, d, c, f, k) {
            this.GetPropertyAdapter().CanChange(d.GetValue()) && super.Interpolate(b, d, c, f, k)
        }
        GetInterpolatedValue(b, d, c) {
            if (this.GetPropertyAdapter().CanChange(d.GetValue())) return super.GetInterpolatedValue(b, d, c)
        }
        _SaveToJson() {
            return Object.assign(super._SaveToJson(), {
                index: this._updatedIndex
            })
        }
        _LoadFromJson(b) {
            b && (super._LoadFromJson(b), this._updatedIndex = b.index)
        }
    }
    e.PropertyTrackState.InstanceVariableSourceAdapter = a
} {
    "use strict";
    const e = self.C3;
    class a extends e.PropertyTrackState.PropertySourceAdapter {
        constructor(b) {
            super(b);
            this._sid = NaN
        }
        GetEditorIndex() {
            return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[1]
        }
        GetTarget() {
            var b = this._propertyTrack.GetPropertyTrackDataItem(),
                d = this._propertyTrack.GetTrack();
            b = this._sid ? this._sid : b.GetSourceAdapterArguments()[0];
            d = d.GetInstance();
            b = d.GetBehaviorIndexBySID(b);
            return d.GetBehaviorInstances()[b].GetSdkInstance()
        }
        GetBehaviorType(b) {
            const d =
                this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[2];
            return b.GetBehaviorTypeByName(d)
        }
        UpdateBehaviorTypeSid(b) {
            this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[0] !== b && (this._sid = b)
        }
        Interpolate(b, d, c, f, k) {
            const h = this._propertyTrack.GetTrack().GetInstance();
            this.GetBehaviorType(h.GetObjectClass()) && super.Interpolate(b, d, c, f, k)
        }
        GetInterpolatedValue(b, d, c) {
            const f = this._propertyTrack.GetTrack().GetInstance();
            if (this.GetBehaviorType(f.GetObjectClass())) return super.GetInterpolatedValue(b,
                d, c)
        }
        _SaveToJson() {
            return Object.assign(super._SaveToJson(), {
                sid: this._sid
            })
        }
        _LoadFromJson(b) {
            b && (super._LoadFromJson(b), this._sid = b.sid)
        }
    }
    e.PropertyTrackState.BehaviorSourceAdapter = a
} {
    "use strict";
    const e = self.C3;
    class a extends e.PropertyTrackState.PropertySourceAdapter {
        constructor(b) {
            super(b)
        }
        GetEditorIndex() {
            return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[1]
        }
        GetTarget() {
            const b = this._propertyTrack.GetTrack().GetWorldInfo().GetInstanceEffectList();
            var d = b.GetEffectList();
            d = this.GetEffectType(d).GetIndex();
            return b.IsEffectIndexActive(d) ? b.GetEffectParametersForIndex(d) : null
        }
        GetEffectType(b) {
            const d = this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[0];
            return b.GetEffectTypeByName(d)
        }
        Interpolate(b, d, c, f, k) {
            this._IsEffectActive() && super.Interpolate(b, d, c, f, k)
        }
        GetInterpolatedValue(b, d, c) {
            if (this._IsEffectActive()) return super.GetInterpolatedValue(b, d, c)
        }
        _IsEffectActive() {
            const b = this._propertyTrack.GetTrack().GetWorldInfo().GetInstanceEffectList();
            var d = b.GetEffectList();
            if (d = this.GetEffectType(d)) return d = d.GetIndex(), b.IsEffectIndexActive(d)
        }
    }
    e.PropertyTrackState.EffectSourceAdapter = a
} {
    "use strict";
    const e = self.C3;
    class a extends e.PropertyTrackState.PropertySourceAdapter {
        constructor(b) {
            super(b)
        }
        GetEditorIndex() {
            return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[0]
        }
        GetTarget() {
            return this._propertyTrack.GetTrack().GetInstance().GetSdkInstance()
        }
        Interpolate(b, d, c, f, k) {
            var h = this._propertyTrack.GetTrack();
            const l = h.GetObjectClass().GetPlugin();
            h = h.GetInstance().GetObjectClass().GetPlugin();
            l === h && super.Interpolate(b, d, c, f, k)
        }
        GetInterpolatedValue(b,
            d, c) {
            var f = this._propertyTrack.GetTrack();
            const k = f.GetObjectClass().GetPlugin();
            f = f.GetInstance().GetObjectClass().GetPlugin();
            if (k === f) return super.GetInterpolatedValue(b, d, c)
        }
    }
    e.PropertyTrackState.PluginSourceAdapter = a
} {
    "use strict";
    const e = self.C3;
    class a extends e.PropertyTrackState.PropertySourceAdapter {
        constructor(b) {
            super(b);
            this._value = 0;
            this._init = !1
        }
        MayNeedBeforeAndAfterInterpolate() {
            return !1
        }
        SetInitialState() {
            const b = this._propertyTrack.GetPropertyTrackData();
            let d = this._propertyTrack.GetPropertyTrackDataItem();
            d = b.GetFirstPropertyKeyframeDataItem(d);
            this._value = d.GetValueWithResultMode()
        }
        SetResumeState() {}
        GetValue() {
            this._init || this._propertyTrack.Interpolate(0);
            return this._value
        }
        Interpolate(b, d, c, f,
            k) {
            this._value = e.PropertyTrackState.NumericTypeAdapter.Interpolate(b, d, c, this._propertyTrack);
            this._init = !0
        }
        SaveState() {}
        ClearSaveState() {}
        GetCurrentState() {
            return this._value
        }
        CompareInitialStateWithCurrent() {
            return !1
        }
        CompareSaveStateWithCurrent() {
            return !1
        }
        _SaveToJson() {
            return {
                value: this._value,
                init: this._init
            }
        }
        _LoadFromJson(b) {
            b && (this._value = b.value, this._init = b.hasOwnProperty("init") ? b.init : !0)
        }
    }
    e.PropertyTrackState.ValueSourceAdapter = a
} {
    "use strict";
    const e = self.C3;
    class a extends e.PropertyTrackState.PropertySourceAdapter {
        constructor(b) {
            super(b);
            this._audioPlaybackStarted = !1;
            this._expressions = this._actions = this._sdkInstance = null;
            this._timeline = this._propertyTrack.GetTimeline();
            this._track = this._propertyTrack.GetTrack();
            this._sourceAdapterArgs = this._propertyTrack.GetSourceAdapterArgs();
            this._fileArgs = this._sourceAdapterArgs[0];
            this._startOffsetTime = this._sourceAdapterArgs[1];
            this._audioTag = this._sourceAdapterArgs[3] ? this._sourceAdapterArgs[3] :
                Math.random().toString(36).slice(2);
            this._volume = this._pauseVolume = this._pauseTime = NaN;
            this._audioSource = null;
            this._Initialize()
        }
        Release() {
            super.Release();
            this._audioSource = this._fileArgs = this._sourceAdapterArgs = this._track = this._timeline = this._expressions = this._actions = this._sdkInstance = null
        }
        _Initialize() {
            if (self.C3.Plugins.Audio) {
                var b = this._propertyTrack.GetRuntime().GetObjectClassByName("audio");
                b && (this._sdkInstance = b.GetSingleGlobalInstance().GetSdkInstance());
                this._actions = self.C3.Plugins.Audio.Acts;
                this._expressions = self.C3.Plugins.Audio.Exps
            }
        }
        _MaybeSetAudioSource() {
            if (!this._audioSource) {
                var b = this._propertyTrack.GetTrack().GetPropertyTrack("audioSource");
                b && (this._audioSource = b.GetSourceAdapter())
            }
        }
        _GetPauseVolume() {
            const b = this._propertyTrack.GetTrack().GetPropertyTrack("volume");
            return b ? b.GetSourceAdapter()._pauseVolume : this._pauseVolume
        }
        TimelineRemoved() {
            super.TimelineRemoved();
            this._audioPlaybackStarted = !1;
            this._sdkInstance && (this._expressions && (this._pauseTime = this._expressions.PlaybackTime.call(this._sdkInstance,
                this._audioTag), this._pauseVolume = this._expressions.Volume.call(this._sdkInstance, this._audioTag)), this._actions && this._actions.Stop.call(this._sdkInstance, this._audioTag))
        }
        GetAudioTag() {
            return this._audioTag
        }
        GetVolume() {
            return this._volume
        }
        SetVolume(b) {
            this._volume = b
        }
        SetInitialState() {
            super.SetInitialState();
            this._pauseTime = NaN;
            this._audioPlaybackStarted = !1
        }
        SetResumeState() {
            super.SetResumeState();
            const b = this._propertyTrack.GetTimeline().GetTime();
            this._pauseTime = b - this._startOffsetTime;
            switch (this._propertyTrack.GetPropertyName()) {
                case "volume":
                    this._pauseVolume =
                        this._propertyTrack.GetInterpolatedValue(b)
            }
            this._audioPlaybackStarted = !1
        }
        Interpolate(b, d, c, f, k) {
            if (this._sdkInstance) switch (this._propertyTrack.GetPropertyName()) {
                case "audioSource":
                    if (!this._timeline.IsForwardPlayBack()) break;
                    if (f) {
                        this._actions && this._actions.Stop.call(this._sdkInstance, this._audioTag);
                        break
                    }
                    if (b < this._startOffsetTime) {
                        this._audioPlaybackStarted = !1;
                        break
                    }
                    d = this._expressions.PlaybackRate.call(this._sdkInstance, this._audioTag);
                    c = this._timeline.GetPlaybackRate();
                    c !== d && this._actions.SetPlaybackRate.call(this._sdkInstance,
                        this._audioTag, c);
                    if (this._audioPlaybackStarted) break;
                    this._audioPlaybackStarted = !0;
                    if (isNaN(this._pauseTime)) {
                        const h = self.performance.now(),
                            l = b - this._startOffsetTime;
                        this._sdkInstance.PostToDOMAsync("get-suspended").then(n => {
                            if ("suspended" === n) this._audioPlaybackStarted = !1;
                            else if (n = (self.performance.now() - h) / 1E3, n = l + n, this._actions) {
                                let u = this.GetVolume();
                                isNaN(u) ? (this.SetVolume(0), u = 0) : this.SetVolume(u);
                                this._actions.Play.call(this._sdkInstance, this._fileArgs, 0, u, this._audioTag, n)
                            }
                        })
                    } else {
                        const h =
                            this._pauseTime;
                        this._pauseTime = NaN;
                        const l = this._GetPauseVolume();
                        this._pauseVolume = NaN;
                        this._sdkInstance.PostToDOMAsync("get-suspended").then(n => {
                            "suspended" === n ? this._audioPlaybackStarted = !1 : this._actions && (this.SetVolume(l), this._actions.Play.call(this._sdkInstance, this._fileArgs, 0, l, this._audioTag, h))
                        })
                    }
                    break;
                case "volume":
                    this._MaybeSetAudioSource(), super.Interpolate(b, d, c, f, k)
            }
        }
        GetInterpolatedValue(b, d, c) {
            if (this._sdkInstance) switch (this._propertyTrack.GetPropertyName()) {
                case "volume":
                    return this._MaybeSetAudioSource(),
                        super.GetInterpolatedValue(b, d, c)
            }
        }
        Getter(b, d) {
            return this._audioSource ? this._audioSource.GetVolume() : 0
        }
        Setter(b, d, c, f) {
            this._audioSource && this._audioSource.SetVolume(this.Getter() + d);
            this._actions && this._audioSource && this._actions.SetVolume.call(this._sdkInstance, this._audioSource.GetAudioTag(), this._audioSource.GetVolume())
        }
        AbsoluteSetter(b, d, c) {
            this._audioSource && this._audioSource.SetVolume(d);
            this._actions && this._audioSource && this._actions.SetVolume.call(this._sdkInstance, this._audioSource.GetAudioTag(),
                this._audioSource.GetVolume())
        }
        DoesRounding() {
            return !0
        }
        _SaveToJson() {
            return {
                audioPlaybackStarted: this._audioPlaybackStarted,
                audioTag: this._audioTag,
                pauseTime: this._pauseTime,
                pauseVolume: this._pauseVolume,
                volume: this._volume
            }
        }
        _LoadFromJson(b) {
            b && (this._audioPlaybackStarted = b.audioPlaybackStarted, this._audioTag = b.audioTag, this._pauseTime = b.pauseTime, this._pauseVolume = b.pauseVolume, this._volume = b.volume, this._Initialize())
        }
    }
    e.PropertyTrackState.AudioSourceAdapter = a
}
"use strict";
self.C3.PropertyTrackState.PropertyInterpolationAdapter = class {
    constructor(e) {
        this._sourceAdapter = e;
        this._propertyTrack = e.GetPropertyTrack();
        this._worldInfo = this._propertyTrack.GetTrack().GetWorldInfo();
        this._property = this._propertyTrack.GetPropertyName();
        this._firstAbsoluteUpdate = !1;
        this._target = this._saveState = null
    }
    Release() {
        this._target = this._saveState = this._worldInfo = this._propertyTrack = this._sourceAdapter = null
    }
    MayNeedBeforeAndAfterInterpolate() {
        return !1
    }
    TimelineRemoved() {}
    CleanCaches() {
        this._target =
            this._saveState = this._worldInfo = null
    }
    GetSourceAdapter() {
        return this._sourceAdapter
    }
    GetPropertyTrack() {
        return this._propertyTrack
    }
    GetWorldInfo() {
        return this._worldInfo ? this._worldInfo : this._worldInfo = this._propertyTrack.GetTrack().GetWorldInfo()
    }
    SetFirstAbsoluteUpdate(e) {
        this._firstAbsoluteUpdate = !!e
    }
    GetFirstAbsoluteUpdate() {
        return this._firstAbsoluteUpdate
    }
    SetInitialState() {}
    SetResumeState() {}
    SetSaveState() {
        this._saveState = this.GetCurrentState()
    }
    ClearSaveState() {
        this._saveState = null
    }
    GetCurrentState() {}
    CompareInitialStateWithCurrent() {}
    CompareSaveStateWithCurrent() {}
    CanChange(e) {
        return typeof this._Getter() ===
            typeof e
    }
    BeforeChangeProperty() {}
    ChangeProperty(e, a, b, d, c) {}
    AfterChangeProperty() {}
    _FirstKeyframeGetter() {
        return this._PickTimelinePlaybackMode(() => {
            const e = this._propertyTrack.GetPropertyTrackDataItem();
            return this._propertyTrack.GetPropertyTrackData().GetFirstPropertyKeyframeDataItem(e)
        }, () => {
            const e = this._propertyTrack.GetPropertyTrackDataItem();
            return this._propertyTrack.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(e)
        }).GetAbsoluteValue()
    }
    _CurrentKeyframeGetter() {
        const e = this._propertyTrack.GetTimeline().GetTime() -
            this._propertyTrack.GetTrack().GetStartOffset();
        return this._PickTimelinePlaybackMode(() => {
            const a = this._propertyTrack.GetPropertyTrackDataItem();
            return this._propertyTrack.GetPropertyTrackData().GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, a)
        }, () => {
            const a = this._propertyTrack.GetPropertyTrackDataItem(),
                b = this._propertyTrack.GetPropertyTrackData(),
                d = b.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(e, a);
            return d ? d : b.GetLastPropertyKeyframeDataItem(a)
        }).GetAbsoluteValue()
    }
    _PickTimelinePlaybackMode(e,
        a) {
        return this._propertyTrack.GetTimeline().IsForwardPlayBack() ? e() : a()
    }
    _PickResultMode(e, a) {
        return "relative" === this._propertyTrack.GetResultMode() ? e() : a()
    }
    _PickFirstAbsoluteUpdate(e, a) {
        return this.GetFirstAbsoluteUpdate() ? (this.SetFirstAbsoluteUpdate(!1), e()) : a()
    }
    _GetAbsoluteInitialValue(e) {}
    _GetIndex() {
        return this._sourceAdapter.GetIndex()
    }
    _GetTarget() {
        return this._target ? this._target : this._target = this._sourceAdapter.GetTarget()
    }
    _PickSource(e, a, b, d, c, f) {
        switch (this._propertyTrack.GetSourceAdapterId()) {
            case "behavior":
                return e();
            case "effect":
                return a();
            case "instance-variable":
                return b();
            case "plugin":
                return d();
            case "world-instance":
                return c();
            case "audio":
                return f()
        }
    }
    _SaveToJson() {
        return {
            firstAbsoluteUpdate: this._firstAbsoluteUpdate,
            saveState: this._saveState
        }
    }
    _LoadFromJson(e) {
        e && (this._firstAbsoluteUpdate = e.firstAbsoluteUpdate, this._saveState = e.saveState)
    }
    _GetPropertyKeyframeStubs(e, a = !1) {
        const b = [];
        for (const d of e) {
            e = d.GetTrack().GetStartOffset();
            for (const c of d.GetPropertyKeyframeDataItems()) a && 0 === c.GetTime() ? b.push({
                time: e +
                    c.GetTime(),
                value: c.GetAbsoluteValue()
            }) : a || b.push({
                time: e + c.GetTime(),
                value: c.GetAbsoluteValue()
            })
        }
        return b.sort((d, c) => d.time - c.time)
    }
    _GetLastPropertyKeyframeStub(e, a, b) {
        return this._GetPropertyKeyframeStubLowerThanPlayhead(a, b)
    }
    _GetPropertyKeyframeStubLowerThanPlayhead(e, a) {
        for (let b = a.length - 1; 0 <= b; b--)
            if (a[b].time <= e) return a[b];
        return null
    }
}; {
    "use strict";
    const e = self.C3,
        a = new Map,
        b = [0, 0, 0];
    class d extends e.PropertyTrackState.PropertyInterpolationAdapter {
        constructor(c) {
            super(c)
        }
        SetInitialState() {}
        SetResumeState() {}
        GetCurrentState() {
            const c = this._propertyTrack.GetSourceAdapterId(),
                f = this._GetTarget(),
                k = this._GetIndex();
            switch (c) {
                case "behavior":
                    return this._ToColorArray(f.GetPropertyValueByIndex(k));
                case "effect":
                    return this._ToColorArray(f[k]);
                case "plugin":
                    return this._ToColorArray(f.GetPropertyValueByIndex(k));
                case "world-instance":
                    return this._ToColorArray(this._Getter())
            }
        }
        CompareInitialStateWithCurrent() {
            const c =
                this._FirstKeyframeGetter();
            return !this._CompareColors(c, this._Getter())
        }
        CompareSaveStateWithCurrent() {
            return e.IsNullOrUndefined(this._saveState) ? !1 : !this._CompareColors(this._saveState, this._Getter())
        }
        _CompareColors(c, f) {
            return c.equalsIgnoringAlpha(f)
        }
        _FirstKeyframeGetter() {
            const c = super._FirstKeyframeGetter();
            return this._GetColorFromArray(c)
        }
        _CurrentKeyframeGetter() {
            const c = super._CurrentKeyframeGetter();
            return this._GetColorFromArray(c)
        }
        _GetAbsoluteInitialValue(c) {}
        _ToColorArray(c) {
            return e.IsInstanceOf(c,
                e.Color) ? c.toArray().slice(0, 3) : c.slice(0, 3)
        }
        _GetColorFromArray(c) {
            return e.IsInstanceOf(c, e.Color) ? c : new e.Color(c[0], c[1], c[2], 1)
        }
        CanChange(c) {
            return !0
        }
        MayNeedBeforeAndAfterInterpolate() {
            return !0
        }
        BeforeChangeProperty() {
            var c = this._propertyTrack.GetTimeline(),
                f = this._propertyTrack.GetInstance();
            const k = this._propertyTrack.GetSourceAdapter();
            (c = c.GetSimilarPropertyTracks(f, k, this._property)) && 1 < c.length && (a.has(f) || a.set(f, new Map), f = a.get(f), c = this._propertyTrack.GetSourceAdapterId(), f.has(c) || f.set(c,
                new Map), f = f.get(c), f.has(this._property) || f.set(this._property, {
                used: !1,
                color: new e.Color(0, 0, 0, 1)
            }))
        }
        _GetTmpColor(c, f, k) {
            c = a.get(c).get(f).get(k);
            c.used = !0;
            return c.color
        }
        ChangeProperty(c, f, k, h, l) {
            l = this._propertyTrack.GetTimeline();
            h = this._propertyTrack.GetTrack();
            c = this._propertyTrack.GetInstance();
            var n = this._propertyTrack.GetSourceAdapter();
            k = this._propertyTrack.GetSourceAdapterId();
            if ((n = l.GetSimilarPropertyTracks(c, n, this._property)) && 1 < n.length) {
                if (n = this._GetPropertyKeyframeStubs(n, !0),
                    l = this._GetLastPropertyKeyframeStub(l, l.GetTime(), n)) h = h.GetStartOffset(), n = l.time - h, 0 === n ? this._GetTmpColor(c, k, this._property).addRgb(f[0], f[1], f[2]) : 0 > n || (l = f[0], h = f[1], f = f[2], n = this._propertyTrack.Interpolate(n, !1, !0), l = e.Color.DiffChannel(l, n[0]), h = e.Color.DiffChannel(h, n[1]), f = e.Color.DiffChannel(f, n[2]), this._GetTmpColor(c, k, this._property).addRgb(l, h, f))
            } else this._Setter(f[0], f[1], f[2])
        }
        AfterChangeProperty() {
            const c = this._propertyTrack.GetInstance();
            if (a.has(c)) {
                var f = a.get(c),
                    k = this._propertyTrack.GetSourceAdapterId();
                if (f.has(k)) {
                    var h = f.get(k);
                    if (h.has(this._property)) {
                        var l = h.get(this._property),
                            n = l.color;
                        l.used && this._Setter(n.getR(), n.getG(), n.getB());
                        0 === h.size && f.delete(k);
                        0 === f.size && a.delete(c)
                    }
                }
            }
        }
        _Getter() {
            const c = this._propertyTrack.GetSourceAdapterId(),
                f = this._GetTarget(),
                k = this._GetIndex();
            switch (c) {
                case "behavior":
                    return this._GetColorFromArray(f.GetPropertyValueByIndex(k));
                case "effect":
                    return f[k].clone();
                case "plugin":
                    return this._GetColorFromArray(f.GetPropertyValueByIndex(k));
                case "world-instance":
                    return this.GetWorldInfo().GetUnpremultipliedColor().clone()
            }
        }
        _Setter(c,
            f, k) {
            const h = this._propertyTrack.GetSourceAdapterId(),
                l = this._GetTarget(),
                n = this._GetIndex();
            switch (h) {
                case "behavior":
                    b[0] = c;
                    b[1] = f;
                    b[2] = k;
                    l.SetPropertyValueByIndex(n, b);
                    break;
                case "effect":
                    l[n].setRgb(c, f, k);
                    break;
                case "plugin":
                    b[0] = c;
                    b[1] = f;
                    b[2] = k;
                    l.SetPropertyValueByIndex(n, b);
                    break;
                case "world-instance":
                    this.GetWorldInfo().SetUnpremultipliedColorRGB(c, f, k)
            }
        }
        _SaveToJson() {}
        _LoadFromJson(c) {}
    }
    e.PropertyTrackState.PropertyInterpolationAdapter.ColorInterpolationAdapter = d
} {
    "use strict";
    const e = self.C3,
        a = e.PropertyTrackState;
    class b extends e.PropertyTrackState.PropertyInterpolationAdapter {
        constructor(d) {
            super(d)
        }
        SetInitialState() {}
        SetResumeState() {}
        GetCurrentState() {
            return this._Getter()
        }
        CompareInitialStateWithCurrent() {
            return this._FirstKeyframeGetter() !== this.GetCurrentState()
        }
        CompareSaveStateWithCurrent() {
            return e.IsNullOrUndefined(this._saveState) ? !1 : this._saveState !== this.GetCurrentState()
        }
        MayNeedBeforeAndAfterInterpolate() {
            return !1
        }
        ChangeProperty(d, c, f, k, h) {
            f =
                this._propertyTrack;
            const l = f.GetTrack();
            k = f.GetSourceAdapterId();
            h = f.GetTimeline();
            var n = l.GetInstance();
            const u = f.GetSourceAdapter();
            (n = h.GetSimilarPropertyTracks(n, u, this._property)) && 1 < n.length && (n = this._GetPropertyKeyframeStubs(n), d += l.GetStartOffset(), d = this._GetLastPropertyKeyframeStub(h, d, n)) && (c = d.value);
            switch (f.GetPropertyKeyframeType()) {
                case "numeric":
                    if (!a.NumericTypeAdapter.WillChange(this._GetIndex(), this._GetTarget(), c, k)) return;
                    break;
                case "angle":
                    if (!a.AngleTypeAdapter.WillChange(this._GetIndex(),
                            this._GetTarget(), c, k)) return;
                    break;
                case "boolean":
                    if (!a.BooleanTypeAdapter.WillChange(this._GetIndex(), this._GetTarget(), c, k)) return;
                    break;
                case "color":
                    if (!a.ColorTypeAdapter.WillChange(this._GetIndex(), this._GetTarget(), c, k)) return;
                    break;
                case "text":
                    if (!a.TextTypeAdapter.WillChange(this._GetIndex(), this._GetTarget(), c, k)) return
            }
            this._Setter(c)
        }
        _Getter() {
            const d = this._propertyTrack.GetSourceAdapterId(),
                c = this._GetTarget(),
                f = this._GetIndex();
            switch (d) {
                case "behavior":
                    return c.GetPropertyValueByIndex(f);
                case "effect":
                    return c[f];
                case "instance-variable":
                    return c.GetInstanceVariableValue(f);
                case "plugin":
                    return c.GetPropertyValueByIndex(f)
            }
        }
        _Setter(d) {
            const c = this._propertyTrack.GetSourceAdapterId(),
                f = this._GetTarget(),
                k = this._GetIndex();
            switch (c) {
                case "behavior":
                    f.SetPropertyValueByIndex(k, d);
                    break;
                case "effect":
                    f[k] = d;
                    break;
                case "instance-variable":
                    f.SetInstanceVariableValue(k, d);
                    break;
                case "plugin":
                    f.SetPropertyValueByIndex(k, d)
            }
        }
    }
    e.PropertyTrackState.PropertyInterpolationAdapter.NoInterpolationAdapter =
        b
} {
    "use strict";
    const e = self.C3,
        a = new Map,
        b = (c, f, k, h, l) => a.set(c, {
            setter: f,
            absolute_setter: k,
            getter: h,
            round: l
        });
    b("offsetX", (c, f) => c.OffsetX(f), (c, f) => c.SetX(f), c => c.GetX(), !0);
    b("offsetY", (c, f) => c.OffsetY(f), (c, f) => c.SetY(f), c => c.GetY(), !0);
    b("offsetWidth", (c, f) => c.OffsetWidth(f), (c, f) => c.SetWidth(f), c => c.GetWidth(), !0);
    b("offsetHeight", (c, f) => c.OffsetHeight(f), (c, f) => c.SetHeight(f), c => c.GetHeight(), !0);
    b("offsetAngle", (c, f) => c.OffsetAngle(f), (c, f) => c.SetAngle(f), c => c.GetAngle(), !1);
    b("offsetOpacity", (c,
            f, k, h) => {
            k = c.GetOpacity() + f;
            0 === h._clampAccumulator ? (1 < k ? h._clampAccumulator += k - 1 : 0 > k && (h._clampAccumulator += k), c.OffsetOpacity(f)) : (c = c.GetOpacity() + f, 0 < f && 0 < h._clampAccumulator ? 1 < c && (h._clampAccumulator += c - 1) : 0 < f && 0 > h._clampAccumulator ? (h._clampAccumulator += f, 0 < h._clampAccumulator && (h._clampAccumulator = 0)) : 0 > f && 0 < h._clampAccumulator ? (h._clampAccumulator += f, 0 > h._clampAccumulator && (h._clampAccumulator = 0)) : 0 > f && 0 > h._clampAccumulator && 0 > c && (h._clampAccumulator += c))
        }, (c, f) => {
            c.SetOpacity(f)
        }, c => c.GetOpacity(),
        !1);
    b("offsetOriginX", (c, f) => c.OffsetOriginX(f), (c, f) => c.SetOriginX(f), c => c.GetOriginX(), !1);
    b("offsetOriginY", (c, f) => c.OffsetOriginY(f), (c, f) => c.SetOriginY(f), c => c.GetOriginY(), !1);
    b("offsetZElevation", (c, f) => c.OffsetZElevation(f), (c, f) => c.SetZElevation(f), c => c.GetZElevation(), !0);
    b("offsetScaleX", (c, f, k, h) => {
        h = 0 > c.GetWidth() ? -1 : 1;
        c.GetTransformWithParentWidth();
        c.OffsetWidth(k.GetOriginalWidth() * h * f)
    }, (c, f, k) => {
        c.SetWidth(k.GetOriginalWidth() * f)
    }, (c, f) => {
        const k = 0 > c.GetWidth() ? -1 : 1;
        if (c.GetTransformWithParentWidth()) {
            var h =
                c.GetParent(),
                l = f.GetTimeline().GetTrackFromInstance(h.GetInstance());
            l ? h = h.GetWidth() / l.GetOriginalWidth() : (l = h.GetInstance().GetSdkInstance(), h = l.IsOriginalSizeKnown() ? h.GetWidth() / l.GetOriginalWidth() : 1);
            return c.GetWidth() * k / (f.GetOriginalWidth() * h)
        }
        return c.GetWidth() * k / f.GetOriginalWidth()
    }, !1);
    b("offsetScaleY", (c, f, k, h) => {
        h = 0 > c.GetHeight() ? -1 : 1;
        c.GetTransformWithParentHeight();
        c.OffsetHeight(k.GetOriginalHeight() * h * f)
    }, (c, f, k) => {
        c.SetHeight(k.GetOriginalHeight() * f)
    }, (c, f) => {
        const k = 0 > c.GetHeight() ?
            -1 : 1;
        if (c.GetTransformWithParentHeight()) {
            var h = c.GetParent(),
                l = f.GetTimeline().GetTrackFromInstance(h.GetInstance());
            l ? h = h.GetHeight() / l.GetOriginalHeight() : (l = h.GetInstance().GetSdkInstance(), h = l.IsOriginalSizeKnown() ? h.GetHeight() / l.GetOriginalHeight() : 1);
            return c.GetHeight() * k / (f.GetOriginalHeight() * h)
        }
        return c.GetHeight() * k / f.GetOriginalHeight()
    }, !1);
    class d extends e.PropertyTrackState.PropertyInterpolationAdapter {
        constructor(c) {
            super(c);
            this._clampAccumulator = this._lastValue = 0;
            this._source_adapter_absolute_setter =
                this._source_adapter_setter = this._source_adapter_getter = this._instance_absolute_setter = this._instance_setter = this._instance_getter = null;
            this._round = !1;
            e.IsInstanceOf(this._propertyTrack.GetTimeline(), e.TweenState) ? this._typeAdapter = new e.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTween(this) : this._typeAdapter = new e.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTimeline(this);
            const f = this._propertyTrack.GetPropertyName();
            switch (this._propertyTrack.GetSourceAdapterId()) {
                case "world-instance":
                    c =
                        a.get(f);
                    this._instance_getter = c.getter;
                    this._instance_setter = c.setter;
                    this._instance_absolute_setter = c.absolute_setter;
                    this._round = c.round;
                    break;
                case "audio":
                    this._source_adapter_getter = c.Getter, this._source_adapter_setter = c.Setter, this._source_adapter_absolute_setter = c.AbsoluteSetter, this._round = !!c.DoesRounding()
            }
        }
        Release() {
            this._instance_absolute_setter = this._instance_setter = this._instance_getter = this._typeAdapter = null;
            super.Release()
        }
        MayNeedBeforeAndAfterInterpolate() {
            return this._typeAdapter.MayNeedBeforeAndAfterInterpolate()
        }
        GetLastValue() {
            return this._lastValue
        }
        SetLastValue(c) {
            this._lastValue =
                c
        }
        SetInitialState() {
            const c = this._typeAdapter.SetInitialState();
            "number" === typeof c && (this._lastValue = c);
            this._clampAccumulator = 0
        }
        SetResumeState() {
            const c = this._typeAdapter.SetResumeState();
            "number" === typeof c && (this._lastValue = c)
        }
        GetCurrentState() {
            return this._Getter()
        }
        CompareInitialStateWithCurrent() {
            return this._FirstKeyframeGetter() !== this.GetCurrentState()
        }
        CompareSaveStateWithCurrent() {
            return e.IsNullOrUndefined(this._saveState) ? !1 : this._saveState !== this.GetCurrentState()
        }
        BeforeChangeProperty() {
            this._typeAdapter.BeforeChangeProperty()
        }
        ChangeProperty(c,
            f, k, h, l, n, u) {
            return this._typeAdapter.ChangeProperty(c, f, k, h, l, n, u)
        }
        AfterChangeProperty() {
            this._typeAdapter.AfterChangeProperty()
        }
        _Getter() {
            const c = this._GetTarget(),
                f = this._GetIndex(),
                k = this.GetWorldInfo(),
                h = this._propertyTrack.GetTrack();
            switch (this._propertyTrack.GetSourceAdapterId()) {
                case "behavior":
                    return c.GetPropertyValueByIndex(f);
                case "effect":
                    return c[f];
                case "instance-variable":
                    return c.GetInstanceVariableValue(f);
                case "plugin":
                    return c.GetPropertyValueByIndex(f);
                case "world-instance":
                    return this._instance_getter(k,
                        h);
                case "audio":
                    return this._source_adapter_getter.call(this.GetSourceAdapter(), k, h)
            }
        }
        _Setter(c, f, k) {
            f = this._GetTarget();
            k = this._GetIndex();
            const h = this.GetWorldInfo(),
                l = this._propertyTrack.GetTrack();
            switch (this._propertyTrack.GetSourceAdapterId()) {
                case "behavior":
                    f.OffsetPropertyValueByIndex(k, c);
                    break;
                case "effect":
                    f[k] += c;
                    break;
                case "instance-variable":
                    f.SetInstanceVariableOffset(k, c);
                    break;
                case "plugin":
                    f.OffsetPropertyValueByIndex(k, c);
                    break;
                case "world-instance":
                    this._instance_setter(h, c, l,
                        this);
                    break;
                case "audio":
                    this._source_adapter_setter.call(this.GetSourceAdapter(), h, c, l, this)
            }
        }
        _SetterAbsolute(c, f, k) {
            f = this._GetTarget();
            k = this._GetIndex();
            const h = this.GetWorldInfo(),
                l = this._propertyTrack.GetTrack();
            switch (this._propertyTrack.GetSourceAdapterId()) {
                case "behavior":
                    f.SetPropertyValueByIndex(k, c);
                    break;
                case "effect":
                    f[k] = c;
                    break;
                case "instance-variable":
                    f.SetInstanceVariableValue(k, c);
                    break;
                case "plugin":
                    f.SetPropertyValueByIndex(k, c);
                    break;
                case "world-instance":
                    this._instance_absolute_setter(h,
                        c, l);
                    break;
                case "audio":
                    this._source_adapter_absolute_setter.call(this.GetSourceAdapter(), h, c, l)
            }
        }
        _MaybeEnsureValue(c, f, k, h, l, n) {
            this._typeAdapter._MaybeEnsureValue(c, f, k, h, l, n)
        }
        _AddDelta(c, f, k) {
            var h = (c.toString().split(".")[1] || "").length;
            c = this._Getter();
            h = 0 === h ? this._round ? Math.round(c) : c : e.toFixed(c, h);
            this._Setter(h - c, f, k)
        }
        _SaveToJson() {
            return Object.assign(super._SaveToJson(), {
                v: this._lastValue,
                a: this._clampAccumulator
            })
        }
        _LoadFromJson(c) {
            c && (super._LoadFromJson(c), this._lastValue = c.v, this._clampAccumulator =
                c.a)
        }
    }
    e.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapter = d
} {
    "use strict";
    class e {
        constructor(b) {
            this._used = !1;
            this._value = 0;
            this._propertyTracks = b;
            for (let d = 0, c = this._propertyTracks.length; d < c; d++) this._propertyTracks[d].SetAbsoluteValueObject(this)
        }
        GetPropertyTracks() {
            return this._propertyTracks
        }
        SetUsed() {
            this._used = !0
        }
        GetUsed() {
            return this._used
        }
        SetValue(b) {
            this._value = b
        }
        GetValue() {
            return this._value
        }
        Reset() {
            this._used = !1;
            this._value = 0
        }
    }
    class a {
        constructor(b) {
            this._numericInterpolationAdapter = b
        }
        Release() {
            this._numericInterpolationAdapter = null
        }
        SetInitialState() {
            const b =
                this._numericInterpolationAdapter;
            this._numericInterpolationAdapter.GetPropertyTrack();
            return b._PickResultMode(() => b._PickTimelinePlaybackMode(() => 0, () => b.GetSourceAdapter().GetValueAtTime()), () => {})
        }
        SetResumeState() {}
        MayNeedBeforeAndAfterInterpolate() {
            switch (this._numericInterpolationAdapter.GetPropertyTrack().GetResultMode()) {
                case "relative":
                    return !1;
                case "absolute":
                    return !0
            }
        }
        BeforeChangeProperty() {
            var b = this._numericInterpolationAdapter.GetPropertyTrack(),
                d = b.GetPropertyName();
            switch (b.GetResultMode()) {
                case "absolute":
                    if (b.HasAbsoluteValueObject()) b.GetAbsoluteValueObject().Reset();
                    else {
                        const c = b.GetTimeline(),
                            f = b.GetInstance();
                        b = b.GetSourceAdapter();
                        (d = c.GetSimilarPropertyTracks(f, b, d)) && 1 < d.length && new e(d)
                    }
            }
        }
        ChangeProperty(b, d, c, f, k, h) {
            var l = this._numericInterpolationAdapter,
                n = this._numericInterpolationAdapter.GetPropertyTrack();
            switch (n.GetResultMode()) {
                case "relative":
                    n = l.GetLastValue();
                    l._Setter(d - n, c, f);
                    h && this._MaybeEnsureValue(b, c, f, k, n, d);
                    l.SetLastValue(d);
                    break;
                case "absolute":
                    if (f = n.GetTimeline(), c = n.GetTrack(), n.GetInstance(), n.GetSourceAdapter(), n.HasAbsoluteValueObject()) {
                        if (b =
                            n.GetAbsoluteValueObject(), k = b.GetPropertyTracks(), k = l._GetPropertyKeyframeStubs(k, !0), l = l._GetLastPropertyKeyframeStub(f, f.GetTime(), k)) c = c.GetStartOffset(), l = l.time - c, 0 === l ? (b.SetUsed(), b.SetValue(b.GetValue() + d)) : 0 > l || (n = n.GetInterpolatedValue(l), b.SetUsed(), b.SetValue(b.GetValue() + (d - n)))
                    } else l._SetterAbsolute(d)
            }
        }
        AfterChangeProperty() {
            const b = this._numericInterpolationAdapter;
            var d = this._numericInterpolationAdapter.GetPropertyTrack();
            switch (d.GetResultMode()) {
                case "absolute":
                    d.HasAbsoluteValueObject() &&
                        (d = d.GetAbsoluteValueObject(), d.GetUsed() && b._SetterAbsolute(d.GetValue()))
            }
        }
        _MaybeEnsureValue(b, d, c, f, k, h) {
            const l = this._numericInterpolationAdapter;
            f || (d && b === d.GetTime() ? l._AddDelta(d.GetValueWithResultMode(), d, c) : c && b === c.GetTime() ? l._AddDelta(c.GetValueWithResultMode(), d, c) : 0 === h - k && l._AddDelta(d.GetValueWithResultMode(), d, c))
        }
    }
    self.C3.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTimeline = a
} {
    "use strict";
    class e {
        constructor(a) {
            this._numericInterpolationAdapter = a
        }
        Release() {
            this._numericInterpolationAdapter = null
        }
        SetInitialState() {
            const a = this._numericInterpolationAdapter;
            a.SetFirstAbsoluteUpdate(!0);
            return this._GetAbsoluteInitialValue(a._FirstKeyframeGetter())
        }
        SetResumeState() {
            const a = this._numericInterpolationAdapter;
            if (a._FirstKeyframeGetter() !== a._CurrentKeyframeGetter()) return a.SetFirstAbsoluteUpdate(!0), this._GetAbsoluteInitialValue(a._CurrentKeyframeGetter())
        }
        MayNeedBeforeAndAfterInterpolate() {
            return !1
        }
        BeforeChangeProperty() {}
        ChangeProperty(a,
            b, d, c, f, k) {
            const h = this._numericInterpolationAdapter,
                l = h.GetLastValue();
            switch (h.GetPropertyTrack().GetResultMode()) {
                case "relative":
                    h._Setter(b - l, d, c);
                    k && this._MaybeEnsureValue(a, d, c, f, l, b);
                    break;
                case "absolute":
                    h.GetFirstAbsoluteUpdate() ? (h.SetFirstAbsoluteUpdate(!1), h._Setter(l, d, c)) : (h._Setter(b - l, d, c), k && this._MaybeEnsureValue(a, d, c, f, l, b))
            }
            h.SetLastValue(b)
        }
        AfterChangeProperty() {}
        _GetAbsoluteInitialValue(a) {
            return a - this._numericInterpolationAdapter.GetCurrentState()
        }
        _MaybeEnsureValue(a, b, d,
            c, f, k) {
            const h = this._numericInterpolationAdapter;
            c ? b && a === b.GetTime() ? h._AddDelta(b.GetValueWithResultMode(), b, d) : d && a === d.GetTime() ? h._AddDelta(d.GetValueWithResultMode(), b, d) : d || h._AddDelta(b.GetValueWithResultMode(), b, d) : b && a === b.GetTime() ? h._AddDelta(b.GetValueWithResultMode(), b, d) : d && a === d.GetTime() ? h._AddDelta(d.GetValueWithResultMode(), b, d) : 0 === k - f && h._AddDelta(b.GetValueWithResultMode(), b, d)
        }
    }
    self.C3.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTween = e
} {
    "use strict";
    const e = self.C3,
        a = self.Ease;
    e.PropertyTrackState.NumericTypeAdapter = class {
        constructor() {}
        static WillChange(b, d, c, f) {
            let k;
            switch (f) {
                case "behavior":
                    k = d.GetPropertyValueByIndex(b);
                    break;
                case "effect":
                    k = d[b];
                    break;
                case "instance-variable":
                    k = d.GetInstanceVariableValue(b);
                    break;
                case "plugin":
                    k = d.GetPropertyValueByIndex(b)
            }
            return k === c ? !1 : !0
        }
        static Interpolate(b, d, c, f) {
            if (!c) return c = f.GetPropertyTrackDataItem(), c = f.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(c), c.GetValueWithResultMode();
            var k = f.GetInterpolationMode();
            "default" === k && (k = "continuous");
            "combo" === f.GetPropertyType() && (k = "discrete");
            if ("discrete" === k) return d.GetValueWithResultMode();
            if ("continuous" === k || "step" === k) {
                "step" === k && (k = f.GetTimeline().GetStep(), 0 !== k && (k = 1 / k, b = Math.floor(b * k) / k));
                var h = d.GetTime();
                const l = c.GetTime();
                k = d.GetValueWithResultMode();
                const n = c.GetValueWithResultMode();
                if (k === n) return k;
                b = e.normalize(b, h, l);
                const u = d.GetEase();
                d = d.GetAddOn("cubic-bezier");
                c = c.GetAddOn("cubic-bezier");
                d && d.GetStartEnable() &&
                    c && c.GetEndEnable() ? (h = l - h, h = a.GetRuntimeEase(u)(h * b, 0, 1, h), h = a.GetRuntimeEase("cubicbezier")(h, k, k + d.GetStartAnchor(), n + c.GetEndAnchor(), n)) : h = a.GetRuntimeEase(u)((l - h) * b, k, n - k, l - h);
                return "integer" === f.GetPropertyType() ? Math.floor(h) : h
            }
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.PropertyTrackState.AngleTypeAdapter = class {
        constructor() {}
        static WillChange(a, b, d, c) {
            let f;
            switch (c) {
                case "behavior":
                    f = b.GetPropertyValueByIndex(a);
                    break;
                case "effect":
                    f = b[a];
                    break;
                case "instance-variable":
                    f = b.GetInstanceVariableValue(a);
                    break;
                case "plugin":
                    f = b.GetPropertyValueByIndex(a)
            }
            return f === d ? !1 : !0
        }
        static Interpolate(a, b, d, c) {
            if (!d) return b = c.GetPropertyTrackDataItem(), b = c.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(b), b.GetValueWithResultMode();
            var f =
                c.GetInterpolationMode();
            "default" === f && (f = "continuous");
            "combo" === c.GetPropertyType() && (f = "discrete");
            if ("discrete" === f) return b.GetValueWithResultMode();
            if ("continuous" === f || "step" === f) {
                "step" === f && (c = c.GetTimeline().GetStep(), 0 !== c && (c = 1 / c, a = Math.floor(a * c) / c));
                const k = b.GetTime(),
                    h = d.GetTime();
                c = b.GetValueWithResultMode();
                d = d.GetValueWithResultMode();
                if (f = b.GetAddOn("angle")) {
                    const l = f.GetRevolutions();
                    if (c === d && 0 === l) return c;
                    a = e.normalize(a, k, h);
                    b = self.Ease.GetRuntimeEase(b.GetEase())(a, 0, 1,
                        1);
                    switch (f.GetDirection()) {
                        case "closest":
                            return e.angleLerp(c, d, b, l);
                        case "clockwise":
                            return e.angleLerpClockwise(c, d, b, l);
                        case "anti-clockwise":
                            return e.angleLerpAntiClockwise(c, d, b, l)
                    }
                } else {
                    if (c === d) return c;
                    a = e.normalize(a, k, h);
                    b = self.Ease.GetRuntimeEase(b.GetEase());
                    return e.angleLerp(c, d, b(a, 0, 1, 1))
                }
            }
        }
    }
}
"use strict";
self.C3.PropertyTrackState.BooleanTypeAdapter = class {
    constructor() {}
    static WillChange(e, a, b, d) {
        let c;
        switch (d) {
            case "behavior":
                c = a.GetPropertyValueByIndex(e);
                break;
            case "effect":
                c = a[e];
                break;
            case "instance-variable":
                c = a.GetInstanceVariableValue(e);
                break;
            case "plugin":
                c = a.GetPropertyValueByIndex(e)
        }
        return !!c === !!b ? !1 : !0
    }
    static Interpolate(e, a, b, d) {
        return b ? a.GetValueWithResultMode() ? 1 : 0 : (e = d.GetPropertyTrackDataItem(), e = d.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(e), e.GetValueWithResultMode() ?
            1 : 0)
    }
}; {
    "use strict";
    const e = self.C3,
        a = [0, 0, 0],
        b = [0, 0, 0],
        d = [0, 0, 0];
    e.PropertyTrackState.ColorTypeAdapter = class {
        constructor() {}
        static WillChange(c, f, k, h) {
            let l;
            switch (h) {
                case "behavior":
                    l = f.GetPropertyValueByIndex(c);
                    break;
                case "effect":
                    l = f[c];
                    break;
                case "instance-variable":
                    l = f.GetInstanceVariableValue(c);
                    break;
                case "plugin":
                    l = f.GetPropertyValueByIndex(c)
            }
            Array.isArray(k) ? (a[0] = k[0], a[1] = k[1], a[2] = k[2]) : (d.parseCommaSeparatedRgb(k), a[0] = Math.floor(255 * d.getR()), a[1] = Math.floor(255 * d.getG()), a[2] = Math.floor(255 * d.getB()));
            Array.isArray(l) ? (b[0] = l[0], b[1] = l[1], b[2] = l[2]) : (d.parseCommaSeparatedRgb(l), b[0] = Math.floor(255 * d.getR()), b[1] = Math.floor(255 * d.getG()), b[2] = Math.floor(255 * d.getB()));
            return a[0] !== b[0] || a[1] !== b[1] || a[2] !== b[2] ? !0 : !1
        }
        static Interpolate(c, f, k, h) {
            if (!k) {
                var l = h.GetPropertyTrackDataItem();
                l = h.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(l);
                h = l.GetValueWithResultMode();
                a[0] = h[0];
                a[1] = h[1];
                a[2] = h[2];
                return a
            }
            l = h.GetInterpolationMode();
            "default" === l && (l = "continuous");
            if ("discrete" === l) return h =
                f.GetValueWithResultMode(), a[0] = h[0], a[1] = h[1], a[2] = h[2], a;
            if ("continuous" === l || "step" === l) {
                "step" === l && (h = h.GetTimeline().GetStep(), 0 !== h && (h = 1 / h, c = Math.floor(c * h) / h));
                h = f.GetTime();
                l = k.GetTime();
                var n = f.GetValueWithResultMode(),
                    u = k.GetValueWithResultMode();
                c = e.normalize(c, h, l);
                var w = f.GetEase();
                f = n[0];
                k = n[1];
                n = n[2];
                const q = u[0],
                    t = u[1];
                u = u[2];
                w = self.Ease.GetRuntimeEase(w);
                h = l - h;
                l = h * c;
                a[0] = f === q ? f : w(l, f, q - f, h);
                a[1] = k === t ? k : w(l, k, t - k, h);
                a[2] = n === u ? n : w(l, n, u - n, h);
                return a
            }
        }
    }
}
"use strict";
self.C3.PropertyTrackState.TextTypeAdapter = class {
    constructor() {}
    static WillChange(e, a, b, d) {
        let c;
        switch (d) {
            case "behavior":
                c = a.GetPropertyValueByIndex(e);
                break;
            case "effect":
                c = a[e];
                break;
            case "instance-variable":
                c = a.GetInstanceVariableValue(e);
                break;
            case "plugin":
                c = a.GetPropertyValueByIndex(e)
        }
        return c === b ? !1 : !0
    }
    static Interpolate(e, a, b, d) {
        return b ? a.GetValueWithResultMode() : (e = d.GetPropertyTrackDataItem(), e = d.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(e), e.GetValueWithResultMode())
    }
}; {
    "use strict";
    const e = self.C3;
    e.TimelineDataManager = class {
        constructor() {
            this._timelineDataItems = new Map
        }
        Release() {
            for (const a of this._timelineDataItems.values()) a.Release();
            this._timelineDataItems.clear();
            this._timelineDataItems = null
        }
        Add(a) {
            a = new e.TimelineDataItem(a);
            const b = a.GetName();
            this._timelineDataItems.set(b, a)
        }
        Get(a) {
            return this._timelineDataItems.get(a)
        }
        GetNameId() {
            return 0
        }
        static _CreateDataItems(a, b, d, c) {
            if (b)
                for (const f of b) e.TimelineDataManager._CreateDataItem("create", f, a, d, c)
        }
        static _LoadDataItemsFromJson(a,
            b, d, c) {
            a.length ? b.forEach((f, k) => {
                a[k]._LoadFromJson(f)
            }) : b.forEach(f => {
                e.TimelineDataManager._CreateDataItem("load", f, a, d, c)
            })
        }
        static _CreateDataItem(a, b, d, c, f) {
            let k;
            if ("function" === typeof c) switch (a) {
                case "load":
                    k = new c(null, f);
                    break;
                case "create":
                    k = new c(b, f)
            } else if ("object" === typeof c) switch (c = c.map.get(b[c.prop]), a) {
                case "load":
                    k = new c(null, f);
                    break;
                case "create":
                    k = new c(b, f)
            }
            switch (a) {
                case "load":
                    k._LoadFromJson(b);
                    d.push(k);
                    break;
                case "create":
                    if ("function" === typeof k.GetEnable && !k.GetEnable()) return k.Release();
                    d.push(k)
            }
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.TimelineDataItem = class {
        constructor(a) {
            this._name = "";
            this._totalTime = NaN;
            this._step = 0;
            this._resultMode = this._interpolationMode = "default";
            this._pingPong = this._loop = !1;
            this._repeatCount = 1;
            this._trackData = null;
            a && (this._name = a[0], this._totalTime = a[1], this._step = a[2], this._interpolationMode = a[3], this._resultMode = a[4], this._loop = !!a[6], this._pingPong = !!a[7], this._repeatCount = a[8], this._trackData = new e.TrackData(a[5], this))
        }
        Release() {
            this._trackData.Release();
            this._trackData =
                null
        }
        GetTrackData() {
            this._trackData || (this._trackData = new e.TrackData(null, this));
            return this._trackData
        }
        GetName() {
            return this._name
        }
        SetName(a) {
            this._name = a
        }
        GetTotalTime() {
            return this._totalTime
        }
        SetTotalTime(a) {
            this._totalTime = a
        }
        GetStep() {
            return this._step
        }
        SetStep(a) {
            this._step = a
        }
        GetInterpolationMode() {
            return this._interpolationMode
        }
        SetInterpolationMode(a) {
            this._interpolationMode = a
        }
        GetResultMode() {
            return this._resultMode
        }
        SetResultMode(a) {
            this._resultMode = a
        }
        GetLoop() {
            return this._loop
        }
        SetLoop(a) {
            this._loop =
                a
        }
        GetPingPong() {
            return this._pingPong
        }
        SetPingPong(a) {
            this._pingPong = a
        }
        GetRepeatCount() {
            return this._repeatCount
        }
        _SaveToJson() {
            return {
                trackDataJson: this._trackData._SaveToJson(),
                name: this._name,
                totalTime: this._totalTime,
                step: this._step,
                interpolationMode: this._interpolationMode,
                resultMode: this._resultMode,
                loop: this._loop,
                pingPong: this._pingPong,
                repeatCount: this._repeatCount
            }
        }
        _LoadFromJson(a) {
            a && (this.GetTrackData()._LoadFromJson(a.trackDataJson), this._name = a.name, this._totalTime = a.totalTime, this._step =
                a.step, this._interpolationMode = a.interpolationMode, this._resultMode = a.resultMode, this._loop = a.loop, this._pingPong = a.pingPong, this._repeatCount = a.repeatCount)
        }
    }
} {
    "use strict";
    const e = self.C3;
    class a {
        constructor(b, d) {
            this._trackData = d;
            this._additionalInstanceData = this._instanceData = null;
            this._objectClassIndex = this._instanceUid = NaN;
            this._resultMode = this._interpolationMode = "default";
            this._enabled = !1;
            this._propertyTrackData = this._keyframeData = null;
            this._id = "";
            this._nestedData = null;
            this._startOffset = 0;
            this._localTotalTime = this._trackData.GetTimelineDataItem().GetTotalTime();
            this._type = 0;
            this._name = "";
            b && (b[0] && (this._instanceData = b[0], this._instanceUid = b[0][2],
                this._objectClassIndex = b[0][1]), this._interpolationMode = b[1], this._resultMode = b[2], this._enabled = !!b[3], b[6] && (this._id = b[6]), b[7] && (this._nestedData = b[7], this._startOffset = b[7][0], this._localTotalTime = b[7][1]), b[8] && (this._additionalInstanceData = b[8]), b[8] && (this._additionalInstanceData = b[8]), b[9] && (this._type = b[9]), b[10] && (this._name = b[10]), this._keyframeData = new e.KeyframeData(b[4], this), this._propertyTrackData = new e.PropertyTrackData(b[5], this))
        }
        Release() {
            this._trackData = this._instanceData = null;
            this._keyframeData && (this._keyframeData.Release(), this._keyframeData = null);
            this._propertyTrackData && (this._propertyTrackData.Release(), this._propertyTrackData = null);
            this._nestedData = null
        }
        GetTrackData() {
            return this._trackData
        }
        GetKeyframeData() {
            this._keyframeData || (this._keyframeData = new e.KeyframeData(null, this));
            return this._keyframeData
        }
        GetPropertyTrackData() {
            this._propertyTrackData || (this._propertyTrackData = new e.PropertyTrackData(null, this));
            return this._propertyTrackData
        }
        GetInstanceData() {
            return this._instanceData
        }
        GetObjectClassIndex() {
            return this._objectClassIndex
        }
        SetObjectClassIndex(b) {
            this._objectClassIndex =
                b
        }
        GetInstanceUID() {
            return this._instanceUid
        }
        SetInstanceUID(b) {
            this._instanceUid = b
        }
        GetInterpolationMode() {
            return this._interpolationMode
        }
        SetInterpolationMode(b) {
            this._interpolationMode = b
        }
        GetResultMode() {
            return this._resultMode
        }
        SetResultMode(b) {
            this._resultMode = b
        }
        GetEnable() {
            return this._enabled
        }
        SetEnable(b) {
            this._enabled = !!b
        }
        GetId() {
            return this._id
        }
        GetStartOffset() {
            return this._startOffset
        }
        GetLocalTotalTime() {
            return this._localTotalTime
        }
        SetLocalTotalTime(b) {
            this._localTotalTime = b
        }
        GetOriginalWidth() {
            return this._additionalInstanceData[0]
        }
        SetOriginalWidth(b) {
            this._additionalInstanceData ||
                (this._additionalInstanceData = []);
            this._additionalInstanceData[0] = b
        }
        GetOriginalHeight() {
            this._additionalInstanceData || (this._additionalInstanceData = []);
            return this._additionalInstanceData[1]
        }
        SetOriginalHeight(b) {
            this._additionalInstanceData || (this._additionalInstanceData = []);
            this._additionalInstanceData[1] = b
        }
        GetType() {
            return this._type
        }
        GetName() {
            return this._name
        }
        _SaveToJson() {
            return {
                keyframeDataJson: this._keyframeData._SaveToJson(),
                propertyTrackDataJson: this._propertyTrackData._SaveToJson(),
                instanceData: this._instanceData,
                additionalInstanceData: this._additionalInstanceData,
                instanceUid: this._instanceUid,
                objectClassIndex: this._objectClassIndex,
                interpolationMode: this._interpolationMode,
                resultMode: this._resultMode,
                enabled: this._enabled,
                id: this._id,
                nestedData: this._nestedData,
                type: this._type,
                name: this._name
            }
        }
        _LoadFromJson(b) {
            b && (this._instanceData = b.instanceData, this._instanceUid = b.instanceUid, this._objectClassIndex = b.objectClassIndex, this._interpolationMode = b.interpolationMode, this._resultMode = b.resultMode, this._enabled =
                b.enabled, this._id = b.id, this._type = b.type ? b.type : 0, this._name = b.name ? b.name : "", this._localTotalTime = this._trackData.GetTimelineDataItem().GetTotalTime(), b.nestedData && (this._nestedData = b.nestedData, this._startOffset = this._nestedData[0], this._localTotalTime = this._nestedData[1]), b.additionalInstanceData && (this._additionalInstanceData = b.additionalInstanceData), this.GetKeyframeData()._LoadFromJson(b.keyframeDataJson), this.GetPropertyTrackData()._LoadFromJson(b.propertyTrackDataJson))
        }
    }
    e.TrackData = class {
        constructor(b,
            d) {
            this._timelineDataItem = d;
            this._trackDataItems = [];
            e.TimelineDataManager._CreateDataItems(this._trackDataItems, b, a, this)
        }
        Release() {
            this._timelineDataItem = null;
            for (const b of this._trackDataItems) b.Release();
            e.clearArray(this._trackDataItems);
            this._trackDataItems = null
        }
        GetTimelineDataItem() {
            return this._timelineDataItem
        }
        AddEmptyTrackDataItem() {
            const b = new a(null, this);
            this._trackDataItems.push(b);
            return b
        }
        GetFirstKeyframeDataItem(b) {
            return b.GetKeyframeData().GetKeyframeDataItemArray()[0]
        }
        GetLastKeyframeDataItem(b) {
            return b.GetKeyframeData().GetKeyframeDataItemArray().at(-1)
        }
        GetKeyFrameDataItemAtTime(b,
            d) {
            d = d.GetKeyframeData().GetKeyframeDataItemArray();
            const c = d.length;
            for (let f = 0; f < c; f++) {
                const k = d[f];
                if (k.GetTime() === b) return k
            }
        }
        GetFirstKeyFrameDataItemHigherThan(b, d) {
            d = d.GetKeyframeData().GetKeyframeDataItemArray();
            const c = d.length;
            for (let f = 0; f < c; f++) {
                const k = d[f];
                if (k.GetTime() > b) return k
            }
        }
        GetFirstKeyFrameDataItemHigherOrEqualThan(b, d) {
            d = d.GetKeyframeData().GetKeyframeDataItemArray();
            const c = d.length;
            for (let f = 0; f < c; f++) {
                const k = d[f];
                if (k.GetTime() >= b) return k
            }
        }
        GetFirstKeyFrameDataItemLowerOrEqualThan(b,
            d) {
            d = d.GetKeyframeData().GetKeyframeDataItemArray();
            for (let c = d.length - 1; 0 <= c; c--) {
                const f = d[c];
                if (f.GetTime() <= b) return f
            }
        }* trackDataItems() {
            for (const b of this._trackDataItems) yield b
        }
        _SaveToJson() {
            return {
                trackDataItemsJson: this._trackDataItems.map(b => b._SaveToJson())
            }
        }
        _LoadFromJson(b) {
            b && e.TimelineDataManager._LoadDataItemsFromJson(this._trackDataItems, b.trackDataItemsJson, a, this)
        }
    }
} {
    "use strict";
    const e = self.C3;
    class a {
        constructor(b, d) {
            this._propertyTrackData = d;
            this._sourceAdapterId = "";
            this._type = this._property = this._sourceAdapterArguments = null;
            this._max = this._min = NaN;
            this._resultMode = this._interpolationMode = "default";
            this._enabled = !1;
            this._propertyKeyframeData = null;
            this._canHavePropertyKeyframes = !0;
            b && (this._sourceAdapterId = b[0][0], this._sourceAdapterArguments = b[0].slice(1), this._property = b[1], this._type = b[2], this._min = b[3], this._max = b[4], this._interpolationMode = b[5], this._resultMode =
                b[6], this._enabled = !!b[7], this._propertyKeyframeData = new e.PropertyKeyframeData(b[8], this), this._canHavePropertyKeyframes = b[9])
        }
        Release() {
            this._propertyKeyframeData.Release();
            this._sourceAdapterArguments = this._propertyTrackData = this._propertyKeyframeData = null
        }
        GetPropertyTrackData() {
            return this._propertyTrackData
        }
        GetPropertyKeyframeData() {
            this._propertyKeyframeData || (this._propertyKeyframeData = new e.PropertyKeyframeData(null, this));
            return this._propertyKeyframeData
        }
        GetSourceAdapterId() {
            return this._sourceAdapterId
        }
        SetSourceAdapterId(b) {
            this._sourceAdapterId =
                b
        }
        GetSourceAdapterArguments() {
            return this._sourceAdapterArguments
        }
        SetSourceAdapterArguments(b) {
            this._sourceAdapterArguments = b
        }
        GetProperty() {
            return this._property
        }
        SetProperty(b) {
            this._property = b
        }
        GetType() {
            return this._type
        }
        SetType(b) {
            this._type = b
        }
        GetMin() {
            return this._min
        }
        SetMin(b) {
            this._min = b
        }
        GetMax() {
            return this._max
        }
        SetMax(b) {
            this._max = b
        }
        GetInterpolationMode() {
            return this._interpolationMode
        }
        SetInterpolationMode(b) {
            this._interpolationMode = b
        }
        GetResultMode() {
            return this._resultMode
        }
        SetResultMode(b) {
            this._resultMode =
                b
        }
        GetEnable() {
            return this._enabled
        }
        SetEnable(b) {
            this._enabled = !!b
        }
        CanHavePropertyKeyframes() {
            return !!this._canHavePropertyKeyframes
        }
        _SaveToJson() {
            return {
                propertyKeyframeDataJson: this._propertyKeyframeData._SaveToJson(),
                sourceAdapterId: this._sourceAdapterId,
                sourceAdapterArguments: this._sourceAdapterArguments,
                property: this._property,
                type: this._type,
                min: this._min,
                max: this._max,
                interpolationMode: this._interpolationMode,
                resultMode: this._resultMode,
                enabled: this._enabled,
                canHavePropertyKeyframes: this._canHavePropertyKeyframes
            }
        }
        _LoadFromJson(b) {
            b &&
                (this._sourceAdapterId = b.sourceAdapterId, this._sourceAdapterArguments = b.sourceAdapterArguments, this._property = b.property, this._type = b.type, this._min = b.min, this._max = b.max, this._interpolationMode = b.interpolationMode, this._resultMode = b.resultMode, this._enabled = b.enabled, this._canHavePropertyKeyframes = b.canHavePropertyKeyframes, this.GetPropertyKeyframeData()._LoadFromJson(b.propertyKeyframeDataJson))
        }
    }
    e.PropertyTrackData = class {
        constructor(b, d) {
            this._trackDataItem = d;
            this._propertyTrackDataItems = [];
            e.TimelineDataManager._CreateDataItems(this._propertyTrackDataItems,
                b, a, this)
        }
        Release() {
            this._trackDataItem = null;
            for (const b of this._propertyTrackDataItems) b.Release();
            e.clearArray(this._propertyTrackDataItems);
            this._propertyTrackDataItems = null
        }
        GetTrackDataItem() {
            return this._trackDataItem
        }
        AddEmptyPropertyTrackDataItem() {
            const b = new a(null, this);
            this._propertyTrackDataItems.push(b);
            return b
        }
        GetFirstPropertyKeyframeDataItem(b) {
            return b.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray()[0]
        }
        GetLastPropertyKeyframeDataItem(b) {
            return b.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray().at(-1)
        }
        GetPropertyKeyFrameDataItemAtTime(b,
            d) {
            d = d.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray();
            const c = d.length;
            for (let f = 0; f < c; f++) {
                const k = d[f];
                if (k.GetTime() === b) return k
            }
        }
        GetFirstPropertyKeyFrameDataItemHigherThan(b, d) {
            d = d.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray();
            const c = d.length;
            for (let f = 0; f < c; f++) {
                const k = d[f];
                if (k.GetTime() > b) return k
            }
        }
        GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(b, d) {
            d = d.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray();
            const c = d.length;
            for (let f = 0; f < c; f++) {
                const k =
                    d[f];
                if (k.GetTime() >= b) return k
            }
        }
        GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(b, d) {
            d = d.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray();
            for (let c = d.length - 1; 0 <= c; c--) {
                const f = d[c];
                if (f.GetTime() <= b) return f
            }
        }* propertyTrackDataItems() {
            for (const b of this._propertyTrackDataItems) yield b
        }
        _SaveToJson() {
            return {
                propertyTrackDataItemsJson: this._propertyTrackDataItems.map(b => b._SaveToJson())
            }
        }
        _LoadFromJson(b) {
            b && e.TimelineDataManager._LoadDataItemsFromJson(this._propertyTrackDataItems, b.propertyTrackDataItemsJson,
                a, this)
        }
    }
} {
    "use strict";
    const e = self.C3;
    class a {
        constructor(b, d) {
            this._keyframeData = d;
            this._time = -1;
            this._ease = "noease";
            this._enable = !1;
            this._lowerTags = this._tags = null;
            b && (this._time = b[0], this._ease = b[1], this._enable = !!b[2], this._tags = (b = b[3]) ? b.split(" ") : [], this._lowerTags = new Set(this._tags.map(c => c.toLowerCase())), this._next = null)
        }
        Release() {
            this._keyframeData = null;
            e.clearArray(this._tags);
            this._tags = null;
            this._lowerTags.clear();
            this._lowerTags = null
        }
        GetKeyframeData() {
            return this._keyframeData
        }
        GetNext() {
            return this._next
        }
        SetNext(b) {
            this._next = b
        }
        GetTime() {
            return this._time
        }
        SetTime(b) {
            this._time =
                b;
            this._keyframeData._LinkKeyframeDataItems()
        }
        GetEase() {
            return this._ease
        }
        SetEase(b) {
            this._ease = b
        }
        GetEnable() {
            return this._enable
        }
        SetEnable(b) {
            this._enable = !!b
        }
        GetTags() {
            return this._tags
        }
        SetTags(b) {
            this._tags = b ? b.split(" ") : [];
            this._lowerTags = new Set(this._tags.map(d => d.toLowerCase()))
        }
        GetLowerTags() {
            return this._lowerTags
        }
        HasTag(b) {
            return this._lowerTags.has(b.toLowerCase())
        }
        _SaveToJson() {
            return {
                time: this._time,
                ease: this._ease,
                enable: this._enable,
                tags: this._tags
            }
        }
        _LoadFromJson(b) {
            b && (this._time =
                b.time, this._ease = b.ease, this._enable = b.enable, this._tags = b.tags, this._lowerTags = new Set(this._tags.map(d => d.toLowerCase())))
        }
    }
    e.KeyframeData = class {
        constructor(b, d) {
            this._trackDataItem = d;
            this._keyframeDataItems = [];
            e.TimelineDataManager._CreateDataItems(this._keyframeDataItems, b, a, this);
            this._LinkKeyframeDataItems()
        }
        Release() {
            this._trackDataItem = null;
            for (const b of this._keyframeDataItems) b.Release();
            e.clearArray(this._keyframeDataItems);
            this._keyframeDataItems = null
        }
        _LinkKeyframeDataItems() {
            this._keyframeDataItems.sort((b,
                d) => b.GetTime() - d.GetTime());
            for (let b = 0; b < this._keyframeDataItems.length; b++) this._keyframeDataItems[b].SetNext(this._keyframeDataItems[b + 1])
        }
        GetTrackDataItem() {
            return this._trackDataItem
        }
        GetKeyframeDataItemCount() {
            return this._keyframeDataItems.length
        }
        GetKeyframeDataItemArray() {
            return this._keyframeDataItems
        }
        AddEmptyKeyframeDataItem() {
            const b = new a(null, this);
            this._keyframeDataItems.push(b);
            this._LinkKeyframeDataItems();
            return b
        }
        DeleteKeyframeDataItems(b) {
            for (const d of this._keyframeDataItems) {
                if (!b(d)) continue;
                const c = this._keyframeDataItems.indexOf(d); - 1 !== c && (d.Release(), this._keyframeDataItems.splice(c, 1))
            }
            this.SortKeyframeDataItems();
            this._LinkKeyframeDataItems()
        }
        SortKeyframeDataItems() {
            this._keyframeDataItems.sort((b, d) => b.GetTime() - d.GetTime())
        }
        GetKeyframeDataItemIndex(b) {
            return this._keyframeDataItems.indexOf(b)
        }
        GetKeyframeDataItemFromIndex(b) {
            return this._keyframeDataItems[b]
        }* keyframeDataItems() {
            for (const b of this._keyframeDataItems) yield b
        }* keyframeDataItemsReverse() {
            for (let b = this._keyframeDataItems.length -
                    1; 0 <= b; b--) yield this._keyframeDataItems[b]
        }
        _SaveToJson() {
            return {
                keyframeDataItemsJson: this._keyframeDataItems.map(b => b._SaveToJson())
            }
        }
        _LoadFromJson(b) {
            b && (e.TimelineDataManager._LoadDataItemsFromJson(this._keyframeDataItems, b.keyframeDataItemsJson, a, this), this._LinkKeyframeDataItems())
        }
    }
} {
    "use strict";
    const e = self.C3;
    class a {
        constructor(b, d) {
            this._propertyKeyframeData = d;
            this._aValue = this._value = null;
            this._type = "";
            this._time = NaN;
            this._ease = "noease";
            this._enable = !1;
            this._addonData = null;
            this._addonInstance = void 0;
            b && (this._value = b[0][0], this._aValue = b[0][1], this._type = b[0][2], this._time = b[1], this._ease = b[2], this._enable = !!b[3], this._addonData = null, b[4] && (this._addonData = new e.AddonData(b[4], this)), this._next = null)
        }
        Release() {
            this._propertyKeyframeData = null;
            this._addonData && (this._addonData.Release(),
                this._addonData = null)
        }
        GetAddonData() {
            return this._addonData
        }
        SetNext(b) {
            this._next = b
        }
        GetNext() {
            return this._next
        }
        GetValue() {
            return this._value
        }
        SetValue(b) {
            "color" === this._type && e.IsFiniteNumber(b) ? (this._value[0] = e.GetRValue(b), this._value[1] = e.GetGValue(b), this._value[2] = e.GetBValue(b)) : this._value = b
        }
        GetAbsoluteValue() {
            return this._aValue
        }
        SetAbsoluteValue(b) {
            "color" === this._type && e.IsFiniteNumber(b) ? (this._aValue[0] = e.GetRValue(b), this._aValue[1] = e.GetGValue(b), this._aValue[2] = e.GetBValue(b)) : this._aValue =
                b
        }
        GetValueWithResultMode() {
            const b = this._propertyKeyframeData.GetPropertyTrackDataItem().GetResultMode();
            if ("relative" === b) return this.GetValue();
            if ("absolute" === b) return this.GetAbsoluteValue()
        }
        GetType() {
            return this._type
        }
        SetType(b) {
            this._type = b
        }
        GetTime() {
            return this._time
        }
        SetTime(b) {
            this._time = b;
            this._propertyKeyframeData._LinkPropertyKeyframeDataItems()
        }
        GetEase() {
            return this._ease
        }
        SetEase(b) {
            this._ease = b
        }
        GetEnable() {
            return this._enable
        }
        SetEnable(b) {
            this._enable = !!b
        }
        GetAddOn(b) {
            if (this._addonData) {
                if (this._addonInstance ||
                    null === this._addonInstance) return this._addonInstance;
                var d = this._addonData.GetAddDataItemArray();
                if (!d) return this._addonInstance = null;
                var c = d.length;
                for (let f = 0; f < c; f++) {
                    const k = d[f];
                    if (k.GetId() === b) return this._addonInstance = k
                }
                return this._addonInstance = null
            }
        }
        _SaveToJson() {
            const b = this._addonData;
            return {
                addonDataJson: b ? b._SaveToJson() : b,
                value: this._value,
                aValue: this._aValue,
                type: this._type,
                time: this._time,
                ease: this._ease,
                enable: this._enable
            }
        }
        _LoadFromJson(b) {
            b && (b.addonDataJson && this._addonData._SetFromJson(b.addonDataJson),
                this._value = b.value, this._aValue = b.aValue, this._type = b.type, this._time = b.time, this._ease = b.ease, this._enable = b.enable)
        }
    }
    e.PropertyKeyframeData = class {
        constructor(b, d) {
            this._propertyTrackDataItem = d;
            this._propertyKeyframeDataItems = [];
            e.TimelineDataManager._CreateDataItems(this._propertyKeyframeDataItems, b, a, this);
            this._LinkPropertyKeyframeDataItems()
        }
        Release() {
            this._propertyTrackDataItem = null;
            for (const b of this._propertyKeyframeDataItems) b.Release();
            e.clearArray(this._propertyKeyframeDataItems);
            this._propertyKeyframeDataItems =
                null
        }
        _LinkPropertyKeyframeDataItems() {
            this._propertyKeyframeDataItems.sort((b, d) => b.GetTime() - d.GetTime());
            for (let b = 0; b < this._propertyKeyframeDataItems.length; b++) this._propertyKeyframeDataItems[b].SetNext(this._propertyKeyframeDataItems[b + 1])
        }
        AddEmptyPropertyKeyframeDataItem() {
            const b = new a(null, this);
            this._propertyKeyframeDataItems.push(b);
            this._LinkPropertyKeyframeDataItems();
            return b
        }
        DeletePropertyKeyframeDataItems(b) {
            for (const d of this._propertyKeyframeDataItems) {
                if (!b(d)) continue;
                const c =
                    this._propertyKeyframeDataItems.indexOf(d); - 1 !== c && (d.Release(), this._propertyKeyframeDataItems.splice(c, 1))
            }
            this.SortPropertyKeyFrameDataItems();
            this._LinkPropertyKeyframeDataItems()
        }
        SortPropertyKeyFrameDataItems() {
            this._propertyKeyframeDataItems.sort((b, d) => b.GetTime() - d.GetTime())
        }
        GetPropertyTrackDataItem() {
            return this._propertyTrackDataItem
        }
        GetPropertyKeyframeDataItemCount() {
            return this._propertyKeyframeDataItems.length
        }
        GetPropertyKeyframeDataItemArray() {
            return this._propertyKeyframeDataItems
        }* propertyKeyframeDataItems() {
            for (const b of this._propertyKeyframeDataItems) yield b
        }* propertyKeyframeDataItemsReverse() {
            for (let b =
                    this._propertyKeyframeDataItems.length - 1; 0 <= b; b--) yield this._propertyKeyframeDataItems[b]
        }
        _SaveToJson() {
            return {
                propertyKeyframeDataItemsJson: this._propertyKeyframeDataItems.map(b => b._SaveToJson())
            }
        }
        _LoadFromJson(b) {
            b && (e.TimelineDataManager._LoadDataItemsFromJson(this._propertyKeyframeDataItems, b.propertyKeyframeDataItemsJson, a, this), this._LinkPropertyKeyframeDataItems())
        }
    }
} {
    "use strict";
    const e = self.C3;
    class a {
        constructor(c, f) {
            this._addonData = f;
            this._id = c[0];
            this._data = c[1]
        }
        Release() {
            this._data = this._addonData = null
        }
        GetAddonData() {
            return this._addonData
        }
        GetId() {
            return this._id
        }
        _SaveToJson() {
            return {
                id: this._id,
                data: this._data
            }
        }
        _LoadFromJson(c) {
            c && (this._id = c.id, this._data = c.data)
        }
    }
    class b extends a {
        constructor(c, f) {
            super(c, f);
            this._startAnchor = this._data[0];
            this._startEnable = !!this._data[1];
            this._endAnchor = this._data[2];
            this._endEnable = !!this._data[3]
        }
        Release() {
            super.Release()
        }
        GetStartAnchor() {
            return this._startAnchor
        }
        GetStartEnable() {
            return this._startEnable
        }
        GetEndAnchor() {
            return this._endAnchor
        }
        GetEndEnable() {
            return this._endEnable
        }
        _SaveToJson() {
            return Object.assign(super._SaveToJson(), {
                startAnchor: this._startAnchor,
                startEnable: !!this._startEnable,
                endAnchor: this._endAnchor,
                endEnable: !!this._endEnable
            })
        }
        _LoadFromJson(c) {
            c && (super._LoadFromJson(c), this._startAnchor = c.startAnchor, this._startEnable = !!c.startEnable, this._endAnchor = c.endAnchor, this._endEnable = !!c.endEnable)
        }
    }
    class d extends a {
        constructor(c, f) {
            super(c, f);
            this._direction = this._data[0];
            this._revolutions = this._data[1]
        }
        Release() {
            super.Release()
        }
        GetDirection() {
            return this._direction
        }
        GetRevolutions() {
            return this._revolutions
        }
        _SaveToJson() {
            return Object.assign(super._SaveToJson(), {
                direction: this._direction,
                revolutions: this._revolutions
            })
        }
        _LoadFromJson(c) {
            c && (super._LoadFromJson(c), this._direction = c.direction, this._revolutions = c.revolutions)
        }
    }
    e.AddonData = class {
        constructor(c, f) {
            this._propertyKeyframeDataItem = f;
            this._addonDataItems = [];
            e.TimelineDataManager._CreateDataItems(this._addonDataItems, c, {
                prop: 0,
                map: new Map([
                    ["cubic-bezier", b],
                    ["angle", d]
                ])
            }, this)
        }
        Release() {
            this._propertyKeyframeDataItem = null;
            for (const c of this._addonDataItems) c.Release();
            e.clearArray(this._addonDataItems);
            this._addonDataItems = null
        }
        GetPropertyKeyframeDataItem() {
            return this._propertyKeyframeDataItem
        }
        GetAddDataItemArray() {
            return this._addonDataItems
        }* addonDataItems() {
            for (const c of this._addonDataItems) yield c
        }
        _SaveToJson() {
            return {
                addonDataItemsJson: this._addonDataItems.map(c => c._SaveToJson())
            }
        }
        _LoadFromJson(c) {
            c && e.TimelineDataManager._LoadDataItemsFromJson(this._addonDataItems, c.addonDataItemsJson, {
                prop: "id",
                map: new Map([
                    ["cubic-bezier", b],
                    ["angle", d]
                ])
            }, this)
        }
    }
} {
    "use strict";
    const e = self.C3;
    let a = 0;
    e.TweenState = class extends e.TimelineState {
        constructor(b, d) {
            super(`tween-${a++}`, b, d);
            this._id = "";
            this._destroyInstanceOnComplete = !1;
            this._initialValueMode = "start-value";
            this._track = this._on_started_callbacks = this._on_completed_callbacks = this._instance = null
        }
        CreateTrackStates() {
            for (const b of this._timelineDataItem.GetTrackData().trackDataItems()) this._tracks.push(e.TweenTrackState.Create(this, b));
            this._track = this._tracks[0]
        }
        AddTrack() {
            var b = this._timelineDataItem.GetTrackData().AddEmptyTrackDataItem();
            b = e.TweenTrackState.Create(this, b);
            this._tracks.push(b);
            this._track = this._tracks[0];
            return b
        }
        GetPropertyTrack(b) {
            return this._track.GetPropertyTracks()[0]
        }
        SetPropertyType(b) {
            this._propertyType = b
        }
        GetInstance() {
            var b = this.GetTracks();
            if (b && b.length && (this._track = b = b[0])) {
                var d = b.GetInstance();
                return b.IsInstanceValid() ? d : void 0
            }
        }
        AddStartedCallback(b) {
            this._on_started_callbacks || (this._on_started_callbacks = []);
            this._on_started_callbacks.push(b)
        }
        AddCompletedCallback(b) {
            this._on_completed_callbacks || (this._on_completed_callbacks = []);
            this._on_completed_callbacks.push(b)
        }
        RemoveStartedCallback(b) {
            this._on_started_callbacks && (b = this._on_started_callbacks.indexOf(b), -1 !== b && this._on_started_callbacks.splice(b, 1))
        }
        RemoveCompletedCallback(b) {
            this._on_completed_callbacks && (b = this._on_completed_callbacks.indexOf(b), -1 !== b && this._on_completed_callbacks.splice(b, 1))
        }
        SetStartValue(b, d) {
            for (const f of this._tracks)
                for (const k of f._propertyTracks) {
                    if (k.GetPropertyName() !== d) continue;
                    var c = k.GetPropertyTrackData();
                    const h = k.GetPropertyTrackDataItem();
                    c = c.GetFirstPropertyKeyframeDataItem(h);
                    c.SetValue(b);
                    c.SetAbsoluteValue(b)
                }
        }
        _GetPropertyTrackState(b) {
            for (const d of this._tracks)
                for (const c of d._propertyTracks)
                    if (c.GetPropertyName() === b) return c
        }
        BeforeSetEndValues(b) {
            for (const f of b) b = this._GetPropertyTrackState(f), this.SetStartValue(b.GetCurrentState(), f);
            if (this.IsForwardPlayBack()) {
                var d = this.GetTotalTime() - this.GetTime();
                this.SetTotalTime(d);
                for (var c of this._tracks) c.SetLocalTotalTime(d);
                this._SetTime(0)
            } else {
                c = this.GetTime();
                this.SetTotalTime(c);
                for (d of this._tracks) d.SetLocalTotalTime(c);
                this._SetTime(c)
            }
            this.SetInitialStateFromSetTime()
        }
        SetEndValue(b, d) {
            var c = this._GetPropertyTrackState(d);
            d = c.GetPropertyTrackData();
            c = c.GetPropertyTrackDataItem();
            d = d.GetLastPropertyKeyframeDataItem(c);
            d.SetTime(this.GetTotalTime());
            d.SetValue(b);
            d.SetAbsoluteValue(b)
        }
        SetId(b) {
            this._id = b
        }
        GetId() {
            return this._id
        }
        SetInitialValueMode(b) {
            this._initialValueMode = b
        }
        GetInitialValueMode() {
            return this._initialValueMode
        }
        SetDestroyInstanceOnComplete(b) {
            this._destroyInstanceOnComplete =
                b
        }
        GetDestroyInstanceOnComplete() {
            return this._destroyInstanceOnComplete
        }
        OnStarted() {
            if (this._on_started_callbacks)
                for (const b of this._on_started_callbacks) b(this);
            if (!this.IsComplete())
                for (const b of this._tracks) b.CompareSaveStateWithCurrent()
        }
        OnCompleted() {
            this._completedTick = this._runtime.GetTickCount()
        }
        FinishTriggers() {
            if (!this._finishedTriggers && (this._finishedTriggers = !0, this._on_completed_callbacks))
                for (const b of this._on_completed_callbacks) b(this)
        }
        SetTime(b) {
            this._DeleteIntermediateKeyframes();
            super.SetTime(b)
        }
        SetInitialState(b) {
            if (!this.InitialStateSet() && "current-state" === this.GetInitialValueMode())
                for (const d of this._tracks) d.CompareInitialStateWithCurrent();
            super.SetInitialState(b)
        }
        Stop(b = !1) {
            super.Stop(b);
            if (!this.IsComplete())
                for (const d of this._tracks) d.SaveState()
        }
        Reset(b = !0, d = !1) {
            this._DeleteIntermediateKeyframes();
            super.Reset(b, d)
        }
        _DeleteIntermediateKeyframes() {
            for (const b of this._tracks) {
                const d = c => {
                    c = c.GetTime();
                    const f = this.GetTotalTime();
                    return 0 !== c && c !== f
                };
                b.DeleteKeyframes(d);
                b.DeletePropertyKeyframes(d)
            }
        }
        _OnBeforeChangeLayout() {
            if (this.IsReleased()) return !0;
            const b = this.GetInstance();
            if (b && b.GetObjectClass().IsGlobal()) return !1;
            this._timelineManager.CompleteTimelineBeforeChangeOfLayout(this);
            this.ResetBeforeChangeLayout();
            return !0
        }
        Tick(b, d, c) {
            this._instance || (this._instance = this.GetInstance());
            if (this._instance && !this._instance.IsDestroyed() && (d = this._instance.GetTimeScale(), -1 !== d && (b = c * d), 0 !== b || 0 !== this._lastDelta)) {
                this._lastDelta = b;
                c = this._playheadTime + b * this._playbackRate;
                b = this._timelineDataItem._totalTime;
                this._playheadTime = 0 > c ? 0 : c >= b ? b : c;
                c = !1;
                d = this.GetLoop();
                var f = this.GetPingPong();
                d || f ? d && !f ? 0 < this._playbackRate ? this._playheadTime >= b && this._SetTime(0) : 0 >= this._playheadTime && this._SetTime(b) : !d && f ? 0 < this._playbackRate ? this._playheadTime >= b && (this._SetTime(b), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), 1 === this._pingPongState ? this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._pingPongState = 0) : c = !0 : 0 === this._pingPongState && (this._pingPongState =
                        1)) : 0 >= this._playheadTime && (this._SetTime(0), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), 1 === this._pingPongState ? this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._pingPongState = 0) : c = !0 : 0 === this._pingPongState && (this._pingPongState = 1)) : d && f && (0 < this._playbackRate ? this._playheadTime >= b && (this._SetTime(b), this.SetPlaybackRate(-1 * this.GetPlaybackRate())) : 0 >= this._playheadTime && (this._SetTime(0), this.SetPlaybackRate(-1 * this.GetPlaybackRate()))) : 0 < this._playbackRate ? this._playheadTime >=
                    b && (this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._SetTime(0)) : (this._SetTime(b), c = !0)) : 0 >= this._playheadTime && (this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._SetTime(b)) : (this._SetTime(0), c = !0));
                c ? (this._track.SetEndState(), this.Stop(!0), this.OnCompleted()) : (this._track.Interpolate(this._playheadTime, !0, !1, !1, this._firstTick, !1), this._firstTick && (this._firstTick = !1))
            }
        }
        _SaveToJson() {
            const b = super._SaveToJson(),
                d = this.GetTimelineDataItem();
            return Object.assign(b, {
                tweenDataItemJson: d._SaveToJson(),
                id: this._id,
                destroyInstanceOnComplete: this._destroyInstanceOnComplete,
                initialValueMode: this._initialValueMode
            })
        }
        _LoadFromJson(b) {
            b && (this.GetTimelineDataItem()._LoadFromJson(b.tweenDataItemJson), super._LoadFromJson(b), this._id = b.id, this._destroyInstanceOnComplete = b.destroyInstanceOnComplete, this._initialValueMode = b.initialValueMode)
        }
        static IsPlaying(b) {
            return b.IsPlaying()
        }
        static IsPaused(b) {
            return b.IsPaused()
        }
        static Build(b) {
            var d = b.runtime.GetTimelineManager(),
                c = new e.TimelineDataItem;
            if (b.json) {
                c._LoadFromJson(b.json.tweenDataItemJson);
                var f = new e.TweenState(c, d);
                f._LoadFromJson(b.json);
                return f
            }
            d = new e.TweenState(c, d);
            e.IsArray(b.propertyTracksConfig) || (b.propertyTracksConfig = [b.propertyTracksConfig]);
            d.SetId(b.id);
            d.SetTags(b.tags);
            d.SetInitialValueMode(b.initialValueMode);
            d.SetDestroyInstanceOnComplete(b.releaseOnComplete);
            d.SetLoop(b.loop);
            d.SetPingPong(b.pingPong);
            d.SetTotalTime(b.time);
            d.SetStep(0);
            d.SetInterpolationMode("default");
            d.SetResultMode(b.propertyTracksConfig[0].resultMode);
            c = d.AddTrack();
            c.SetInstanceUID(b.instance.GetUID());
            c.SetInterpolationMode("default");
            c.SetResultMode(b.propertyTracksConfig[0].resultMode);
            c.SetEnable(!0);
            c.SetObjectClassIndex(b.instance.GetObjectClass().GetIndex());
            var k = b.instance.GetSdkInstance(),
                h = k.IsOriginalSizeKnown() ? k.GetOriginalWidth() : b.instance.GetWorldInfo().GetWidth();
            k = k.IsOriginalSizeKnown() ? k.GetOriginalHeight() : b.instance.GetWorldInfo().GetHeight();
            c.SetOriginalWidth(h);
            c.SetOriginalHeight(k);
            h = c.AddKeyframe();
            h.SetTime(0);
            h.SetEase("noease");
            h.SetEnable(!0);
            h.SetTags("");
            h = c.AddKeyframe();
            h.SetTime(b.time);
            h.SetEase("noease");
            h.SetEnable(!0);
            h.SetTags("");
            for (f of b.propertyTracksConfig) h = c.AddPropertyTrack(), h.SetSourceAdapterId(f.sourceId), h.SetSourceAdapterArgs(f.sourceArgs), h.SetPropertyName(f.property), h.SetPropertyType(f.type), h.SetMin(NaN), h.SetMax(NaN), h.SetInterpolationMode("default"), h.SetResultMode(f.resultMode), h.SetEnable(!0), k = h.AddPropertyKeyframe(), k.SetType(f.valueType), k.SetTime(0), k.SetEase(f.ease), k.SetEnable(!0),
                k.SetValue(f.startValue), k.SetAbsoluteValue(f.startValue), k = h.AddPropertyKeyframe(), k.SetType(f.valueType), k.SetTime(b.time), k.SetEase(f.ease), k.SetEnable(!0), k.SetValue(f.endValue), k.SetAbsoluteValue(f.endValue), h.GetSourceAdapter();
            return d
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.TweenTrackState = class extends e.TrackState {
        constructor(a, b) {
            super(a, b);
            this._secondPropertyTrack = this._firstPropertyTrack = null
        }
        static Create(a, b) {
            return e.New(e.TweenTrackState, a, b)
        }
        _CachePropertyTracks() {
            1 === this._propertyTracks.length ? this._firstPropertyTrack = this._propertyTracks[0] : (this._firstPropertyTrack = this._propertyTracks[0], this._secondPropertyTrack = this._propertyTracks[1])
        }
        CreatePropertyTrackStates() {
            for (const a of this._trackDataItem.GetPropertyTrackData().propertyTrackDataItems()) this._propertyTracks.push(e.TweenPropertyTrackState.Create(this,
                a));
            this._CachePropertyTracks()
        }
        AddPropertyTrack() {
            var a = this._trackDataItem.GetPropertyTrackData().AddEmptyPropertyTrackDataItem();
            a = e.TweenPropertyTrackState.Create(this, a);
            this._propertyTracks.push(a);
            this._CachePropertyTracks();
            return a
        }
        BeforeInterpolate() {}
        Interpolate(a, b, d = !1, c = !1, f, k = !1) {
            this._instance || this.GetInstance();
            if (this._instance) {
                if (this._instance.IsDestroyed() || k && this.GetObjectClass().IsGlobal()) return !1;
                this._secondPropertyTrack ? (this._firstPropertyTrack.Interpolate(a, d, c), this._secondPropertyTrack.Interpolate(a,
                    d, c)) : this._firstPropertyTrack.Interpolate(a, d, c);
                0 !== this._firstPropertyTrack.GetWorldInfoChange() && (this._worldInfo || (this._worldInfo = this._instance.GetWorldInfo()), this._worldInfo && this._worldInfo.SetBboxChanged())
            }
        }
        AfterInterpolate() {}
        _LoadFromJson(a) {
            super._LoadFromJson(a);
            this._CachePropertyTracks()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.TweenPropertyTrackState = class extends e.PropertyTrackState {
        constructor(a, b) {
            super(a, b);
            this._basic = !1
        }
        static Create(a, b) {
            return e.New(e.TweenPropertyTrackState, a, b)
        }
        Interpolate(a, b = !1, d = !1) {
            if (this._basic) {
                var c = this._propertyKeyframeDataItems[0];
                var f = this._propertyKeyframeDataItems[1]
            } else {
                if (b) c = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a, this._propertyTrackDataItem);
                else {
                    if (this._lastPropertyKeyframeDataItem) {
                        f = this.GetTimeline();
                        const k = this._lastPropertyKeyframeDataItem.GetNext();
                        c = this._lastPropertyKeyframeDataItem.GetTime();
                        f = k ? k.GetTime() : f.GetTotalTime();
                        if (a <= c || a >= f) this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a, this._propertyTrackDataItem)
                    } else this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a, this._propertyTrackDataItem);
                    c = this._lastPropertyKeyframeDataItem
                }
                f = c.GetNext()
            }
            this._sourceAdapter.Interpolate(a,
                c, f, b, d)
        }
        AddPropertyKeyframe() {
            const a = this._propertyTrackDataItem.GetPropertyKeyframeData().AddEmptyPropertyKeyframeDataItem();
            this._lastPropertyKeyframeDataItem = null;
            this._basic = 2 >= this.GetPropertyKeyframeDataItems().length;
            return a
        }
        DeletePropertyKeyframes(a) {
            this._lastPropertyKeyframeDataItem = null;
            this._propertyTrackDataItem.GetPropertyKeyframeData().DeletePropertyKeyframeDataItems(a);
            this._basic = 2 >= this.GetPropertyKeyframeDataItems().length
        }
        _SaveToJson() {
            return {
                sourceAdapterJson: this.GetSourceAdapter()._SaveToJson(),
                basic: this._basic
            }
        }
        _LoadFromJson(a) {
            a && (this.GetSourceAdapter()._LoadFromJson(a.sourceAdapterJson), this._basic = a.basic)
        }
    }
} {
    "use strict";
    const e = self.C3,
        a = self.Ease;
    e.Transition = class extends e.DefendedBase {
        constructor(b) {
            super();
            this._name = b[0];
            this._transitionKeyframes = [];
            for (var d of b[1]) b = e.TransitionKeyframe.Create(this, d), this._transitionKeyframes.push(b);
            for (d = 0; d < this._transitionKeyframes.length; d++) this._transitionKeyframes[d].SetNext(this._transitionKeyframes[d + 1]);
            this._precalculatedSamples = new Map;
            this._transitionKeyframeCache = new Map;
            this._PreCalcSamples();
            a.AddCustomEase(this._name, (c, f, k, h) => this.Interpolate(c,
                f, k, h))
        }
        static Create(b) {
            return e.New(e.Transition, b)
        }
        Release() {
            for (const b of this._transitionKeyframes) b.Release();
            e.clearArray(this._transitionKeyframes);
            this._transitionKeyframes = null;
            this._precalculatedSamples.clear();
            this._precalculatedSamples = null;
            this._transitionKeyframeCache.clear();
            this._transitionKeyframeCache = null
        }
        GetTransitionKeyFrameAt(b) {
            const d = this._transitionKeyframeCache.get(b);
            if (d) return d;
            for (const c of this._transitionKeyframes)
                if (c.GetValueX() === b) return this._transitionKeyframeCache.set(b,
                    c), c
        }
        GetFirstTransitionKeyFrameHigherThan(b) {
            for (const d of this._transitionKeyframes)
                if (d.GetValueX() > b) return d
        }
        GetFirstTransitionKeyFrameHigherOrEqualThan(b) {
            for (const d of this._transitionKeyframes)
                if (d.GetValueX() >= b) return d
        }
        GetFirstTransitionKeyFrameLowerThan(b) {
            for (let d = this._transitionKeyframes.length - 1; 0 <= d; d--) {
                const c = this._transitionKeyframes[d];
                if (c.GetValueX() < b) return c
            }
        }
        GetFirstTransitionKeyFrameLowerOrEqualThan(b) {
            for (let d = this._transitionKeyframes.length - 1; 0 <= d; d--) {
                const c = this._transitionKeyframes[d];
                if (c.GetValueX() <= b) return c
            }
        }
        Interpolate(b, d, c, f) {
            var k = b / f;
            b = this.GetFirstTransitionKeyFrameLowerOrEqualThan(k);
            f = b.GetNext();
            f || (b = this.GetFirstTransitionKeyFrameLowerThan(k), f = b.GetNext());
            var h = f.GetValueX() - b.GetValueX();
            k = e.mapToRange(k, b.GetValueX(), f.GetValueX(), 0, h);
            h = b.GetValueX();
            const l = b.GetValueY(),
                n = b.GetValueX() + b.GetStartAnchorX(),
                u = b.GetValueY() + b.GetStartAnchorY(),
                w = f.GetValueX() + f.GetEndAnchorX(),
                q = f.GetValueY() + f.GetEndAnchorY(),
                t = f.GetValueX();
            f = f.GetValueY();
            f = a.GetRuntimeEase("spline")(k,
                h, l, n, u, w, q, t, f, this._precalculatedSamples.get(b));
            f += b.GetValueY();
            return (1 - f) * d + f * (d + c)
        }
        _PreCalcSamples() {
            this._precalculatedSamples.clear();
            for (let c = 0; c < this._transitionKeyframes.length - 1; c++) {
                var b = this._transitionKeyframes[c];
                if (!b.GetStartEnable()) continue;
                var d = this._transitionKeyframes[c + 1];
                const f = b.GetValueX(),
                    k = b.GetValueX() + b.GetStartAnchorX(),
                    h = d.GetValueX() + d.GetEndAnchorX();
                d = d.GetValueX();
                this._precalculatedSamples.set(b, a.GetBezierSamples(f, k, h, d))
            }
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.TransitionKeyframe = class extends e.DefendedBase {
        constructor(a, b) {
            super();
            this._transition = a;
            this._valueX = b[0];
            this._valueY = b[1];
            this._startAnchorX = b[2];
            this._startAnchorY = b[3];
            this._endAnchorX = b[4];
            this._endAnchorY = b[5];
            this._startEnable = b[6];
            this._endEnable = b[7];
            this._next = null
        }
        Release() {
            this._transition = null
        }
        static Create(a, b) {
            return e.New(e.TransitionKeyframe, a, b)
        }
        SetNext(a) {
            this._next = a
        }
        GetNext() {
            return this._next
        }
        GetValueX() {
            return this._valueX
        }
        GetValueY() {
            return this._valueY
        }
        GetStartAnchorX() {
            return this._startAnchorX
        }
        GetStartAnchorY() {
            return this._startAnchorY
        }
        GetEndAnchorX() {
            return this._endAnchorX
        }
        GetEndAnchorY() {
            return this._endAnchorY
        }
        GetStartEnable() {
            return this._startEnable
        }
        GetEndEnable() {
            return this._endEnable
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.TransitionManager = class extends e.DefendedBase {
        constructor(a) {
            super();
            this._runtime = a;
            this._transitions = []
        }
        Release() {
            for (const a of this._transitions) a.Release();
            e.clearArray(this._transitions);
            this._transitions = null
        }
        Create(a) {
            this._transitions.push(e.Transition.Create(a))
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.SolStack = class extends e.DefendedBase {
        constructor(a) {
            super();
            this._objectClass = a;
            this._stack = [];
            this._stack.push(e.New(e.Sol, this));
            this._index = 0;
            this._current = this._stack[0]
        }
        Release() {
            for (const a of this._stack) a.Release();
            e.clearArray(this._stack);
            this._objectClass = this._current = null
        }
        GetObjectClass() {
            return this._objectClass
        }
        GetCurrentSol() {
            return this._current
        }
        Clear() {
            this.GetCurrentSol().Clear()
        }
        PushClean() {
            var a = this._stack,
                b = ++this._index;
            b === a.length ? (b = e.New(e.Sol,
                this), a.push(b), this._current = b) : (a = a[b], a.Reset(), this._current = a)
        }
        PushCopy() {
            const a = this._stack,
                b = ++this._index;
            b === a.length && a.push(e.New(e.Sol, this));
            const d = a[b];
            d.Copy(a[b - 1]);
            this._current = d
        }
        Pop() {
            this._current = this._stack[--this._index]
        }
        RemoveInstances(a) {
            const b = this._stack;
            for (let d = 0, c = b.length; d < c; ++d) b[d].RemoveInstances(a)
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Sol = class extends e.DefendedBase {
        constructor(a) {
            super();
            this._stack = a;
            this._objectClass = this._stack.GetObjectClass();
            this._eventStack = this._objectClass.GetRuntime().GetEventStack();
            this._selectAll = !0;
            this._instances = [];
            this._elseInstances = []
        }
        Release() {
            this.ClearArrays();
            this._eventStack = this._objectClass = this._stack = null
        }
        ClearArrays() {
            e.clearArray(this._instances);
            e.clearArray(this._elseInstances)
        }
        GetObjectClass() {
            return this._objectClass
        }
        IsSelectAll() {
            return this._selectAll
        }
        HasAnyInstances() {
            return this._selectAll ?
                !!this._objectClass.GetInstanceCount() : !!this._instances.length
        }
        GetInstances() {
            return this._selectAll ? this._objectClass.GetInstances() : this._instances
        }
        HasAnyElseInstances() {
            return !!this._elseInstances.length
        }
        GetElseInstances() {
            return this._elseInstances
        }
        GetExpressionInstances() {
            const a = this.GetInstances();
            return a.length ? a : this._elseInstances
        }
        Reset() {
            this._selectAll = !0;
            e.clearArray(this._elseInstances)
        }
        Clear() {
            this._selectAll = !0
        }
        Copy(a) {
            a.IsSelectAll() ? this.Reset() : (this._selectAll = !1, e.shallowAssignArray(this._instances,
                a._instances), e.clearArray(this._elseInstances))
        }
        _PushInstance(a) {
            this._instances.push(a)
        }
        _PushElseInstance(a) {
            this._elseInstances.push(a)
        }
        _SetSelectAll(a) {
            this._selectAll = !!a
        }
        _GetOwnInstances() {
            return this._instances
        }
        _GetOwnElseInstances() {
            return this._elseInstances
        }
        SetSinglePicked(a) {
            this._selectAll = !1;
            e.clearArray(this._instances);
            this._instances.push(a)
        }
        SetArrayPicked(a) {
            this._selectAll = !1;
            e.shallowAssignArray(this._instances, a)
        }
        SetSetPicked(a) {
            this._selectAll = !1;
            e.clearArray(this._instances);
            for (const b of a) this._instances.push(b)
        }
        AddElseInstances(a, b) {
            for (const d of b) a.has(d) || this._elseInstances.push(d)
        }
        TransferElseInstancesToOwn(a) {
            for (const b of a) this._instances.push(b);
            e.arrayRemoveAllInSet(this._elseInstances, a)
        }
        PickOne(a) {
            a && (this._eventStack.GetCurrentStackFrame().GetCurrentEvent().IsOrBlock() ? (this.IsSelectAll() && (e.clearArray(this._instances), e.shallowAssignArray(this._elseInstances, a.GetObjectClass().GetInstances()), this._selectAll = !1), a = this._elseInstances.indexOf(a), -1 !==
                a && (this._instances.push(this._elseInstances[a]), this._elseInstances.splice(a, 1))) : this.SetSinglePicked(a))
        }
        RemoveInstances(a) {
            e.arrayRemoveAllInSet(this._instances, a);
            e.arrayRemoveAllInSet(this._elseInstances, a)
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.EventStack = class extends e.DefendedBase {
        constructor(a) {
            super();
            this._eventSheetManager = a;
            this._runtime = this._eventSheetManager.GetRuntime();
            this._stack = [];
            this._stack.push(e.New(e.EventStackFrame, this, null));
            this._index = 0;
            this._expFuncStack = []
        }
        Release() {
            for (const a of this._stack) a.Release();
            e.clearArray(this._stack);
            e.clearArray(this._expFuncStack);
            this._runtime = this._eventSheetManager = null
        }
        GetEventSheetManager() {
            return this._eventSheetManager
        }
        GetRuntime() {
            return this._runtime
        }
        GetCurrentStackFrame() {
            return this._stack[this._index]
        }
        Push(a) {
            var b =
                this._stack;
            const d = ++this._index;
            if (d === b.length) return a = e.New(e.EventStackFrame, this, a), b.push(a), a;
            b = b[d];
            b.Reset(a);
            return b
        }
        Pop() {
            --this._index
        }
        PushExpFunc(a) {
            this._expFuncStack.push(a)
        }
        PopExpFunc() {
            this._expFuncStack.pop()
        }
        GetCurrentExpFuncStackFrame() {
            const a = this._expFuncStack;
            return 0 === a.length ? null : a.at(-1)
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.EventStackFrame = class extends e.DefendedBase {
        constructor(a, b) {
            super();
            this._stack = a;
            this._runtime = this._stack.GetRuntime();
            this._currentEvent = b;
            this._actIndex = this._cndIndex = 0;
            this._elseBranchRan = this._lastEventTrue = !1;
            this._expressionObjectClass = null;
            this._functionReturnValue = this._functionReturnType = 0
        }
        Release() {
            this.Reset(null);
            this._runtime = this._stack = null
        }
        Reset(a) {
            this._currentEvent = a;
            this._actIndex = this._cndIndex = 0;
            this._elseBranchRan = this._lastEventTrue = !1
        }
        _Restore(a,
            b) {
            this._currentEvent = a;
            this._cndIndex = 0;
            this._actIndex = b
        }
        ResetQuick() {
            this._actIndex = this._cndIndex = 0
        }
        GetCurrentEvent() {
            return this._currentEvent
        }
        SetCurrentEvent(a) {
            this._currentEvent = a
        }
        GetConditionIndex() {
            return this._cndIndex
        }
        SetConditionIndex(a) {
            this._cndIndex = a
        }
        GetActionIndex() {
            return this._actIndex
        }
        SetActionIndex(a) {
            this._actIndex = a
        }
        SetLastEventTrue(a) {
            this._lastEventTrue = !!a
        }
        GetLastEventTrue() {
            return this._lastEventTrue
        }
        SetElseBranchRan(a) {
            this._elseBranchRan = !!a
        }
        GetElseBranchRan() {
            return this._elseBranchRan
        }
        SetExpressionObjectClass(a) {
            this._expressionObjectClass =
                a
        }
        GetExpressionObjectClass() {
            return this._expressionObjectClass
        }
        InitCallFunctionExpression(a, b) {
            this._functionReturnType = a;
            this._functionReturnValue = b
        }
        GetFunctionReturnType() {
            return this._functionReturnType
        }
        SetFunctionReturnValue(a) {
            this._functionReturnValue = a
        }
        GetFunctionReturnValue() {
            return this._functionReturnValue
        }
        IsSolModifierAfterCnds() {
            const a = this._currentEvent;
            return a.IsSolWriterAfterCnds() ? !0 : this._cndIndex < a.GetConditionCount() - 1 ? !!a.GetSolModifiers().length : !1
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.LocalVarStack = class extends e.DefendedBase {
        constructor(a) {
            super();
            this._eventSheetManager = a;
            this._runtime = this._eventSheetManager.GetRuntime();
            this._stack = [];
            this._index = -1;
            this._current = null;
            this._initialValues = []
        }
        Release() {
            e.clearArray(this._stack);
            this._runtime = this._eventSheetManager = null
        }
        _SetInitialValues(a) {
            this._initialValues = a;
            a = this._initialValues.slice(0);
            this._stack.push(a);
            this._index = 0;
            this._current = a
        }
        GetEventSheetManager() {
            return this._eventSheetManager
        }
        GetRuntime() {
            return this._runtime
        }
        GetCurrent() {
            return this._current
        }
        Push() {
            const a =
                ++this._index,
                b = this._stack;
            a === b.length ? b.push(this._initialValues.slice(0)) : e.shallowAssignArray(b[a], this._initialValues);
            this._current = b[a]
        }
        Pop() {
            this._current = this._stack[--this._index]
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.LoopStack = class extends e.DefendedBase {
        constructor(a) {
            super();
            this._eventSheetManager = a;
            this._runtime = this._eventSheetManager.GetRuntime();
            this._stack = [];
            this._index = -1
        }
        Release() {
            e.clearArray(this._stack);
            this._runtime = this._eventSheetManager = null
        }
        GetEventSheetManager() {
            return this._eventSheetManager
        }
        GetRuntime() {
            return this._runtime
        }
        IsInLoop() {
            return 0 <= this._index
        }
        GetCurrent() {
            return this._stack[this._index]
        }
        Push() {
            ++this._index;
            if (this._index === this._stack.length) {
                var a =
                    e.New(e.Loop, this);
                this._stack.push(a);
                return a
            }
            a = this._stack[this._index];
            a.Reset();
            return a
        }
        Pop() {
            --this._index
        }
        FindByName(a) {
            const b = this._stack;
            for (let d = this._index; 0 <= d; --d) {
                const c = b[d];
                if (c.GetName() === a) return c
            }
            return null
        }
        _GetStack() {
            return this._stack.slice(0, this._index + 1)
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Loop = class extends e.DefendedBase {
        constructor(a) {
            super();
            this._loopStack = a;
            this._name = "";
            this._index = 0;
            this._isStopped = !1;
            this._end = NaN
        }
        Reset() {
            this._name = "";
            this._index = 0;
            this._isStopped = !1;
            this._end = NaN
        }
        SetName(a) {
            this._name = a
        }
        GetName() {
            return this._name
        }
        SetIndex(a) {
            this._index = a
        }
        GetIndex() {
            return this._index
        }
        Stop() {
            this._isStopped = !0
        }
        IsStopped() {
            return this._isStopped
        }
        SetEnd(a) {
            this._end = a
        }
        GetEnd() {
            return this._end
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.ArrayStack = class extends e.DefendedBase {
        constructor() {
            super();
            this._stack = [];
            this._index = -1
        }
        Release() {
            e.clearArray(this._stack)
        }
        GetCurrent() {
            return this._stack[this._index]
        }
        Push() {
            ++this._index;
            if (this._index === this._stack.length) {
                const a = [];
                this._stack.push(a);
                return a
            }
            return this._stack[this._index]
        }
        Pop() {
            --this._index
        }
    }
} {
    "use strict";
    const e = self.C3;

    function a(d, c) {
        return d.GetIndex() - c.GetIndex()
    }

    function b(d, c) {
        for (let f = 0, k = d.length; f < k; ++f)
            if (d[f] !== c[f]) return !1;
        return !0
    }
    e.EventSheetManager = class extends e.DefendedBase {
        constructor(d) {
            super();
            this._runtime = d;
            this._allSheets = [];
            this._sheetsByName = new Map;
            this._allGroups = [];
            this._groupsByName = new Map;
            this._blocksBySid = new Map;
            this._cndsBySid = new Map;
            this._actsBySid = new Map;
            this._allUniqueSolModifiers = new Map;
            this._eventVarsBySid = new Map;
            this._nextLocalVarIndex =
                0;
            this._allGlobalVars = [];
            this._allLocalVars = [];
            this._localVarInitialValues = [];
            this._functionBlocksByName = new Map;
            this._eventStack = e.New(e.EventStack, this);
            this._localVarStack = e.New(e.LocalVarStack, this);
            this._loopStack = e.New(e.LoopStack, this);
            this._triggersToPostInit = [];
            this._queuedTriggers = [];
            this._queuedDebugTriggers = [];
            this._blockFlushingDepth = this._executingTriggerDepth = this._runningEventsDepth = 0;
            this._scheduledWaits = [];
            this._asyncActionPromises = [];
            self.c3_callFunction = (c, f) => this._InvokeFunctionFromJS(c,
                f)
        }
        Release() {
            this.ClearAllScheduledWaits();
            this._eventStack.Release();
            this._eventStack = null;
            this._localVarStack.Release();
            this._localVarStack = null;
            e.clearArray(this._queuedTriggers);
            e.clearArray(this._queuedDebugTriggers);
            this._runtime = null;
            e.clearArray(this._allSheets);
            this._sheetsByName.clear()
        }
        Create(d) {
            d = e.New(e.EventSheet, this, d);
            this._allSheets.push(d);
            this._sheetsByName.set(d.GetName().toLowerCase(), d)
        }
        _AddTriggerToPostInit(d) {
            this._triggersToPostInit.push(d)
        }
        _PostInit() {
            for (const d of this._functionBlocksByName.values()) d._PostInit(!1);
            for (const d of this._allSheets) d._PostInit();
            for (const d of this._allSheets) d._UpdateDeepIncludes();
            for (const d of this._triggersToPostInit) d._PostInit(!1);
            e.clearArray(this._triggersToPostInit);
            this._localVarStack._SetInitialValues(this._localVarInitialValues)
        }
        GetRuntime() {
            return this._runtime
        }
        GetEventSheetByName(d) {
            return this._sheetsByName.get(d.toLowerCase()) || null
        }
        _RegisterGroup(d) {
            this._allGroups.push(d);
            this._groupsByName.set(d.GetGroupName(), d)
        }
        _RegisterEventBlock(d) {
            this._blocksBySid.set(d.GetSID(),
                d)
        }
        _RegisterCondition(d) {
            this._cndsBySid.set(d.GetSID(), d)
        }
        _RegisterAction(d) {
            this._actsBySid.set(d.GetSID(), d)
        }
        _RegisterFunctionBlock(d) {
            this._functionBlocksByName.set(d.GetFunctionName().toLowerCase(), d)
        }
        _RegisterEventVariable(d) {
            this._eventVarsBySid.set(d.GetSID(), d);
            d.IsGlobal() ? this._allGlobalVars.push(d) : this._allLocalVars.push(d)
        }
        _DeduplicateSolModifierList(d) {
            2 <= d.length && d.sort(a);
            let c = this._allUniqueSolModifiers.get(d.length);
            c || (c = [], this._allUniqueSolModifiers.set(d.length, c));
            for (let f =
                    0, k = c.length; f < k; ++f) {
                const h = c[f];
                if (b(d, h)) return h
            }
            c.push(d);
            return d
        }
        _GetNextLocalVarIndex(d) {
            this._localVarInitialValues.push(d.GetInitialValue());
            return this._nextLocalVarIndex++
        }
        GetEventStack() {
            return this._eventStack
        }
        GetCurrentEventStackFrame() {
            return this.GetEventStack().GetCurrentStackFrame()
        }
        GetCurrentEvent() {
            return this.GetCurrentEventStackFrame().GetCurrentEvent()
        }
        GetCurrentCondition() {
            const d = this.GetCurrentEventStackFrame();
            return d.GetCurrentEvent().GetConditionAt(d.GetConditionIndex())
        }
        GetCurrentAction() {
            const d =
                this.GetCurrentEventStackFrame();
            return d.GetCurrentEvent().GetActionAt(d.GetActionIndex())
        }
        GetLocalVarStack() {
            return this._localVarStack
        }
        GetLoopStack() {
            return this._loopStack
        }
        GetAllLocalVariablesInScope(d) {
            const c = [];
            for (d = d.GetScopeParent(); d;) e.appendArray(c, d._GetAllLocalVariablesInScope()), d = d.GetScopeParent();
            return c
        }
        _GetLocalVariablesScriptInterface(d) {
            const c = {};
            for (const f of this.GetAllLocalVariablesInScope(d)) c[f.GetJsPropName()] = f._GetScriptInterfaceDescriptor();
            return Object.create(Object.prototype,
                c)
        }
        GetEventVariableBySID(d) {
            return this._eventVarsBySid.get(d) || null
        }
        GetEventBlockBySID(d) {
            return this._blocksBySid.get(d) || null
        }
        GetConditionBySID(d) {
            return this._cndsBySid.get(d) || null
        }
        GetActionBySID(d) {
            return this._actsBySid.get(d) || null
        }
        GetFunctionBlockByName(d) {
            return this._functionBlocksByName.get(d.toLowerCase()) || null
        }
        GetAllGlobalVariables() {
            return this._allGlobalVars
        }
        GetAllLocalVariables() {
            return this._allLocalVars
        }
        ResetAllGlobalsToInitialValue() {
            for (const d of this._allGlobalVars) d.ResetToInitialValue()
        }
        GetEventGroupByName(d) {
            return this._groupsByName.get(d.toLowerCase()) ||
                null
        }
        GetEventGroupBySID(d) {
            return (d = this._blocksBySid.get(d)) && d.IsGroup() ? d : null
        }
        GetAllGroups() {
            return this._allGroups
        }
        ResetAllGroupsInitialActivation() {
            for (const d of this._allGroups) d.ResetInitialActivation()
        }
        _ResetAllHasRunFlags() {
            for (const d of this._allSheets) d._ResetHasRunFlag()
        }
        RunEvents(d) {
            this._ResetAllHasRunFlags();
            this._runningEventsDepth++;
            for (const c of d.runningLayouts())
                if (d = c.GetEventSheet()) this._runtime.PushCurrentLayout(c), d.Run(), this._runtime.PopCurrentLayout();
            this._runningEventsDepth--
        }
        async DebugRunEvents(d) {
            this._ResetAllHasRunFlags();
            this._runningEventsDepth++;
            for (const c of this._DebugRunEventsGen(d)) await this._runtime.DebugBreak(c);
            this._runningEventsDepth--
        }* _DebugRunEventsGen(d) {
            for (const c of d.runningLayouts())
                if (d = c.GetEventSheet()) this._runtime.PushCurrentLayout(c), yield* d.DebugRun(), this._runtime.PopCurrentLayout()
        }
        _Trigger(d, c, f, k) {
            let h = !1;
            if (!d.GetMainRunningLayout()) return this.QueueTrigger(c, f, k);
            this._executingTriggerDepth++;
            for (const l of d.runningLayouts())
                if (d = l.GetEventSheet()) {
                    this._runtime.PushCurrentLayout(l);
                    for (const n of d.deepIncludes()) {
                        const u = n._Trigger(c, f, k);
                        h = h || u
                    }
                    d = d._Trigger(c, f, k);
                    h = h || d;
                    this._runtime.PopCurrentLayout()
                } this._executingTriggerDepth--;
            return h
        }* _DebugTrigger(d, c, f, k) {
            let h = !1;
            if (!d.GetMainRunningLayout()) return this.QueueTrigger(c, f, k);
            this._executingTriggerDepth++;
            for (const l of d.runningLayouts())
                if (d = l.GetEventSheet()) {
                    this._runtime.PushCurrentLayout(l);
                    for (const n of d.deepIncludes()) {
                        const u = yield* n._DebugTrigger(c, f, k);
                        h = h || u
                    }
                    d = yield* d._DebugTrigger(c, f, k);
                    h = h || d;
                    this._runtime.PopCurrentLayout()
                } this._executingTriggerDepth--;
            return h
        }
        QueueTrigger(d, c, f) {
            this._queuedTriggers.push([d, c, f]);
            return !1
        }
        QueueDebugTrigger(d, c, f) {
            let k = null;
            const h = new Promise(l => k = l);
            this._queuedDebugTriggers.push([d, c, f, k]);
            return h
        }* _RunQueuedDebugTriggersGen() {
            if (this._runtime.HitBreakpoint()) throw Error("should not be in breakpoint");
            const d = this._runtime.GetLayoutManager();
            for (; this._queuedDebugTriggers.length;) {
                const [c, f, k, h] = this._queuedDebugTriggers.shift(), l = yield* this._DebugTrigger(d, c, f, k);
                h(l)
            }
        }
        async RunQueuedDebugTriggersAsync() {
            for (const d of this._RunQueuedDebugTriggersGen()) await this._runtime.DebugBreak(d)
        }
        _FastTrigger(d,
            c, f, k) {
            let h = !1;
            var l = d.GetMainRunningLayout();
            if (d = l.GetEventSheet()) {
                this._executingTriggerDepth++;
                this._runtime.PushCurrentLayout(l);
                l = d.deepIncludes();
                for (let n = 0, u = l.length; n < u; ++n) {
                    const w = l[n]._FastTrigger(c, f, k);
                    h = h || w
                }
                c = d._FastTrigger(c, f, k);
                h = h || c;
                this._runtime.PopCurrentLayout();
                this._executingTriggerDepth--;
                return h
            }
        }* _DebugFastTrigger(d, c, f, k) {
            let h = !1;
            var l = d.GetMainRunningLayout();
            if (d = l.GetEventSheet()) {
                this._executingTriggerDepth++;
                this._runtime.PushCurrentLayout(l);
                l = d.deepIncludes();
                for (let n = 0, u = l.length; n < u; ++n) {
                    const w = yield* l[n]._DebugFastTrigger(c, f, k);
                    h = h || w
                }
                c = yield* d._DebugFastTrigger(c, f, k);
                h = h || c;
                this._runtime.PopCurrentLayout();
                this._executingTriggerDepth--;
                return h
            }
        }
        GetTriggerDepth() {
            return this._executingTriggerDepth
        }
        IsInTrigger() {
            return 0 < this.GetTriggerDepth()
        }
        _IncTriggerDepth() {
            return ++this._executingTriggerDepth
        }
        _DecTriggerDepth() {
            --this._executingTriggerDepth
        }
        IsRunningEvents() {
            return 0 < this._runningEventsDepth
        }
        IsInEventEngine() {
            return this.IsRunningEvents() ||
                this.IsInTrigger()
        }
        _RunQueuedTriggers(d) {
            for (const [c, f, k] of this._queuedTriggers) this._Trigger(d, c, f, k);
            e.clearArray(this._queuedTriggers)
        }
        BlockFlushingInstances(d) {
            d ? this._blockFlushingDepth++ : this._blockFlushingDepth--
        }
        IsFlushingBlocked() {
            return 0 < this._blockFlushingDepth
        }
        ClearSol(d) {
            for (let c = 0, f = d.length; c < f; ++c) d[c].GetSolStack().Clear()
        }
        PushCleanSol(d) {
            for (let c = 0, f = d.length; c < f; ++c) d[c].GetSolStack().PushClean()
        }
        PushCopySol(d) {
            for (let c = 0, f = d.length; c < f; ++c) d[c].GetSolStack().PushCopy()
        }
        PopSol(d) {
            for (let c =
                    0, f = d.length; c < f; ++c) d[c].GetSolStack().Pop()
        }
        AddScheduledWait() {
            const d = e.New(e.ScheduledWait, this);
            this._scheduledWaits.push(d);
            return d
        }
        scheduledWaits() {
            return this._scheduledWaits
        }
        RunScheduledWaits() {
            if (this._scheduledWaits.length) {
                var d = this.GetCurrentEventStackFrame(),
                    c = !1;
                this._runningEventsDepth++;
                for (let f = 0, k = this._scheduledWaits.length; f < k; ++f) {
                    const h = this._scheduledWaits[f];
                    h._ShouldRun() && h._Run(d);
                    h.ShouldRelease() && (c = !0)
                }
                c && this._FilterScheduledWaitsToRelease();
                this._runningEventsDepth--
            }
        }
        async DebugRunScheduledWaits() {
            if (this._scheduledWaits.length) {
                var d =
                    this.GetCurrentEventStackFrame(),
                    c = !1;
                this._runningEventsDepth++;
                for (let f = 0, k = this._scheduledWaits.length; f < k; ++f) {
                    const h = this._scheduledWaits[f];
                    h._ShouldRun() && await h._DebugRun(d);
                    h.ShouldRelease() && (c = !0)
                }
                c && this._FilterScheduledWaitsToRelease();
                this._runningEventsDepth--
            }
        }
        _FilterScheduledWaitsToRelease() {
            const d = e.arrayFilterOut(this._scheduledWaits, c => c.ShouldRelease());
            for (const c of d) c.Release()
        }
        ClearAllScheduledWaits() {
            for (const d of this._scheduledWaits) d.Release();
            e.clearArray(this._scheduledWaits)
        }
        RemoveInstancesFromScheduledWaits(d) {
            for (const c of this._scheduledWaits) c.RemoveInstances(d)
        }
        AddAsyncActionPromise(d) {
            this._asyncActionPromises.push(d)
        }
        ClearAsyncActionPromises() {
            e.clearArray(this._asyncActionPromises)
        }
        GetPromiseForAllAsyncActions() {
            const d =
                Promise.all(this._asyncActionPromises);
            this._asyncActionPromises = [];
            return d
        }
        _SaveToJson() {
            return {
                groups: this._SaveGroupsToJson(),
                cnds: this._SaveCndsToJson(),
                acts: this._SaveActsToJson(),
                vars: this._SaveVarsToJson(),
                waits: this._SaveScheduledWaitsToJson()
            }
        }
        _LoadFromJson(d) {
            this._LoadGroupsFromJson(d.groups);
            this._LoadCndsFromJson(d.cnds);
            this._LoadActsFromJson(d.acts);
            this._LoadVarsFromJson(d.vars);
            this._LoadScheduledWaitsFromJson(d.waits)
        }
        _SaveGroupsToJson() {
            const d = {};
            for (const c of this.GetAllGroups()) d[c.GetSID().toString()] =
                c.IsGroupActive();
            return d
        }
        _LoadGroupsFromJson(d) {
            for (const [c, f] of Object.entries(d)) d = parseInt(c, 10), (d = this.GetEventGroupBySID(d)) && d.SetGroupActive(f)
        }
        _SaveCndsToJson() {
            const d = {};
            for (const [c, f] of this._cndsBySid) {
                const k = f._SaveToJson();
                k && (d[c.toString()] = k)
            }
            return d
        }
        _LoadCndsFromJson(d) {
            const c = new Map;
            for (const [f, k] of Object.entries(d)) c.set(parseInt(f, 10), k);
            for (const [f, k] of this._cndsBySid) k._LoadFromJson(c.get(f) || null)
        }
        _SaveActsToJson() {
            const d = {};
            for (const [c, f] of this._actsBySid) {
                const k =
                    f._SaveToJson();
                k && (d[c.toString()] = k)
            }
            return d
        }
        _LoadActsFromJson(d) {
            const c = new Map;
            for (const [f, k] of Object.entries(d)) c.set(parseInt(f, 10), k);
            for (const [f, k] of this._actsBySid) k._LoadFromJson(c.get(f) || null)
        }
        _SaveVarsToJson() {
            const d = {};
            for (const [c, f] of this._eventVarsBySid) f.IsConstant() || !f.IsGlobal() && !f.IsStatic() || (d[c.toString()] = f.GetValue());
            return d
        }
        _LoadVarsFromJson(d) {
            for (const [c, f] of Object.entries(d)) d = parseInt(c, 10), (d = this.GetEventVariableBySID(d)) && d.SetValue(f)
        }
        _SaveScheduledWaitsToJson() {
            return this._scheduledWaits.filter(d =>
                !d.IsPromise()).map(d => d._SaveToJson())
        }
        _LoadScheduledWaitsFromJson(d) {
            this.ClearAllScheduledWaits();
            for (const c of d)(d = e.ScheduledWait._CreateFromJson(this, c)) && this._scheduledWaits.push(d)
        }
        _GetPerfRecords() {
            return [...this._runtime.GetLayoutManager().runningLayouts()].map(d => d.GetEventSheet()).filter(d => d).map(d => d._GetPerfRecord())
        }
        FindFirstFunctionBlockParent(d) {
            for (; d;)
                if (d = d.GetScopeParent(), d instanceof e.FunctionBlock) return d;
            return null
        }
        _InvokeFunctionFromJS(d, c) {
            Array.isArray(c) || (c = []);
            d = this.GetFunctionBlockByName(d.toLowerCase());
            if (!d) return null;
            if (!d.IsEnabled()) return d.GetDefaultReturnValue();
            var f = d.GetFunctionParameters();
            if (c.length < f.length) {
                c = c.slice(0);
                do c.push(f[c.length].GetInitialValue()); while (c.length < f.length)
            }
            f = d.GetEventBlock();
            return f.RunAsExpressionFunctionCall(f.GetSolModifiersIncludingParents(), d.GetReturnType(), d.GetDefaultReturnValue(), ...c)
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.EventSheet = class extends e.DefendedBase {
        constructor(a, b) {
            super();
            this._eventSheetManager = a;
            this._runtime = a.GetRuntime();
            this._name = b[0];
            this._events = [];
            this._triggers = new Map;
            this._fastTriggers = new Map;
            this._eventsByDisplayNumber = new Map;
            this._hasRun = !1;
            this._shallowIncludes = [];
            this._deepIncludes = [];
            this._alreadyIncludedSheets = new Set;
            for (const d of b[1]) this._CreateEvent(d, null, this._events);
            this._perfRecord = this._runtime.IsDebug() ? {
                type: "sheet",
                name: this._name,
                totalTimeCounter: 0,
                children: []
            } : null
        }
        Release() {
            this._runtime = this._eventSheetManager = null
        }
        _CreateEvent(a, b, d) {
            switch (a[0]) {
                case 0:
                case 3:
                    this._CreateEventBlock(a, b, d);
                    break;
                case 1:
                    this._CreateEventVariable(a, b, d);
                    break;
                case 2:
                    this._CreateInclude(a, b, d);
                    break;
                case 4:
                    this._CreateFunctionBlock(a, b);
                    break;
                case 5:
                    this._CreateScriptBlock(a, b, d);
                    break;
                default:
                    throw Error("invalid event type");
            }
        }
        _CreateEventBlock(a, b, d) {
            a = e.EventBlock.Create(this, b, a);
            if (a.IsOrBlock()) {
                d.push(a);
                d = a.GetConditions();
                for (let c = 0, f = d.length; c <
                    f; ++c) d[c].IsTrigger() && this._InitTrigger(a, c)
            } else a.IsTrigger() ? this._InitTrigger(a, 0) : d.push(a)
        }
        _CreateFunctionBlock(a, b) {
            a = e.FunctionBlock.Create(this, b, a);
            this._eventSheetManager._RegisterFunctionBlock(a)
        }
        _CreateEventVariable(a, b, d) {
            a = e.EventVariable.Create(this, b, a);
            d.push(a)
        }
        _CreateInclude(a, b, d) {
            a = e.EventInclude.Create(this, b, a);
            d.push(a)
        }
        _CreateScriptBlock(a, b, d) {
            a = e.EventScript.Create(this, b, a);
            d.push(a)
        }
        _InitTrigger(a, b) {
            a.IsOrBlock() || this._eventSheetManager._AddTriggerToPostInit(a);
            var d =
                a.GetConditionAt(b),
                c = d._GetFunc(),
                f = d.GetObjectClass();
            if (d.IsFastTrigger()) {
                var k = this._fastTriggers.get(f);
                k || (k = new Map, this._fastTriggers.set(f, k));
                d = d.GetFastTriggerValue().toLowerCase();
                f = k.get(c);
                f || (f = new Map, k.set(c, f));
                c = f.get(d);
                c || (c = [], f.set(d, c));
                c.push([a, b])
            } else k = this._triggers.get(f), k || (k = {
                    methodMap: new Map,
                    behaviors: new Map
                }, this._triggers.set(f, k)), (f = d.GetBehaviorType()) ? (d = k.behaviors.get(f), d || (d = new Map, k.behaviors.set(f, d))) : d = k.methodMap, k = d.get(c), k || (k = [], d.set(c, k)),
                k.push([a, b])
        }
        _PostInit() {
            const a = this._events;
            for (let b = 0, d = a.length; b < d; ++b) {
                const c = b < d - 1 && a[b + 1] instanceof e.EventBlock && a[b + 1].IsElseBlock();
                a[b]._PostInit(c)
            }
        }
        _AddShallowInclude(a) {
            this._shallowIncludes.push(a)
        }
        _UpdateDeepIncludes() {
            e.clearArray(this._deepIncludes);
            this._AddDeepIncludes(this);
            this._alreadyIncludedSheets.clear()
        }
        _AddDeepIncludes(a) {
            const b = a._deepIncludes,
                d = a._alreadyIncludedSheets;
            for (const c of this._shallowIncludes) {
                const f = c.GetIncludeSheet();
                c.IsActive() && a !== f && !d.has(f) &&
                    (d.add(f), f._AddDeepIncludes(a), b.push(f))
            }
        }
        deepIncludes() {
            return this._deepIncludes
        }
        GetEventSheetManager() {
            return this._eventSheetManager
        }
        GetRuntime() {
            return this._runtime
        }
        GetName() {
            return this._name
        }
        _RegisterEventByDisplayNumber(a, b) {
            this._eventsByDisplayNumber.set(b, a)
        }
        _GetEventByDisplayNumber(a) {
            return this._eventsByDisplayNumber.get(a) || null
        }
        _ResetHasRunFlag() {
            this._hasRun = !1
        }
        Run() {
            if (!this._hasRun) {
                var a = this._runtime,
                    b = a.IsCPUProfiling(),
                    d = b ? performance.now() : 0;
                this._hasRun = !0;
                var c = this.GetEventSheetManager(),
                    f = c.GetCurrentEventStackFrame();
                for (const k of this._events) k.Run(f), c.ClearSol(k.GetSolModifiers()), c.ClearAsyncActionPromises(), a.FlushPendingInstances();
                f.Reset(null);
                b && (this._perfRecord.totalTimeCounter += performance.now() - d)
            }
        }* DebugRun() {
            if (!this._hasRun) {
                this._hasRun = !0;
                var a = this._runtime,
                    b = this.GetEventSheetManager(),
                    d = b.GetCurrentEventStackFrame();
                for (const c of this._events) yield* c.DebugRun(d), b.ClearSol(c.GetSolModifiers()), b.ClearAsyncActionPromises(), a.FlushPendingInstances();
                d.Reset(null)
            }
        }
        _Trigger(a,
            b, d) {
            if (b) {
                const c = b.GetObjectClass();
                this._TriggerForClass(a, b, c, d);
                for (const f of c.GetFamilies()) this._TriggerForClass(a, b, f, d)
            } else return this._TriggerForClass(a, b, null, null)
        }
        _TriggerForClass(a, b, d, c) {
            d = this._triggers.get(d);
            if (!d) return !1;
            c = c ? d.behaviors.get(c) : d.methodMap;
            if (!c) return !1;
            c = c.get(a);
            if (!c) return !1;
            a = !1;
            for (const [f, k] of c) c = this._ExecuteTrigger(b, f, k), a = a || c;
            return a
        }* _DebugTrigger(a, b, d) {
            if (b) {
                const c = b.GetObjectClass();
                yield* this._DebugTriggerForClass(a, b, c, d);
                for (const f of c.GetFamilies()) yield* this._DebugTriggerForClass(a,
                    b, f, d)
            } else return yield* this._DebugTriggerForClass(a, b, null, null)
        }* _DebugTriggerForClass(a, b, d, c) {
            d = this._triggers.get(d);
            if (!d) return !1;
            c = c ? d.behaviors.get(c) : d.methodMap;
            if (!c) return !1;
            c = c.get(a);
            if (!c) return !1;
            a = !1;
            for (const [f, k] of c) c = f.DebugCanRunFast() ? this._ExecuteTrigger(b, f, k) : yield* this._DebugExecuteTrigger(b, f, k), a = a || c;
            return a
        }
        _FastTrigger(a, b, d) {
            b = b.GetObjectClass();
            b = this._fastTriggers.get(b);
            if (!b) return !1;
            a = b.get(a);
            if (!a) return !1;
            d = a.get(d);
            if (!d) return !1;
            a = !1;
            for (let c = 0, f = d.length; c <
                f; ++c) b = d[c], b = this._ExecuteTrigger(null, b[0], b[1]), a = a || b;
            return a
        }* _DebugFastTrigger(a, b, d) {
            b = b.GetObjectClass();
            b = this._fastTriggers.get(b);
            if (!b) return !1;
            a = b.get(a);
            if (!a) return !1;
            d = a.get(d);
            if (!d) return !1;
            a = !1;
            for (let f = 0, k = d.length; f < k; ++f) {
                var c = d[f];
                b = c[0];
                c = c[1];
                b = b.DebugCanRunFast() ? this._ExecuteTrigger(null, b, c) : yield* this._DebugExecuteTrigger(null, b, c);
                a = a || b
            }
            return a
        }
        _ExecuteTrigger(a, b, d) {
            const c = this._runtime,
                f = this._eventSheetManager,
                k = f.GetCurrentEvent(),
                h = f.GetEventStack(),
                l = f.GetTriggerDepth();
            let n = !1;
            k && f.PushCleanSol(k.GetSolModifiersIncludingParents());
            f.PushCleanSol(b.GetSolModifiersIncludingParents());
            const u = 1 < l;
            u && f.GetLocalVarStack().Push();
            const w = h.Push(b);
            a && (b.GetConditions()[d].GetObjectClass().GetCurrentSol().SetSinglePicked(a), a.IsInContainer() && a.SetSiblingsSinglePicked());
            a = !0;
            if (b.GetParent()) {
                const q = b.GetTriggerParents();
                for (let t = 0, p = q.length; t < p; ++t)
                    if (!q[t].RunPreTrigger(w)) {
                        a = !1;
                        break
                    }
            }
            a && (c.IncrementExecCount(), b.IsOrBlock() ? b.RunOrBlockTrigger(w, d) : b.Run(w), n =
                w.GetLastEventTrue());
            h.Pop();
            u && f.GetLocalVarStack().Pop();
            f.PopSol(b.GetSolModifiersIncludingParents());
            k && f.PopSol(k.GetSolModifiersIncludingParents());
            k || 1 !== l || (f.ClearAsyncActionPromises(), f.IsFlushingBlocked() || c.FlushPendingInstances());
            return n
        }* _DebugExecuteTrigger(a, b, d) {
            const c = this._runtime,
                f = this._eventSheetManager,
                k = f.GetCurrentEvent(),
                h = f.GetEventStack(),
                l = f.GetTriggerDepth();
            let n = !1;
            k && f.PushCleanSol(k.GetSolModifiersIncludingParents());
            f.PushCleanSol(b.GetSolModifiersIncludingParents());
            const u = 1 < l;
            u && f.GetLocalVarStack().Push();
            const w = h.Push(b);
            a && (b.GetConditions()[d].GetObjectClass().GetCurrentSol().SetSinglePicked(a), a.IsInContainer() && a.SetSiblingsSinglePicked());
            a = !0;
            if (b.GetParent()) {
                const q = b.GetTriggerParents();
                for (let t = 0, p = q.length; t < p; ++t)
                    if (!(yield* q[t].DebugRunPreTrigger(w))) {
                        a = !1;
                        break
                    }
            }
            a && (c.IncrementExecCount(), b.IsOrBlock() ? yield* b.DebugRunOrBlockTrigger(w, d): yield* b.DebugRun(w), n = w.GetLastEventTrue());
            h.Pop();
            u && f.GetLocalVarStack().Pop();
            f.PopSol(b.GetSolModifiersIncludingParents());
            k && f.PopSol(k.GetSolModifiersIncludingParents());
            k || 1 !== l || (f.ClearAsyncActionPromises(), f.IsFlushingBlocked() || c.FlushPendingInstances());
            return n
        }
        _GetPerfRecord() {
            return this._perfRecord
        }
    }
} {
    "use strict";
    const e = self.C3,
        a = [];

    function b(c, f) {
        return !0
    }

    function* d(c, f) {
        return !0
    }
    e.EventBlock = class extends e.DefendedBase {
        constructor(c, f, k) {
            super();
            this._eventSheet = c;
            this._runtime = c.GetRuntime();
            this._parent = f;
            this._scopeParent = null;
            this._eventStack = this._runtime.GetEventSheetManager().GetEventStack();
            this._solModifiers = [];
            this._solModifiersIncludingParents = [];
            this._hasElseBlock = this._isTopLevelGroup = this._isSolWriterAfterCnds = this._hasGotSolModifiersIncludingParents = !1;
            this._isOrBlock = !!k[2];
            this._isElseBlock = !1;
            this._triggerParents = null;
            this._conditions = [];
            this._actions = [];
            this._subEvents = [];
            this._RunActions = b;
            this._DebugRunActions = d;
            this._isInitiallyActive = this._isGroup = !1;
            this._groupName = "";
            this._isGroupActive = !1;
            this._perfRecord = this._containedIncludes = null;
            this._sid = k[4];
            this._displayNumber = k[5];
            this._eventSheet._RegisterEventByDisplayNumber(this, this._displayNumber);
            this._debugData = this._runtime.IsDebug() ? {
                isBreakpoint: k[3][0],
                isBreakable: k[3][1],
                canRunAllConditionsFast: !1,
                canRunAllActionsFast: !1,
                canRunAllSubEventsFast: !1,
                canRunSelfFast: !1
            } : null;
            this.GetEventSheetManager()._RegisterEventBlock(this);
            3 === k[0] && this._InitGroup(k[1]);
            c = 0;
            for (var h of k[6]) f = e.Condition.Create(this, h, c++), this._conditions.push(f), this._AddSolModifier(f.GetObjectClass());
            c = 0;
            for (const l of k[7]) h = e.Action.Create(this, l, c++), this._actions.push(h);
            if (9 === k.length) {
                k = k[8];
                for (const l of k) this._eventSheet._CreateEvent(l, this, this._subEvents)
            }
            this._conditions.length && (this._isElseBlock = null === this._conditions[0].GetObjectClass() &&
                this._conditions[0]._GetFunc() === e.Plugins.System.Cnds.Else);
            0 === this._conditions.length && (this._conditions = a);
            0 === this._actions.length && (this._actions = a);
            0 === this._subEvents.length && (this._subEvents = a)
        }
        static Create(c, f, k) {
            return e.New(e.EventBlock, c, f, k)
        }
        _InitGroup(c) {
            this._isGroup = !0;
            this._isGroupActive = this._isInitiallyActive = !!c[0];
            this._groupName = c[1].toLowerCase();
            this._containedIncludes = [];
            this.GetEventSheetManager()._RegisterGroup(this);
            this._runtime.IsDebug() && (this._perfRecord = {
                type: "group",
                name: c[1],
                totalTimeCounter: 0,
                children: []
            })
        }
        _AddContainedInclude(c) {
            this._containedIncludes.push(c)
        }
        _AddContainerSolModifierToList(c, f) {
            for (const k of c.GetContainer().objectTypes()) f.includes(k) || f.push(k)
        }
        _AddSolModifierToList(c, f) {
            if (c)
                if (f.includes(c) || f.push(c), c.IsFamily())
                    for (const k of c.GetFamilyMembers()) k.IsInContainer() && this._AddContainerSolModifierToList(k, f);
                else c.IsInContainer() && this._AddContainerSolModifierToList(c, f)
        }
        _AddSolModifier(c) {
            this._AddSolModifierToList(c, this._solModifiers)
        }
        _AddParentSolModifier(c) {
            this._AddSolModifierToList(c,
                this._solModifiersIncludingParents)
        }
        SetAllSolModifiers() {
            this._solModifiers = this._runtime.GetAllObjectClasses()
        }
        _PostInit(c) {
            this._hasElseBlock = !!c;
            this._IdentifyTopLevelGroup();
            this._IdentifyTriggerParents();
            for (const k of this._conditions) k._PostInit();
            if (0 < this._actions.length) {
                c = !1;
                for (var f of this._actions) f._PostInit(), f.HasReturnType() && (c = !0);
                c ? (this._RunActions = this._RunActions_ReturnValue, this._DebugRunActions = this._DebugRunActions_ReturnValue) : (this._RunActions = this._RunActions_Fast, this._DebugRunActions =
                    this._DebugRunActions_Fast)
            }
            f = this._subEvents;
            for (let k = 0, h = f.length; k < h; ++k) c = k < h - 1 && f[k + 1] instanceof e.EventBlock && f[k + 1].IsElseBlock(), f[k]._PostInit(c);
            this._debugData && this._UpdateCanRunFast();
            this._perfRecord && this._GetPerfRecordParent()._GetPerfRecord().children.push(this._perfRecord)
        }
        _GetPerfRecord() {
            return this._perfRecord
        }
        _GetPerfRecordParent() {
            let c = this.GetParent();
            for (; c;) {
                if (c.IsGroup()) return c;
                c = c.GetParent()
            }
            return this._eventSheet
        }
        _UpdateCanRunFast() {
            const c = this._debugData;
            c.canRunAllConditionsFast =
                this._conditions.every(f => f.DebugCanRunFast());
            c.canRunAllActionsFast = this._actions.every(f => f.DebugCanRunFast());
            c.canRunAllSubEventsFast = this._subEvents.every(f => f.DebugCanRunFast());
            c.canRunSelfFast = c.canRunAllConditionsFast && c.canRunAllActionsFast && c.canRunAllSubEventsFast
        }
        _UpdateCanRunFastRecursive() {
            let c = this;
            do c._UpdateCanRunFast(), c = c.GetParent(); while (c)
        }
        _IdentifyTopLevelGroup() {
            if (this.IsGroup()) {
                var c = this.GetParent();
                for (this._isTopLevelGroup = !0; c;) {
                    if (!c.IsGroup()) {
                        this._isTopLevelGroup = !1;
                        break
                    }
                    c = c.GetParent()
                }
            }
        }
        _IdentifySolModifiersIncludingParents() {
            var c = this._runtime.GetAllObjectClasses();
            if (this._solModifiers === c) this._solModifiersIncludingParents = c;
            else {
                this._solModifiersIncludingParents = e.cloneArray(this._solModifiers);
                for (c = this.GetParent(); c;) {
                    for (var f of c._solModifiers) this._AddParentSolModifier(f);
                    c = c.GetParent()
                }
                f = this.GetEventSheetManager();
                this._solModifiers = f._DeduplicateSolModifierList(this._solModifiers);
                this._solModifiersIncludingParents = f._DeduplicateSolModifierList(this._solModifiersIncludingParents)
            }
        }
        _IdentifyTriggerParents() {
            if (this.HasAnyTriggeredCondition()) {
                this._triggerParents = [];
                for (var c = this.GetParent(); c;) this._triggerParents.push(c), c = c.GetParent();
                this._triggerParents.reverse()
            }
        }
        SetSolWriterAfterCnds() {
            this._isSolWriterAfterCnds = !0;
            this._parent && this._parent.SetSolWriterAfterCnds()
        }
        IsSolWriterAfterCnds() {
            return this._isSolWriterAfterCnds
        }
        GetSolModifiers() {
            return this._solModifiers
        }
        GetSolModifiersIncludingParents() {
            this._hasGotSolModifiersIncludingParents || (this._hasGotSolModifiersIncludingParents = !0, this._IdentifySolModifiersIncludingParents());
            return this._solModifiersIncludingParents
        }
        HasSolModifier(c) {
            return this._solModifiers.includes(c)
        }
        GetTriggerParents() {
            return this._triggerParents
        }
        GetEventSheet() {
            return this._eventSheet
        }
        GetEventSheetManager() {
            return this._eventSheet.GetEventSheetManager()
        }
        GetRuntime() {
            return this._runtime
        }
        GetParent() {
            return this._parent
        }
        _SetScopeParent(c) {
            this._scopeParent =
                c
        }
        GetScopeParent() {
            return this._scopeParent || this._parent
        }
        GetDisplayNumber() {
            return this._displayNumber
        }
        IsDebugBreakable() {
            return this._debugData && this._debugData.isBreakable
        }
        IsDebugBreakpoint() {
            return this.IsDebugBreakable() && this._debugData.isBreakpoint
        }
        _SetDebugBreakpoint(c) {
            this._debugData.isBreakpoint = !!c;
            this._UpdateCanRunFastRecursive()
        }
        IsGroup() {
            return this._isGroup
        }
        IsTopLevelGroup() {
            return this._isTopLevelGroup
        }
        IsElseBlock() {
            return this._isElseBlock
        }
        HasElseBlock() {
            return this._hasElseBlock
        }
        GetGroupName() {
            return this._groupName
        }
        IsGroupActive() {
            return this._isGroupActive
        }
        ResetInitialActivation() {
            this.SetGroupActive(this._isInitiallyActive)
        }
        SetGroupActive(c) {
            c = !!c;
            if (!this._isGroup) throw Error("not a group");
            if (this._isGroupActive !== c) {
                this._isGroupActive = c;
                for (const f of this._containedIncludes) f.UpdateActive();
                this._containedIncludes.length && (c = this._runtime.GetCurrentLayout().GetEventSheet()) && c._UpdateDeepIncludes()
            }
        }
        GetSID() {
            return this._sid
        }
        IsOrBlock() {
            return this._isOrBlock
        }
        IsTrigger() {
            return this._conditions.length && this._conditions[0].IsTrigger()
        }
        IsForFunctionBlock() {
            return this._scopeParent && this._scopeParent instanceof e.FunctionBlock
        }
        HasAnyTriggeredCondition() {
            return this.IsForFunctionBlock() ||
                this._conditions.some(c => c.IsTrigger())
        }
        GetConditions() {
            return this._conditions
        }
        GetConditionCount() {
            return this._conditions.length
        }
        GetConditionAt(c) {
            c = Math.floor(c);
            if (0 > c || c >= this._conditions.length) throw new RangeError("invalid condition index");
            return this._conditions[c]
        }
        GetConditionByDebugIndex(c) {
            return this.GetConditionAt(c)
        }
        IsFirstConditionOfType(c) {
            let f = c.GetIndex();
            if (0 === f) return !0;
            for (--f; 0 <= f; --f)
                if (this._conditions[f].GetObjectClass() === c.GetObjectClass()) return !1;
            return !0
        }
        GetActions() {
            return this._actions
        }
        GetActionCount() {
            return this._actions.length
        }
        GetActionAt(c) {
            c =
                Math.floor(c);
            if (0 > c || c >= this._actions.length) throw new RangeError("invalid action index");
            return this._actions[c]
        }
        GetActionByDebugIndex(c) {
            c = Math.floor(c);
            const f = this._actions.find(k => k.GetDebugIndex() === c);
            if (!f) throw new RangeError("invalid action debug index");
            return f
        }
        _HasActionIndex(c) {
            c = Math.floor(c);
            return 0 <= c && c < this._actions.length
        }
        GetSubEvents() {
            return this._subEvents
        }
        _GetAllLocalVariablesInScope() {
            return this._subEvents.filter(c => c instanceof e.EventVariable)
        }
        RunPreTrigger(c) {
            c.SetCurrentEvent(this);
            let f = !1;
            const k = this._conditions;
            for (let h = 0, l = k.length; h < l; ++h) {
                const n = k[h];
                c.SetConditionIndex(h);
                if (n.IsLooping()) throw Error("trigger cannot be used as sub-event to a loop");
                if (n.Run()) f = !0;
                else if (!this._isOrBlock) return !1
            }
            return this._isOrBlock ? f : !0
        }
        RunOrBlockTrigger(c, f) {
            c.SetCurrentEvent(this);
            this._conditions[f].Run() && (this._RunActions(c, 0) && this._RunSubEvents(c), c.SetLastEventTrue(!0))
        }* DebugRunPreTrigger(c) {
            c.SetCurrentEvent(this);
            let f = !1;
            const k = this._conditions;
            for (let h = 0, l = k.length; h <
                l; ++h) {
                const n = k[h];
                c.SetConditionIndex(h);
                if (n.IsLooping()) throw Error("trigger cannot be used as sub-event to a loop");
                if (n.DebugCanRunFast() ? n.Run() : yield* n.DebugRun()) f = !0;
                else if (!this._isOrBlock) return !1
            }
            return this._isOrBlock ? f : !0
        }* DebugRunOrBlockTrigger(c, f) {
            c.SetCurrentEvent(this);
            f = this._conditions[f];
            if (f.DebugCanRunFast() ? f.Run() : yield* f.DebugRun())(this.DebugCanRunActionsFast() ? this._RunActions(c, 0) : yield* this._DebugRunActions(c, 0)) && (this.DebugCanRunSubEventsFast() ? this._RunSubEvents() :
                yield* this._DebugRunSubEvents()), c.SetLastEventTrue(!0)
        }
        Run(c) {
            c.SetCurrentEvent(this);
            this._isElseBlock || c.SetElseBranchRan(!1);
            this._isOrBlock ? this._RunOrBlock(c) : this._RunAndBlock(c)
        }* DebugRun(c) {
            if (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext()) yield this;
            c.SetCurrentEvent(this);
            this._isElseBlock || c.SetElseBranchRan(!1);
            this._isOrBlock ? yield* this._DebugRunOrBlock(c): yield* this._DebugRunAndBlock(c)
        }
        _RunOrBlock(c) {
            const f = this._conditions;
            let k = 0 === f.length;
            for (let l = 0, n = f.length; l < n; ++l) {
                var h =
                    f[l];
                h.IsTrigger() || (c.SetConditionIndex(l), h = h.Run(), k = k || h)
            }
            c.SetLastEventTrue(k);
            k && (this._RunActions(c, 0) && this._RunSubEvents(c), this._hasElseBlock && c.SetElseBranchRan(!0))
        }* _DebugRunOrBlock(c) {
            const f = this._conditions;
            let k = 0 === f.length;
            for (let l = 0, n = f.length; l < n; ++l) {
                var h = f[l];
                h.IsTrigger() || (c.SetConditionIndex(l), h = h.DebugCanRunFast() ? h.Run() : yield* h.DebugRun(), k = k || h)
            }
            c.SetLastEventTrue(k);
            k && ((this.DebugCanRunActionsFast() ? this._RunActions(c, 0) : yield* this._DebugRunActions(c, 0)) && (this.DebugCanRunSubEventsFast() ?
                this._RunSubEvents() : yield* this._DebugRunSubEvents()), this._hasElseBlock && c.SetElseBranchRan(!0))
        }
        _RunAndBlock(c) {
            const f = this._conditions;
            for (let k = 0, h = f.length; k < h; ++k) {
                const l = f[k];
                c.SetConditionIndex(k);
                if (!l.Run()) {
                    c.SetLastEventTrue(!1);
                    return
                }
            }
            c.SetLastEventTrue(!0);
            this._RunActions(c, 0) && this._RunSubEvents(c);
            c.GetLastEventTrue() && this._hasElseBlock && c.SetElseBranchRan(!0)
        }* _DebugRunAndBlock(c) {
            const f = this._conditions;
            for (let k = 0, h = f.length; k < h; ++k) {
                const l = f[k];
                c.SetConditionIndex(k);
                if (l.DebugCanRunFast() ?
                    !l.Run() : !(yield* l.DebugRun())) {
                    c.SetLastEventTrue(!1);
                    return
                }
            }
            c.SetLastEventTrue(!0);
            (this.DebugCanRunActionsFast() ? this._RunActions(c, 0) : yield* this._DebugRunActions(c, 0)) && (this.DebugCanRunSubEventsFast() ? this._RunSubEvents() : yield* this._DebugRunSubEvents());
            c.GetLastEventTrue() && this._hasElseBlock && c.SetElseBranchRan(!0)
        }
        _RunActions_Fast(c, f) {
            const k = this._actions;
            for (let h = f, l = k.length; h < l; ++h) f = k[h], c.SetActionIndex(h), f.Run();
            return !0
        }* _DebugRunActions_Fast(c, f) {
            const k = this._actions;
            for (let h =
                    f, l = k.length; h < l; ++h) f = k[h], c.SetActionIndex(h), f.DebugCanRunFast() ? f.Run() : yield* f.DebugRun();
            return !0
        }
        _RunActions_ReturnValue(c, f) {
            const k = this.GetEventSheetManager(),
                h = this._actions;
            for (let l = f, n = h.length; l < n; ++l) {
                f = h[l];
                c.SetActionIndex(l);
                const u = f.Run();
                if (f.CanBailOut() && !0 === u) return !1;
                f.IsAsync() && u instanceof Promise && k.AddAsyncActionPromise(u)
            }
            return !0
        }* _DebugRunActions_ReturnValue(c, f) {
            const k = this.GetEventSheetManager(),
                h = this._actions;
            for (let l = f, n = h.length; l < n; ++l) {
                f = h[l];
                c.SetActionIndex(l);
                let u;
                u = f.DebugCanRunFast() ? f.Run() : yield* f.DebugRun();
                if (f.CanBailOut() && !0 === u) return !1;
                f.IsAsync() && u instanceof Promise && k.AddAsyncActionPromise(u)
            }
            return !0
        }
        _ResumeActionsAndSubEvents(c) {
            this._RunActions(c, c.GetActionIndex()) && this._RunSubEvents()
        }* _DebugResumeActionsAndSubEvents(c) {
            if (yield* this._DebugRunActions(c, c.GetActionIndex())) yield* this._DebugRunSubEvents()
        }
        _RunSubEvents() {
            if (this._subEvents.length) {
                var c = this.IsGroup() && this._runtime.IsCPUProfiling(),
                    f = c ? performance.now() : 0,
                    k = this._eventStack,
                    h = k.Push(this);
                this._isSolWriterAfterCnds ? this._RunSubEvents_SolWriterAfterCnds(h) : this._RunSubEvents_Fast(h);
                k.Pop();
                c && (this._perfRecord.totalTimeCounter += performance.now() - f)
            }
        }
        _RunSubEvents_SolWriterAfterCnds(c) {
            const f = this._isGroup,
                k = this._isTopLevelGroup,
                h = this.GetEventSheetManager(),
                l = this._subEvents;
            for (let n = 0, u = l.length, w = u - 1; n < u; ++n) {
                const q = l[n],
                    t = q.GetSolModifiers(),
                    p = !k || !f && n < w;
                p && h.PushCopySol(t);
                q.Run(c);
                p ? h.PopSol(t) : h.ClearSol(t)
            }
        }
        _RunSubEvents_Fast(c) {
            const f = this._subEvents;
            for (let k =
                    0, h = f.length; k < h; ++k) f[k].Run(c)
        }* _DebugRunSubEvents() {
            if (this._subEvents.length) {
                var c = this._eventStack,
                    f = c.Push(this);
                this._isSolWriterAfterCnds ? yield* this._DebugRunSubEvents_SolWriterAfterCnds(f): yield* this._DebugRunSubEvents_Fast(f);
                c.Pop()
            }
        }* _DebugRunSubEvents_SolWriterAfterCnds(c) {
            const f = this._isGroup,
                k = this._isTopLevelGroup,
                h = this.GetEventSheetManager(),
                l = this._subEvents;
            for (let n = 0, u = l.length, w = u - 1; n < u; ++n) {
                const q = l[n],
                    t = q.GetSolModifiers(),
                    p = !k || !f && n < w;
                p && h.PushCopySol(t);
                yield* q.DebugRun(c);
                p ? h.PopSol(t) : h.ClearSol(t)
            }
        }* _DebugRunSubEvents_Fast(c) {
            const f = this._subEvents;
            for (let k = 0, h = f.length; k < h; ++k) yield* f[k].DebugRun(c)
        }
        Retrigger(c, f) {
            this._runtime.IncrementExecCount();
            f.ResetQuick();
            const k = this._conditions;
            if (!this.IsOrBlock())
                for (let h = c.GetConditionIndex() + 1, l = k.length; h < l; ++h)
                    if (c = k[h], f.SetConditionIndex(h), !c.Run()) return !1;
            this._RunActions(f, 0) && this._RunSubEvents(f);
            return !0
        }* DebugRetrigger(c, f) {
            this._runtime.IncrementExecCount();
            f.ResetQuick();
            const k = this._conditions;
            if (!this.IsOrBlock())
                for (let h =
                        c.GetConditionIndex() + 1, l = k.length; h < l; ++h)
                    if (c = k[h], f.SetConditionIndex(h), c.DebugCanRunFast() ? !c.Run() : !(yield* c.DebugRun())) return !1;
            (this.DebugCanRunActionsFast() ? this._RunActions(f, 0) : yield* this._DebugRunActions(f, 0)) && (this.DebugCanRunSubEventsFast() ? this._RunSubEvents() : yield* this._DebugRunSubEvents());
            return !0
        }
        DebugCanRunFast() {
            return !this.IsDebugBreakpoint() && !this._runtime.DebugBreakNext() && this._debugData.canRunSelfFast
        }
        DebugCanRunActionsFast() {
            return !this._runtime.DebugBreakNext() && this._debugData.canRunAllActionsFast
        }
        DebugCanRunSubEventsFast() {
            return !this._runtime.DebugBreakNext() &&
                this._debugData.canRunAllSubEventsFast
        }
        _CheckParentsOKToRun(c) {
            if (this.GetParent()) {
                const f = this.GetTriggerParents();
                for (let k = 0, h = f.length; k < h; ++k)
                    if (!f[k].RunPreTrigger(c)) return !1
            }
            return !0
        }* _DebugCheckParentsOKToRun(c) {
            if (this.GetParent()) {
                const f = this.GetTriggerParents();
                for (let k = 0, h = f.length; k < h; ++k)
                    if (!(yield* f[k].DebugRunPreTrigger(c))) return !1
            }
            return !0
        }
        _EvaluateFunctionCallParameters(c, f, k) {
            0 < f.length ? k ? (f = f.map(h => h.Get(0)), c.GetLocalVarStack().Push(), this._scopeParent.SetFunctionParameters(f)) :
                this._scopeParent.EvaluateFunctionParameters(f) : k && c.GetLocalVarStack().Push()
        }
        RunAsFunctionCall(c, f) {
            let k, h;
            const l = 0 < c.length;
            var n = this._runtime;
            const u = this._eventStack,
                w = n.GetEventSheetManager(),
                q = 1 < w._IncTriggerDepth();
            this._EvaluateFunctionCallParameters(w, f, q);
            l && w.PushCleanSol(c);
            f = u.Push(this);
            this._CheckParentsOKToRun(f) && (n.IncrementExecCount(), f.SetCurrentEvent(this), (n = this._scopeParent.IsAsync()) && ([h, k] = this._scopeParent.StartAsyncFunctionCall()), this._RunAndBlock(f), n && this._scopeParent.MaybeFinishAsyncFunctionCall(h));
            u.Pop();
            q && w.GetLocalVarStack().Pop();
            l && w.PopSol(c);
            w._DecTriggerDepth();
            return k
        }* DebugRunAsFunctionCall(c, f) {
            let k, h;
            if (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext()) yield this;
            const l = 0 < c.length;
            var n = this._runtime;
            const u = this._eventStack,
                w = n.GetEventSheetManager(),
                q = 1 < w._IncTriggerDepth();
            this._EvaluateFunctionCallParameters(w, f, q);
            l && w.PushCleanSol(c);
            f = u.Push(this);
            if (yield* this._DebugCheckParentsOKToRun(f)) n.IncrementExecCount(), f.SetCurrentEvent(this), (n = this._scopeParent.IsAsync()) &&
                ([h, k] = this._scopeParent.StartAsyncFunctionCall()), yield* this._DebugRunAndBlock(f), n && this._scopeParent.MaybeFinishAsyncFunctionCall(h);
            u.Pop();
            q && w.GetLocalVarStack().Pop();
            l && w.PopSol(c);
            w._DecTriggerDepth();
            return k
        }
        RunAsMappedFunctionCall(c) {
            const f = this.GetSolModifiersIncludingParents(),
                k = 0 < f.length,
                h = this._runtime,
                l = this._eventStack,
                n = h.GetEventSheetManager(),
                u = 1 < n._IncTriggerDepth();
            u && n.GetLocalVarStack().Push();
            this._scopeParent.SetFunctionParameters(c);
            k && n.PushCleanSol(f);
            c = l.Push(this);
            this._CheckParentsOKToRun(c) && (h.IncrementExecCount(), c.SetCurrentEvent(this), this._RunAndBlock(c));
            l.Pop();
            u && n.GetLocalVarStack().Pop();
            k && n.PopSol(f);
            n._DecTriggerDepth()
        }* DebugRunAsMappedFunctionCall(c) {
            if (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext()) yield this;
            const f = this.GetSolModifiersIncludingParents(),
                k = 0 < f.length,
                h = this._runtime,
                l = this._eventStack,
                n = h.GetEventSheetManager(),
                u = 1 < n._IncTriggerDepth();
            u && n.GetLocalVarStack().Push();
            this._scopeParent.SetFunctionParameters(c);
            k &&
                n.PushCleanSol(f);
            c = l.Push(this);
            if (yield* this._DebugCheckParentsOKToRun(c)) h.IncrementExecCount(), c.SetCurrentEvent(this), yield* this._DebugRunAndBlock(c);
            l.Pop();
            u && n.GetLocalVarStack().Pop();
            k && n.PopSol(f);
            n._DecTriggerDepth()
        }
        RunAsExpressionFunctionCall(c, f, k, ...h) {
            let l, n;
            const u = 0 < c.length,
                w = this._runtime,
                q = this._eventStack,
                t = w.GetEventSheetManager(),
                p = 1 < t._IncTriggerDepth();
            p && t.GetLocalVarStack().Push();
            0 < h.length && this._scopeParent.SetFunctionParameters(h);
            u && t.PushCleanSol(c);
            h = q.Push(this);
            h.InitCallFunctionExpression(f, k);
            q.PushExpFunc(h);
            w.SetDebuggingEnabled(!1);
            this._CheckParentsOKToRun(h) && (w.IncrementExecCount(), h.SetCurrentEvent(this), (f = this._scopeParent.IsAsync()) && ([n, l] = this._scopeParent.StartAsyncFunctionCall()), this._RunAndBlock(h), f && this._scopeParent.MaybeFinishAsyncFunctionCall(n));
            w.SetDebuggingEnabled(!0);
            q.Pop();
            q.PopExpFunc();
            p && t.GetLocalVarStack().Pop();
            u && t.PopSol(c);
            t._DecTriggerDepth();
            return l || h.GetFunctionReturnValue()
        }
    }
} {
    "use strict";
    const e = self.C3,
        a = [];
    let b = !1;
    e.EventScript = class extends e.DefendedBase {
        constructor(d, c, f) {
            super();
            const k = d.GetRuntime(),
                h = d.GetEventSheetManager();
            this._eventSheet = d;
            this._eventSheetManager = h;
            this._runtime = d.GetRuntime();
            this._parent = c;
            this._func = k.GetObjectReference(f[1]);
            this._displayNumber = f[2];
            this._eventSheet._RegisterEventByDisplayNumber(this, this._displayNumber);
            this._debugData = k.IsDebug() ? {
                isBreakpoint: f[3][0],
                isBreakable: f[3][1]
            } : null
        }
        static Create(d, c, f) {
            return e.New(e.EventScript,
                d, c, f)
        }
        _PostInit() {
            const d = this._func,
                c = this._runtime.GetEventSheetManager()._GetLocalVariablesScriptInterface(this);
            this._func = d.bind(null, this._runtime.GetIRuntime(), c)
        }
        GetParent() {
            return this._parent
        }
        GetScopeParent() {
            return this._parent
        }
        GetEventSheet() {
            return this._eventSheet
        }
        GetDisplayNumber() {
            return this._displayNumber
        }
        IsDebugBreakable() {
            return this._debugData && this._debugData.isBreakable
        }
        IsDebugBreakpoint() {
            return this.IsDebugBreakable() && this._debugData.isBreakpoint
        }
        _SetDebugBreakpoint(d) {
            this._debugData.isBreakpoint = !!d
        }
        IsElseBlock() {
            return !1
        }
        GetSolModifiers() {
            return a
        }
        GetSolModifiersIncludingParents() {
            return this._parent ? this._parent.GetSolModifiersIncludingParents() : a
        }
        Run(d) {
            d.SetCurrentEvent(this);
            this._eventSheetManager.AddAsyncActionPromise(this._RunUserScript())
        }
        async _RunUserScript() {
            try {
                await this._func()
            } catch (d) {
                console.error(`Unhandled exception running script %c${this.GetEventSheet().GetName()}, event ${this.GetDisplayNumber()}:`, "font-size: 1.2em; font-weight: bold;", d), self.C3Debugger && self.C3Debugger._SetLastErrorScript(this),
                    b || (console.info("%cTip:%c run this to highlight in Construct the last script that had an error: %cgoToLastErrorScript()", "font-weight: bold; text-decoration: underline", "", "font-weight: bold"), b = !0)
            }
        }* DebugRun(d) {
            d.SetCurrentEvent(this);
            if (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext()) yield this;
            this.Run(d)
        }
        DebugCanRunFast() {
            return !this.IsDebugBreakpoint() && !this._runtime.DebugBreakNext()
        }
        static HadUserScriptException() {
            return b
        }
        static SetHadUserScriptException() {
            b = !0
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.FunctionBlock = class extends e.DefendedBase {
        constructor(a, b, d) {
            super();
            this._eventSheet = a;
            this._runtime = a.GetRuntime();
            this._parent = b;
            const c = d[1];
            this._functionName = c[0];
            this._returnType = c[1];
            this._functionParameters = c[2].map(f => e.EventVariable.Create(a, this, f));
            this._isEnabled = c[3];
            this._innerLocalVariables = [];
            this._isAsync = c[4];
            this._nextAsyncId = 0;
            this._currentAsyncId = -1;
            this._asyncMap = new Map;
            this._eventBlock = e.EventBlock.Create(a, b, d);
            this._eventBlock._SetScopeParent(this)
        }
        static Create(a,
            b, d) {
            return e.New(e.FunctionBlock, a, b, d)
        }
        _PostInit() {
            for (const a of this._functionParameters) a._PostInit();
            this._eventBlock._PostInit(!1)
        }
        _GetAllLocalVariablesInScope() {
            return this._functionParameters
        }
        GetFunctionParameters() {
            return this._functionParameters
        }
        GetFunctionParameterCount() {
            return this._functionParameters.length
        }
        _RegisterLocalVariable(a) {
            this._innerLocalVariables.push(a)
        }
        _GetAllInnerLocalVariables() {
            return this._innerLocalVariables
        }
        EvaluateFunctionParameters(a) {
            const b = this._functionParameters;
            for (let d = 0, c = b.length; d < c; ++d) b[d].SetValue(a[d].Get(0))
        }
        SetFunctionParameters(a) {
            const b = this._functionParameters;
            for (let d = 0, c = b.length; d < c; ++d) b[d].SetValue(a[d])
        }
        CaptureFunctionParameters() {
            return this._functionParameters.map(a => a.GetValue())
        }
        GetParent() {
            return this._parent
        }
        GetScopeParent() {
            return this._parent
        }
        GetFunctionName() {
            return this._functionName
        }
        GetReturnType() {
            return this._returnType
        }
        IsEnabled() {
            return this._isEnabled
        }
        GetDefaultReturnValue() {
            switch (this._returnType) {
                case 0:
                    return null;
                case 2:
                    return "";
                default:
                    return 0
            }
        }
        GetEventBlock() {
            return this._eventBlock
        }
        IsAsync() {
            return this._isAsync
        }
        StartAsyncFunctionCall() {
            const a = this._nextAsyncId++;
            this._currentAsyncId = a;
            let b;
            const d = new Promise(c => b = c);
            this._asyncMap.set(a, {
                resolve: b,
                pauseCount: 0
            });
            return [a, d]
        }
        MaybeFinishAsyncFunctionCall(a) {
            const b = this._asyncMap.get(a);
            0 === b.pauseCount && (b.resolve(), this._asyncMap.delete(a));
            this._currentAsyncId = -1
        }
        PauseCurrentAsyncFunction() {
            this._asyncMap.get(this._currentAsyncId).pauseCount++;
            return this._currentAsyncId
        }
        ResumeAsyncFunction(a) {
            this._currentAsyncId =
                a;
            this._asyncMap.get(a).pauseCount--
        }
    }
} {
    "use strict";
    const e = self.C3,
        a = [];
    e.EventVariable = class extends e.DefendedBase {
        constructor(b, d, c) {
            super();
            const f = b.GetEventSheetManager();
            this._eventSheet = b;
            this._eventSheetManager = f;
            this._runtime = b.GetRuntime();
            this._parent = d;
            this._localVarStack = f.GetLocalVarStack();
            this._name = c[1];
            this._type = c[2];
            this._initialValue = c[3];
            this._isStatic = !!c[4];
            this._isConstant = !!c[5];
            this._isFunctionParameter = d instanceof e.FunctionBlock;
            this._sid = c[6];
            this._jsPropName = this._runtime.GetJsPropName(c[8]);
            this._scriptSetter =
                k => this.SetValue(k);
            this._scriptGetter = () => this.GetValue();
            this._hasSingleValue = !this._parent || this._isStatic || this._isConstant;
            this._value = this._initialValue;
            this._localIndex = -1;
            this.IsBoolean() && (this._value = this._value ? 1 : 0);
            !this.IsLocal() || this.IsStatic() || this.IsConstant() || (this._localIndex = f._GetNextLocalVarIndex(this));
            f._RegisterEventVariable(this)
        }
        static Create(b, d, c) {
            return e.New(e.EventVariable, b, d, c)
        }
        _PostInit() {
            if (this.IsLocal() && !this.IsStatic() && !this.IsConstant() && !this.IsFunctionParameter()) {
                const b =
                    this._eventSheetManager.FindFirstFunctionBlockParent(this);
                b && b._RegisterLocalVariable(this)
            }
        }
        GetName() {
            return this._name
        }
        GetJsPropName() {
            return this._jsPropName
        }
        GetParent() {
            return this._parent
        }
        GetScopeParent() {
            return this.GetParent()
        }
        IsGlobal() {
            return !this.GetParent()
        }
        IsLocal() {
            return !this.IsGlobal()
        }
        IsFunctionParameter() {
            return this._isFunctionParameter
        }
        IsStatic() {
            return this._isStatic
        }
        IsConstant() {
            return this._isConstant
        }
        IsNumber() {
            return 0 === this._type
        }
        IsString() {
            return 1 === this._type
        }
        IsBoolean() {
            return 2 ===
                this._type
        }
        IsElseBlock() {
            return !1
        }
        GetSID() {
            return this._sid
        }
        GetInitialValue() {
            return this._initialValue
        }
        GetSolModifiers() {
            return a
        }
        Run(b) {
            !this.IsLocal() || this.IsStatic() || this.IsConstant() || this.SetValue(this.GetInitialValue())
        }
        DebugCanRunFast() {
            return !0
        }* DebugRun(b) {
            this.Run(b)
        }
        SetValue(b) {
            this.IsNumber() ? "number" !== typeof b && (b = parseFloat(b)) : this.IsString() ? "string" !== typeof b && (b = b.toString()) : this.IsBoolean() && (b = b ? 1 : 0);
            this._hasSingleValue ? this._value = b : this._localVarStack.GetCurrent()[this._localIndex] =
                b
        }
        GetValue() {
            return this._hasSingleValue ? this._value : this._localVarStack.GetCurrent()[this._localIndex]
        }
        GetTypedValue() {
            let b = this.GetValue();
            this.IsBoolean() && (b = !!b);
            return b
        }
        ResetToInitialValue() {
            this._value = this._initialValue
        }
        _GetScriptInterfaceDescriptor() {
            return {
                configurable: !1,
                enumerable: !0,
                get: this._scriptGetter,
                set: this._scriptSetter
            }
        }
    }
} {
    "use strict";
    const e = self.C3,
        a = [];
    e.EventInclude = class extends e.DefendedBase {
        constructor(b, d, c) {
            super();
            const f = b.GetEventSheetManager();
            this._eventSheet = b;
            this._eventSheetManager = f;
            this._runtime = b.GetRuntime();
            this._parent = d;
            this._includeSheet = null;
            this._includeSheetName = c[1];
            this._isActive = !0
        }
        static Create(b, d, c) {
            return e.New(e.EventInclude, b, d, c)
        }
        _PostInit() {
            this._includeSheet = this._eventSheetManager.GetEventSheetByName(this._includeSheetName);
            this._eventSheet._AddShallowInclude(this);
            let b =
                this.GetParent();
            for (; b;) b instanceof e.EventBlock && b.IsGroup() && b._AddContainedInclude(this), b = b.GetParent();
            this.UpdateActive();
            this._runtime.IsDebug() && this._eventSheet._GetPerfRecord().children.push(this._includeSheet._GetPerfRecord())
        }
        GetParent() {
            return this._parent
        }
        GetSolModifiers() {
            return a
        }
        GetIncludeSheet() {
            return this._includeSheet
        }
        Run(b) {
            b = !!this.GetParent();
            const d = this._runtime.GetAllObjectClasses();
            b && this._eventSheetManager.PushCleanSol(d);
            this._includeSheet.Run();
            b && this._eventSheetManager.PopSol(d)
        }* DebugRun(b) {
            b = !!this.GetParent();
            const d = this._runtime.GetAllObjectClasses();
            b && this._eventSheetManager.PushCleanSol(d);
            yield* this._includeSheet.DebugRun();
            b && this._eventSheetManager.PopSol(d)
        }
        DebugCanRunFast() {
            return !1
        }
        IsActive() {
            return this._isActive
        }
        UpdateActive() {
            let b = this.GetParent();
            for (; b;) {
                if (b instanceof e.EventBlock && b.IsGroup() && !b.IsGroupActive()) {
                    this._isActive = !1;
                    return
                }
                b = b.GetParent()
            }
            this._isActive = !0
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.ExpNode = class extends e.DefendedBase {
        constructor(l) {
            super();
            this._owner = l;
            this._runtime = l.GetRuntime()
        }
        _PostInit() {}
        static CreateNode(l, n) {
            return e.New([k, c, f, h, a, b][n[0]], l, n)
        }
    };
    class a extends e.ExpNode {
        constructor(l, n) {
            super(l);
            this._systemPlugin = this._runtime.GetSystemPlugin();
            this._func = this._runtime.GetObjectReference(n[1]);
            this._func !== e.Plugins.System.Exps.random && this._func !== e.Plugins.System.Exps.choose || this._owner.SetVariesPerInstance()
        }
        GetBoundMethod() {
            return this._systemPlugin._GetBoundACEMethod(this._func,
                this._systemPlugin)
        }
    }
    class b extends e.ExpNode {
        constructor(l, n) {
            super(l);
            this._functionBlock = null;
            this._functionName = n[1];
            this._owner.SetVariesPerInstance()
        }
        _PostInit() {
            const l = this._runtime.GetEventSheetManager();
            this._functionBlock = l.GetFunctionBlockByName(this._functionName);
            this._functionName = null;
            const n = this._owner.GetEventBlock(),
                u = this._functionBlock.GetEventBlock();
            this._combinedSolModifiers = [...new Set([...n.GetSolModifiersIncludingParents(), ...u.GetSolModifiersIncludingParents()])];
            this._combinedSolModifiers =
                l._DeduplicateSolModifierList(this._combinedSolModifiers)
        }
        GetBoundMethod() {
            const l = this._functionBlock;
            if (l.IsEnabled()) {
                const n = l.GetEventBlock();
                return e.EventBlock.prototype.RunAsExpressionFunctionCall.bind(n, this._combinedSolModifiers, l.GetReturnType(), l.GetDefaultReturnValue())
            } {
                const n = l.GetDefaultReturnValue();
                return () => n
            }
        }
    }

    function d(l, n) {
        if (l >= n) return l % n;
        0 > l && (l <= -n && (l %= n), 0 > l && (l += n));
        return l
    }
    class c extends e.ExpNode {
        constructor(l, n) {
            super(l);
            this._objectClass = this._runtime.GetObjectClassByIndex(n[1]);
            this._func = this._runtime.GetObjectReference(n[2]);
            this._returnsString = !!n[3];
            this._eventStack = this._runtime.GetEventSheetManager().GetEventStack();
            this._owner._MaybeVaryFor(this._objectClass)
        }
        GetBoundMethod() {
            return this._objectClass.GetPlugin()._GetBoundACEMethod(this._func, this._objectClass.GetSingleGlobalInstance().GetSdkInstance())
        }
        ExpObject(...l) {
            const n = this._objectClass,
                u = n.GetCurrentSol().GetExpressionInstances();
            var w = u.length;
            if (0 === w) return this._returnsString ? "" : 0;
            w = d(this._owner.GetSolIndex(),
                w);
            this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(n);
            return this._func.apply(u[w].GetSdkInstance(), l)
        }
        ExpObject_InstExpr(l, ...n) {
            const u = this._objectClass,
                w = u.GetInstances(),
                q = w.length;
            if (0 === q) return this._returnsString ? "" : 0;
            l = d(l, q);
            this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(u);
            return this._func.apply(w[l].GetSdkInstance(), n)
        }
    }
    class f extends e.ExpNode {
        constructor(l, n) {
            super(l);
            this._objectClass = this._runtime.GetObjectClassByIndex(n[1]);
            this._varIndex = n[3];
            this._returnsString = !!n[2];
            this._owner._MaybeVaryFor(this._objectClass)
        }
        ExpInstVar() {
            const l = this._objectClass.GetCurrentSol().GetExpressionInstances();
            var n = l.length;
            if (0 === n) return this._returnsString ? "" : 0;
            n = d(this._owner.GetSolIndex(), n);
            return l[n]._GetInstanceVariableValueUnchecked(this._varIndex)
        }
        ExpInstVar_Family() {
            var l = this._objectClass,
                n = l.GetCurrentSol().GetExpressionInstances(),
                u = n.length;
            if (0 === u) return this._returnsString ? "" : 0;
            u = d(this._owner.GetSolIndex(), u);
            n = n[u];
            l = n.GetObjectClass().GetFamilyInstanceVariableOffset(l.GetFamilyIndex());
            return n._GetInstanceVariableValueUnchecked(this._varIndex + l)
        }
        ExpInstVar_InstExpr(l) {
            const n = this._objectClass;
            var u = n.GetInstances();
            const w = u.length;
            if (0 === w) return this._returnsString ? "" : 0;
            l = d(l, w);
            u = u[l];
            l = 0;
            n.IsFamily() && (l = u.GetObjectClass().GetFamilyInstanceVariableOffset(n.GetFamilyIndex()));
            return u._GetInstanceVariableValueUnchecked(this._varIndex + l)
        }
    }
    class k extends e.ExpNode {
        constructor(l, n) {
            super(l);
            this._objectClass = this._runtime.GetObjectClassByIndex(n[1]);
            this._behaviorType = this._objectClass.GetBehaviorTypeByName(n[2]);
            this._behaviorIndex = this._objectClass.GetBehaviorIndexByName(n[2]);
            this._func = this._runtime.GetObjectReference(n[3]);
            this._returnsString = !!n[4];
            this._eventStack = this._runtime.GetEventSheetManager().GetEventStack();
            this._owner._MaybeVaryFor(this._objectClass)
        }
        ExpBehavior(...l) {
            const n = this._objectClass;
            var u = n.GetCurrentSol().GetExpressionInstances(),
                w = u.length;
            if (0 === w) return this._returnsString ? "" : 0;
            w = d(this._owner.GetSolIndex(), w);
            this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(n);
            u = u[w];
            w = 0;
            n.IsFamily() && (w = u.GetObjectClass().GetFamilyBehaviorOffset(n.GetFamilyIndex()));
            return this._func.apply(u.GetBehaviorInstances()[this._behaviorIndex + w].GetSdkInstance(), l)
        }
        ExpBehavior_InstExpr(l, ...n) {
            const u = this._objectClass;
            var w = u.GetInstances();
            const q = w.length;
            if (0 === q) return this._returnsString ? "" : 0;
            l = d(l, q);
            this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(u);
            w = w[l];
            l = 0;
            u.IsFamily() && (l = w.GetObjectClass().GetFamilyBehaviorOffset(u.GetFamilyIndex()));
            return this._func.apply(w.GetBehaviorInstances()[this._behaviorIndex +
                l].GetSdkInstance(), n)
        }
    }
    class h extends e.ExpNode {
        constructor(l, n) {
            super(l);
            this._eventVar = null;
            this._eventVarSid = n[1]
        }
        _PostInit() {
            this._eventVar = this._runtime.GetEventSheetManager().GetEventVariableBySID(this._eventVarSid)
        }
        GetVar() {
            return this._eventVar
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Parameter = class extends e.DefendedBase {
        constructor(y, E, G) {
            super();
            this._owner = y;
            this._index = G;
            this._type = E;
            this.Get = null;
            this._isConstant = this._variesPerInstance = !1
        }
        static Create(y, E, G) {
            const A = E[0];
            return e.New([b, d, u, f, h, c, l, b, f, f, w, q, u, p, d, n, k, t, r, x][A], y, A, G, E)
        }
        _PostInit() {}
        SetVariesPerInstance() {
            this._variesPerInstance = !0
        }
        _MaybeVaryFor(y) {
            this._variesPerInstance || !y || y.GetPlugin().IsSingleGlobal() || (this._variesPerInstance = !0)
        }
        VariesPerInstance() {
            return this._variesPerInstance
        }
        GetIndex() {
            return this._index
        }
        GetRuntime() {
            return this._owner.GetRuntime()
        }
        GetEventBlock() {
            return this._owner.GetEventBlock()
        }
        IsConstant() {
            return this._isConstant
        }
    };

    function a(y) {
        y = self.C3_ExpressionFuncs[y];
        if (!y) throw Error("invalid expression number");
        return y
    }
    class b extends e.Parameter {
        constructor(y, E, G, A) {
            super(y, E, G);
            this._solIndex = 0;
            y = A[1];
            this._expressionNumber = y[0];
            this._numberedNodes = [];
            this._expressionFunc = null;
            for (let F = 1, J = y.length; F < J; ++F) this._numberedNodes.push(e.ExpNode.CreateNode(this, y[F]));
            this._numberedNodes.length ? this.Get = this.GetExpression : (this.Get = a(this._expressionNumber), this._isConstant = !0)
        }
        _GetNode(y) {
            if (0 > y || y >= this._numberedNodes.length) throw new RangeError("invalid numbered node");
            return this._numberedNodes[y]
        }
        _PostInit() {
            for (var y of this._numberedNodes) y._PostInit();
            y = a(this._expressionNumber);
            this._expressionFunc = this._numberedNodes.length ? y(this) : y
        }
        GetSolIndex() {
            return this._solIndex
        }
        GetExpression(y) {
            this._solIndex = y;
            return this._expressionFunc()
        }
    }
    class d extends b {
        constructor(y, E, G, A) {
            super(y, E, G, A);
            this.Get = this.GetStringExpression;
            14 === E && (this.GetEventBlock().SetAllSolModifiers(), this._owner instanceof e.Action && this.GetEventBlock().SetSolWriterAfterCnds())
        }
        GetStringExpression(y) {
            this._solIndex =
                y;
            y = this._expressionFunc();
            return "string" === typeof y ? y : ""
        }
        _GetFastTriggerValue() {
            return a(this._expressionNumber)()
        }
    }
    class c extends b {
        constructor(y, E, G, A) {
            super(y, E, G, A);
            this.Get = this.GetLayer;
            this._isConstant = !1
        }
        GetLayer(y) {
            this._solIndex = y;
            y = this._expressionFunc();
            return this.GetRuntime().GetCurrentLayout().GetLayer(y)
        }
    }
    class f extends e.Parameter {
        constructor(y, E, G, A) {
            super(y, E, G);
            this._combo = A[1];
            this.Get = this.GetCombo;
            this._isConstant = !0
        }
        GetCombo() {
            return this._combo
        }
    }
    class k extends e.Parameter {
        constructor(y,
            E, G, A) {
            super(y, E, G);
            this._bool = A[1];
            this.Get = this.GetBoolean;
            this._isConstant = !0
        }
        GetBoolean() {
            return this._bool
        }
    }
    class h extends e.Parameter {
        constructor(y, E, G, A) {
            super(y, E, G);
            this._objectClass = this.GetRuntime().GetObjectClassByIndex(A[1]);
            this.Get = this.GetObjectClass;
            y = this.GetEventBlock();
            y._AddSolModifier(this._objectClass);
            this._owner instanceof e.Action ? y.SetSolWriterAfterCnds() : y.GetParent() && y.GetParent().SetSolWriterAfterCnds();
            this._isConstant = !0
        }
        GetObjectClass() {
            return this._objectClass
        }
    }
    class l extends e.Parameter {
        constructor(y, E, G, A) {
            super(y, E, G);
            this._layout = this.GetRuntime().GetLayoutManager().GetLayoutByName(A[1]);
            this.Get = this.GetLayout;
            this._isConstant = !0
        }
        GetLayout() {
            return this._layout
        }
    }
    class n extends e.Parameter {
        constructor(y, E, G, A) {
            super(y, E, G);
            this._timeline = this.GetRuntime().GetTimelineManager().GetTimelineByName(A[1]);
            this.Get = this.GetTimeline;
            this._isConstant = !0
        }
        GetTimeline() {
            return this._timeline
        }
    }
    class u extends e.Parameter {
        constructor(y, E, G, A) {
            super(y, E, G);
            this._fileInfo =
                A[1];
            this.Get = this.GetFile;
            this._isConstant = !0
        }
        GetFile() {
            return this._fileInfo
        }
    }
    class w extends e.Parameter {
        constructor(y, E, G, A) {
            super(y, E, G);
            this._instVarIndex = A[1];
            (y = this._owner.GetObjectClass()) && y.IsFamily() ? (this.Get = this.GetFamilyInstanceVariable, this.SetVariesPerInstance()) : (this.Get = this.GetInstanceVariable, this._isConstant = !0)
        }
        GetInstanceVariable() {
            return this._instVarIndex
        }
        GetFamilyInstanceVariable(y) {
            y = y || 0;
            const E = this._owner.GetObjectClass();
            var G = E.GetCurrentSol();
            const A = G.GetInstances();
            if (A.length) y = A[y % A.length].GetObjectClass();
            else if (G.HasAnyElseInstances()) G = G.GetElseInstances(), y = G[y % G.length].GetObjectClass();
            else if (0 < E.GetInstanceCount()) G = E.GetInstances(), y = G[y % G.length].GetObjectClass();
            else return 0;
            return this._instVarIndex + y.GetFamilyInstanceVariableOffset(E.GetFamilyIndex())
        }
    }
    class q extends e.Parameter {
        constructor(y, E, G, A) {
            super(y, E, G);
            this._eventVarSid = A[1];
            this._eventVar = null;
            this.Get = this.GetEventVariable;
            this._isConstant = !0
        }
        _PostInit() {
            this._eventVar = this.GetRuntime().GetEventSheetManager().GetEventVariableBySID(this._eventVarSid)
        }
        GetEventVariable() {
            return this._eventVar
        }
    }
    class t extends e.Parameter {
        constructor(y, E, G, A) {
            super(y, E, G);
            this._functionBlockName = A[1];
            this._functionBlock = null;
            this.Get = this.GetFunction;
            this._isConstant = !0
        }
        _PostInit() {
            this._functionBlock = this.GetRuntime().GetEventSheetManager().GetFunctionBlockByName(this._functionBlockName);
            this._functionBlockName = null
        }
        GetFunction() {
            return this._functionBlock
        }
    }
    class p extends e.Parameter {
        constructor(y, E, G, A) {
            super(y, E, G);
            this._subParams = [];
            this._variadicRet = [];
            this._isConstant = !0;
            for (let F = 1, J = A.length; F <
                J; ++F) y = e.Parameter.Create(this._owner, A[F], 0), this._subParams.push(y), this._variadicRet.push(0), y.IsConstant() || (this._isConstant = !1);
            this.Get = this.GetVariadic
        }
        _PostInit() {
            for (const y of this._subParams) y._PostInit()
        }
        GetVariadic() {
            const y = this._subParams,
                E = this._variadicRet;
            for (let G = 0, A = y.length; G < A; ++G) E[G] = y[G].Get(0);
            return E
        }
    }
    class r extends e.Parameter {
        constructor(y, E, G, A) {
            super(y, E, G);
            this._easeIndex = A[1];
            this.Get = this.GetEase;
            this._isConstant = !0
        }
        GetEase() {
            return this._easeIndex
        }
    }
    class x extends e.Parameter {
        constructor(y,
            E, G, A) {
            super(y, E, G);
            this._brushIndex = A[1];
            this.Get = this.GetTilemapBrush;
            this._isConstant = !0
        }
        GetTilemapBrush() {
            return this._brushIndex
        }
    }
} {
    "use strict";
    const e = self.C3;

    function a(c, f) {
        for (let k = 0, h = c.length; k < h; ++k) f[k] = c[k].Get(0)
    }
    const b = [],
        d = function () {};
    e.Condition = class extends e.DefendedBase {
        constructor(c, f, k) {
            super();
            this._eventBlock = c;
            this._runtime = c.GetRuntime();
            this._index = k;
            this._func = this._runtime.GetObjectReference(f[1]);
            this._isTrigger = 0 < f[3];
            this._isFastTrigger = 2 === f[3];
            this._isLooping = !!f[4];
            this._isInverted = !!f[5];
            this._isStatic = !!f[6];
            this._sid = f[7];
            this._isInOrBlock = this._eventBlock.IsOrBlock();
            this._behaviorType =
                this._objectClass = null;
            this._behaviorIndex = -1;
            this._systemPlugin = null;
            this.DebugRun = this.Run = d;
            this._parameters = [];
            this._results = [];
            this._anyParamVariesPerInstance = !1;
            this._unsavedData = this._savedData = null;
            this._debugData = this._runtime.IsDebug() ? {
                isBreakpoint: f[8][0],
                canDebug: f[8][1]
            } : null; - 1 === f[0] ? this._systemPlugin = this._runtime.GetSystemPlugin() : (this._objectClass = this._runtime.GetObjectClassByIndex(f[0]), f[2] && (this._behaviorType = this._objectClass.GetBehaviorTypeByName(f[2]), this._behaviorIndex =
                this._objectClass.GetBehaviorIndexByName(f[2])), this._eventBlock.GetParent() && this._eventBlock.GetParent().SetSolWriterAfterCnds());
            if (10 === f.length) {
                c = f[9];
                for (let h of c) this._parameters.push(e.Parameter.Create(this, h, this._parameters.length)), this._results.push(0)
            }
            0 === this._parameters.length && (this._results = this._parameters = b);
            this._eventBlock.GetEventSheetManager()._RegisterCondition(this)
        }
        static Create(c, f, k) {
            return e.New(e.Condition, c, f, k)
        }
        _PostInit() {
            for (const c of this._parameters) c._PostInit(),
                c.VariesPerInstance() && (this._anyParamVariesPerInstance = !0);
            this._isFastTrigger ? (this.Run = this._RunFastTrigger, this.DebugRun = this._DebugRunFastTrigger) : this._systemPlugin ? (this._SetSystemRunMethod(), this.DebugRun = this._DebugRunSystem) : this._objectClass.GetPlugin().IsSingleGlobal() ? (this._SetSingleGlobalRunMethod(), this.DebugRun = this._DebugRunSingleGlobal) : this._isStatic ? (this.Run = this._RunStatic, this.DebugRun = this._DebugRunStatic) : (this.Run = this._RunObject, this.DebugRun = this._DebugRunObject)
        }
        _SetSystemRunMethod() {
            this._SetRunMethodForBoundFunc(this._systemPlugin,
                this._systemPlugin, this._RunSystem)
        }
        _SetSingleGlobalRunMethod() {
            const c = this._objectClass.GetPlugin(),
                f = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();
            this._SetRunMethodForBoundFunc(c, f, this._RunSingleGlobal)
        }
        _SetRunMethodForBoundFunc(c, f, k) {
            const h = this._func,
                l = this._isInverted,
                n = this._parameters;
            if (0 === n.length) {
                const u = c._GetBoundACEMethod(h, f);
                this.Run = l ? function () {
                    return e.xor(u(), l)
                } : u
            } else if (1 === n.length) {
                const u = n[0];
                if (!l && u.IsConstant()) this.Run = c._GetBoundACEMethod_1param(h,
                    f, u.Get(0));
                else {
                    const w = c._GetBoundACEMethod(h, f);
                    this.Run = function () {
                        return e.xor(w(u.Get(0)), l)
                    }
                }
            } else if (2 === n.length) {
                const u = n[0],
                    w = n[1];
                if (!l && u.IsConstant() && w.IsConstant()) this.Run = c._GetBoundACEMethod_2params(h, f, u.Get(0), w.Get(0));
                else {
                    const q = c._GetBoundACEMethod(h, f);
                    this.Run = function () {
                        return e.xor(q(u.Get(0), w.Get(0)), l)
                    }
                }
            } else if (3 === n.length) {
                const u = n[0],
                    w = n[1],
                    q = n[2];
                if (!l && u.IsConstant() && w.IsConstant() && q.IsConstant()) this.Run = c._GetBoundACEMethod_3params(h, f, u.Get(0), w.Get(0),
                    q.Get(0));
                else {
                    const t = c._GetBoundACEMethod(h, f);
                    this.Run = function () {
                        return e.xor(t(u.Get(0), w.Get(0), q.Get(0)), l)
                    }
                }
            } else this.Run = k
        }
        GetSID() {
            return this._sid
        }
        _GetFunc() {
            return this._func
        }
        GetObjectClass() {
            return this._objectClass
        }
        GetBehaviorType() {
            return this._behaviorType
        }
        GetEventBlock() {
            return this._eventBlock
        }
        GetRuntime() {
            return this._runtime
        }
        GetIndex() {
            return this._index
        }
        GetDebugIndex() {
            return this.GetIndex()
        }
        IsTrigger() {
            return this._isTrigger
        }
        IsFastTrigger() {
            return this._isFastTrigger
        }
        IsInverted() {
            return this._isInverted
        }
        IsLooping() {
            return this._isLooping
        }
        IsBreakpoint() {
            return this._debugData.isBreakpoint
        }
        _SetBreakpoint(c) {
            this._debugData.isBreakpoint = !!c;
            this._eventBlock._UpdateCanRunFastRecursive()
        }
        _DebugReturnsGenerator() {
            return this._debugData.canDebug
        }
        DebugCanRunFast() {
            return !this.IsBreakpoint() && !this._runtime.DebugBreakNext() && !this._DebugReturnsGenerator()
        }
        GetSavedDataMap() {
            this._savedData || (this._savedData = new Map);
            return this._savedData
        }
        GetUnsavedDataMap() {
            this._unsavedData || (this._unsavedData = new Map);
            return this._unsavedData
        }
        _RunSystem() {
            const c = this._results;
            a(this._parameters, c);
            return e.xor(this._func.apply(this._systemPlugin, c),
                this._isInverted)
        }* _DebugRunSystem() {
            if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this;
            if (this._DebugReturnsGenerator()) {
                var c = this._results;
                a(this._parameters, c);
                c = this._func.apply(this._systemPlugin, c);
                e.IsIterator(c) && (c = yield* c);
                return e.xor(c, this._isInverted)
            }
            return this.Run()
        }
        _RunSingleGlobal() {
            const c = this._results;
            a(this._parameters, c);
            const f = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();
            return e.xor(this._func.apply(f, c), this._isInverted)
        }* _DebugRunSingleGlobal() {
            if (this.IsBreakpoint() ||
                this._runtime.DebugBreakNext()) yield this;
            if (this._DebugReturnsGenerator()) {
                var c = this._results;
                a(this._parameters, c);
                const f = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();
                c = this._func.apply(f, c);
                e.IsIterator(c) && (c = yield* c);
                return e.xor(c, this._isInverted)
            }
            return this.Run()
        }
        _RunFastTrigger() {
            return !0
        }* _DebugRunFastTrigger() {
            if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this;
            return !0
        }
        _RunStatic() {
            var c = this._results;
            a(this._parameters, c);
            c = this._func.apply(this._behaviorType ||
                this._objectClass, c);
            this._objectClass.ApplySolToContainer();
            return c
        }* _DebugRunStatic() {
            if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this;
            if (this._DebugReturnsGenerator()) {
                var c = this._results;
                a(this._parameters, c);
                c = this._func.apply(this._behaviorType || this._objectClass, c);
                e.IsIterator(c) && (c = yield* c);
                this._objectClass.ApplySolToContainer();
                return c
            }
            return this.Run()
        }
        _RunObject() {
            const c = this._parameters,
                f = this._results,
                k = this._objectClass.GetCurrentSol();
            for (let h = 0, l = c.length; h <
                l; ++h) {
                const n = c[h];
                n.VariesPerInstance() || (f[h] = n.Get(0))
            }
            return k.IsSelectAll() ? this._RunObject_FirstFilter(k) : this._RunObject_NextFilter(k)
        }* _DebugRunObject() {
            if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this;
            return this._RunObject()
        }
        _EvaluateVaryingParameters(c) {
            const f = this._parameters,
                k = this._results;
            for (let h = 0, l = f.length; h < l; ++h) {
                const n = f[h];
                n.VariesPerInstance() && (k[h] = n.Get(c))
            }
        }
        _RunObject_FirstFilter(c) {
            const f = this._objectClass,
                k = f.IsFamily(),
                h = f.GetFamilyIndex(),
                l = this._behaviorIndex,
                n = 0 <= l,
                u = f.GetInstances(),
                w = this._anyParamVariesPerInstance,
                q = this._results,
                t = this._func,
                p = this._isInverted,
                r = this._isInOrBlock && !this._isTrigger;
            c.ClearArrays();
            for (let y = 0, E = u.length; y < E; ++y) {
                const G = u[y];
                w && this._EvaluateVaryingParameters(y);
                var x = void 0;
                n ? (x = k ? G.GetObjectClass().GetFamilyBehaviorOffset(h) : 0, x = t.apply(G.GetBehaviorInstances()[l + x].GetSdkInstance(), q)) : x = t.apply(G.GetSdkInstance(), q);
                e.xor(x, p) ? c._PushInstance(G) : r && c._PushElseInstance(G)
            }
            f.FinishCondition(!0);
            c._SetSelectAll(!1);
            f.ApplySolToContainer();
            return c.HasAnyInstances()
        }
        _RunObject_NextFilter(c) {
            const f = this._objectClass;
            var k = f.IsFamily();
            const h = f.GetFamilyIndex(),
                l = f.IsInContainer(),
                n = this._behaviorIndex,
                u = 0 <= n,
                w = this._anyParamVariesPerInstance,
                q = this._results,
                t = this._func,
                p = this._isInverted,
                r = this._isInOrBlock && !this._isTrigger,
                x = c._GetOwnInstances(),
                y = c._GetOwnElseInstances(),
                E = r && !this._eventBlock.IsFirstConditionOfType(this),
                G = E ? y : x;
            let A = 0,
                F = !1;
            for (let B = 0, I = G.length; B < I; ++B) {
                const L = G[B];
                w && this._EvaluateVaryingParameters(B);
                var J = void 0;
                u ? (J = k ? L.GetObjectClass().GetFamilyBehaviorOffset(h) : 0, J = t.apply(L.GetBehaviorInstances()[n + J].GetSdkInstance(), q)) : J = t.apply(L.GetSdkInstance(), q);
                e.xor(J, p) ? (F = !0, E ? (x.push(L), l && L._PushSiblingsToSolInstances()) : (G[A] = L, l && L._SetSiblingsToSolInstancesIndex(A), ++A)) : E ? (G[A] = L, l && L._SetSiblingsToSolElseInstancesIndex(A), ++A) : r && (y.push(L), l && L._PushSiblingsToSolElseInstances())
            }
            e.truncateArray(G, A);
            l && f._TruncateContainerSols(E, A);
            k = F;
            E && !F && (F = this._OrBlockCheckInstances(x));
            f.FinishCondition(k ||
                r);
            return r ? F : c.HasAnyInstances()
        }
        _OrBlockCheckInstances(c) {
            var f = this._objectClass;
            const k = f.IsFamily();
            f = f.GetFamilyIndex();
            const h = this._anyParamVariesPerInstance,
                l = this._behaviorIndex,
                n = 0 <= l,
                u = this._results,
                w = this._func,
                q = this._isInverted;
            for (let p = 0, r = c.length; p < r; ++p) {
                var t = c[p];
                h && this._EvaluateVaryingParameters(p);
                if (n) {
                    const x = k ? t.GetObjectClass().GetFamilyBehaviorOffset(f) : 0;
                    t = w.apply(t.GetBehaviorInstances()[l + x].GetSdkInstance(), u)
                } else t = w.apply(t.GetSdkInstance(), u);
                if (e.xor(t, q)) return !0
            }
            return !1
        }
        ReevaluateParameter(c,
            f) {
            return this._parameters[c].Get(f)
        }
        GetFastTriggerValue() {
            const c = this._parameters;
            if (!c.length) throw Error("no parameters");
            return c[0]._GetFastTriggerValue()
        }
        _SaveToJson() {
            if (!this._savedData || !this._savedData.size) return null;
            const c = {};
            for (const [f, k] of this._savedData.entries()) {
                let h = k;
                "collmemory" === f && (h = [...k.entries()].map(l => [l[0].GetUID(), l[1].GetUID(), l[2]]));
                c[f] = h
            }
            return {
                ex: c
            }
        }
        _LoadFromJson(c) {
            this._savedData && (this._savedData.clear(), this._savedData = null);
            if (c) {
                var f = this._runtime,
                    k = c.ex;
                if (k) {
                    c = this.GetSavedDataMap();
                    c.clear();
                    for (const [h, l] of Object.entries(k)) k = l, "collmemory" === h && (k = e.New(e.PairMap, l.map(n => [f.GetInstanceByUID(n[0]), f.GetInstanceByUID(n[1]), n[2]]).filter(n => n[0] && n[1]))), c.set(h, k)
                }
            }
        }
    }
} {
    "use strict";
    const e = self.C3;

    function a(f, k) {
        for (let h = 0, l = f.length; h < l; ++h) k[h] = f[h].Get(0)
    }
    const b = [],
        d = function () {},
        c = function* () {};
    e.Action = class extends e.DefendedBase {
        constructor(f, k, h) {
            super();
            this._eventBlock = f;
            this._runtime = f = f.GetRuntime();
            this._index = h;
            this._sid = 4 <= k.length ? k[3] : -1;
            this._actionReturnType = 5 <= k.length ? k[4] : 0;
            this._behaviorType = this._objectClass = this._func = null;
            this._behaviorIndex = -1;
            this._systemPlugin = null;
            this._callFunctionName = "";
            this._combinedSolModifiers = this._callEventBlock =
                null;
            this.DebugRun = this.Run = d;
            this._parameters = [];
            this._results = [];
            this._anyParamVariesPerInstance = !1;
            this._unsavedData = this._savedData = null;
            const l = (h = -3 === k[0]) ? k[2] : k[5];
            this._debugData = f.IsDebug() || h ? {
                isBreakpoint: l[0],
                canDebug: l[1],
                index: l[2]
            } : null; - 1 === k[0] ? (this._systemPlugin = f.GetSystemPlugin(), this._func = f.GetObjectReference(k[1])) : -2 === k[0] ? this._callFunctionName = k[1] : h ? (this._func = f.GetObjectReference(k[1]), this.Run = this.RunUserScript, this.DebugRun = this.DebugRunUserScript, this._actionReturnType =
                1) : (this._func = f.GetObjectReference(k[1]), this._objectClass = f.GetObjectClassByIndex(k[0]), k[2] && (this._behaviorType = this._objectClass.GetBehaviorTypeByName(k[2]), this._behaviorIndex = this._objectClass.GetBehaviorIndexByName(k[2])));
            if (7 === k.length) {
                k = k[6];
                for (const n of k) this._parameters.push(e.Parameter.Create(this, n, this._parameters.length)), this._results.push(0)
            }
            0 === this._parameters.length && (this._results = this._parameters = b);
            this._eventBlock.GetEventSheetManager()._RegisterAction(this)
        }
        static Create(f,
            k, h) {
            return e.New(e.Action, f, k, h)
        }
        _PostInit() {
            for (var f of this._parameters) f._PostInit(), f.VariesPerInstance() && (this._anyParamVariesPerInstance = !0);
            if (this._systemPlugin) this._SetSystemRunMethod(), this.DebugRun = this._DebugRunSystem;
            else if (this._callFunctionName) this._SetCallFunctionRunMethod(), this._callFunctionName = "";
            else if (this.Run === this.RunUserScript) {
                f = this._func;
                const k = this._runtime.GetEventSheetManager()._GetLocalVariablesScriptInterface(this._eventBlock);
                this._func = f.bind(null, this._runtime.GetIRuntime(),
                    k)
            } else this._behaviorType ? this.IsAsync() ? (this.Run = this._RunBehavior_Async, this.DebugRun = this._DebugRunBehavior_Async) : (this.Run = this._RunBehavior, this.DebugRun = this._DebugRunBehavior) : this._objectClass.GetPlugin().IsSingleGlobal() ? (this._SetSingleGlobalRunMethod(), this.DebugRun = this._DebugRunSingleGlobal) : this.IsAsync() ? (this.Run = this._RunObject_Async, this.DebugRun = this._DebugRunObject_Async) : this._parameters.length ? this._parameters.every(k => k.VariesPerInstance()) ? (this.Run = this._RunObject_AllParamsVary,
                this.DebugRun = this._DebugRunObject_AllParamsVary) : this._anyParamVariesPerInstance ? (this.Run = this._RunObject_SomeParamsVary, this.DebugRun = this._DebugRunObject_SomeParamsVary) : this._parameters.every(k => k.IsConstant()) ? (a(this._parameters, this._results), this.Run = this._RunObject_ParamsConst, this.DebugRun = this._DebugRunObject_ParamsConst) : (this.Run = this._RunObject_ParamsDontVary, this.DebugRun = this._DebugRunObject_ParamsDontVary) : (this.Run = this._RunObject_ParamsConst, this.DebugRun = this._DebugRunObject_ParamsConst)
        }
        _SetSystemRunMethod() {
            this._SetRunMethodForBoundFunc(this._systemPlugin,
                this._systemPlugin, this._RunSystem)
        }
        _SetSingleGlobalRunMethod() {
            const f = this._objectClass.GetPlugin(),
                k = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();
            this._SetRunMethodForBoundFunc(f, k, this._RunSingleGlobal)
        }
        _SetCallFunctionRunMethod() {
            const f = this._eventBlock.GetEventSheetManager(),
                k = f.GetFunctionBlockByName(this._callFunctionName);
            k.IsEnabled() ? (this._callEventBlock = k.GetEventBlock(), this._combinedSolModifiers = [...new Set([...this._eventBlock.GetSolModifiersIncludingParents(), ...this._callEventBlock.GetSolModifiersIncludingParents()])],
                this._combinedSolModifiers = f._DeduplicateSolModifierList(this._combinedSolModifiers), this.Run = e.EventBlock.prototype.RunAsFunctionCall.bind(this._callEventBlock, this._combinedSolModifiers, this._parameters), this.DebugRun = this._DebugRunCallFunction) : (this.Run = d, this.DebugRun = c)
        }
        _SetRunMethodForBoundFunc(f, k, h) {
            const l = this._func,
                n = this._parameters;
            if (0 === n.length) this.Run = f._GetBoundACEMethod(l, k);
            else if (1 === n.length) {
                const u = n[0];
                if (u.IsConstant()) this.Run = f._GetBoundACEMethod_1param(l, k, u.Get(0));
                else {
                    const w = f._GetBoundACEMethod(l, k);
                    this.Run = function () {
                        return w(u.Get(0))
                    }
                }
            } else if (2 === n.length) {
                const u = n[0],
                    w = n[1];
                if (u.IsConstant() && w.IsConstant()) this.Run = f._GetBoundACEMethod_2params(l, k, u.Get(0), w.Get(0));
                else {
                    const q = f._GetBoundACEMethod(l, k);
                    this.Run = function () {
                        return q(u.Get(0), w.Get(0))
                    }
                }
            } else if (3 === n.length) {
                const u = n[0],
                    w = n[1],
                    q = n[2];
                if (u.IsConstant() && w.IsConstant() && q.IsConstant()) this.Run = f._GetBoundACEMethod_3params(l, k, u.Get(0), w.Get(0), q.Get(0));
                else {
                    const t = f._GetBoundACEMethod(l,
                        k);
                    this.Run = function () {
                        return t(u.Get(0), w.Get(0), q.Get(0))
                    }
                }
            } else this.Run = h
        }
        GetSID() {
            return this._sid
        }
        IsAsync() {
            return 1 === this._actionReturnType
        }
        CanBailOut() {
            return 2 === this._actionReturnType
        }
        HasReturnType() {
            return 0 !== this._actionReturnType
        }
        GetObjectClass() {
            return this._objectClass
        }
        GetEventBlock() {
            return this._eventBlock
        }
        GetRuntime() {
            return this._runtime
        }
        GetIndex() {
            return this._index
        }
        GetDebugIndex() {
            return this._debugData.index
        }
        GetCombinedSolModifiers() {
            return this._combinedSolModifiers
        }
        IsBreakpoint() {
            return this._debugData.isBreakpoint
        }
        _SetBreakpoint(f) {
            this._debugData.isBreakpoint = !!f;
            this._eventBlock._UpdateCanRunFastRecursive()
        }
        _DebugReturnsGenerator() {
            return this._debugData.canDebug
        }
        DebugCanRunFast() {
            return !this.IsBreakpoint() && !this._runtime.DebugBreakNext() && !this._DebugReturnsGenerator()
        }
        GetSavedDataMap() {
            this._savedData || (this._savedData = new Map);
            return this._savedData
        }
        GetUnsavedDataMap() {
            this._unsavedData || (this._unsavedData = new Map);
            return this._unsavedData
        }
        _RunSystem() {
            const f = this._results;
            a(this._parameters, f);
            return this._func.apply(this._systemPlugin, f)
        }* _DebugRunSystem() {
            if (this.IsBreakpoint() ||
                this._runtime.DebugBreakNext()) yield this;
            if (this._DebugReturnsGenerator()) {
                const f = this._results;
                a(this._parameters, f);
                return yield* this._func.apply(this._systemPlugin, f)
            }
            return this.Run()
        }* _DebugRunCallFunction() {
            if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this;
            return yield* this._callEventBlock.DebugRunAsFunctionCall(this._combinedSolModifiers, this._parameters)
        }
        _RunSingleGlobal() {
            const f = this._results;
            a(this._parameters, f);
            return this._func.apply(this._objectClass.GetSingleGlobalInstance().GetSdkInstance(),
                f)
        }* _DebugRunSingleGlobal() {
            if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this;
            if (this._DebugReturnsGenerator()) {
                const f = this._results;
                a(this._parameters, f);
                return yield* this._func.apply(this._objectClass.GetSingleGlobalInstance().GetSdkInstance(), f)
            }
            return this.Run()
        }
        _RunObject_ParamsConst() {
            const f = this._results,
                k = this._objectClass.GetCurrentSol().GetInstances();
            for (let h = 0, l = k.length; h < l; ++h) this._func.apply(k[h].GetSdkInstance(), f)
        }* _DebugRunObject_ParamsConst() {
            if (this.IsBreakpoint() ||
                this._runtime.DebugBreakNext()) yield this;
            if (this._DebugReturnsGenerator()) {
                const f = this._results,
                    k = this._objectClass.GetCurrentSol().GetInstances();
                for (let h = 0, l = k.length; h < l; ++h) yield* this._func.apply(k[h].GetSdkInstance(), f)
            } else this._RunObject_ParamsConst()
        }
        _RunObject_ParamsDontVary() {
            const f = this._results;
            a(this._parameters, f);
            const k = this._objectClass.GetCurrentSol().GetInstances();
            for (let h = 0, l = k.length; h < l; ++h) this._func.apply(k[h].GetSdkInstance(), f)
        }* _DebugRunObject_ParamsDontVary() {
            if (this.IsBreakpoint() ||
                this._runtime.DebugBreakNext()) yield this;
            if (this._DebugReturnsGenerator()) {
                const f = this._results;
                a(this._parameters, f);
                const k = this._objectClass.GetCurrentSol().GetInstances();
                for (let h = 0, l = k.length; h < l; ++h) yield* this._func.apply(k[h].GetSdkInstance(), f)
            } else this._RunObject_ParamsDontVary()
        }
        _RunObject_AllParamsVary() {
            const f = this._parameters,
                k = this._results,
                h = this._func,
                l = this._objectClass.GetCurrentSol().GetInstances();
            for (let n = 0, u = l.length; n < u; ++n) {
                const w = l[n];
                for (let q = 0, t = f.length; q < t; ++q) k[q] =
                    f[q].Get(n);
                h.apply(w.GetSdkInstance(), k)
            }
        }* _DebugRunObject_AllParamsVary() {
            if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this;
            if (this._DebugReturnsGenerator()) {
                const f = this._parameters,
                    k = this._results,
                    h = this._func,
                    l = this._objectClass.GetCurrentSol().GetInstances();
                for (let n = 0, u = l.length; n < u; ++n) {
                    const w = l[n];
                    for (let q = 0, t = f.length; q < t; ++q) k[q] = f[q].Get(n);
                    yield* h.apply(w.GetSdkInstance(), k)
                }
            } else this._RunObject_AllParamsVary()
        }
        _RunObject_SomeParamsVary() {
            const f = this._parameters,
                k = this._results,
                h = this._func,
                l = this._objectClass.GetCurrentSol().GetInstances();
            for (let u = 0, w = f.length; u < w; ++u) {
                var n = f[u];
                n.VariesPerInstance() || (k[u] = n.Get(0))
            }
            for (let u = 0, w = l.length; u < w; ++u) {
                n = l[u];
                for (let q = 0, t = f.length; q < t; ++q) {
                    const p = f[q];
                    p.VariesPerInstance() && (k[q] = p.Get(u))
                }
                h.apply(n.GetSdkInstance(), k)
            }
        }* _DebugRunObject_SomeParamsVary() {
            if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this;
            if (this._DebugReturnsGenerator()) {
                const k = this._parameters,
                    h = this._results,
                    l = this._func,
                    n = this._objectClass.GetCurrentSol().GetInstances();
                for (let u = 0, w = k.length; u < w; ++u) {
                    var f = k[u];
                    f.VariesPerInstance() || (h[u] = f.Get(0))
                }
                for (let u = 0, w = n.length; u < w; ++u) {
                    f = n[u];
                    for (let q = 0, t = k.length; q < t; ++q) {
                        const p = k[q];
                        p.VariesPerInstance() && (h[q] = p.Get(u))
                    }
                    yield* l.apply(f.GetSdkInstance(), h)
                }
            } else this._RunObject_SomeParamsVary()
        }
        _RunBehavior() {
            var f = this._objectClass;
            const k = f.IsFamily(),
                h = f.GetFamilyIndex(),
                l = this._parameters,
                n = this._anyParamVariesPerInstance,
                u = this._results,
                w = this._func,
                q = this._behaviorIndex;
            f = f.GetCurrentSol().GetInstances();
            for (let r = 0, x = l.length; r < x; ++r) {
                var t = l[r];
                t.VariesPerInstance() || (u[r] = t.Get(0))
            }
            for (let r = 0, x = f.length; r < x; ++r) {
                t = f[r];
                if (n)
                    for (let y = 0, E = l.length; y < E; ++y) {
                        var p = l[y];
                        p.VariesPerInstance() && (u[y] = p.Get(r))
                    }
                p = k ? t.GetObjectClass().GetFamilyBehaviorOffset(h) : 0;
                w.apply(t.GetBehaviorInstances()[q + p].GetSdkInstance(), u)
            }
        }* _DebugRunBehavior() {
            if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this;
            if (this._DebugReturnsGenerator()) {
                var f = this._objectClass;
                const l =
                    f.IsFamily(),
                    n = f.GetFamilyIndex(),
                    u = this._parameters,
                    w = this._anyParamVariesPerInstance,
                    q = this._results,
                    t = this._func,
                    p = this._behaviorIndex;
                f = f.GetCurrentSol().GetInstances();
                for (let r = 0, x = u.length; r < x; ++r) {
                    var k = u[r];
                    k.VariesPerInstance() || (q[r] = k.Get(0))
                }
                for (let r = 0, x = f.length; r < x; ++r) {
                    k = f[r];
                    if (w)
                        for (let y = 0, E = u.length; y < E; ++y) {
                            var h = u[y];
                            h.VariesPerInstance() && (q[y] = h.Get(r))
                        }
                    h = l ? k.GetObjectClass().GetFamilyBehaviorOffset(n) : 0;
                    yield* t.apply(k.GetBehaviorInstances()[p + h].GetSdkInstance(), q)
                }
            } else this._RunBehavior()
        }
        _RunObject_Async() {
            const f =
                this._parameters,
                k = this._results,
                h = this._func,
                l = this._objectClass.GetCurrentSol().GetInstances(),
                n = [];
            for (let u = 0, w = l.length; u < w; ++u) {
                const q = l[u];
                for (let t = 0, p = f.length; t < p; ++t) k[t] = f[t].Get(u);
                n.push(h.apply(q.GetSdkInstance(), k))
            }
            return Promise.all(n)
        }* _DebugRunObject_Async() {
            if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this;
            if (this._DebugReturnsGenerator()) {
                const f = this._parameters,
                    k = this._results,
                    h = this._func,
                    l = this._objectClass.GetCurrentSol().GetInstances(),
                    n = [];
                for (let u = 0,
                        w = l.length; u < w; ++u) {
                    const q = l[u];
                    for (let t = 0, p = f.length; t < p; ++t) k[t] = f[t].Get(u);
                    n.push(yield* h.apply(q.GetSdkInstance(), k))
                }
                return Promise.all(n)
            }
            return this._RunObject_Async()
        }
        _RunBehavior_Async() {
            var f = this._objectClass;
            const k = f.IsFamily(),
                h = f.GetFamilyIndex(),
                l = this._parameters,
                n = this._results,
                u = this._func,
                w = this._behaviorIndex;
            f = f.GetCurrentSol().GetInstances();
            const q = [];
            for (let t = 0, p = f.length; t < p; ++t) {
                const r = f[t];
                for (let y = 0, E = l.length; y < E; ++y) n[y] = l[y].Get(t);
                const x = k ? r.GetObjectClass().GetFamilyBehaviorOffset(h) :
                    0;
                q.push(u.apply(r.GetBehaviorInstances()[w + x].GetSdkInstance(), n))
            }
            return Promise.all(q)
        }* _DebugRunBehavior_Async() {
            if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this;
            if (this._DebugReturnsGenerator()) {
                var f = this._objectClass;
                const k = f.IsFamily(),
                    h = f.GetFamilyIndex(),
                    l = this._parameters,
                    n = this._results,
                    u = this._func,
                    w = this._behaviorIndex;
                f = f.GetCurrentSol().GetInstances();
                const q = [];
                for (let t = 0, p = f.length; t < p; ++t) {
                    const r = f[t];
                    for (let y = 0, E = l.length; y < E; ++y) n[y] = l[y].Get(t);
                    const x = k ?
                        r.GetObjectClass().GetFamilyBehaviorOffset(h) : 0;
                    q.push(yield* u.apply(r.GetBehaviorInstances()[w + x].GetSdkInstance(), n))
                }
                return Promise.all(q)
            }
            return this._RunBehavior_Async()
        }
        async RunUserScript() {
            try {
                await this._func()
            } catch (f) {
                console.error(`Unhandled exception running script %c${this._eventBlock.GetEventSheet().GetName()}, event ${this._eventBlock.GetDisplayNumber()}, action ${this.GetDebugIndex()+1}:`, "font-size: 1.2em; font-weight: bold;", f), self.C3Debugger && self.C3Debugger._SetLastErrorScript(this),
                    e.EventScript.HadUserScriptException() || (console.info("%cTip:%c run this to highlight in Construct the last script that had an error: %cgoToLastErrorScript()", "font-weight: bold; text-decoration: underline", "", "font-weight: bold"), e.EventScript.SetHadUserScriptException())
            }
        }* DebugRunUserScript() {
            if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this;
            return this.RunUserScript()
        }
        _SaveToJson() {
            return this._savedData && this._savedData.size ? {
                ex: e.ToSuperJSON(this._savedData)
            } : null
        }
        _LoadFromJson(f) {
            this._savedData &&
                (this._savedData.clear(), this._savedData = null);
            f && (f = f.ex) && (this._savedData = e.FromSuperJSON(f))
        }
    }
} {
    "use strict";
    const e = self.C3,
        a = new e.Color;

    function b(N, Q) {
        return e.compare(this.GetWorldInfo().GetX(), N, Q)
    }

    function d(N, Q) {
        return e.compare(this.GetWorldInfo().GetY(), N, Q)
    }

    function c() {
        const N = this.GetWorldInfo(),
            Q = N.GetLayer();
        return Q.Has3DCamera() ? N.IsInViewport3D(Q._GetViewFrustum()) : N.IsInViewport(Q.GetViewport(), N.GetLayout().HasVanishingPointOutsideViewport(), N.GetLayout().IsOrthographicProjection())
    }

    function f() {
        var N = this.GetWorldInfo();
        const Q = N.GetLayout();
        N = N.GetBoundingBox();
        return 0 >
            N.getRight() || 0 > N.getBottom() || N.getLeft() > Q.GetWidth() || N.getTop() > Q.GetHeight()
    }

    function k(N, Q, W) {
        const aa = this.GetCurrentSol(),
            ea = aa.GetInstances();
        if (!ea.length) return !1;
        let ca = ea[0];
        var ia = ca.GetWorldInfo();
        let oa = ca,
            ja = e.distanceSquared(ia.GetX(), ia.GetY(), Q, W);
        for (let wa = 1, Ka = ea.length; wa < Ka; ++wa)
            if (ca = ea[wa], ia = ca.GetWorldInfo(), ia = e.distanceSquared(ia.GetX(), ia.GetY(), Q, W), 0 === N && ia < ja || 1 === N && ia > ja) ja = ia, oa = ca;
        aa.PickOne(oa);
        return !0
    }

    function h(N) {
        const Q = this.GetWorldInfo();
        Q.GetX() !==
            N && (Q.SetX(N), Q.SetBboxChanged())
    }

    function l(N) {
        const Q = this.GetWorldInfo();
        Q.GetY() !== N && (Q.SetY(N), Q.SetBboxChanged())
    }

    function n(N, Q) {
        const W = this.GetWorldInfo();
        W.EqualsXY(N, Q) || (W.SetXY(N, Q), W.SetBboxChanged())
    }

    function u(N, Q) {
        if (N && (N = N.GetPairedInstance(this._inst))) {
            var [W, aa] = N.GetImagePoint(Q);
            Q = this.GetWorldInfo();
            if (Q.GetX() !== W || Q.GetY() !== aa) Q.SetXY(W, aa), Q.SetBboxChanged()
        }
    }

    function w(N) {
        if (0 !== N) {
            var Q = this.GetWorldInfo();
            Q.OffsetXY(Q.GetCosAngle() * N, Q.GetSinAngle() * N);
            Q.SetBboxChanged()
        }
    }

    function q(N, Q) {
        if (0 !== Q) {
            var W = this.GetWorldInfo();
            N = e.toRadians(N);
            W.OffsetXY(Math.cos(N) * Q, Math.sin(N) * Q);
            W.SetBboxChanged()
        }
    }

    function t() {
        return this.GetWorldInfo().GetX()
    }

    function p() {
        return this.GetWorldInfo().GetY()
    }

    function r() {
        return this._runtime.GetDt(this._inst)
    }

    function x(N, Q) {
        return e.compare(this.GetWorldInfo().GetWidth(), N, Q)
    }

    function y(N, Q) {
        return e.compare(this.GetWorldInfo().GetHeight(), N, Q)
    }

    function E(N) {
        const Q = this.GetWorldInfo();
        Q.GetWidth() !== N && (Q.SetWidth(N), Q.SetBboxChanged())
    }

    function G(N) {
        const Q = this.GetWorldInfo();
        Q.GetHeight() !== N && (Q.SetHeight(N), Q.SetBboxChanged())
    }

    function A(N, Q) {
        const W = this.GetWorldInfo();
        if (W.GetWidth() !== N || W.GetHeight() !== Q) W.SetSize(N, Q), W.SetBboxChanged()
    }

    function F() {
        return this.GetWorldInfo().GetWidth()
    }

    function J() {
        return this.GetWorldInfo().GetHeight()
    }

    function B() {
        return this.GetWorldInfo().GetBoundingBox().getLeft()
    }

    function I() {
        return this.GetWorldInfo().GetBoundingBox().getTop()
    }

    function L() {
        return this.GetWorldInfo().GetBoundingBox().getRight()
    }

    function P() {
        return this.GetWorldInfo().GetBoundingBox().getBottom()
    }

    function S(N, Q) {
        return e.angleDiff(this.GetWorldInfo().GetAngle(), e.toRadians(Q)) <= e.toRadians(N)
    }

    function U(N) {
        return e.angleClockwise(this.GetWorldInfo().GetAngle(), e.toRadians(N))
    }

    function V(N, Q) {
        N = e.toRadians(N);
        Q = e.toRadians(Q);
        const W = this.GetWorldInfo().GetAngle();
        return e.angleClockwise(Q, N) ? e.angleClockwise(W, N) && !e.angleClockwise(W, Q) : !(!e.angleClockwise(W, N) && e.angleClockwise(W, Q))
    }

    function Z(N) {
        const Q = this.GetWorldInfo();
        N = e.clampAngle(e.toRadians(N));
        isNaN(N) || Q.GetAngle() === N || (Q.SetAngle(N), Q.SetBboxChanged())
    }

    function ma(N) {
        if (!isNaN(N) && 0 !== N) {
            var Q = this.GetWorldInfo();
            Q.SetAngle(Q.GetAngle() + e.toRadians(N));
            Q.SetBboxChanged()
        }
    }

    function va(N) {
        if (!isNaN(N) && 0 !== N) {
            var Q = this.GetWorldInfo();
            Q.SetAngle(Q.GetAngle() - e.toRadians(N));
            Q.SetBboxChanged()
        }
    }

    function Na(N, Q) {
        const W = this.GetWorldInfo(),
            aa = W.GetAngle();
        N = e.angleRotate(aa, e.toRadians(Q), e.toRadians(N));
        isNaN(N) || aa === N || (W.SetAngle(N), W.SetBboxChanged())
    }

    function Ea(N, Q, W) {
        const aa = this.GetWorldInfo(),
            ea = aa.GetAngle();
        Q -= aa.GetX();
        W -= aa.GetY();
        N = e.angleRotate(ea, Math.atan2(W, Q), e.toRadians(N));
        isNaN(N) || ea === N || (aa.SetAngle(N), aa.SetBboxChanged())
    }

    function Ia(N, Q) {
        const W = this.GetWorldInfo(),
            aa = W.GetAngle();
        N -= W.GetX();
        Q -= W.GetY();
        Q = Math.atan2(Q, N);
        isNaN(Q) || aa === Q || (W.SetAngle(Q), W.SetBboxChanged())
    }

    function Ma() {
        return e.toDegrees(this.GetWorldInfo().GetAngle())
    }

    function Fa(N, Q) {
        return e.compare(e.round6dp(100 * this.GetWorldInfo().GetOpacity()),
            N, Q)
    }

    function ya() {
        return this.GetWorldInfo().IsVisible()
    }

    function na(N) {
        const Q = this.GetWorldInfo();
        N = 2 === N ? !Q.IsVisible() : 0 !== N;
        Q.IsVisible() !== N && (Q.SetVisible(N), this._runtime.UpdateRender())
    }

    function Va(N) {
        N = e.clamp(N / 100, 0, 1);
        const Q = this.GetWorldInfo();
        Q.GetOpacity() !== N && (Q.SetOpacity(N), this._runtime.UpdateRender())
    }

    function xa(N) {
        a.setFromRgbValue(N);
        N = this.GetWorldInfo();
        N.GetUnpremultipliedColor().equalsIgnoringAlpha(a) || (N.SetUnpremultipliedColor(a), this._runtime.UpdateRender())
    }

    function Ga() {
        const N =
            this.GetWorldInfo().GetUnpremultipliedColor();
        return e.PackRGBAEx(N.getR(), N.getG(), N.getB(), N.getA())
    }

    function bb() {
        return e.round6dp(100 * this.GetWorldInfo().GetOpacity())
    }

    function Xa(N) {
        return N ? this.GetWorldInfo().GetLayer() === N : !1
    }

    function ob(N) {
        const Q = this.GetCurrentSol(),
            W = Q.GetInstances();
        if (!W.length) return !1;
        let aa = W[0];
        for (let ea = 1, ca = W.length; ea < ca; ++ea) {
            const ia = W[ea],
                oa = ia.GetWorldInfo(),
                ja = aa.GetWorldInfo(),
                wa = oa.GetLayer().GetIndex(),
                Ka = ja.GetLayer().GetIndex();
            if (0 === N) {
                if (wa > Ka ||
                    wa === Ka && oa.GetZIndex() > ja.GetZIndex()) aa = ia
            } else if (wa < Ka || wa === Ka && oa.GetZIndex() < ja.GetZIndex()) aa = ia
        }
        Q.PickOne(aa);
        return !0
    }

    function pb(N, Q, W) {
        const aa = this.GetWorldInfo();
        N = 0 === N ? aa.GetZElevation() : aa.GetTotalZElevation();
        return e.compare(N, Q, W)
    }

    function cb() {
        this.GetWorldInfo().ZOrderMoveToTop()
    }

    function qb() {
        this.GetWorldInfo().ZOrderMoveToBottom()
    }

    function rb(N) {
        N && this.GetWorldInfo().ZOrderMoveToLayer(N)
    }

    function sb(N, Q) {
        N = 0 === N;
        Q && (Q = Q.GetFirstPicked(this.GetInstance())) && this.GetWorldInfo().ZOrderMoveAdjacentToInstance(Q,
            N)
    }

    function tb(N) {
        const Q = this.GetWorldInfo();
        Q.GetZElevation() !== N && (Q.SetZElevation(N), this._runtime.UpdateRender())
    }

    function ub() {
        return this.GetWorldInfo().GetLayer().GetIndex()
    }

    function vb() {
        return this.GetWorldInfo().GetLayer().GetName()
    }

    function wb() {
        return this.GetWorldInfo().GetZIndex()
    }

    function db() {
        return this.GetWorldInfo().GetZElevation()
    }

    function xb() {
        return this.GetWorldInfo().GetTotalZElevation()
    }

    function yb(N, Q) {
        if (Q = this.GetObjectClass().GetEffectList().GetEffectTypeByName(Q)) {
            Q =
                Q.GetIndex();
            N = 1 === N;
            var W = this.GetWorldInfo().GetInstanceEffectList();
            W.IsEffectIndexActive(Q) !== N && (W.SetEffectIndexActive(Q, N), W.UpdateActiveEffects(), this._runtime.UpdateRender())
        }
    }

    function zb(N, Q, W) {
        var aa = this.GetObjectClass().GetEffectList().GetEffectTypeByName(N);
        if (aa) {
            N = aa.GetIndex();
            var ea = this.GetWorldInfo().GetInstanceEffectList(),
                ca = ea.GetEffectParametersForIndex(N);
            Q = Math.floor(Q);
            if (!(0 > Q || Q >= ca.length)) {
                aa = aa.GetShaderProgram().GetParameterType(Q);
                if ("color" === aa) {
                    a.setFromRgbValue(W);
                    Q = ca[Q];
                    if (a.equalsIgnoringAlpha(Q)) return;
                    Q.copyRgb(a)
                } else {
                    "percent" === aa && (W /= 100);
                    if (ca[Q] === W) return;
                    ca[Q] = W
                }
                ea.IsEffectIndexActive(N) && this._runtime.UpdateRender()
            }
        }
    }
    const eb = e.New(e.Rect),
        Wa = [],
        fb = [];
    let gb = !1,
        Ya = null,
        hb = !1;
    const Ta = new Set;

    function ib(N, Q, W, aa) {
        const ea = Q.GetUID(),
            ca = W.GetUID();
        ea < ca ? N.Set(Q, W, aa) : N.Set(W, Q, aa)
    }

    function jb(N, Q, W) {
        const aa = Q.GetUID(),
            ea = W.GetUID();
        aa < ea ? N.Delete(Q, W) : N.Delete(W, Q)
    }

    function sa(N, Q) {
        N.DeleteEither(Q)
    }

    function Sa(N, Q, W) {
        const aa = Q.GetUID(),
            ea =
            W.GetUID();
        return aa < ea ? N.Get(Q, W) : N.Get(W, Q)
    }

    function Ab(N, Q, W, aa) {
        if (!Q) return !1;
        N = N.GetInstance();
        const ea = 0 !== W || 0 !== aa,
            ca = N.GetWorldInfo(),
            ia = N.GetRuntime(),
            oa = ia.GetCollisionEngine();
        var ja = ia.GetCurrentCondition();
        const wa = ja.GetEventBlock().IsOrBlock();
        var Ka = ja.GetObjectClass();
        ja = ja.IsInverted();
        const Oa = Q.GetCurrentSol();
        Ka = Ka !== Q;
        Ya = Q;
        gb = Ka && !ja;
        hb = !1;
        let Za = 0,
            La = 0,
            la = !1;
        Oa.IsSelectAll() ? (eb.copy(ca.GetBoundingBox()), eb.offset(W, aa), oa.GetCollisionCandidates(ca.GetLayer(), Q, eb, fb), Q = fb) :
            wa ? ia.IsCurrentConditionFirst() && !Oa._GetOwnElseInstances().length && Oa._GetOwnInstances().length ? Q = Oa._GetOwnInstances() : (Q = Oa._GetOwnElseInstances(), hb = !0) : Q = Oa._GetOwnInstances();
        ea && (Za = ca.GetX(), La = ca.GetY(), ca.OffsetXY(W, aa), ca.SetBboxChanged());
        for (const da of Q)
            if (oa.TestOverlap(N, da)) {
                la = !0;
                if (ja) break;
                Ka && Ta.add(da)
            } ea && (ca.SetXY(Za, La), ca.SetBboxChanged());
        e.clearArray(fb);
        return la
    }

    function Db(N) {
        N = N.GetRuntime().GetCurrentEvent().IsOrBlock();
        const Q = Ya.GetCurrentSol(),
            W = Q._GetOwnInstances(),
            aa = Q._GetOwnElseInstances();
        Q.IsSelectAll() ? (Q.SetSetPicked(Ta), N && (e.clearArray(aa), Q.AddElseInstances(Ta, Ya.GetInstances()))) : N ? hb ? Q.TransferElseInstancesToOwn(Ta) : (Q.AddElseInstances(Ta, W), Q.SetSetPicked(Ta)) : Q.SetSetPicked(Ta);
        Ya.ApplySolToContainer()
    }

    function Eb(N, Q) {
        gb && (Q && Db(N), Ta.clear(), Ya = null, gb = !1)
    }

    function Fb(N) {
        if (this._runtime.IsDebugging()) return Gb.call(this, N);
        if (!N) return !1;
        var Q = this._runtime;
        const W = Q.GetCollisionEngine(),
            aa = Q.GetEventSheetManager(),
            ea = aa.GetEventStack();
        var ca =
            aa.GetCurrentCondition();
        const ia = ca.GetObjectClass();
        var oa = ca.GetSavedDataMap(),
            ja = ca.GetUnsavedDataMap();
        ca = ea.GetCurrentStackFrame();
        const wa = Q.GetTickCount(),
            Ka = wa - 1,
            Oa = ca.GetCurrentEvent(),
            Za = ea.Push(Oa);
        let La = oa.get("collmemory");
        La || (La = e.New(e.PairMap), oa.set("collmemory", La));
        ja.get("collisionCreatedDestroyCallback") || (ja.set("collisionCreatedDestroyCallback", !0), Q.Dispatcher().addEventListener("instancedestroy", Ua => sa(La, Ua.instance)));
        oa = ia.GetCurrentSol();
        Q = N.GetCurrentSol();
        oa = oa.GetInstances();
        ja = null;
        for (let Ua = 0; Ua < oa.length; ++Ua) {
            const Ha = oa[Ua];
            Q.IsSelectAll() ? (W.GetCollisionCandidates(Ha.GetWorldInfo().GetLayer(), N, Ha.GetWorldInfo().GetBoundingBox(), Wa), ja = Wa, W.AddRegisteredCollisionCandidates(Ha, N, ja)) : ja = Q.GetInstances();
            for (let ab = 0; ab < ja.length; ++ab) {
                const Ra = ja[ab];
                if (W.TestOverlap(Ha, Ra) || W.CheckRegisteredCollision(Ha, Ra)) {
                    var la = Sa(La, Ha, Ra),
                        da = !1,
                        pa = -2;
                    "number" === typeof la && (da = !0, pa = la);
                    la = !da || pa < Ka;
                    ib(La, Ha, Ra, wa);
                    la && (la = Oa.GetSolModifiers(), aa.PushCopySol(la), pa = ia.GetCurrentSol(),
                        da = N.GetCurrentSol(), pa._SetSelectAll(!1), da._SetSelectAll(!1), ia === N ? (da = pa._GetOwnInstances(), e.clearArray(da), da.push(Ha), da.push(Ra), ia.ApplySolToContainer()) : (pa = pa._GetOwnInstances(), da = da._GetOwnInstances(), e.clearArray(pa), e.clearArray(da), pa.push(Ha), da.push(Ra), ia.ApplySolToContainer(), N.ApplySolToContainer()), Oa.Retrigger(ca, Za), aa.PopSol(la))
                } else jb(La, Ha, Ra)
            }
            e.clearArray(Wa)
        }
        ea.Pop();
        return !1
    }

    function* Gb(N) {
        if (!N) return !1;
        var Q = this._runtime;
        const W = Q.GetCollisionEngine(),
            aa = Q.GetEventSheetManager(),
            ea = aa.GetEventStack();
        var ca = aa.GetCurrentCondition();
        const ia = ca.GetObjectClass();
        var oa = ca.GetSavedDataMap(),
            ja = ca.GetUnsavedDataMap();
        ca = ea.GetCurrentStackFrame();
        const wa = Q.GetTickCount(),
            Ka = wa - 1,
            Oa = ca.GetCurrentEvent(),
            Za = ea.Push(Oa);
        let La = oa.get("collmemory");
        La || (La = e.New(e.PairMap), oa.set("collmemory", La));
        ja.get("collisionCreatedDestroyCallback") || (ja.set("collisionCreatedDestroyCallback", !0), Q.Dispatcher().addEventListener("instancedestroy", Ua => sa(La, Ua.instance)));
        oa = ia.GetCurrentSol();
        Q = N.GetCurrentSol();
        oa = oa.GetInstances();
        ja = null;
        for (let Ua = 0; Ua < oa.length; ++Ua) {
            const Ha = oa[Ua];
            Q.IsSelectAll() ? (W.GetCollisionCandidates(Ha.GetWorldInfo().GetLayer(), N, Ha.GetWorldInfo().GetBoundingBox(), Wa), ja = Wa, W.AddRegisteredCollisionCandidates(Ha, N, ja)) : ja = Q.GetInstances();
            for (let ab = 0; ab < ja.length; ++ab) {
                const Ra = ja[ab];
                if (W.TestOverlap(Ha, Ra) || W.CheckRegisteredCollision(Ha, Ra)) {
                    var la = Sa(La, Ha, Ra),
                        da = !1,
                        pa = -2;
                    "number" === typeof la && (da = !0, pa = la);
                    la = !da || pa < Ka;
                    ib(La, Ha, Ra, wa);
                    la && (la = Oa.GetSolModifiers(),
                        aa.PushCopySol(la), pa = ia.GetCurrentSol(), da = N.GetCurrentSol(), pa._SetSelectAll(!1), da._SetSelectAll(!1), ia === N ? (da = pa._GetOwnInstances(), e.clearArray(da), da.push(Ha), da.push(Ra), ia.ApplySolToContainer()) : (pa = pa._GetOwnInstances(), da = da._GetOwnInstances(), e.clearArray(pa), e.clearArray(da), pa.push(Ha), da.push(Ra), ia.ApplySolToContainer(), N.ApplySolToContainer()), yield* Oa.DebugRetrigger(ca, Za), aa.PopSol(la))
                } else jb(La, Ha, Ra)
            }
            e.clearArray(Wa)
        }
        ea.Pop();
        return !1
    }

    function Hb(N) {
        return Ab(this, N, 0, 0)
    }

    function kb(N,
        Q, W) {
        return Ab(this, N, Q, W)
    }

    function lb() {
        return this.GetWorldInfo().HasParent()
    }

    function mb() {
        return this.GetWorldInfo().HasChildren()
    }

    function nb(N, Q) {
        const W = this.GetCurrentSol().GetInstances();
        if (0 === W.length) return !1;
        const aa = N.GetCurrentSol();
        var ea = aa.GetInstances();
        if (0 === ea.length) return !1;
        ea = new Set(ea);
        const ca = new Set;
        for (let oa = 0, ja = W.length; oa < ja; ++oa) {
            var ia = W[oa];
            if (1 === Q)
                for (const wa of ia.parents()) wa.BelongsToObjectClass(N) && ea.has(wa) && ca.add(wa);
            else {
                if (0 === Q) {
                    if (ia = ia.GetParent(),
                        null === ia) continue
                } else ia = ia.GetTopParent();
                ia.BelongsToObjectClass(N) && ea.has(ia) && ca.add(ia)
            }
        }
        if (0 === ca.size) return !1;
        aa.SetSetPicked(ca);
        N.ApplySolToContainer();
        return !0
    }

    function $a(N, Q) {
        const W = this.GetCurrentSol().GetInstances();
        if (0 === W.length) return !1;
        const aa = N.GetCurrentSol();
        var ea = aa.GetInstances();
        if (aa.IsSelectAll()) {
            var ca = [...this._runtime.instancesPendingCreateForObjectClass(N)];
            0 < ca.length && (ea = ea.concat(ca))
        }
        if (0 === ea.length) return !1;
        ea = new Set(ea);
        ca = new Set;
        for (let ia = 0, oa = W.length; ia <
            oa; ++ia) {
            const ja = W[ia];
            2 === Q && !ja.HasChildren() && ja.BelongsToObjectClass(N) && ea.has(ja) && ca.add(ja);
            for (const wa of 0 === Q ? ja.children() : ja.allChildren()) 2 === Q && wa.HasChildren() || wa.BelongsToObjectClass(N) && ea.has(wa) && ca.add(wa)
        }
        if (0 === ca.size) return !1;
        aa.SetSetPicked(ca);
        N.ApplySolToContainer();
        return !0
    }

    function g(N, Q) {
        const W = this.GetCurrentSol().GetInstances();
        if (0 === W.length) return !1;
        const aa = N.GetCurrentSol();
        var ea = aa.GetInstances();
        if (aa.IsSelectAll()) {
            var ca = [...this._runtime.instancesPendingCreateForObjectClass(N)];
            0 < ca.length && (ea = ea.concat(ca))
        }
        if (0 === ea.length) return !1;
        ea = new Set(ea);
        ca = [];
        for (let ia = 0, oa = W.length; ia < oa; ++ia) {
            const ja = W[ia].GetChildAt(Q);
            null !== ja && ja.BelongsToObjectClass(N) && ea.has(ja) && ca.push(ja)
        }
        if (0 === ca.length) return !1;
        aa.SetArrayPicked(ca);
        N.ApplySolToContainer();
        return !0
    }

    function m(N, Q) {
        return e.compare(this._inst.GetChildCount(), N, Q)
    }

    function v(N, Q, W, aa, ea, ca, ia, oa) {
        const ja = this._inst,
            wa = this._runtime.GetCurrentAction().GetObjectClass();
        for (const Ka of N.allCorrespondingInstances(ja,
                wa)) {
            if (!Ka.GetPlugin().SupportsSceneGraph()) break;
            ja.AddChild(Ka, {
                transformX: Q,
                transformY: W,
                transformWidth: aa,
                transformHeight: ea,
                transformAngle: ca,
                transformZElevation: ia,
                destroyWithParent: oa
            })
        }
    }

    function z(N) {
        const Q = this._inst,
            W = this._runtime.GetCurrentAction().GetObjectClass();
        for (const aa of N.allCorrespondingInstances(Q, W)) Q.RemoveChild(aa)
    }

    function C() {
        this._inst.HasParent() && this._inst.GetParent().RemoveChild(this._inst)
    }

    function D() {
        return this._inst.GetChildCount()
    }

    function H(N, Q) {
        N = Math.floor(N);
        Q = Math.floor(Q);
        const W = this.GetWorldInfo();
        2 > N || 2 > Q || !isFinite(N) || !isFinite(Q) ? (W.ReleaseMesh(), W.SetBboxChanged()) : W.CreateMesh(N, Q)
    }

    function K(N, Q, W, aa, ea, ca, ia, oa) {
        const ja = this.GetWorldInfo();
        ja.SetMeshPoint(N, Q, {
            mode: 0 === W ? "absolute" : "relative",
            x: aa,
            y: ea,
            zElevation: ca,
            u: ia,
            v: oa
        }) && ja.SetBboxChanged()
    }

    function M() {
        const N = this.GetWorldInfo();
        return N.HasMesh() ? N.GetSourceMesh().GetHSize() : 0
    }

    function O() {
        const N = this.GetWorldInfo();
        return N.HasMesh() ? N.GetSourceMesh().GetVSize() : 0
    }

    function R(N) {
        const Q =
            this.GetWorldInfo();
        N = 2 === N ? !Q.IsVisible() : 0 !== N;
        Q.IsVisible() !== N && Q.SetVisible(N)
    }

    function T(N, Q) {
        this.SetElementCSSStyle(N, Q)
    }

    function Y(N, Q) {
        this.SetElementAttribute(N, "" + Q)
    }

    function X(N) {
        this.RemoveElementAttribute(N)
    }

    function fa() {
        this.FocusElement()
    }

    function ha() {
        this.BlurElement()
    }

    function ba() {
        return this.IsElementFocused()
    }

    function qa(N) {
        this._SetEnabled(0 !== N)
    }

    function ka() {
        return this._IsEnabled()
    }

    function ta(N, Q, W) {
        return e.compare(this.GetInstance().GetInstanceVariableValue(N), Q, W)
    }

    function ua(N) {
        return !!this.GetInstance().GetInstanceVariableValue(N)
    }

    function ra(N, Q) {
        const W = this.GetCurrentSol(),
            aa = W.GetInstances();
        if (!aa.length) return !1;
        let ea = aa[0],
            ca = ea,
            ia = ea.GetInstanceVariableValue(Q);
        for (let oa = 1, ja = aa.length; oa < ja; ++oa) {
            ea = aa[oa];
            const wa = ea.GetInstanceVariableValue(Q);
            if (0 === N && wa < ia || 1 === N && wa > ia) ia = wa, ca = ea
        }
        W.PickOne(ca);
        return !0
    }

    function za(N) {
        return this._runtime.GetCurrentCondition().IsInverted() ? Ba(this, N) : Aa(this, N)
    }

    function Aa(N, Q) {
        Q = N.GetRuntime().GetInstanceByUID(Q);
        if (!Q) return !1;
        const W = N.GetCurrentSol();
        if (!W.IsSelectAll() && !W._GetOwnInstances().includes(Q)) return !1;
        if (N.IsFamily()) {
            if (Q.GetObjectClass().BelongsToFamily(N)) return W.PickOne(Q), N.ApplySolToContainer(), !0
        } else if (Q.GetObjectClass() === N) return W.PickOne(Q), N.ApplySolToContainer(), !0;
        return !1
    }

    function Ba(N, Q) {
        const W = N.GetCurrentSol();
        if (W.IsSelectAll()) {
            W._SetSelectAll(!1);
            W.ClearArrays();
            var aa = N.GetInstances();
            for (let ca = 0, ia = aa.length; ca < ia; ++ca) {
                var ea = aa[ca];
                ea.GetUID() === Q ? W._PushElseInstance(ea) :
                    W._PushInstance(ea)
            }
            N.ApplySolToContainer();
            return !!W._GetOwnInstances().length
        }
        aa = W._GetOwnInstances();
        ea = 0;
        for (let ca = 0, ia = aa.length; ca < ia; ++ca) {
            const oa = aa[ca];
            aa[ea] = oa;
            oa.GetUID() === Q ? W._PushElseInstance(oa) : ++ea
        }
        e.truncateArray(aa, ea);
        N.ApplySolToContainer();
        return !!aa.length
    }

    function Ca() {
        this._runtime.DestroyInstance(this._inst)
    }

    function Ja() {
        return !0
    }

    function Pa() {
        return !0
    }

    function Qa(N, Q) {
        this.GetInstance().SetInstanceVariableValue(N, Q)
    }

    function Da(N, Q) {
        const W = this.GetInstance(),
            aa = W.GetInstanceVariableValue(N);
        "number" === typeof aa && "number" !== typeof Q ? Q = parseFloat(Q) : "string" === typeof aa && "string" !== typeof Q && (Q = Q.toString());
        W.SetInstanceVariableValue(N, aa + Q)
    }

    function Bb(N, Q) {
        const W = this.GetInstance(),
            aa = W.GetInstanceVariableValue(N);
        "number" === typeof aa && ("number" !== typeof Q && (Q = parseFloat(Q)), W.SetInstanceVariableValue(N, aa - Q))
    }

    function Cb(N, Q) {
        this.GetInstance().SetInstanceVariableValue(N, Q ? 1 : 0)
    }

    function Ib(N) {
        const Q = this.GetInstance();
        Q.SetInstanceVariableValue(N, 0 === Q.GetInstanceVariableValue(N) ?
            1 : 0)
    }

    function Jb(N) {
        let Q;
        try {
            Q = JSON.parse(N)
        } catch (W) {
            console.error("Failed to load from JSON string: ", W);
            return
        }
        N = this.GetInstance();
        N._OnBeforeLoad("state");
        N.LoadFromJson(Q, "state")
    }

    function Kb() {
        return JSON.stringify(this.GetInstance().SaveToJson("state"))
    }

    function Lb() {
        return this.GetInstance().GetObjectClass().GetName()
    }

    function Mb() {
        const N = this._runtime.GetCurrentEventStackFrame().GetExpressionObjectClass();
        let Q = N.GetInstanceCount();
        for (const W of this._runtime.instancesPendingCreateForObjectClass(N)) ++Q;
        return Q
    }

    function Nb() {
        return this._runtime.GetCurrentEventStackFrame().GetExpressionObjectClass().GetCurrentSol().GetInstances().length
    }

    function Ob() {
        return this._inst.GetIID()
    }

    function Pb() {
        return this._inst.GetUID()
    }
    e.AddCommonACEs = function (N, Q) {
        const W = N[1],
            aa = N[4],
            ea = N[5],
            ca = N[6],
            ia = N[7],
            oa = N[8],
            ja = N[10],
            wa = N[11],
            Ka = N[12],
            Oa = N[13],
            Za = N[14],
            La = N[15],
            la = Q.Cnds,
            da = Q.Acts,
            pa = Q.Exps;
        N[3] && (la.CompareX = b, la.CompareY = d, la.IsOnScreen = c, la.IsOutsideLayout = f, la.PickDistance = k, da.SetX = h, da.SetY = l, da.SetPos =
            n, da.SetPosToObject = u, da.MoveForward = w, da.MoveAtAngle = q, pa.X = t, pa.Y = p, pa.dt = r);
        aa && (la.CompareWidth = x, la.CompareHeight = y, da.SetWidth = E, da.SetHeight = G, da.SetSize = A, pa.Width = F, pa.Height = J, pa.BBoxLeft = B, pa.BBoxTop = I, pa.BBoxRight = L, pa.BBoxBottom = P);
        ea && (la.AngleWithin = S, la.IsClockwiseFrom = U, la.IsBetweenAngles = V, da.SetAngle = Z, da.RotateClockwise = ma, da.RotateCounterclockwise = va, da.RotateTowardAngle = Na, da.RotateTowardPosition = Ea, da.SetTowardPosition = Ia, pa.Angle = Ma);
        ca && (la.IsVisible = ya, la.CompareOpacity =
            Fa, da.SetVisible = na, da.SetOpacity = Va, da.SetDefaultColor = xa, pa.Opacity = bb, pa.ColorValue = Ga);
        ia && (la.IsOnLayer = Xa, la.PickTopBottom = ob, la.CompareZElevation = pb, da.MoveToTop = cb, da.MoveToBottom = qb, da.MoveToLayer = rb, da.ZMoveToObject = sb, da.SetZElevation = tb, pa.LayerNumber = ub, pa.LayerName = vb, pa.ZIndex = wb, pa.ZElevation = db, pa.TotalZElevation = xb);
        oa && (da.SetEffectEnabled = yb, da.SetEffectParam = zb);
        Oa && (la.HasParent = lb, la.HasChildren = mb, la.PickParent = nb, la.PickChildren = $a, la.PickNthChild = g, la.CompareChildCount = m,
            da.AddChild = v, da.RemoveChild = z, da.RemoveFromParent = C, pa.ChildCount = D);
        Za && (da.SetMeshSize = H, da.SetMeshPoint = K, pa.MeshColumns = M, pa.MeshRows = O);
        ja && (la.IsVisible = ya, da.SetVisible = R, da.SetCSSStyle = T, da.SetElemAttribute = Y, da.RemoveElemAttribute = X);
        wa && (la.IsFocused = ba, da.SetFocus = fa, da.SetBlur = ha);
        Ka && (la.IsEnabled = ka, da.SetEnabled = qa);
        La && (la.OnCollision = Fb, la.IsOverlapping = Hb, la.IsOverlappingOffset = kb, Q.FinishCollisionCondition = Eb);
        W || (la.CompareInstanceVar = ta, la.IsBoolInstanceVarSet = ua, la.PickInstVarHiLow =
            ra, la.PickByUID = za, da.SetInstanceVar = Qa, da.AddInstanceVar = Da, da.SubInstanceVar = Bb, da.SetBoolInstanceVar = Cb, da.ToggleBoolInstanceVar = Ib, la.OnCreated = Ja, la.OnDestroyed = Pa, da.Destroy = Ca, da.LoadFromJsonString || (da.LoadFromJsonString = Jb), pa.AsJSON || (pa.AsJSON = Kb), pa.Count = Mb, pa.PickedCount = Nb, pa.IID = Ob, pa.UID = Pb, pa.ObjectTypeName = Lb)
    }
} {
    "use strict";
    const e = self.C3;
    e.ScheduledWait = class extends e.DefendedBase {
        constructor(a) {
            super();
            this._eventSheetManager = a;
            this._type = "";
            this._time = -1;
            this._signalTag = "";
            this._isSignalled = !1;
            this._event = null;
            this._actIndex = 0;
            this._solModifiers = [];
            this._sols = new Map;
            this._callingFunctionBlock = null;
            this._asyncId = -1;
            this._functionInnerLocalVars = this._functionParameters = null;
            this._shouldRelease = !1
        }
        Release() {
            this._type = "";
            this._time = -1;
            this._signalTag = "";
            this._functionInnerLocalVars = this._functionParameters =
                this._callingFunctionBlock = this._event = null;
            this._asyncId = -1;
            e.clearArray(this._solModifiers);
            for (const a of this._sols.values()) a.Release();
            this._sols.clear()
        }
        _Init() {
            var a = this._eventSheetManager,
                b = a.GetRuntime().GetAllObjectClasses();
            const d = a.GetCurrentEventStackFrame();
            this._event = d.GetCurrentEvent();
            this._actIndex = d.GetActionIndex() + 1;
            if (a = a.FindFirstFunctionBlockParent(this._event)) this._callingFunctionBlock = a, this._functionParameters = a.CaptureFunctionParameters(), this._functionInnerLocalVars =
                a._GetAllInnerLocalVariables().map(c => c.GetValue()), a.IsAsync() && (this._asyncId = a.PauseCurrentAsyncFunction());
            for (const c of b)
                if (b = c.GetCurrentSol(), !b.IsSelectAll() || this._event.HasSolModifier(c)) this._solModifiers.push(c), this._sols.set(c, e.New(e.SolState, b))
        }
        InitTimer(a) {
            this._type = "timer";
            this._Init();
            this._time = this._eventSheetManager.GetRuntime().GetGameTime() + a
        }
        InitSignal(a) {
            this._type = "signal";
            this._Init();
            this._signalTag = a.toLowerCase()
        }
        InitPromise(a) {
            this._type = "promise";
            this._Init();
            a.then(() => this.SetSignalled()).catch(b => {
                console.warn("[C3 runtime] Promise rejected in 'Wait for previous actions to complete': ", b);
                this.SetSignalled()
            })
        }
        IsTimer() {
            return "timer" === this._type
        }
        IsSignal() {
            return "signal" === this._type
        }
        IsPromise() {
            return "promise" === this._type
        }
        GetSignalTag() {
            return this._signalTag
        }
        IsSignalled() {
            return this._isSignalled
        }
        SetSignalled() {
            this._isSignalled = !0
        }
        _ShouldRun() {
            return this.IsTimer() ? this._time <= this._eventSheetManager.GetRuntime().GetGameTime() : this.IsSignalled()
        }
        _RestoreState(a) {
            a._Restore(this._event,
                this._actIndex);
            for (const [b, d] of this._sols.entries()) a = b.GetCurrentSol(), d._Restore(a);
            if (a = this._callingFunctionBlock) a.SetFunctionParameters(this._functionParameters), a._GetAllInnerLocalVariables().map((b, d) => b.SetValue(this._functionInnerLocalVars[d])), a.IsAsync() && a.ResumeAsyncFunction(this._asyncId)
        }
        _Run(a) {
            this._RestoreState(a);
            this._event._ResumeActionsAndSubEvents(a);
            this._callingFunctionBlock && this._callingFunctionBlock.IsAsync() && this._callingFunctionBlock.MaybeFinishAsyncFunctionCall(this._asyncId);
            this._eventSheetManager.ClearSol(this._solModifiers);
            this._shouldRelease = !0
        }
        async _DebugRun(a) {
            this._RestoreState(a);
            for (const b of this._event._DebugResumeActionsAndSubEvents(a)) await this._eventSheetManager.GetRuntime().DebugBreak(b);
            this._callingFunctionBlock && this._callingFunctionBlock.IsAsync() && this._callingFunctionBlock.MaybeFinishAsyncFunctionCall(this._asyncId);
            this._eventSheetManager.ClearSol(this._solModifiers);
            this._shouldRelease = !0
        }
        ShouldRelease() {
            return this._shouldRelease
        }
        RemoveInstances(a) {
            for (const b of this._sols.values()) b.RemoveInstances(a)
        }
        _SaveToJson() {
            const a = {},
                b = {
                    t: this._time,
                    st: this._signalTag,
                    s: this._isSignalled,
                    ev: this._event.GetSID(),
                    sm: this._solModifiers.map(d => d.GetSID()),
                    sols: a
                };
            this._event._HasActionIndex(this._actIndex) && (b.act = this._event.GetActionAt(this._actIndex).GetSID());
            for (const [d, c] of this._sols) a[d.GetSID().toString()] = c._SaveToJson();
            return b
        }
        static _CreateFromJson(a, b) {
            const d = a.GetRuntime();
            var c = a.GetEventBlockBySID(b.ev);
            if (!c) return null;
            let f = 0;
            if (b.hasOwnProperty("act")) {
                var k = a.GetActionBySID(b.act);
                if (!k) return null;
                f = k.GetIndex()
            }
            k =
                e.New(e.ScheduledWait, a);
            k._time = b.t;
            k._type = -1 === k._time ? "signal" : "timer";
            k._signalTag = b.st;
            k._isSignalled = b.s;
            k._event = c;
            k._actIndex = f;
            for (var h of b.sm)(c = d.GetObjectClassBySID(h)) && k._solModifiers.push(c);
            for (const [l, n] of Object.entries(b.sols))
                if (b = parseInt(l, 10), b = d.GetObjectClassBySID(b)) h = e.New(e.SolState, null), h._LoadFromJson(a, n), k._sols.set(b, h);
            return k
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.SolState = class extends e.DefendedBase {
        constructor(a) {
            super();
            this._objectClass = null;
            this._isSelectAll = !0;
            this._instances = [];
            a && (this._objectClass = a.GetObjectClass(), this._isSelectAll = a.IsSelectAll(), e.shallowAssignArray(this._instances, a._GetOwnInstances()))
        }
        Release() {
            this._objectClass = null;
            e.clearArray(this._instances)
        }
        _Restore(a) {
            a._SetSelectAll(this._isSelectAll);
            e.shallowAssignArray(a._GetOwnInstances(), this._instances)
        }
        RemoveInstances(a) {
            e.arrayRemoveAllInSet(this._instances,
                a)
        }
        _SaveToJson() {
            return {
                sa: this._isSelectAll,
                insts: this._instances.map(a => a.GetUID())
            }
        }
        _LoadFromJson(a, b) {
            a = a.GetRuntime();
            this._isSelectAll = !!b.sa;
            e.clearArray(this._instances);
            for (const d of b.insts)(b = a.GetInstanceByUID(d)) && this._instances.push(b)
        }
    }
} {
    "use strict";
    const e = self.C3;

    function a(b, d) {
        let c = b.get(d);
        c || (c = new Map, b.set(d, c));
        return c
    }
    e.SDKPluginBase = class extends e.DefendedBase {
        constructor(b) {
            super();
            this._runtime = b.runtime;
            this._isSingleGlobal = !!b.isSingleGlobal;
            this._isWorldType = !!b.isWorld;
            this._isRotatable = !!b.isRotatable;
            this._mustPredraw = !!b.mustPredraw;
            this._hasEffects = !!b.hasEffects;
            this._supportsSceneGraph = !!b.supportsSceneGraph;
            this._supportsMesh = !!b.supportsMesh;
            this._singleGlobalObjectClass = null;
            this._boundACEMethodCache =
                new Map;
            this._boundACEMethodCache_1param = new Map;
            this._boundACEMethodCache_2params = new Map;
            this._boundACEMethodCache_3params = new Map
        }
        Release() {
            this._runtime = null
        }
        GetRuntime() {
            return this._runtime
        }
        OnCreate() {}
        IsSingleGlobal() {
            return this._isSingleGlobal
        }
        IsWorldType() {
            return this._isWorldType
        }
        IsRotatable() {
            return this._isRotatable
        }
        MustPreDraw() {
            return this._mustPredraw
        }
        HasEffects() {
            return this._hasEffects
        }
        SupportsSceneGraph() {
            return this._supportsSceneGraph
        }
        SupportsMesh() {
            return this._supportsMesh
        }
        _GetBoundACEMethod(b,
            d) {
            if (!d) throw Error("missing 'this' binding");
            let c = this._boundACEMethodCache.get(b);
            if (c) return c;
            c = b.bind(d);
            this._boundACEMethodCache.set(b, c);
            return c
        }
        _GetBoundACEMethod_1param(b, d, c) {
            if (!d) throw Error("missing 'this' binding");
            const f = a(this._boundACEMethodCache_1param, b);
            let k = f.get(c);
            if (k) return k;
            k = b.bind(d, c);
            f.set(c, k);
            return k
        }
        _GetBoundACEMethod_2params(b, d, c, f) {
            if (!d) throw Error("missing 'this' binding");
            var k = a(this._boundACEMethodCache_2params, b);
            k = a(k, c);
            let h = k.get(f);
            if (h) return h;
            h = b.bind(d, c, f);
            k.set(f, h);
            return h
        }
        _GetBoundACEMethod_3params(b, d, c, f, k) {
            if (!d) throw Error("missing 'this' binding");
            var h = a(this._boundACEMethodCache_3params, b);
            h = a(h, c);
            h = a(h, f);
            let l = h.get(k);
            if (l) return l;
            l = b.bind(d, c, f, k);
            h.set(k, l);
            return l
        }
        _SetSingleGlobalObjectClass(b) {
            if (!this.IsSingleGlobal()) throw Error("must be single-global plugin");
            this._singleGlobalObjectClass = b
        }
        GetSingleGlobalObjectClass() {
            if (!this.IsSingleGlobal()) throw Error("must be single-global plugin");
            return this._singleGlobalObjectClass
        }
        GetSingleGlobalInstance() {
            if (!this.IsSingleGlobal()) throw Error("must be single-global plugin");
            return this._singleGlobalObjectClass.GetSingleGlobalInstance()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.SDKDOMPluginBase = class extends e.SDKPluginBase {
        constructor(a, b) {
            super(a);
            this._domComponentId = b;
            this._nextElementId = 0;
            this._instMap = new Map;
            this.AddElementMessageHandler("elem-focused", d => d._OnElemFocused());
            this.AddElementMessageHandler("elem-blurred", d => {
                d && d._OnElemBlurred()
            })
        }
        Release() {
            super.Release()
        }
        _AddElement(a) {
            const b = this._nextElementId++;
            this._instMap.set(b, a);
            return b
        }
        _RemoveElement(a) {
            this._instMap.delete(a)
        }
        AddElementMessageHandler(a, b) {
            this._runtime.AddDOMComponentMessageHandler(this._domComponentId,
                a, d => {
                    const c = this._instMap.get(d.elementId);
                    b(c, d)
                })
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.SDKTypeBase = class extends e.DefendedBase {
        constructor(a) {
            super();
            this._objectClass = a;
            this._runtime = a.GetRuntime();
            this._plugin = a.GetPlugin()
        }
        Release() {
            this._plugin = this._runtime = this._objectClass = null
        }
        GetObjectClass() {
            return this._objectClass
        }
        GetRuntime() {
            return this._runtime
        }
        GetPlugin() {
            return this._plugin
        }
        GetImageInfo() {
            return this._objectClass.GetImageInfo()
        }
        FinishCondition(a) {}
        LoadTextures(a) {}
        ReleaseTextures() {}
        OnDynamicTextureLoadComplete() {}
        PreloadTexturesWithInstances(a) {}
        LoadTilemapData() {}
        GetScriptInterfaceClass() {
            return null
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.SDKInstanceBase = class extends e.DefendedBase {
        constructor(a, b) {
            super();
            this._inst = a;
            this._domComponentId = b;
            this._runtime = a.GetRuntime();
            this._objectClass = this._inst.GetObjectClass();
            this._sdkType = this._objectClass.GetSdkType();
            this._tick2Func = this._tickFunc = null;
            this._isTicking2 = this._isTicking = !1;
            this._disposables = null;
            this._wasReleased = !1
        }
        Release() {
            this._wasReleased = !0;
            this._StopTicking();
            this._StopTicking2();
            this._tick2Func = this._tickFunc = null;
            this._disposables &&
                (this._disposables.Release(), this._disposables = null);
            this._sdkType = this._objectClass = this._runtime = this._inst = null
        }
        WasReleased() {
            return this._wasReleased
        }
        GetInstance() {
            return this._inst
        }
        GetRuntime() {
            return this._runtime
        }
        GetObjectClass() {
            return this._objectClass
        }
        GetPlugin() {
            return this._sdkType.GetPlugin()
        }
        GetSdkType() {
            return this._sdkType
        }
        GetScriptInterface() {
            return this._inst.GetInterfaceClass()
        }
        Trigger(a) {
            return this._runtime.Trigger(a, this._inst, null)
        }
        DebugTrigger(a) {
            return this._runtime.DebugTrigger(a,
                this._inst, null)
        }
        TriggerAsync(a) {
            return this._runtime.TriggerAsync(a, this._inst, null)
        }
        FastTrigger(a, b) {
            return this._runtime.FastTrigger(a, this._inst, b)
        }
        DebugFastTrigger(a, b) {
            return this._runtime.DebugFastTrigger(a, this._inst, b)
        }
        ScheduleTriggers(a) {
            return this._runtime.ScheduleTriggers(a)
        }
        AddDOMMessageHandler(a, b) {
            this._runtime.AddDOMComponentMessageHandler(this._domComponentId, a, b)
        }
        AddDOMMessageHandlers(a) {
            for (const [b, d] of a) this.AddDOMMessageHandler(b, d)
        }
        PostToDOM(a, b) {
            this._runtime.PostComponentMessageToDOM(this._domComponentId,
                a, b)
        }
        PostToDOMAsync(a, b) {
            return this._runtime.PostComponentMessageToDOMAsync(this._domComponentId, a, b)
        }
        _PostToDOMMaybeSync(a, b) {
            if (this._runtime.IsInWorker()) this.PostToDOM(a, b);
            else return window.c3_runtimeInterface._OnMessageFromRuntime({
                type: "event",
                component: this._domComponentId,
                handler: a,
                data: b,
                responseId: null
            })
        }
        Tick() {}
        Tick2() {}
        _StartTicking() {
            this._isTicking || (this._tickFunc || (this._tickFunc = () => this.Tick()), this._runtime.Dispatcher().addEventListener("tick", this._tickFunc), this._isTicking = !0)
        }
        _StopTicking() {
            this._isTicking && (this._runtime.Dispatcher().removeEventListener("tick", this._tickFunc), this._isTicking = !1)
        }
        IsTicking() {
            return this._isTicking
        }
        _StartTicking2() {
            this._isTicking2 || (this._tick2Func || (this._tick2Func = () => this.Tick2()), this._runtime.Dispatcher().addEventListener("tick2", this._tick2Func), this._isTicking2 = !0)
        }
        _StopTicking2() {
            this._isTicking2 && (this._runtime.Dispatcher().removeEventListener("tick2", this._tick2Func), this._isTicking2 = !1)
        }
        IsTicking2() {
            return this._isTicking2
        }
        GetDebuggerProperties() {
            return []
        }
        SaveToJson() {
            return null
        }
        LoadFromJson(a) {}
        GetPropertyValueByIndex(a) {}
        SetPropertyValueByIndex(a,
            b) {}
        OffsetPropertyValueByIndex(a, b) {
            if (0 !== b) {
                var d = this.GetPropertyValueByIndex(a);
                if ("number" !== typeof d) throw Error("expected number");
                this.SetPropertyValueByIndex(a, d + b)
            }
        }
        SetPropertyColorOffsetValueByIndex(a, b, d, c) {}
        CallAction(a, ...b) {
            a.call(this, ...b)
        }
        CallExpression(a, ...b) {
            return a.call(this, ...b)
        }
        GetScriptInterfaceClass() {
            return null
        }
        DispatchScriptEvent(a, b, d) {
            const c = this.GetScriptInterface();
            a = e.New(e.Event, a, b);
            a.instance = c;
            d && Object.assign(a, d);
            c.dispatchEvent(a)
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.SDKWorldInstanceBase = class extends e.SDKInstanceBase {
        constructor(a, b) {
            super(a, b);
            this._worldInfo = a.GetWorldInfo();
            this._webglcontextrestored_handler = this._webglcontextlost_handler = null
        }
        Release() {
            if (this._webglcontextlost_handler) {
                const a = this._runtime.Dispatcher();
                a.removeEventListener("webglcontextlost", this._webglcontextlost_handler);
                a.removeEventListener("webglcontextrestored", this._webglcontextrestored_handler);
                this._webglcontextrestored_handler = this._webglcontextlost_handler =
                    null
            }
            this._worldInfo = null;
            super.Release()
        }
        HandleWebGLContextLoss() {
            if (!this._webglcontextlost_handler) {
                this._webglcontextlost_handler = () => this.OnWebGLContextLost();
                this._webglcontextrestored_handler = () => this.OnWebGLContextRestored();
                var a = this._runtime.Dispatcher();
                a.addEventListener("webglcontextlost", this._webglcontextlost_handler);
                a.addEventListener("webglcontextrestored", this._webglcontextrestored_handler)
            }
        }
        OnWebGLContextLost() {}
        OnWebGLContextRestored() {}
        GetWorldInfo() {
            return this._worldInfo
        }
        IsOriginalSizeKnown() {
            return !1
        }
        GetOriginalWidth() {
            if (!this.IsOriginalSizeKnown()) throw Error("original size not known");
            const a = this.GetCurrentImageInfo();
            if (a) return a.GetWidth()
        }
        GetOriginalHeight() {
            if (!this.IsOriginalSizeKnown()) throw Error("original size not known");
            const a = this.GetCurrentImageInfo();
            if (a) return a.GetHeight()
        }
        GetCurrentImageInfo() {
            return null
        }
        GetCurrentSurfaceSize() {
            var a = this.GetCurrentImageInfo();
            return a && (a = a.GetTexture()) ? [a.GetWidth(), a.GetHeight()] : [100, 100]
        }
        GetCurrentTexRect() {
            const a = this.GetCurrentImageInfo();
            return a ? a.GetTexRect() : null
        }
        GetCurrentTexQuad() {
            const a = this.GetCurrentImageInfo();
            return a ? a.GetTexQuad() : null
        }
        IsCurrentTexRotated() {
            const a = this.GetCurrentImageInfo();
            return a ? a.IsRotated() : !1
        }
        GetImagePoint(a) {
            a = this._inst.GetWorldInfo();
            return [a.GetX(), a.GetY()]
        }
        LoadTilemapData(a, b, d) {}
        TestPointOverlapTile(a, b) {}
        RendersToOwnZPlane() {
            return !0
        }
    }
} {
    "use strict";
    const e = self.C3,
        a = e.New(e.Rect);
    e.SDKDOMInstanceBase = class extends e.SDKWorldInstanceBase {
        constructor(b, d) {
            super(b, d);
            this._elementId = this.GetPlugin()._AddElement(this);
            this._isElementShowing = !0;
            this._autoFontSize = this._elemHasFocus = !1;
            this._lastRect = e.New(e.Rect, 0, 0, -1, -1);
            b = this._runtime.GetCanvasManager();
            this._lastWindowWidth = b.GetLastWidth();
            this._lastWindowHeight = b.GetLastHeight();
            this._isPendingUpdateState = !1;
            this._StartTicking()
        }
        Release() {
            this.GetPlugin()._RemoveElement(this._elementId);
            this.PostToDOMElement("destroy");
            this._elementId = -1;
            super.Release()
        }
        _GetElementInDOMMode() {
            if (this._runtime.IsInWorker()) throw Error("not valid in worker mode");
            return this._PostToDOMElementMaybeSync("get-element")
        }
        PostToDOMElement(b, d) {
            d || (d = {});
            d.elementId = this._elementId;
            this.PostToDOM(b, d)
        }
        _PostToDOMElementMaybeSync(b, d) {
            d || (d = {});
            d.elementId = this._elementId;
            return this._PostToDOMMaybeSync(b, d)
        }
        PostToDOMElementAsync(b, d) {
            d || (d = {});
            d.elementId = this._elementId;
            return this.PostToDOMAsync(b, d)
        }
        CreateElement(b) {
            b ||
                (b = {});
            const d = this.GetWorldInfo().IsVisible();
            b.elementId = this._elementId;
            b.isVisible = d;
            Object.assign(b, this.GetElementState());
            this._isElementShowing = !!b.isVisible;
            this._PostToDOMMaybeSync("create", b);
            this._UpdatePosition(!0)
        }
        SetElementVisible(b) {
            b = !!b;
            this._isElementShowing !== b && (this._isElementShowing = b, this.PostToDOMElement("set-visible", {
                isVisible: b
            }))
        }
        Tick() {
            this._UpdatePosition(!1)
        }
        _ShouldPreserveElement() {
            const b = this._runtime.GetCanvasManager().GetFullscreenMode();
            return "Android" === e.Platform.OS &&
                ("scale-inner" === b || "scale-outer" === b || "crop" === b)
        }
        _UpdatePosition(b) {
            var d = this.GetWorldInfo();
            const c = d.GetLayer();
            var f = d.GetX(),
                k = d.GetY();
            let [h, l] = c.LayerToCanvasCss(f, k), [n, u] = c.LayerToCanvasCss(f + d.GetWidth(), k + d.GetHeight());
            f = this._runtime.GetCanvasManager();
            k = f.GetCssWidth();
            const w = f.GetCssHeight();
            if (d.IsVisible() && c.IsVisible()) {
                if (!this._ShouldPreserveElement()) {
                    if (0 >= n || 0 >= u || h >= k || l >= w) {
                        this.SetElementVisible(!1);
                        return
                    }
                    1 > h && (h = 1);
                    1 > l && (l = 1);
                    n >= k && (n = k - 1);
                    u >= w && (u = w - 1)
                }
                a.set(h, l,
                    n, u);
                d = f.GetLastWidth();
                k = f.GetLastHeight();
                !b && a.equals(this._lastRect) && this._lastWindowWidth === d && this._lastWindowHeight === k ? this.SetElementVisible(!0) : (this._lastRect.copy(a), this._lastWindowWidth = d, this._lastWindowHeight = k, this.SetElementVisible(!0), b = null, this._autoFontSize && (b = c.GetDisplayScale() - .2), this.PostToDOMElement("update-position", {
                    left: Math.round(this._lastRect.getLeft()) + f.GetCanvasClientX(),
                    top: Math.round(this._lastRect.getTop()) + f.GetCanvasClientY(),
                    width: Math.round(this._lastRect.width()),
                    height: Math.round(this._lastRect.height()),
                    fontSize: b
                }))
            } else this.SetElementVisible(!1)
        }
        FocusElement() {
            this._PostToDOMElementMaybeSync("focus", {
                focus: !0
            })
        }
        BlurElement() {
            this._PostToDOMElementMaybeSync("focus", {
                focus: !1
            })
        }
        _OnElemFocused() {
            this._elemHasFocus = !0
        }
        _OnElemBlurred() {
            this._elemHasFocus = !1
        }
        IsElementFocused() {
            return this._elemHasFocus
        }
        SetElementCSSStyle(b, d) {
            this.PostToDOMElement("set-css-style", {
                prop: e.CSSToCamelCase(b),
                val: d
            })
        }
        SetElementAttribute(b, d) {
            this.PostToDOMElement("set-attribute", {
                name: b,
                val: d
            })
        }
        RemoveElementAttribute(b) {
            this.PostToDOMElement("remove-attribute", {
                name: b
            })
        }
        UpdateElementState() {
            this._isPendingUpdateState || (this._isPendingUpdateState = !0, Promise.resolve().then(() => {
                this._isPendingUpdateState = !1;
                this.PostToDOMElement("update-state", this.GetElementState())
            }))
        }
        GetElementState() {}
        GetElementId() {
            return this._elementId
        }
    }
} {
    "use strict";
    const e = self.C3,
        a = self.IBehavior;
    e.SDKBehaviorBase = class extends e.DefendedBase {
        constructor(b) {
            super();
            this._runtime = b.runtime;
            this._myObjectClasses = e.New(e.ArraySet);
            this._myInstances = e.New(e.ArraySet);
            this._iBehavior = null;
            this._scriptInterfaceClass = b.scriptInterfaceClass || null
        }
        Release() {
            this._myInstances.Release();
            this._myObjectClasses.Release();
            this._runtime = null
        }
        GetRuntime() {
            return this._runtime
        }
        OnCreate() {}
        _AddObjectClass(b) {
            this._myObjectClasses.Add(b)
        }
        GetObjectClasses() {
            return this._myObjectClasses.GetArray()
        }
        _AddInstance(b) {
            this._myInstances.Add(b)
        }
        _RemoveInstance(b) {
            this._myInstances.Delete(b)
        }
        GetInstances() {
            return this._myInstances.GetArray()
        }
        GetIBehavior() {
            if (null ===
                this._iBehavior) {
                const b = this._scriptInterfaceClass;
                if (b) {
                    if (this._iBehavior = new b(this), !(this._iBehavior instanceof a)) throw new TypeError("script interface class must derive from IBehavior");
                } else this._iBehavior = new a(this)
            }
            return this._iBehavior
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.SDKBehaviorTypeBase = class extends e.DefendedBase {
        constructor(a) {
            super();
            this._runtime = a.GetRuntime();
            this._behaviorType = a;
            this._objectClass = a.GetObjectClass();
            this._behavior = a.GetBehavior();
            this._behavior._AddObjectClass(this._objectClass)
        }
        Release() {
            this._behavior = this._objectClass = this._behaviorType = this._runtime = null
        }
        GetBehaviorType() {
            return this._behaviorType
        }
        GetObjectClass() {
            return this._objectClass
        }
        GetRuntime() {
            return this._runtime
        }
        GetBehavior() {
            return this._behavior
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.SDKBehaviorInstanceBase = class extends e.DefendedBase {
        constructor(a, b) {
            super();
            this._behInst = a;
            this._domComponentId = b;
            this._inst = a.GetObjectInstance();
            this._runtime = a.GetRuntime();
            this._behaviorType = a.GetBehaviorType();
            this._sdkType = this._behaviorType.GetSdkType();
            this._isPostTicking = this._isTicking2 = this._isTicking = !1;
            this._disposables = null
        }
        Release() {
            this._StopTicking();
            this._StopTicking2();
            this._StopPostTicking();
            this._disposables && (this._disposables.Release(), this._disposables =
                null);
            this._sdkType = this._behaviorType = this._runtime = this._inst = this._behInst = null
        }
        GetBehavior() {
            return this._behaviorType.GetBehavior()
        }
        GetBehaviorInstance() {
            return this._behInst
        }
        GetObjectInstance() {
            return this._inst
        }
        GetObjectClass() {
            return this._inst.GetObjectClass()
        }
        GetWorldInfo() {
            return this._inst.GetWorldInfo()
        }
        GetRuntime() {
            return this._runtime
        }
        GetBehaviorType() {
            return this._behaviorType
        }
        GetSdkType() {
            return this._sdkType
        }
        GetScriptInterface() {
            return this._behInst.GetScriptInterface()
        }
        Trigger(a) {
            return this._runtime.Trigger(a,
                this._inst, this._behaviorType)
        }
        DebugTrigger(a) {
            return this._runtime.DebugTrigger(a, this._inst, this._behaviorType)
        }
        TriggerAsync(a) {
            return this._runtime.TriggerAsync(a, this._inst, this._behaviorType)
        }
        PostCreate() {}
        Tick() {}
        Tick2() {}
        PostTick() {}
        _StartTicking() {
            this._isTicking || (this._runtime._AddBehInstToTick(this), this._isTicking = !0)
        }
        _StopTicking() {
            this._isTicking && (this._runtime._RemoveBehInstToTick(this), this._isTicking = !1)
        }
        IsTicking() {
            return this._isTicking
        }
        _StartTicking2() {
            this._isTicking2 || (this._runtime._AddBehInstToTick2(this),
                this._isTicking2 = !0)
        }
        _StopTicking2() {
            this._isTicking2 && (this._runtime._RemoveBehInstToTick2(this), this._isTicking2 = !1)
        }
        IsTicking2() {
            return this._isTicking2
        }
        _StartPostTicking() {
            this._isPostTicking || (this._runtime._AddBehInstToPostTick(this), this._isPostTicking = !0)
        }
        _StopPostTicking() {
            this._isPostTicking && (this._runtime._RemoveBehInstToPostTick(this), this._isPostTicking = !1)
        }
        IsPostTicking() {
            return this._isPostTicking
        }
        GetDebuggerProperties() {
            return []
        }
        AddDOMMessageHandler(a, b) {
            this._runtime.AddDOMComponentMessageHandler(this._domComponentId,
                a, b)
        }
        OnSpriteFrameChanged(a, b) {}
        SaveToJson() {
            return null
        }
        LoadFromJson(a) {}
        GetPropertyValueByIndex(a) {}
        SetPropertyValueByIndex(a, b) {}
        OffsetPropertyValueByIndex(a, b) {
            if (0 !== b) {
                var d = this.GetPropertyValueByIndex(a);
                if ("number" !== typeof d) throw Error("expected number");
                this.SetPropertyValueByIndex(a, d + b)
            }
        }
        SetPropertyColorOffsetValueByIndex(a, b, d, c) {}
        CallAction(a, ...b) {
            a.call(this, ...b)
        }
        CallExpression(a, ...b) {
            return a.call(this, ...b)
        }
        GetScriptInterfaceClass() {
            return null
        }
        DispatchScriptEvent(a, b, d) {
            const c =
                this.GetScriptInterface();
            a = e.New(e.Event, a, b);
            a.behaviorInstance = c;
            a.instance = c.instance;
            d && Object.assign(a, d);
            c.dispatchEvent(a)
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins = {};
    e.Behaviors = {};
    e.PluginManager = class extends e.DefendedBase {
        constructor(a) {
            super();
            this._runtime = a;
            this._allPlugins = [];
            this._pluginsByCtor = new Map;
            this._systemPlugin = null;
            this._allBehaviors = [];
            this._behaviorsByCtor = new Map;
            this._jumpthruBehavior = this._solidBehavior = null
        }
        CreatePlugin(a) {
            const b = this._runtime.GetObjectReference(a[0]);
            if (!b) throw Error("missing plugin");
            e.AddCommonACEs(a, b);
            a = e.New(b, {
                runtime: this._runtime,
                isSingleGlobal: a[1],
                isWorld: a[2],
                isRotatable: a[5],
                hasEffects: a[8],
                mustPredraw: a[9],
                supportsSceneGraph: a[13],
                supportsMesh: a[14]
            });
            a.OnCreate();
            this._allPlugins.push(a);
            this._pluginsByCtor.set(b, a)
        }
        CreateSystemPlugin() {
            this._systemPlugin = e.New(e.Plugins.System, {
                runtime: this._runtime,
                isSingleGlobal: !0
            });
            this._systemPlugin.OnCreate()
        }
        CreateBehavior(a) {
            a = this._runtime.GetObjectReference(a[1]);
            if (!a) throw Error("missing behavior");
            const b = e.New(a, {
                runtime: this._runtime
            });
            b.OnCreate();
            this._allBehaviors.push(b);
            this._behaviorsByCtor.set(a, b);
            !this._solidBehavior &&
                e.Behaviors.solid && b instanceof e.Behaviors.solid ? this._solidBehavior = b : !this._jumpthruBehavior && e.Behaviors.jumpthru && b instanceof e.Behaviors.jumpthru && (this._jumpthruBehavior = b)
        }
        GetPluginByConstructorFunction(a) {
            return this._pluginsByCtor.get(a) || null
        }
        HasBehaviorByConstructorFunction(a) {
            return this._behaviorsByCtor.has(a)
        }
        GetBehaviorByConstructorFunction(a) {
            return this._behaviorsByCtor.get(a) || null
        }
        GetSystemPlugin() {
            return this._systemPlugin
        }
        GetSolidBehavior() {
            return this._solidBehavior
        }
        GetJumpthruBehavior() {
            return this._jumpthruBehavior
        }
    }
} {
    "use strict";
    const e = self.C3,
        a = new Set;
    e.ImageInfo = class extends e.DefendedBase {
        constructor() {
            super();
            this._url = "";
            this._height = this._width = this._offsetY = this._offsetX = this._size = 0;
            this._hasMetaData = this._isRotated = !1;
            this._imageAsset = null;
            this._textureState = "";
            this._rcTex = e.New(e.Rect);
            this._quadTex = e.New(e.Quad);
            a.add(this)
        }
        Release() {
            this.ReleaseTexture();
            this._imageAsset = null;
            a.delete(this)
        }
        static OnWebGLContextLost() {
            for (const b of a) b._textureState = "", b._rcTex.set(0, 0, 0, 0), b._quadTex.setFromRect(b._rcTex)
        }
        LoadData(b) {
            this._url =
                b[0];
            this._size = b[1];
            this._offsetX = b[2];
            this._offsetY = b[3];
            this._width = b[4];
            this._height = b[5];
            this._isRotated = b[6];
            this._hasMetaData = !0
        }
        LoadDynamicAsset(b, d) {
            if (this._imageAsset) throw Error("already loaded asset");
            this._url = d;
            const c = {};
            e.IsAbsoluteURL(d) && (c.loadPolicy = "remote");
            this.LoadAsset(b, c);
            return this._imageAsset.Load()
        }
        ReplaceWith(b) {
            if (b === this) throw Error("cannot replace with self");
            this.ReleaseTexture();
            this._url = b._url;
            this._size = b._size;
            this._offsetX = b._offsetX;
            this._offsetY = b._offsetY;
            this._width = b._width;
            this._height = b._height;
            this._isRotated = b._isRotated;
            this._hasMetaData = b._hasMetaData;
            this._imageAsset = b._imageAsset;
            this._textureState = b._textureState;
            this._rcTex = b._rcTex;
            this._quadTex = b._quadTex
        }
        GetURL() {
            return this._url
        }
        GetSize() {
            return this._size
        }
        GetOffsetX() {
            return this._offsetX
        }
        GetOffsetY() {
            return this._offsetY
        }
        IsRotated() {
            return this._isRotated
        }
        GetWidth() {
            return this._width
        }
        GetHeight() {
            return this._height
        }
        GetSheetWidth() {
            return this._imageAsset.GetWidth()
        }
        GetSheetHeight() {
            return this._imageAsset.GetHeight()
        }
        LoadAsset(b,
            d) {
            if (this._imageAsset) throw Error("already got asset");
            d = Object.assign({}, d, {
                url: this.GetURL(),
                size: this.GetSize()
            });
            this._imageAsset = b.LoadImage(d)
        }
        IsLoaded() {
            return this._imageAsset && this._imageAsset.IsLoaded()
        }
        async LoadStaticTexture(b, d) {
            if (!this._imageAsset) throw Error("no asset");
            if (this._textureState) throw Error("already loaded texture");
            this._textureState = "loading";
            b = await this._imageAsset.LoadStaticTexture(b, d);
            if (!b) return this._textureState = "", null;
            this._textureState = "loaded";
            this._hasMetaData ||
                (this._width = b.GetWidth(), this._height = b.GetHeight(), this._hasMetaData = !0);
            this._rcTex.set(this._offsetX, this._offsetY, this._offsetX + (this._isRotated ? this._height : this._width), this._offsetY + (this._isRotated ? this._width : this._height));
            this._rcTex.divide(b.GetWidth(), b.GetHeight());
            this._quadTex.setFromRect(this._rcTex);
            this._isRotated && this._quadTex.rotatePointsAnticlockwise();
            return b
        }
        ReleaseTexture() {
            this._textureState && (this._imageAsset && this._imageAsset.ReleaseTexture(), this._textureState = "", this._rcTex.set(0,
                0, 0, 0), this._quadTex.setFromRect(this._rcTex))
        }
        GetTexture() {
            return this._imageAsset ? this._imageAsset.GetTexture() : null
        }
        GetTexRect() {
            return this._rcTex
        }
        GetTexQuad() {
            return this._quadTex
        }
        async ExtractImageToCanvas() {
            const b = await this._imageAsset.LoadToDrawable(),
                d = e.CreateCanvas(this._width, this._height);
            d.getContext("2d").drawImage(b, this._offsetX, this._offsetY, this._width, this._height, 0, 0, this._width, this._height);
            return d
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.AnimationInfo = class extends e.DefendedBase {
        constructor(a) {
            super();
            this._name = a[0];
            this._speed = a[1];
            this._isLooping = !!a[2];
            this._repeatCount = a[3];
            this._repeatTo = a[4];
            this._isPingPong = !!a[5];
            this._sid = a[6];
            this._frames = a[7].map(b => e.New(e.AnimationFrameInfo, b))
        }
        Release() {
            for (const a of this._frames) a.Release();
            e.clearArray(this._frames)
        }
        LoadAllAssets(a) {
            for (const b of this._frames) b.GetImageInfo().LoadAsset(a)
        }
        LoadAllTextures(a, b) {
            return Promise.all(this._frames.map(d =>
                d.GetImageInfo().LoadStaticTexture(a, b)))
        }
        ReleaseAllTextures() {
            for (const a of this._frames) a.GetImageInfo().ReleaseTexture()
        }
        GetName() {
            return this._name
        }
        GetSID() {
            return this._sid
        }
        GetFrameCount() {
            return this._frames.length
        }
        GetFrames() {
            return this._frames
        }
        GetFrameAt(a) {
            a = Math.floor(a);
            if (0 > a || a >= this._frames.length) throw new RangeError("invalid frame");
            return this._frames[a]
        }
        GetSpeed() {
            return this._speed
        }
        IsLooping() {
            return this._isLooping
        }
        GetRepeatCount() {
            return this._repeatCount
        }
        GetRepeatTo() {
            return this._repeatTo
        }
        IsPingPong() {
            return this._isPingPong
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.AnimationFrameInfo = class extends e.DefendedBase {
        constructor(a) {
            super();
            this._imageInfo = e.New(e.ImageInfo);
            this._imageInfo.LoadData(a);
            this._duration = a[7];
            this._origin = e.New(e.Vector2, a[8], a[9]);
            this._imagePoints = a[10].map(b => e.New(e.ImagePoint, this, b));
            this._imagePointsByName = new Map;
            for (const b of this._imagePoints) this._imagePointsByName.set(b.GetName().toLowerCase(), b);
            this._collisionPoly = null;
            a = a[11];
            6 <= a.length && (this._collisionPoly = e.New(e.CollisionPoly, a))
        }
        Release() {
            this._collisionPoly &&
                (this._collisionPoly.Release(), this._collisionPoly = null);
            this._imageInfo.Release();
            this._imageInfo = null
        }
        GetImageInfo() {
            return this._imageInfo
        }
        GetDuration() {
            return this._duration
        }
        GetOriginX() {
            return this._origin.getX()
        }
        GetOriginY() {
            return this._origin.getY()
        }
        GetCollisionPoly() {
            return this._collisionPoly
        }
        GetImagePointByName(a) {
            return this._imagePointsByName.get(a.toLowerCase()) || null
        }
        GetImagePointByIndex(a) {
            a = Math.floor(a);
            return 0 > a || a >= this._imagePoints.length ? null : this._imagePoints[a]
        }
        GetImagePointCount() {
            return this._imagePoints.length
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.ImagePoint = class extends e.DefendedBase {
        constructor(a, b) {
            super();
            this._afi = a;
            this._name = b[0];
            this._pos = e.New(e.Vector2, b[1], b[2])
        }
        Release() {}
        GetName() {
            return this._name
        }
        GetX() {
            return this._pos.getX()
        }
        GetY() {
            return this._pos.getY()
        }
        GetVec2() {
            return this._pos
        }
    }
} {
    "use strict";
    const e = self.C3,
        a = self.C3Debugger,
        b = self.IObjectClass;
    e.ObjectClass = class extends e.DefendedBase {
        constructor(d, c, f) {
            super();
            const k = d.GetObjectReference(f[1]);
            this._runtime = d;
            this._plugin = d.GetPluginManager().GetPluginByConstructorFunction(k);
            this._sdkType = null;
            this._instSdkCtor = k.Instance;
            this._index = c;
            this._sid = f[11];
            this._name = f[0];
            this._jsPropName = this._runtime.GetJsPropName(f[14]);
            this._isGlobal = !!f[9];
            this._isFamily = !!f[2];
            this._isOnLoaderLayout = !!f[10];
            this._instVars = f[3].map(h =>
                ({
                    sid: h[0],
                    type: h[1],
                    name: h[2],
                    jsPropName: d.GetJsPropName(h[3])
                }));
            this._behaviorsCount = f[4];
            this._effectsCount = f[5];
            this._isWorldType = this._plugin.IsWorldType();
            this._effectList = null;
            this._collisionGrid = e.New(e.SparseGrid, d.GetOriginalViewportWidth(), d.GetOriginalViewportHeight());
            this._anyCollisionCellChanged = !0;
            this._anyInstanceParallaxed = !1;
            this._familyMembersSet = this._familyMembers = null;
            this._familyIndex = -1;
            this._familyEffectMap = this._familyBehaviorMap = this._familyInstVarMap = this._familiesSet =
                this._families = null;
            this._isInContainer = !1;
            this._container = null;
            this._behaviorTypes = f[8].map(h => e.BehaviorType.Create(this, h));
            this._behaviorTypesIncludingInherited = [];
            this._behaviorsByName = new Map;
            this._behaviorNameToIndex = new Map;
            this._usedBehaviorCtors = new Set;
            this._solStack = e.New(e.SolStack, this);
            this._defaultInstanceData = null;
            this._defaultLayerIndex = 0;
            this._isContained = !1;
            this._animationsBySid = this._animationsByName = this._animations = this._imageInfo = this._container = null;
            this._textureRefCount =
                0;
            this._savedData = new Map;
            this._unsavedData = new Map;
            this._instances = [];
            this._iidsStale = !0;
            this._plugin.HasEffects() && (this._effectList = e.New(e.EffectList, this, f[12]));
            f[6] && (this._imageInfo = e.New(e.ImageInfo), this._imageInfo.LoadData(f[6]));
            if (f[7]) {
                this._animations = f[7].map(h => e.New(e.AnimationInfo, h));
                this._animationsByName = new Map;
                this._animationsBySid = new Map;
                for (const h of this._animations) this._animationsByName.set(h.GetName().toLowerCase(), h), this._animationsBySid.set(h.GetSID(), h)
            }
            this._isFamily ?
                (this._familyMembers = [], this._familyMembersSet = new Set, this._familyIndex = this._runtime._GetNextFamilyIndex()) : (this._families = [], this._familiesSet = new Set, this._familyInstVarMap = [], this._familyBehaviorMap = [], this._familyEffectMap = []);
            this._sdkType = e.New(k.Type, this, f[15]);
            this._instanceUserScriptClass = this._iObjectClass = null;
            this._userScriptDispatcher = e.New(e.Event.Dispatcher);
            if (c = this._sdkType.GetScriptInterfaceClass()) {
                if (this._iObjectClass = new c(this), !(this._iObjectClass instanceof b)) throw new TypeError("script interface class must derive from IObjectClass");
            } else this._iObjectClass = new b(this);
            f[13] && (c = f[13]) && this._sdkType.LoadTilemapData(c[0], c[1], c[2]);
            this._runtime.UsesLoaderLayout() && !this._isFamily && !this._isOnLoaderLayout && this._isWorldType || this.OnCreate();
            this._plugin.IsSingleGlobal() && (this._plugin._SetSingleGlobalObjectClass(this), this._CreateSingleGlobalInstance(f))
        }
        static Create(d, c, f) {
            return e.New(e.ObjectClass, d, c, f)
        }
        Release() {
            this._imageInfo && (this._imageInfo.Release(), this._imageInfo = null);
            if (this._animations) {
                for (const d of this._animations) d.Release();
                e.clearArray(this._animations);
                this._animationsByName.clear();
                this._animationsBySid.clear()
            }
            this._solStack.Release();
            this._solStack = null;
            this._savedData.clear();
            this._unsavedData.clear();
            this._runtime = this._container = null
        }
        _LoadFamily(d) {
            for (let c = 1, f = d.length; c < f; ++c) {
                const k = this._runtime.GetObjectClassByIndex(d[c]);
                this._familyMembers.push(k);
                this._familyMembersSet.add(k);
                k._families.push(this);
                k._familiesSet.add(this)
            }
        }
        _SetContainer(d) {
            this._isInContainer = !0;
            this._container = d
        }
        IsInContainer() {
            return this._isInContainer
        }
        GetContainer() {
            return this._container
        }
        _OnAfterCreate() {
            var d =
                0;
            if (!this._isFamily)
                for (var c of this._families)
                    for (var f of c.GetBehaviorTypes()) {
                        const l = f.GetName().toLowerCase();
                        this._behaviorsByName.set(l, f);
                        this._behaviorNameToIndex.set(l, d);
                        this._behaviorTypesIncludingInherited.push(f);
                        ++d
                    }
            for (var k of this.GetBehaviorTypes()) c = k.GetName().toLowerCase(), this._behaviorsByName.set(c, k), this._behaviorNameToIndex.set(c, d), this._behaviorTypesIncludingInherited.push(k), ++d;
            for (var h of this._behaviorTypesIncludingInherited) this._usedBehaviorCtors.add(h.GetBehavior().constructor);
            if (!this._isFamily && this._families.length) {
                d = this._runtime.GetFamilyCount();
                e.extendArray(this._familyInstVarMap, d, 0);
                e.extendArray(this._familyBehaviorMap, d, 0);
                e.extendArray(this._familyEffectMap, d, 0);
                d = [];
                c = h = k = 0;
                for (const l of this._families)
                    if (f = l.GetFamilyIndex(), this._familyInstVarMap[f] = k, k += l.GetInstanceVariablesCount(), this._familyBehaviorMap[f] = h, h += l.GetBehaviorTypesCount(), this._familyEffectMap[f] = c, c += l.GetEffectTypesCount(), (f = l.GetEffectList()) && this._effectList)
                        for (const n of f.GetAllEffectTypes()) d.push(n.Clone(this._effectList));
                this._effectList && this._effectList.PrependEffectTypes(d)
            }
        }
        _CreateSingleGlobalInstance(d) {
            const c = this._runtime._GetNewUID(),
                f = e.New(e.Instance, {
                    runtime: this._runtime,
                    objectType: this,
                    uid: c
                });
            f._CreateSdkInstance(d[16], []);
            this._runtime._MapInstanceByUID(c, f);
            this._instances.push(f)
        }
        GetSdkType() {
            return this._sdkType
        }
        IsOnLoaderLayout() {
            return this._isOnLoaderLayout
        }
        OnCreate() {
            this._isFamily || this._sdkType.OnCreate()
        }
        HasLoadedTextures() {
            return 0 < this._textureRefCount
        }
        LoadTextures(d) {
            if (this._isFamily) return Promise.resolve();
            this._textureRefCount++;
            return 1 === this._textureRefCount ? this._sdkType.LoadTextures(d) || Promise.resolve() : Promise.resolve()
        }
        ReleaseTextures() {
            if (!this._isFamily) {
                this._textureRefCount--;
                if (0 > this._textureRefCount) throw Error("released textures too many times");
                0 === this._textureRefCount && this._sdkType.ReleaseTextures()
            }
        }
        OnDynamicTextureLoadComplete() {
            if (this._isFamily) throw Error("not applicable to family");
            this._sdkType.OnDynamicTextureLoadComplete()
        }
        PreloadTexturesWithInstances(d) {
            return this._isFamily ?
                Promise.resolve() : this._sdkType.PreloadTexturesWithInstances(d)
        }
        GetRuntime() {
            return this._runtime
        }
        GetPlugin() {
            return this._plugin
        }
        GetInstanceSdkCtor() {
            return this._instSdkCtor
        }
        GetName() {
            return this._name
        }
        GetJsPropName() {
            return this._jsPropName
        }
        GetIndex() {
            return this._index
        }
        GetSID() {
            return this._sid
        }
        IsFamily() {
            return this._isFamily
        }
        IsGlobal() {
            return this._isGlobal
        }
        IsWorldType() {
            return this._isWorldType
        }
        GetFamilyIndex() {
            return this._familyIndex
        }
        GetBehaviorTypes() {
            return this._behaviorTypes
        }
        GetBehaviorTypesCount() {
            return this._behaviorsCount
        }
        UsesBehaviorByCtor(d) {
            return d &&
                this._usedBehaviorCtors.has(d)
        }
        GetInstanceVariablesCount() {
            return this._instVars.length
        }
        GetInstanceVariableSIDs() {
            return this._instVars.map(d => d.sid)
        }
        GetInstanceVariableIndexBySID(d) {
            return this._instVars.findIndex(c => c.sid === d)
        }
        GetInstanceVariableIndexByName(d) {
            return this._instVars.findIndex(c => c.name === d)
        }
        _GetAllInstanceVariableNames() {
            return this._instVars.map(d => d.name)
        }
        _GetAllInstanceVariableJsPropNames() {
            return this._instVars.map(d => d.jsPropName)
        }
        GetInstanceVariableType(d) {
            d = Math.floor(d);
            if (0 > d || d >= this._instVars.length) throw new RangeError("invalid instance variable index");
            return this._instVars[d].type
        }
        GetInstanceVariableName(d) {
            d = Math.floor(d);
            if (0 > d || d >= this._instVars.length) throw new RangeError("invalid instance variable index");
            return this._instVars[d].name
        }
        GetEffectTypesCount() {
            return this._effectsCount
        }
        GetBehaviorTypesIncludingInherited() {
            return this._behaviorTypesIncludingInherited
        }
        GetBehaviorTypeByName(d) {
            return this._behaviorsByName.get(d.toLowerCase()) || null
        }
        GetBehaviorIndexByName(d) {
            d =
                this._behaviorNameToIndex.get(d.toLowerCase());
            return "undefined" === typeof d ? -1 : d
        }
        GetEffectList() {
            return this._effectList
        }
        HasEffects() {
            return this._plugin.HasEffects()
        }
        UsesEffects() {
            return this._effectList && this._effectList.HasAnyEffectType()
        }
        GetSolStack() {
            return this._solStack
        }
        GetCurrentSol() {
            return this._solStack.GetCurrentSol()
        }
        GetImageInfo() {
            return this._imageInfo
        }
        SetDefaultInstanceData(d) {
            this._defaultInstanceData = d
        }
        GetDefaultInstanceData() {
            return this._defaultInstanceData
        }
        _SetDefaultLayerIndex(d) {
            this._defaultLayerIndex =
                d
        }
        GetDefaultLayerIndex() {
            return this._defaultLayerIndex
        }
        GetAnimations() {
            return this._animations
        }
        GetAnimationCount() {
            return this._animations.length
        }
        GetFamilies() {
            return this._families
        }
        BelongsToFamily(d) {
            return this._familiesSet.has(d)
        }
        GetFamilyMembers() {
            return this._familyMembers
        }
        FamilyHasMember(d) {
            return this._familyMembersSet.has(d)
        }
        GetFamilyBehaviorOffset(d) {
            return this._familyBehaviorMap[d]
        }
        GetFamilyInstanceVariableOffset(d) {
            return this._familyInstVarMap[d]
        }
        GetAnimationByName(d) {
            if (!this._animations) throw Error("no animations");
            return this._animationsByName.get(d.toLowerCase()) || null
        }
        GetAnimationBySID(d) {
            if (!this._animations) throw Error("no animations");
            return this._animationsBySid.get(d) || null
        }
        GetFirstAnimationFrame() {
            if (!this._animations) throw Error("no animations");
            return this._animations[0].GetFrameAt(0)
        }
        GetDefaultInstanceSize() {
            if (this._animations) {
                const d = this.GetFirstAnimationFrame().GetImageInfo();
                return [d.GetWidth(), d.GetHeight()]
            }
            return this._imageInfo ? [this._imageInfo.GetWidth(), this._imageInfo.GetHeight()] : [100,
                100
            ]
        }
        GetSingleGlobalInstance() {
            if (!this._plugin.IsSingleGlobal()) throw Error("not a single-global plugin");
            return this._instances[0]
        }
        GetInstances() {
            return this._instances
        }* instances() {
            yield* this._instances
        }* instancesIncludingPendingCreate() {
            yield* this._instances;
            for (const d of this._runtime._GetInstancesPendingCreate()) d.GetObjectClass() === this && (yield d)
        }
        GetInstanceCount() {
            return this._instances.length
        }
        _AddInstance(d) {
            this._instances.push(d)
        }
        _SetIIDsStale() {
            this._iidsStale = !0
        }
        _UpdateIIDs() {
            if (this._iidsStale &&
                !this._isFamily) {
                var d = this._instances,
                    c = 0;
                for (let f = d.length; c < f; ++c) d[c]._SetIID(c);
                d = this._runtime._GetInstancesPendingCreate();
                for (const f of d) f.GetObjectClass() === this && f._SetIID(c++);
                this._iidsStale = !1
            }
        }
        GetInstanceByIID(d) {
            var c = this._instances;
            if (d < c.length) return c[d];
            d -= c.length;
            c = this._runtime._GetInstancesPendingCreate();
            for (const f of c)
                if (f.GetObjectClass() === this) {
                    if (0 === d) return f;
                    --d
                } return null
        }
        GetFirstPicked(d) {
            if (d && d.IsInContainer() && d.GetObjectClass() !== this)
                for (const c of d.siblings())
                    if (c.GetObjectClass() ===
                        this) return c;
            d = this.GetCurrentSol().GetInstances();
            return d.length ? d[0] : null
        }
        GetPairedInstance(d) {
            const c = this.GetCurrentSol().GetInstances();
            return 0 < c.length ? c[d.GetIID() % c.length] : null
        }* allCorrespondingInstances(d, c) {
            const f = this.GetCurrentSol().GetInstances();
            var k = f.length;
            const h = c.GetCurrentSol(),
                l = c.GetCurrentSol().GetInstances(),
                n = l.length;
            var u = d.GetIID();
            if (c.IsFamily() || !h.IsSelectAll()) u = l.indexOf(d);
            d = Math.ceil(k / n);
            k %= n;
            0 === k || u < k ? (u *= d, k = d) : (u = k * d + (u - k) * (d - 1), k = d - 1);
            for (let w = u, q =
                    u + k; w < q; ++w) yield f[w]
        }
        FinishCondition(d) {
            this._sdkType.FinishCondition(d)
        }
        ApplySolToContainer() {
            if (this._isInContainer && !this._isFamily) {
                this._UpdateIIDs();
                var d = this.GetCurrentSol(),
                    c = d._GetOwnInstances(),
                    f = d.IsSelectAll(),
                    k = this._runtime.GetCurrentEventStackFrame();
                k = k && k.GetCurrentEvent() && k.GetCurrentEvent().IsOrBlock();
                for (const n of this._container.objectTypes())
                    if (n !== this) {
                        n._UpdateIIDs();
                        var h = n.GetCurrentSol();
                        h._SetSelectAll(f);
                        if (!f) {
                            var l = h._GetOwnInstances();
                            e.clearArray(l);
                            for (const u of c) l.push(n.GetInstanceByIID(u.GetIID()));
                            if (k) {
                                l = d._GetOwnElseInstances();
                                h = h._GetOwnElseInstances();
                                e.clearArray(h);
                                for (const u of l) h.push(n.GetInstanceByIID(u.GetIID()))
                            }
                        }
                    }
            }
        }
        _TruncateContainerSols(d, c) {
            for (const f of this.GetContainer().objectTypes()) {
                const k = f.GetCurrentSol();
                d ? e.truncateArray(k._GetOwnElseInstances(), c) : e.truncateArray(k._GetOwnInstances(), c)
            }
        }
        _GetCollisionCellGrid() {
            return this._collisionGrid
        }
        _SetAnyCollisionCellChanged(d) {
            this._anyCollisionCellChanged = !!d
        }
        _SetAnyInstanceParallaxed(d) {
            this._anyInstanceParallaxed = !!d
        }
        IsAnyInstanceParallaxed() {
            return this._anyInstanceParallaxed
        }
        _UpdateAllCollisionCells() {
            if (this._anyCollisionCellChanged &&
                this._isWorldType) {
                for (const d of this._instances) d.GetWorldInfo()._UpdateCollisionCell();
                for (const d of this._runtime._GetInstancesPendingCreate()) d.GetObjectClass() === this && d.GetWorldInfo()._UpdateCollisionCell();
                this._anyCollisionCellChanged = !1
            }
        }
        GetSavedDataMap() {
            this._savedData || (this._savedData = new Map);
            return this._savedData
        }
        GetUnsavedDataMap() {
            this._unsavedData || (this._unsavedData = new Map);
            return this._unsavedData
        }
        HasSolidBehavior() {
            return this.UsesBehaviorByCtor(e.Behaviors.solid)
        }
        HasNoSaveBehavior() {
            return this.UsesBehaviorByCtor(e.Behaviors.NoSave)
        }
        HasPersistBehavior() {
            return this.UsesBehaviorByCtor(e.Behaviors.Persist)
        }
        _SaveToJson() {
            const d = {
                instances: this._instances.map(c => c.SaveToJson())
            };
            this._savedData && this._savedData.size && (d.ex = e.ToSuperJSON(this._savedData));
            return d
        }
        _LoadFromJson(d) {
            this._savedData && (this._savedData.clear(), this._savedData = null);
            var c = d.ex;
            c && (this._savedData = e.FromSuperJSON(c));
            c = this._instances;
            d = d.instances;
            for (let f = 0, k = Math.min(c.length, d.length); f < k; ++f) c[f].LoadFromJson(d[f]);
            for (let f = d.length, k = c.length; f < k; ++f) this._runtime.DestroyInstance(c[f]);
            for (let f = c.length, k = d.length; f < k; ++f) {
                c = d[f];
                let h =
                    null;
                if (this.IsWorldType() && (h = this._runtime.GetMainRunningLayout().GetLayerBySID(c.w.l), !h)) continue;
                this._runtime.CreateInstanceFromData(this._defaultInstanceData || this, h, !1, 0, 0, !0).LoadFromJson(c)
            }
            this._SetIIDsStale()
        }
        GetIObjectClass() {
            return this._iObjectClass
        }
        UserScriptDispatcher() {
            return this._userScriptDispatcher
        }
        _GetUserScriptInstanceClass() {
            return this._instanceUserScriptClass
        }
        _SetUserScriptInstanceClass(d) {
            this._instanceUserScriptClass = d
        }
        DispatchUserScriptEvent(d) {
            var c = this._runtime;
            (c =
                c.IsDebug() && !c.GetEventSheetManager().IsInEventEngine()) && a.StartMeasuringScriptTime();
            this._userScriptDispatcher.dispatchEvent(d);
            c && a.AddScriptTime()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Container = class extends e.DefendedBase {
        constructor(a, b) {
            super();
            this._runtime = a;
            this._objectTypes = b;
            for (const d of this._objectTypes) d._SetContainer(this)
        }
        Release() {
            this._runtime = null
        }
        GetRuntime() {
            return this._runtime
        }
        GetObjectTypes() {
            return this._objectTypes
        }
        objectTypes() {
            return this._objectTypes
        }
        HasAnyWorldType() {
            return this._objectTypes.some(a => a.IsWorldType())
        }
    }
} {
    "use strict";
    const e = self.C3,
        a = self.C3Debugger,
        b = self.IInstance,
        d = [];
    let c = 0;
    const f = new WeakMap,
        k = new WeakMap;
    e.Instance = class extends e.DefendedBase {
        constructor(h) {
            super();
            this._runtime = h.runtime;
            this._objectType = h.objectType;
            this._iScriptInterface = this._sdkInst = this._worldInfo = null;
            this._iid = 0;
            this._uid = h.uid;
            this._puid = c++;
            this._flags = 0;
            this._behaviorInstances = this._instVarValues = d;
            var l = this._objectType.GetBehaviorTypesIncludingInherited();
            0 < l.length && (this._behaviorInstances = l.map((n, u) => e.New(e.BehaviorInstance, {
                runtime: this._runtime,
                behaviorType: n,
                instance: this,
                index: u
            })));
            this._siblings = this._objectType.IsInContainer() ? [] : null;
            this._timeScale = -1;
            this._dispatcher = null;
            l = this.GetPlugin();
            l.MustPreDraw() && (this._flags |= 4);
            if (l.IsWorldType())
                if (this._worldInfo = e.New(e.WorldInfo, this, h.layer), h.worldData) this._worldInfo.Init(h.worldData);
                else {
                    this._worldInfo.InitNoData();
                    const [n, u] = this._objectType.GetDefaultInstanceSize();
                    this._worldInfo.SetSize(n, u);
                    this.GetObjectClass().UsesEffects() && this._worldInfo.GetInstanceEffectList().LoadDefaultEffectParameters()
                } h.instVarData ?
                this._LoadInstanceVariableData(h.instVarData) : this._LoadDefaultInstanceVariables()
        }
        Release() {
            this._iScriptInterface && (this._iScriptInterface._Release(), this._iScriptInterface = null);
            if (0 < this._behaviorInstances.length) {
                for (var h of this._behaviorInstances) h.Release();
                e.clearArray(this._behaviorInstances)
            }
            this._sdkInst.Release();
            this._sdkInst = null;
            if (h = f.get(this)) h.clear(), f.delete(this);
            if (h = k.get(this)) h.clear(), k.delete(this);
            this._siblings && e.clearArray(this._siblings);
            this._dispatcher && (this._dispatcher.Release(),
                this._dispatcher = null);
            this._objectType = this._runtime = null;
            0 < this._instVarValues.length && e.clearArray(this._instVarValues);
            this._worldInfo && (this._worldInfo.Release(), this._worldInfo = null)
        }
        _LoadInstanceVariableData(h) {
            0 < h.length && (this._instVarValues = [], e.shallowAssignArray(this._instVarValues, h))
        }
        _LoadDefaultInstanceVariables() {
            const h = this._objectType.GetInstanceVariablesCount();
            if (0 !== h) {
                this._instVarValues = [];
                var l = [0, 0, ""];
                for (let n = 0; n < h; ++n) this._instVarValues.push(l[this._objectType.GetInstanceVariableType(n)])
            }
        }
        _CreateSdkInstance(h,
            l) {
            if (this._sdkInst) throw Error("already got sdk instance");
            for (let n = 0, u = this._behaviorInstances.length; n < u; ++n) this._behaviorInstances[n]._CreateSdkInstance(l ? l[n] : null);
            this._sdkInst = e.New(this._objectType.GetInstanceSdkCtor(), this, h);
            if (!(this._sdkInst instanceof e.SDKInstanceBase)) throw Error("sdk type must derive from SDKInstanceBase");
            for (let n = 0, u = this._behaviorInstances.length; n < u; ++n) this._behaviorInstances[n].PostCreate();
            this._objectType._GetUserScriptInstanceClass() && this._InitUserScriptInterface()
        }
        GetSdkInstance() {
            return this._sdkInst
        }
        GetWorldInfo() {
            return this._worldInfo
        }
        GetRuntime() {
            return this._runtime
        }
        GetTimeScale() {
            return this._timeScale
        }
        GetActiveTimeScale() {
            const h =
                this._timeScale;
            return -1 === h ? this.GetRuntime().GetTimeScale() : h
        }
        SetTimeScale(h) {
            h = +h;
            if (0 > h || !isFinite(h)) h = 0;
            this._timeScale = h
        }
        RestoreTimeScale() {
            this._timeScale = -1
        }
        Dispatcher() {
            this._dispatcher || (this._dispatcher = e.New(e.Event.Dispatcher));
            return this._dispatcher
        }
        Draw(h) {
            this._sdkInst.Draw(h)
        }
        OnCreate(h) {
            this._sdkInst.OnCreate(h)
        }
        _SetHasTilemap() {
            this._flags |= 2
        }
        HasTilemap() {
            return 0 !== (this._flags & 2)
        }
        _MarkDestroyed() {
            this._flags |= 1
        }
        IsDestroyed() {
            return 0 !== (this._flags & 1)
        }
        MustPreDraw() {
            return 0 !==
                (this._flags & 4)
        }
        SetMustMitigateZFighting() {
            this._flags |= 32
        }
        MustMitigateZFighting() {
            return 0 !== (this._flags & 32)
        }
        _IsSolidEnabled() {
            return 0 !== (this._flags & 8)
        }
        _SetSolidEnabled(h) {
            this._flags = h ? this._flags | 8 : this._flags & -9
        }
        _IsJumpthruEnabled() {
            return 0 !== (this._flags & 16)
        }
        _SetJumpthruEnabled(h) {
            this._flags = h ? this._flags | 16 : this._flags & -17
        }
        SetFlag(h, l) {
            h <<= 16;
            this._flags = l ? this._flags | h : this._flags & ~h
        }
        GetFlag(h) {
            return 0 !== (this._flags & h << 16)
        }
        GetCurrentImageInfo() {
            return this._sdkInst.GetCurrentImageInfo()
        }
        GetCurrentSurfaceSize() {
            return this._sdkInst.GetCurrentSurfaceSize()
        }
        GetCurrentTexRect() {
            return this._sdkInst.GetCurrentTexRect()
        }
        GetCurrentTexQuad() {
            return this._sdkInst.GetCurrentTexQuad()
        }
        IsCurrentTexRotated() {
            return this._sdkInst.IsCurrentTexRotated()
        }
        GetImagePoint(h) {
            return this._sdkInst.GetImagePoint(h)
        }
        GetObjectClass() {
            return this._objectType
        }
        RendersToOwnZPlane() {
            return this._sdkInst.RendersToOwnZPlane()
        }
        BelongsToObjectClass(h) {
            return h.IsFamily() ?
                h.FamilyHasMember(this.GetObjectClass()) : this.GetObjectClass() === h
        }
        VerifySupportsSceneGraph() {
            if (!this.GetPlugin().SupportsSceneGraph()) throw Error("object does not support scene graph");
        }
        HasParent() {
            return null !== this.GetParent()
        }
        GetParent() {
            var h = this.GetWorldInfo();
            return h ? (h = h.GetParent()) ? h.GetInstance() : null : null
        }
        GetTopParent() {
            var h = this.GetWorldInfo();
            return h ? (h = h.GetTopParent()) ? h.GetInstance() : null : null
        }* parents() {
            const h = this.GetWorldInfo();
            if (h)
                for (const l of h.parents()) yield l.GetInstance()
        }
        HasChildren() {
            const h =
                this.GetWorldInfo();
            return h ? h.HasChildren() : !1
        }
        GetChildren() {
            const h = this.GetWorldInfo();
            return h ? h.GetChildren().map(l => l.GetInstance()) : []
        }* children() {
            const h = this.GetWorldInfo();
            if (h)
                for (const l of h.children()) yield l.GetInstance()
        }* allChildren() {
            const h = this.GetWorldInfo();
            if (h)
                for (const l of h.allChildren()) yield l.GetInstance()
        }
        GetChildCount() {
            const h = this.GetWorldInfo();
            return h ? h.GetChildCount() : 0
        }
        GetChildAt(h) {
            const l = this.GetWorldInfo();
            return l ? (h = l.GetChildAt(h)) ? h.GetInstance() : null :
                null
        }
        AddChild(h, l) {
            this.VerifySupportsSceneGraph();
            h.VerifySupportsSceneGraph();
            this.GetWorldInfo().AddChild(h.GetWorldInfo(), l || {})
        }
        RemoveChild(h) {
            const l = this.GetWorldInfo();
            l && l.RemoveChild(h.GetWorldInfo())
        }
        GetDestroyWithParent() {
            const h = this.GetWorldInfo();
            return h ? h.GetDestroyWithParent() : !1
        }
        SetupInitialSceneGraphConnections() {
            var h = this.GetWorldInfo();
            if (h && (h = h.GetSceneGraphChildrenExportData()))
                for (const l of h)
                    if (h = this._runtime.GetInstanceByUID(l[2])) {
                        const n = l[3];
                        this.AddChild(h, {
                            transformX: !!(n >>
                                0 & 1),
                            transformY: !!(n >> 1 & 1),
                            transformWidth: !!(n >> 2 & 1),
                            transformHeight: !!(n >> 3 & 1),
                            transformAngle: !!(n >> 4 & 1),
                            destroyWithParent: !!(n >> 5 & 1),
                            transformZElevation: !!(n >> 6 & 1)
                        })
                    }
        }
        IsInContainer() {
            return null !== this._siblings
        }
        _AddSibling(h) {
            this._siblings.push(h)
        }
        GetSiblings() {
            return this._siblings
        }
        HasSibling(h) {
            return !!this.GetSibling(h)
        }
        GetSibling(h) {
            const l = this.siblings();
            if (null === l || 0 === l.length) return !1;
            for (const n of l)
                if (n.GetObjectClass() === h) return n;
            return null
        }
        siblings() {
            return this._siblings
        }
        SetSiblingsSinglePicked() {
            for (const h of this.siblings()) h.GetObjectClass().GetCurrentSol().SetSinglePicked(h)
        }
        _PushSiblingsToSolInstances() {
            for (const h of this.siblings()) h.GetObjectClass().GetCurrentSol()._PushInstance(h)
        }
        _SetSiblingsToSolInstancesIndex(h) {
            for (const l of this.siblings()) l.GetObjectClass().GetCurrentSol()._GetOwnInstances()[h] =
                l
        }
        _PushSiblingsToSolElseInstances() {
            for (const h of this.siblings()) h.GetObjectClass().GetCurrentSol()._PushElseInstance(h)
        }
        _SetSiblingsToSolElseInstancesIndex(h) {
            for (const l of this.siblings()) l.GetObjectClass().GetCurrentSol()._GetOwnElseInstances()[h] = l
        }
        GetPlugin() {
            return this._objectType.GetPlugin()
        }
        _SetIID(h) {
            this._iid = h
        }
        GetIID() {
            this._objectType._UpdateIIDs();
            return this._iid
        }
        GetUID() {
            return this._uid
        }
        GetPUID() {
            return this._puid
        }
        GetBehaviorInstances() {
            return this._behaviorInstances
        }
        GetBehaviorInstanceFromCtor(h) {
            if (!h) return null;
            for (const l of this._behaviorInstances)
                if (l.GetBehavior() instanceof h) return l;
            return null
        }
        GetBehaviorSdkInstanceFromCtor(h) {
            return h ? (h = this.GetBehaviorInstanceFromCtor(h)) ? h.GetSdkInstance() : null : null
        }
        GetBehaviorIndexBySID(h) {
            const l = this._behaviorInstances;
            for (let n = 0, u = l.length; n < u; ++n)
                if (l[n].GetBehaviorType().GetSID() === h) return n;
            return -1
        }
        GetAllInstanceVariableValues() {
            return this._instVarValues
        }
        _GetAllInstanceVariableNames() {
            return this._objectType._GetAllInstanceVariableNames()
        }
        GetInstanceVariableCount() {
            return this._instVarValues.length
        }
        GetInstanceVariableValue(h) {
            h |=
                0;
            const l = this._instVarValues;
            if (0 > h || h >= l.length) throw new RangeError("invalid instance variable");
            return l[h]
        }
        _GetInstanceVariableValueUnchecked(h) {
            return this._instVarValues[h]
        }
        _GetInstanceVariableTypedValue(h) {
            const l = this._instVarValues[h];
            return 0 === this._objectType.GetInstanceVariableType(h) ? !!l : l
        }
        SetInstanceVariableValue(h, l) {
            h |= 0;
            const n = this._instVarValues;
            if (0 > h || h >= n.length) throw new RangeError("invalid instance variable");
            switch (this._objectType.GetInstanceVariableType(h)) {
                case 0:
                    n[h] =
                        l ? 1 : 0;
                    break;
                case 1:
                    n[h] = "number" === typeof l ? l : parseFloat(l);
                    break;
                case 2:
                    n[h] = "string" === typeof l ? l : l.toString();
                    break;
                default:
                    throw Error("unknown instance variable type");
            }
        }
        SetInstanceVariableOffset(h, l) {
            if (0 !== l) {
                h |= 0;
                var n = this._instVarValues;
                if (0 > h || h >= n.length) throw new RangeError("invalid instance variable");
                var u = n[h];
                if ("number" === typeof u) n[h] = "number" === typeof l ? n[h] + l : n[h] + parseFloat(l);
                else {
                    if ("boolean" === typeof u) throw Error("can not set offset of boolean variable");
                    if ("string" === typeof u) throw Error("can not set offset of string variable");
                    throw Error("unknown instance variable type");
                }
            }
        }
        GetSavedDataMap() {
            let h = f.get(this);
            if (h) return h;
            h = new Map;
            f.set(this, h);
            return h
        }
        GetUnsavedDataMap() {
            let h = k.get(this);
            if (h) return h;
            h = new Map;
            k.set(this, h);
            return h
        }
        _HasAnyCreateDestroyHandler(h) {
            const l = this.GetObjectClass();
            if (l.UserScriptDispatcher().HasAnyHandlerFor(h)) return !0;
            for (const n of l.GetFamilies())
                if (n.UserScriptDispatcher().HasAnyHandlerFor(h)) return !0;
            return this._runtime.UserScriptDispatcher().HasAnyHandlerFor(h) ? !0 : !1
        }
        _TriggerOnCreatedOnSelfAndRelated() {
            const h =
                new Set;
            h.add(this);
            const l = this.GetWorldInfo();
            if (l && l.HasChildren())
                for (const n of this.allChildren())
                    if (h.add(n), n.IsInContainer())
                        for (const u of n.siblings()) h.add(u);
            if (this.IsInContainer())
                for (const n of this.siblings()) h.add(n);
            for (const n of h.values()) n._TriggerOnCreated()
        }
        _TriggerOnCreated() {
            if (this._HasAnyCreateDestroyHandler("instancecreate")) {
                const h = this.GetObjectClass(),
                    l = new e.Event("instancecreate");
                l.instance = this.GetInterfaceClass();
                h.DispatchUserScriptEvent(l);
                for (const n of h.GetFamilies()) n.DispatchUserScriptEvent(l);
                this._runtime.DispatchUserScriptEvent(l)
            }
            this._runtime.Trigger(this.GetPlugin().constructor.Cnds.OnCreated, this, null)
        }
        _TriggerOnDestroyed() {
            this._runtime.Trigger(this.GetPlugin().constructor.Cnds.OnDestroyed, this, null)
        }
        _FireDestroyedScriptEvents(h) {
            if (this._iScriptInterface) {
                var l = new e.Event("destroy");
                l.isEndingLayout = h;
                this.DispatchUserScriptEvent(l)
            }
            if (this._HasAnyCreateDestroyHandler("instancedestroy")) {
                l = this.GetObjectClass();
                var n = new e.Event("instancedestroy");
                n.instance = this.GetInterfaceClass();
                n.isEndingLayout = h;
                l.DispatchUserScriptEvent(n);
                for (const u of l.GetFamilies()) u.DispatchUserScriptEvent(n);
                this._runtime.DispatchUserScriptEvent(n)
            }
        }
        _GetDebuggerProperties() {
            return this._sdkInst.GetDebuggerProperties()
        }
        SaveToJson(h = "full") {
            const l = {};
            "full" === h ? l.uid = this.GetUID() : l.c3 = !0;
            if ("visual-state" !== h) {
                var n = f.get(this);
                n && n.size && (l.ex = e.ToSuperJSON(n)); - 1 !== this.GetTimeScale() && (l.mts = this.GetTimeScale());
                if (0 < this._objectType.GetInstanceVariablesCount()) {
                    n = {};
                    var u = this._objectType.GetInstanceVariableSIDs();
                    for (let w = 0, q = this._instVarValues.length; w < q; ++w) n[u[w].toString()] = this._instVarValues[w];
                    l.ivs = n
                }
                if (this._behaviorInstances.length) {
                    n = {};
                    for (const w of this._behaviorInstances)(u = w.SaveToJson()) && (n[w.GetBehaviorType().GetSID().toString()] = u);
                    l.behs = n
                }
            }
            this._worldInfo && (l.w = this._worldInfo._SaveToJson(h));
            (h = this._sdkInst.SaveToJson()) && (l.data = h);
            return l
        }
        _OnBeforeLoad(h = "full") {
            this._worldInfo && this._worldInfo._OnBeforeLoad(h)
        }
        LoadFromJson(h, l = "full") {
            if ("full" === l) this._uid = h.uid;
            else if (!h.c3) return;
            if ("visual-state" !== l) {
                var n = f.get(this);
                n && (n.clear(), f.delete(this));
                if (n = h.ex) n = e.FromSuperJSON(n), f.set(this, n);
                this._timeScale = h.hasOwnProperty("mts") ? h.mts : -1;
                if (n = h.ivs)
                    for (const [q, t] of Object.entries(n))
                        if (n = parseInt(q, 10), n = this._objectType.GetInstanceVariableIndexBySID(n), !(0 > n || n >= this._instVarValues.length)) {
                            var u = t;
                            null === u && (u = NaN);
                            this._instVarValues[n] = u
                        }
            }
            if (this.GetPlugin().IsWorldType()) {
                n = h.w;
                var w = n.l;
                this._worldInfo.GetLayer().GetSID() !== w && (u = this._worldInfo.GetLayer(), (w = u.GetLayout().GetLayerBySID(w)) ?
                    (this._worldInfo._SetLayer(w), u._RemoveInstance(this, !0), w._AddInstance(this, !0), w.SetZIndicesChanged(), this._worldInfo.SetBboxChanged()) : "full" === l && this._runtime.DestroyInstance(this));
                this._worldInfo._LoadFromJson(n, l)
            }
            if ("visual-state" !== l && (l = h.behs))
                for (const [q, t] of Object.entries(l)) l = parseInt(q, 10), l = this.GetBehaviorIndexBySID(l), 0 > l || l >= this._behaviorInstances.length || this._behaviorInstances[l].LoadFromJson(t);
            (h = h.data) && this._sdkInst.LoadFromJson(h)
        }
        GetInterfaceClass() {
            return this._iScriptInterface ||
                this._InitUserScriptInterface()
        }
        _InitUserScriptInterface() {
            var h = this._worldInfo ? self.IWorldInstance : b;
            const l = this._sdkInst.GetScriptInterfaceClass(),
                n = this._objectType._GetUserScriptInstanceClass(),
                u = n || l || h;
            b._Init(this);
            this._iScriptInterface = new u;
            b._Init(null);
            if (l && !(this._iScriptInterface instanceof h)) throw new TypeError(`script interface class '${l.name}' does not extend the right base class '${h.name}'`);
            if (n && (h = l || h, !(this._iScriptInterface instanceof h))) throw new TypeError(`setInstanceClass(): class '${n.name}' does not extend the right base class '${h.name}'`);
            return this._iScriptInterface
        }
        _GetInstVarsScriptDescriptor(h) {
            if (0 !== this._instVarValues.length) {
                var l = {},
                    n = this._objectType._GetAllInstanceVariableJsPropNames();
                for (let u = 0, w = n.length; u < w; ++u) l[n[u]] = {
                    configurable: !1,
                    enumerable: !0,
                    get: e.Instance.prototype._GetInstanceVariableTypedValue.bind(this, u),
                    set: e.Instance.prototype.SetInstanceVariableValue.bind(this, u)
                };
                l = Object.create(Object.prototype, l);
                h.instVars = {
                    value: l,
                    writable: !1
                }
            }
        }
        _GetBehaviorsScriptDescriptor(h) {
            var l = this._behaviorInstances;
            if (0 !==
                l.length) {
                var n = {};
                for (const u of l) n[u.GetBehaviorType().GetJsPropName()] = {
                    value: u.GetScriptInterface(),
                    writable: !1
                };
                l = Object.create(Object.prototype, n);
                h.behaviors = {
                    value: l,
                    writable: !1
                }
            }
        }
        DispatchUserScriptEvent(h) {
            h.instance = this.GetInterfaceClass();
            var l = this._runtime;
            (l = l.IsDebug() && !l.GetEventSheetManager().IsInEventEngine()) && a.StartMeasuringScriptTime();
            this.GetInterfaceClass().dispatchEvent(h);
            l && a.AddScriptTime()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.SceneGraphInfo = class extends e.DefendedBase {
        constructor(a) {
            super();
            this._owner = a;
            this._parent = null;
            this._children = [];
            this._startWidth = a.GetWidth();
            this._startHeight = a.GetHeight();
            this._startScaleY = this._startScaleX = 1;
            this._parentStartAngle = 0
        }
        Release() {
            this._parent = null;
            e.clearArray(this._children)
        }
        SetParent(a) {
            this._parentStartAngle = (this._parent = a) ? a.GetAngle() : 0
        }
        GetParent() {
            return this._parent
        }
        HasChildren() {
            return 0 < this._children.length
        }
        GetChildren() {
            return this._children
        }
        GetStartScaleX() {
            return this._startScaleX
        }
        SetStartScaleX(a) {
            this._startScaleX =
                a
        }
        GetStartScaleY() {
            return this._startScaleY
        }
        SetStartScaleY(a) {
            this._startScaleY = a
        }
        _GetStartWidth() {
            return this._startWidth
        }
        _GetStartHeight() {
            return this._startHeight
        }
        GetParentScaleX() {
            return this._owner.GetTransformWithParentWidth() ? this._parent.GetWidth() / this._parent._GetSceneGraphInfo()._GetStartWidth() : 1
        }
        GetParentScaleY() {
            return this._owner.GetTransformWithParentHeight() ? this._parent.GetHeight() / this._parent._GetSceneGraphInfo()._GetStartHeight() : 1
        }
        GetParentStartAngle() {
            return this._parentStartAngle
        }
        _SaveToJson() {
            return {
                sw: this._startWidth,
                sh: this._startHeight,
                sx: this._startScaleX,
                sy: this._startScaleY,
                psa: this._parentStartAngle,
                c: this._children.map(a => {
                    let b = "";
                    a.GetTransformWithParentX() && (b += "x");
                    a.GetTransformWithParentY() && (b += "y");
                    a.GetTransformWithParentWidth() && (b += "w");
                    a.GetTransformWithParentHeight() && (b += "h");
                    a.GetTransformWithParentAngle() && (b += "a");
                    a.GetTransformWithParentZElevation() && (b += "z");
                    a.GetDestroyWithParent() && (b += "d");
                    return {
                        uid: a.GetInstance().GetUID(),
                        f: b
                    }
                })
            }
        }
        _LoadFromJson(a) {
            this._startWidth = a.sw;
            this._startHeight =
                a.sh;
            this._startScaleX = a.sx;
            this._startScaleY = a.sy;
            this._parentStartAngle = a.psa
        }
        _OnAfterLoad(a) {
            const b = this._owner,
                d = b.GetRuntime();
            for (const c of a.c) {
                a = d.GetInstanceByUID(c.uid).GetWorldInfo();
                const f = c.f,
                    k = {};
                k.transformX = f.includes("x");
                k.transformY = f.includes("y");
                k.transformWidth = f.includes("w");
                k.transformHeight = f.includes("h");
                k.transformAngle = f.includes("a");
                k.transformZElevation = f.includes("z");
                k.destroyWithParent = f.includes("d");
                b.AddChild(a, k)
            }
        }
    }
} {
    "use strict";
    const e = self.C3,
        a = e.New(e.Rect),
        b = e.New(e.Quad),
        d = e.New(e.Event, "bboxchange", !1),
        c = e.New(e.Color, 0, 0, 0, 0),
        f = e.New(e.CollisionPoly),
        k = e.New(e.Color, 1, 1, 1, 1),
        h = e.New(e.Rect, 0, 0, -1, -1),
        l = e.New(e.Rect, 0, 0, -1, -1),
        n = new Set(["absolute", "relative"]),
        u = [];
    let w = !0;
    const q = new WeakMap,
        t = new WeakMap;
    e.WorldInfo = class extends e.DefendedBase {
        constructor(p, r) {
            super();
            this._inst = p;
            this._objectClass = p.GetObjectClass();
            this._runtime = p.GetRuntime();
            this._layer = r;
            this._zIndex = -1;
            this._flags = 196635;
            this._objectClass.GetPlugin().IsRotatable() &&
                (this._flags |= 128);
            this._oy = this._ox = this._cosA = this._sinA = this._a = this._depth = this._h = this._w = this._zElevation = this._y = this._x = NaN;
            this._boundingBox = e.New(e.Rect);
            this._boundingQuad = e.New(e.Quad);
            this._collisionCells = l;
            this._renderCells = h;
            this._solidFilterTags = this._transformedPolyInfo = this._sourceCollisionPoly = null;
            this._colorPremultiplied = this._color = k;
            this._instanceEffectList = this._stateGroup = null;
            this._inst.GetObjectClass().UsesEffects() && (this._instanceEffectList = e.New(e.InstanceEffectList,
                this._inst, this));
            this._meshInfo = this._sceneGraphInfo = null
        }
        _MarkDestroyed() {
            this._flags |= 256
        }
        Release() {
            this._stateGroup && (this._runtime.GetRenderer().ReleaseStateGroup(this._stateGroup), this._stateGroup = null);
            this._sourceCollisionPoly = null;
            this._transformedPolyInfo && (this._transformedPolyInfo.poly.Release(), this._transformedPolyInfo = null);
            this._solidFilterTags && (this._solidFilterTags.clear(), this._solidFilterTags = null);
            this.ReleaseMesh();
            this.HasParent() && this.GetParent().RemoveChild(this);
            if (this.HasChildren()) {
                const p = [...this.GetChildren()];
                for (const r of p) this.RemoveChild(r)
            }
            this._ReleaseSceneGraphInfo();
            this._layer = this._runtime = this._objectClass = this._inst = null
        }
        Init(p) {
            w = !1;
            this.SetXY(p[0], p[1]);
            this.SetZElevation(p[2]);
            this.SetSize(p[3], p[4]);
            this._depth = 0;
            this.IsRotatable() ? this.SetAngle(p[6]) : this._a = 0;
            c.setFromJSON(p[7]);
            this._SetColor(c);
            this.SetOriginX(p[8]);
            this.SetOriginY(p[9]);
            this.SetBlendMode(p[10]);
            this._instanceEffectList && this._instanceEffectList._LoadEffectParameters(p[12]);
            p[14] && q.set(this, {
                childrenData: p[14][1],
                zIndexData: p[14][2]
            });
            if (p[15]) {
                var r = p[15];
                this.CreateMesh(r[0], r[1]);
                p = this.GetSourceMesh();
                r = r[2];
                for (let x = 0, y = r.length; x < y; ++x) {
                    const E = r[x];
                    for (let G = 0, A = E.length; G < A; ++G) {
                        const F = E[G],
                            J = p.GetMeshPointAt(G, x);
                        J.SetX(F[0]);
                        J.SetY(F[1]);
                        J.SetZElevation(F[2]);
                        J.SetU(F[3]);
                        J.SetV(F[4])
                    }
                }
            }
            w = !0;
            this._UpdateRendererStateGroup()
        }
        InitNoData() {
            this._sinA = this._a = this._depth = this._h = this._w = this._zElevation = this._y = this._x = 0;
            this._cosA = 1;
            this._oy = this._ox = 0;
            this._UpdateRendererStateGroup()
        }
        GetRuntime() {
            return this._runtime
        }
        GetObjectClass() {
            return this._objectClass
        }
        GetInstance() {
            return this._inst
        }
        _GetParentOffsetAngle() {
            return this.GetTransformWithParentAngle() ?
                this.GetParent().GetAngle() - this._sceneGraphInfo.GetParentStartAngle() : 0
        }
        SetX(p) {
            p = +p;
            if (this.GetTransformWithParentX()) {
                const r = this._sceneGraphInfo;
                p -= this.GetX();
                const x = -this._GetParentOffsetAngle();
                0 === x ? this._x += p / r.GetParentScaleX() : (this._x += Math.cos(x) * p / r.GetParentScaleX(), this.GetTransformWithParentY() && (this._y += Math.sin(x) * p / r.GetParentScaleY()))
            } else this._x = p
        }
        OffsetX(p) {
            p = +p;
            this.GetTransformWithParentX() ? this.SetX(this.GetX() + p) : this._x += p
        }
        GetX() {
            if (this.GetTransformWithParentX()) {
                let p =
                    this._x;
                const r = this._sceneGraphInfo,
                    x = this.GetParent(),
                    y = this._GetParentOffsetAngle();
                0 === y ? p *= r.GetParentScaleX() : (p = p * r.GetParentScaleX() * Math.cos(y), this.GetTransformWithParentY() && (p -= this._y * r.GetParentScaleY() * Math.sin(y)));
                return x.GetX() + p
            }
            return this._x
        }
        SetY(p) {
            p = +p;
            if (this.GetTransformWithParentY()) {
                const r = this._sceneGraphInfo;
                p -= this.GetY();
                const x = -this._GetParentOffsetAngle();
                0 === x ? this._y += p / r.GetParentScaleY() : (this.GetTransformWithParentX() && (this._x -= Math.sin(x) * p / r.GetParentScaleX()),
                    this._y += Math.cos(x) * p / r.GetParentScaleY())
            } else this._y = p
        }
        OffsetY(p) {
            p = +p;
            this.GetTransformWithParentY() ? this.SetY(this.GetY() + p) : this._y += p
        }
        GetY() {
            if (this.GetTransformWithParentY()) {
                let p = this._y;
                const r = this._sceneGraphInfo,
                    x = this.GetParent(),
                    y = this._GetParentOffsetAngle();
                0 === y ? p *= r.GetParentScaleY() : (p = p * r.GetParentScaleY() * Math.cos(y), this.GetTransformWithParentX() && (p += this._x * r.GetParentScaleX() * Math.sin(y)));
                return x.GetY() + p
            }
            return this._y
        }
        SetXY(p, r) {
            p = +p;
            r = +r;
            if (this.GetTransformWithParentXOrY()) {
                const y =
                    this.GetTransformWithParentX(),
                    E = this.GetTransformWithParentY(),
                    G = this._sceneGraphInfo,
                    A = p - this.GetX(),
                    F = r - this.GetY();
                var x = -this._GetParentOffsetAngle();
                if (0 === x) this._x = y ? this._x + A / G.GetParentScaleX() : p, this._y = E ? this._y + F / G.GetParentScaleY() : r;
                else {
                    const J = Math.sin(x);
                    x = Math.cos(x);
                    this._x = y ? E ? this._x + (x * A - J * F) / G.GetParentScaleX() : this._x + x * A / G.GetParentScaleX() : p;
                    this._y = E ? y ? this._y + (J * A + x * F) / G.GetParentScaleY() : this._y + x * F / G.GetParentScaleY() : r
                }
            } else this._x = p, this._y = r
        }
        OffsetXY(p, r) {
            p = +p;
            r = +r;
            this.GetTransformWithParentXOrY() ? this.SetXY(this.GetX() + p, this.GetY() + r) : (this._x += p, this._y += r)
        }
        EqualsXY(p, r) {
            return this.GetX() === p && this.GetY() === r
        }
        SetZElevation(p) {
            p = +p;
            this.GetTransformWithParentZElevation() && (p -= this.GetParent().GetZElevation());
            this._zElevation !== p && (this._zElevation = p, this._UpdateZElevation(), p = this.GetLayer(), 0 !== this._zElevation && p._SetAnyInstanceZElevated(), p.SetZIndicesChanged())
        }
        _UpdateZElevation() {
            this._UpdateRendererStateGroup();
            if (this.HasChildren()) {
                const p = this.GetChildren();
                for (let r = 0, x = p.length; r < x; r++) {
                    const y = p[r];
                    y.GetTransformWithParentZElevation() && y._UpdateZElevation()
                }
            }
        }
        OffsetZElevation(p) {
            this.SetZElevation(this.GetZElevation() + p)
        }
        GetZElevation() {
            return this.GetTransformWithParentZElevation() ? this.GetParent().GetZElevation() + this._zElevation : this._zElevation
        }
        GetTotalZElevation() {
            return this.GetLayer().GetZElevation() + this.GetZElevation()
        }
        SetWidth(p) {
            p = +p;
            if (this.GetTransformWithParentWidth()) {
                const r = this.GetWidth();
                this._w = 0 === r ? 1E-6 : p / r * this._w
            } else this._w =
                p
        }
        OffsetWidth(p) {
            p = +p;
            this.GetTransformWithParentWidth() ? this.SetWidth(this.GetWidth() + p) : this._w += p
        }
        GetWidth() {
            return this.GetTransformWithParentWidth() ? this.GetParent().GetWidth() * this._w : this._w
        }
        SetHeight(p) {
            p = +p;
            if (this.GetTransformWithParentHeight()) {
                const r = this.GetHeight();
                this._h = 0 === r ? 1E-6 : p / r * this._h
            } else this._h = p
        }
        OffsetHeight(p) {
            p = +p;
            this.GetTransformWithParentHeight() ? this.SetHeight(this.GetHeight() + p) : this._h += p
        }
        GetHeight() {
            return this.GetTransformWithParentHeight() ? this.GetParent().GetHeight() *
                this._h : this._h
        }
        SetSize(p, r) {
            p = +p;
            r = +r;
            if (this.GetTransformWithParentWidth()) {
                const x = this.GetWidth();
                this._w = 0 === x ? 1E-6 : p / x * this._w
            } else this._w = p;
            this.GetTransformWithParentHeight() ? (p = this.GetHeight(), this._h = 0 === p ? 1E-6 : r / p * this._h) : this._h = r
        }
        GetDepth() {
            return this._depth
        }
        SetDepth(p) {
            if (0 > p) throw new RangeError("invalid depth");
            this._depth = p
        }
        GetSceneGraphScale() {
            if (this.HasParent()) {
                const p = this._sceneGraphInfo;
                return Math.min(p.GetParentScaleX(), p.GetParentScaleY())
            }
            return 1
        }
        IsRotatable() {
            return 0 !==
                (this._flags & 128)
        }
        SetAngle(p) {
            p = +p;
            this.IsRotatable() && (this.GetTransformWithParentAngle() && (p -= this.GetParent().GetAngle()), p = e.clampAngle(p), this._a !== p && (this._a = p, this._MarkSinCosAngleChanged()))
        }
        OffsetAngle(p) {
            p = +p;
            0 !== p && this.IsRotatable() && (this._a = e.clampAngle(this._a + p), this._MarkSinCosAngleChanged())
        }
        _MarkSinCosAngleChanged() {
            this._flags |= 262144;
            if (this.HasChildren()) {
                const p = this.GetChildren();
                for (let r = 0, x = p.length; r < x; r++) p[r]._MarkSinCosAngleChanged()
            }
        }
        GetAngle() {
            return this.GetTransformWithParentAngle() ?
                e.clampAngle(this.GetParent().GetAngle() + this._a) : this._a
        }
        _MaybeUpdateSinCosAngle() {
            const p = this._flags;
            if (0 !== (p & 262144)) {
                var r = this.GetAngle();
                this._sinA = Math.sin(r);
                this._cosA = Math.cos(r);
                this._flags = p & -262145
            }
        }
        GetSinAngle() {
            this._MaybeUpdateSinCosAngle();
            return this._sinA
        }
        GetCosAngle() {
            this._MaybeUpdateSinCosAngle();
            return this._cosA
        }
        SetOriginX(p) {
            this._ox = +p
        }
        OffsetOriginX(p) {
            this._ox += +p
        }
        GetOriginX() {
            return this._ox
        }
        SetOriginY(p) {
            this._oy = +p
        }
        OffsetOriginY(p) {
            this._oy += +p
        }
        GetOriginY() {
            return this._oy
        }
        _SetColor(p) {
            this._color.equals(p) ||
                (this._color === k ? (this._color = e.New(e.Color, p), this._colorPremultiplied = e.New(e.Color, p), this._colorPremultiplied.premultiply()) : p.equalsRgba(1, 1, 1, 1) ? this._colorPremultiplied = this._color = k : (this._color.set(p), this._colorPremultiplied.set(p), this._colorPremultiplied.premultiply()), this._UpdateRendererStateGroup())
        }
        SetOpacity(p) {
            p = e.clamp(+p, 0, 1);
            this._color.a !== p && (c.copyRgb(this._color), c.a = p, this._SetColor(c))
        }
        OffsetOpacity(p) {
            this.SetOpacity(this.GetOpacity() + p)
        }
        GetOpacity() {
            return this._color.a
        }
        SetUnpremultipliedColor(p) {
            this._color.equalsIgnoringAlpha(p) ||
                (c.copyRgb(p), c.a = this._color.a, this._SetColor(c))
        }
        SetUnpremultipliedColorRGB(p, r, x) {
            c.setRgb(p, r, x);
            this.SetUnpremultipliedColor(c)
        }
        OffsetUnpremultipliedColorRGB(p, r, x) {
            if (0 !== p || 0 !== r || 0 !== x) c.copyRgb(this._color), c.r += p, c.g += r, c.b += x, this.SetUnpremultipliedColor(c)
        }
        GetUnpremultipliedColor() {
            return this._color
        }
        GetPremultipliedColor() {
            return this._colorPremultiplied
        }
        GetDestroyWithParent() {
            return 0 !== (this._flags & 512)
        }
        SetDestroyWithParent(p) {
            this._SetFlag(512, p)
        }
        GetTransformWithParentX() {
            return 0 !==
                (this._flags & 1024)
        }
        SetTransformWithParentX(p) {
            this._SetFlag(1024, p)
        }
        GetTransformWithParentY() {
            return 0 !== (this._flags & 2048)
        }
        GetTransformWithParentXOrY() {
            return 0 !== (this._flags & 3072)
        }
        SetTransformWithParentY(p) {
            this._SetFlag(2048, p)
        }
        GetTransformWithParentWidth() {
            return 0 !== (this._flags & 4096)
        }
        SetTransformWithParentWidth(p) {
            this._SetFlag(4096, p)
        }
        GetTransformWithParentHeight() {
            return 0 !== (this._flags & 8192)
        }
        SetTransformWithParentHeight(p) {
            this._SetFlag(8192, p)
        }
        GetTransformWithParentAngle() {
            return 0 !==
                (this._flags & 16384)
        }
        SetTransformWithParentAngle(p) {
            this._SetFlag(16384, p)
        }
        GetTransformWithParentZElevation() {
            return 0 !== (this._flags & 32768)
        }
        SetTransformWithParentZElevation(p) {
            this._SetFlag(32768, p)
        }
        _ClearAllSceneGraphFlags() {
            this._flags &= -65025
        }
        AddChild(p, r) {
            if (p !== this && !p.HasParent() && !this._HasChildRecursive(p) && !this._HasAnyParent(p)) {
                var x = p.GetX(),
                    y = p.GetY(),
                    E = p.GetWidth(),
                    G = p.GetHeight(),
                    A = p.GetAngle(),
                    F = p.GetZElevation();
                p._SetParent(this);
                p.SetTransformWithParentX(r.transformX);
                p.SetTransformWithParentY(r.transformY);
                p.SetTransformWithParentWidth(r.transformWidth);
                p.SetTransformWithParentHeight(r.transformHeight);
                p.SetTransformWithParentAngle(r.transformAngle);
                p.SetTransformWithParentZElevation(r.transformZElevation);
                p.SetDestroyWithParent(r.destroyWithParent);
                r.transformX && (p._x = x - this.GetX(), r.transformWidth && (p._x /= this.GetWidth() / this._sceneGraphInfo._GetStartWidth()));
                r.transformY && (p._y = y - this.GetY(), r.transformHeight && (p._y /= this.GetHeight() / this._sceneGraphInfo._GetStartHeight()));
                r.transformWidth && (p._w =
                    E / this.GetWidth(), p._sceneGraphInfo.SetStartScaleX(p._w));
                r.transformHeight && (p._h = G / this.GetHeight(), p._sceneGraphInfo.SetStartScaleY(p._h));
                r.transformAngle && (p._a = A - this.GetAngle());
                r.transformZElevation && (p._zElevation = F - this.GetZElevation());
                this._AddChildToSceneGraphInfo(p);
                this.SetBboxChanged()
            }
        }
        RemoveChild(p) {
            if (p.GetParent() === this) {
                var r = p.GetX(),
                    x = p.GetY(),
                    y = p.GetWidth(),
                    E = p.GetHeight(),
                    G = p.GetAngle(),
                    A = p.GetZElevation();
                p._SetParent(null);
                p._ClearAllSceneGraphFlags();
                p.SetXY(r, x);
                p.SetSize(y,
                    E);
                p.SetAngle(G);
                p.SetZElevation(A);
                this._RemoveChildFromSceneGraphInfo(p);
                this.SetBboxChanged()
            }
        }
        _ResetAllSceneGraphState() {
            for (var p of this.children()) this.RemoveChild(p);
            (p = this.GetParent()) && p.RemoveChild(this);
            this._ClearAllSceneGraphFlags()
        }
        HasParent() {
            return null !== this.GetParent()
        }
        GetParent() {
            const p = this._sceneGraphInfo;
            return null !== p ? p.GetParent() : null
        }
        GetTopParent() {
            let p = this;
            for (; p.HasParent();) p = p.GetParent();
            return p
        }* parents() {
            let p = this.GetParent();
            for (; p;) yield p, p = p.GetParent()
        }
        HasChild(p) {
            return this.GetChildren().includes(p)
        }
        HasChildren() {
            const p =
                this._sceneGraphInfo;
            return null !== p ? p.HasChildren() : !1
        }
        GetChildren() {
            const p = this._sceneGraphInfo;
            return null !== p ? p.GetChildren() : u
        }
        children() {
            return this.GetChildren()
        }* allChildren() {
            for (const p of this.children()) yield p, yield* p.allChildren()
        }
        GetChildCount() {
            return this.GetChildren().length
        }
        GetChildAt(p) {
            const r = this.GetChildren();
            p = Math.floor(+p);
            return 0 > p || p >= r.length ? null : r[p]
        }
        _CreateSceneGraphInfo(p) {
            this._sceneGraphInfo || (this._sceneGraphInfo = e.New(e.SceneGraphInfo, this));
            p && this._sceneGraphInfo.SetParent(p)
        }
        _GetSceneGraphInfo() {
            return this._sceneGraphInfo
        }
        _ReleaseSceneGraphInfo() {
            this._sceneGraphInfo &&
                (this._sceneGraphInfo.Release(), this._sceneGraphInfo = null)
        }
        _SetParent(p) {
            p ? (p._CreateSceneGraphInfo(null), this._CreateSceneGraphInfo(p)) : (this._sceneGraphInfo && this._sceneGraphInfo.SetParent(null), this.HasChildren() || this._ReleaseSceneGraphInfo())
        }
        _HasAnyParent(p) {
            if (!this.HasParent()) return !1;
            const r = this.GetParent();
            return r === p ? !0 : r._HasAnyParent(p)
        }
        _HasChildRecursive(p) {
            if (this.HasChild(p)) return !0;
            for (const r of this.GetChildren())
                if (r._HasChildRecursive(p)) return !0;
            return !1
        }
        _AddChildToSceneGraphInfo(p) {
            this._sceneGraphInfo.GetChildren().push(p)
        }
        _RemoveChildFromSceneGraphInfo(p) {
            const r =
                this._sceneGraphInfo.GetChildren(),
                x = r.indexOf(p); - 1 !== x && r.splice(x, 1);
            0 !== r.length || this.HasParent() || this._ReleaseSceneGraphInfo();
            p.HasChildren() || p._ReleaseSceneGraphInfo()
        }
        GetSceneGraphChildrenExportData() {
            const p = q.get(this);
            return p ? p.childrenData : null
        }
        GetSceneGraphZIndexExportData() {
            const p = q.get(this);
            return p ? p.zIndexData : NaN
        }
        GetSceneGraphZIndex() {
            return t.get(this) || NaN
        }
        SetSceneGraphZIndex(p) {
            t.set(this, p)
        }
        SetUsePointsShaderProgram() {
            this._SetFlag(524288, !0);
            this._UpdateRendererStateGroup()
        }
        _UpdateRendererStateGroup() {
            if (w) {
                var p =
                    this._runtime.GetRenderer();
                this._stateGroup && p.ReleaseStateGroup(this._stateGroup);
                var r = 0 !== (this._flags & 524288) ? p.GetPointsRenderingProgram() || "<point>" : p.GetTextureFillShaderProgram() || "<default>";
                this._stateGroup = p.AcquireStateGroup(r, this.GetBlendMode(), this._colorPremultiplied, this.GetZElevation())
            }
        }
        GetRendererStateGroup() {
            return this._stateGroup
        }
        HasDefaultColor() {
            return this._color === k
        }
        SetBlendMode(p) {
            p |= 0;
            if (0 > p || 31 < p) throw new RangeError("invalid blend mode");
            this.GetBlendMode() !== p && (this._flags =
                this._flags & -2080374785 | p << 26, this._UpdateRendererStateGroup())
        }
        GetBlendMode() {
            return (this._flags & 2080374784) >> 26
        }
        _SetLayer(p) {
            this._layer = p;
            0 !== this.GetZElevation() && this._layer._SetAnyInstanceZElevated()
        }
        GetLayer() {
            return this._layer
        }
        GetLayout() {
            return this.GetLayer().GetLayout()
        }
        _SetZIndex(p) {
            this._zIndex = p | 0
        }
        GetZIndex() {
            this._layer._UpdateZIndices();
            return this._zIndex
        }
        _GetLastCachedZIndex() {
            return this._zIndex
        }
        _SetFlag(p, r) {
            this._flags = r ? this._flags | p : this._flags & ~p
        }
        IsVisible() {
            return 0 !== (this._flags &
                1)
        }
        SetVisible(p) {
            this._SetFlag(1, p)
        }
        IsCollisionEnabled() {
            return 0 !== (this._flags & 8)
        }
        SetCollisionEnabled(p) {
            p = !!p;
            this.IsCollisionEnabled() !== p && (this._SetFlag(8, p), p ? this.SetBboxChanged() : this._RemoveFromCollisionCells())
        }
        SetSolidCollisionFilter(p, r) {
            this._SetFlag(32, p);
            this._solidFilterTags && this._solidFilterTags.clear();
            if (r.trim()) {
                this._solidFilterTags || (this._solidFilterTags = new Set);
                for (const x of r.split(" ")) x && this._solidFilterTags.add(x.toLowerCase())
            } else this._solidFilterTags = null
        }
        IsSolidCollisionAllowed(p) {
            const r =
                0 !== (this._flags & 32),
                x = this._solidFilterTags;
            if (!p || !x) return !r;
            for (const y of x)
                if (p.has(y)) return r;
            return !r
        }
        SetBboxChanged() {
            this._flags |= 65554;
            this._objectClass._SetAnyCollisionCellChanged(!0);
            this._runtime.UpdateRender();
            this._layer.UsesRenderCells() && (this.CalculateBbox(this._boundingBox, this._boundingQuad, !0), this._flags &= -3, this._UpdateRenderCell());
            0 !== (this._flags & 4) && this._inst.Dispatcher().dispatchEvent(d);
            if (null !== this._sceneGraphInfo) {
                const p = this._sceneGraphInfo.GetChildren();
                for (let r =
                        0, x = p.length; r < x; ++r) p[r].SetBboxChanged()
            }
        }
        CalculateBbox(p, r, x) {
            const y = this.GetX(),
                E = this.GetY(),
                G = this.GetWidth(),
                A = this.GetHeight(),
                F = this.GetAngle();
            p.setWH(y - this._ox * G, E - this._oy * A, G, A);
            x && this.HasMesh() && this._ExpandBboxForMesh(p);
            0 === F ? r.setFromRect(p) : (p.offset(-y, -E), r.setFromRotatedRectPrecalc(p, this.GetSinAngle(), this.GetCosAngle()), r.offset(y, E), r.getBoundingBox(p));
            p.normalize()
        }
        _UpdateBbox() {
            const p = this._flags;
            0 !== (p & 2) && (this.CalculateBbox(this._boundingBox, this._boundingQuad, !0),
                this._flags = p & -3)
        }
        GetBoundingBox() {
            this._UpdateBbox();
            return this._boundingBox
        }
        GetBoundingQuad() {
            this._UpdateBbox();
            return this._boundingQuad
        }
        PixelRoundQuad(p) {
            var r = this.GetX(),
                x = this.GetY();
            r = Math.round(r) - r;
            x = Math.round(x) - x;
            if (0 === r && 0 === x) return p;
            b.copy(p);
            b.offset(r, x);
            return b
        }
        OverwriteBoundingBox(p) {
            this._boundingBox.copy(p);
            this._boundingQuad.setFromRect(this._boundingBox);
            this._flags &= -3;
            this._UpdateCollisionCell();
            this._UpdateRenderCell()
        }
        SetBboxChangeEventEnabled(p) {
            this._SetFlag(4, p)
        }
        IsBboxChangeEventEnabled() {
            return 0 !==
                (this._flags & 4)
        }
        IsInViewport(p, r, x) {
            return r && 0 !== this.GetDepth() ? this.IsInViewport3D(this.GetLayer()._GetViewFrustum()) : 0 === this.GetZElevation() || x ? p.intersectsRect(this.GetBoundingBox()) : this._IsInViewport_ZElevated()
        }
        _IsInViewport_ZElevated() {
            const p = this.GetLayer(),
                r = this.GetTotalZElevation();
            if (r >= p.GetCameraZ()) return !1;
            p.GetViewportForZ(r, a);
            return a.intersectsRect(this.GetBoundingBox())
        }
        IsInViewport3D(p) {
            var r = this.GetBoundingBox();
            const x = r.getLeft(),
                y = r.getRight(),
                E = r.getTop();
            r = r.getBottom();
            const G = this.GetTotalZElevation(),
                A = G + this.GetDepth();
            return p.ContainsAABB(x, E, G, y, r, A)
        }
        _SetDrawBackFaceOnly(p) {
            this._SetFlag(1048576, p)
        }
        _SetDrawNonBackFacesOnly(p) {
            this._SetFlag(2097152, p)
        }
        IsDrawBackFaceOnly() {
            return 0 !== (this._flags & 1048576)
        }
        IsDrawNonBackFacesOnly() {
            return 0 !== (this._flags & 2097152)
        }
        SetSourceCollisionPoly(p) {
            this._sourceCollisionPoly = p;
            this._DiscardTransformedCollisionPoly();
            this.HasMesh() && (this._meshInfo.meshPoly = null)
        }
        GetSourceCollisionPoly() {
            return this._sourceCollisionPoly
        }
        HasOwnCollisionPoly() {
            return null !==
                this._sourceCollisionPoly || this.HasMesh()
        }
        GetTransformedCollisionPoly() {
            return this._GetCustomTransformedCollisionPolyPrecalc(this.GetWidth(), this.GetHeight(), this.GetAngle(), this.GetSinAngle(), this.GetCosAngle())
        }
        GetCustomTransformedCollisionPoly(p, r, x) {
            let y = 0,
                E = 1;
            0 !== x && (y = Math.sin(x), E = Math.cos(x));
            return this._GetCustomTransformedCollisionPolyPrecalc(p, r, x, y, E)
        }
        _GetCustomTransformedCollisionPolyPrecalc(p, r, x, y, E) {
            let G = this._transformedPolyInfo;
            null === G && (this._transformedPolyInfo = G = {
                poly: e.New(e.CollisionPoly),
                width: NaN,
                height: NaN,
                angle: NaN
            });
            const A = G.poly;
            if (G.width === p && G.height === r && G.angle === x) return A;
            const F = this._sourceCollisionPoly;
            if (this.HasMesh()) {
                const J = this.GetOriginX(),
                    B = this.GetOriginY(),
                    I = this.GetSourceMesh();
                let L = this._meshInfo.meshPoly;
                L || (F ? (f.copy(F), f.offset(J, B)) : f.setDefaultPoints(), L = I.InsertPolyMeshVertices(f), this._meshInfo.meshPoly = L);
                I.TransformCollisionPoly(L, A);
                A.offset(-J, -B);
                A.transformPrecalc(p, r, y, E)
            } else F ? (A.copy(F), A.transformPrecalc(p, r, y, E)) : A.setFromQuad(this.GetBoundingQuad(),
                -this.GetX(), -this.GetY());
            G.width = p;
            G.height = r;
            G.angle = x;
            return A
        }
        _DiscardTransformedCollisionPoly() {
            this.SetPhysicsBodyChanged(!0);
            const p = this._transformedPolyInfo;
            null !== p && (p.width = NaN)
        }
        CreateMesh(p, r) {
            p = Math.floor(p);
            r = Math.floor(r);
            if (!this.GetInstance().GetPlugin().SupportsMesh()) throw Error("object does not support mesh");
            this.ReleaseMesh();
            this._meshInfo = {
                sourceMesh: e.New(e.Gfx.Mesh, p, r),
                transformedMesh: e.New(e.Gfx.Mesh, p, r),
                meshPoly: null
            }
        }
        HasMesh() {
            return null !== this._meshInfo
        }
        GetSourceMesh() {
            if (!this.HasMesh()) throw Error("no mesh");
            return this._meshInfo.sourceMesh
        }
        GetTransformedMesh() {
            if (!this.HasMesh()) throw Error("no mesh");
            return this._meshInfo.transformedMesh
        }
        SetMeshChanged(p) {
            this._SetFlag(65536, p)
        }
        IsMeshChanged() {
            return 0 !== (this._flags & 65536)
        }
        SetPhysicsBodyChanged(p) {
            this._SetFlag(131072, p)
        }
        IsPhysicsBodyChanged() {
            return 0 !== (this._flags & 131072)
        }
        _ExpandBboxForMesh(p) {
            const r = this._meshInfo.sourceMesh,
                x = Math.min(r.GetMinX(), 0),
                y = Math.min(r.GetMinY(), 0),
                E = Math.max(r.GetMaxX(), 1),
                G = Math.max(r.GetMaxY(), 1),
                A = p.width(),
                F = p.height();
            p.offsetLeft(x * A);
            p.offsetTop(y * F);
            p.offsetRight((E - 1) * A);
            p.offsetBottom((G - 1) * F);
            this._depth = r.GetMaxZ()
        }
        ReleaseMesh() {
            this._meshInfo && (this._meshInfo.sourceMesh.Release(), this._meshInfo.transformedMesh.Release(), this._meshInfo = null, this._DiscardTransformedCollisionPoly())
        }
        SetMeshPoint(p, r, x) {
            p = Math.floor(p);
            r = Math.floor(r);
            var y = x.mode || "absolute";
            if (!n.has(y)) throw Error("invalid mode");
            y = "relative" === y;
            let E = x.x,
                G = x.y;
            const A = x.zElevation;
            let F = "number" === typeof x.u ? x.u : y ? 0 : -1;
            x = "number" === typeof x.v ?
                x.v : y ? 0 : -1;
            if (!this.HasMesh()) return !1;
            const J = this.GetSourceMesh(),
                B = J.GetMeshPointAt(p, r);
            if (null === B) return !1;
            let I = !1;
            "number" === typeof A && B.GetZElevation() !== A && (B.SetZElevation(A), I = !0);
            y && (E += p / (J.GetHSize() - 1), G += r / (J.GetVSize() - 1)); - 1 !== F || y ? (y && (F += p / (J.GetHSize() - 1)), F = e.clamp(F, 0, 1)) : F = B.GetU(); - 1 !== x || y ? (y && (x += r / (J.GetVSize() - 1)), x = e.clamp(x, 0, 1)) : x = B.GetV();
            if (B.GetX() === E && B.GetY() === G && B.GetU() === F && B.GetV() === x) return I;
            B.SetX(E);
            B.SetY(G);
            B.SetU(F);
            B.SetV(x);
            this._DiscardTransformedCollisionPoly();
            return !0
        }
        HasTilemap() {
            return this._inst.HasTilemap()
        }
        ContainsPoint(p, r) {
            return this.GetBoundingBox().containsPoint(p, r) && this.GetBoundingQuad().containsPoint(p, r) ? this.HasTilemap() ? this._inst.GetSdkInstance().TestPointOverlapTile(p, r) : this.HasOwnCollisionPoly() ? this.GetTransformedCollisionPoly().containsPoint(p - this.GetX(), r - this.GetY()) : !0 : !1
        }
        _IsCollisionCellChanged() {
            return 0 !== (this._flags & 16)
        }
        _UpdateCollisionCell() {
            if (this._IsCollisionCellChanged() && this.IsCollisionEnabled() && 0 === (this._flags &
                    256)) {
                var p = this.GetBoundingBox(),
                    r = this._objectClass._GetCollisionCellGrid(),
                    x = this._collisionCells;
                a.set(r.XToCell(p.getLeft()), r.YToCell(p.getTop()), r.XToCell(p.getRight()), r.YToCell(p.getBottom()));
                x.equals(a) || (p = this._inst, x === l ? (r.Update(p, null, a), this._collisionCells = e.New(e.Rect, a)) : (r.Update(p, x, a), x.copy(a)), this._flags &= -17)
            }
        }
        _RemoveFromCollisionCells() {
            const p = this._collisionCells;
            p !== l && (this._objectClass._GetCollisionCellGrid().Update(this._inst, p, null), this._collisionCells = l)
        }
        _UpdateRenderCell() {
            const p =
                this.GetLayer();
            if (p.UsesRenderCells() && 0 === (this._flags & 256)) {
                var r = p.GetRenderGrid(),
                    x = this.GetBoundingBox(),
                    y = this._renderCells;
                a.set(r.XToCell(x.getLeft()), r.YToCell(x.getTop()), r.XToCell(x.getRight()), r.YToCell(x.getBottom()));
                y.equals(a) || (x = this._inst, y === h ? (r.Update(x, null, a), this._renderCells = e.New(e.Rect, a)) : (r.Update(x, y, a), y.copy(a)), p.SetRenderListStale())
            }
        }
        _RemoveFromRenderCells() {
            const p = this._renderCells;
            p !== h && (this.GetLayer().GetRenderGrid().Update(this._inst, p, null), this._renderCells =
                h)
        }
        GetRenderCellRange() {
            return this._renderCells
        }
        ZOrderMoveToTop() {
            const p = this._inst,
                r = this._layer,
                x = r._GetInstances();
            x.length && x.at(-1) === p || (r._RemoveInstance(p, !1), r._AddInstance(p, !1), this._runtime.UpdateRender())
        }
        ZOrderMoveToBottom() {
            const p = this._inst,
                r = this._layer,
                x = r._GetInstances();
            x.length && x[0] === p || (r._RemoveInstance(p, !1), r._PrependInstance(p, !1), this._runtime.UpdateRender())
        }
        ZOrderMoveToLayer(p) {
            const r = this._inst,
                x = this._layer;
            if (x.GetLayout() !== p.GetLayout()) throw Error("layer from different layout");
            p !== x && (x._RemoveInstance(r, !0), this._SetLayer(p), p._AddInstance(r, !0), this._runtime.UpdateRender())
        }
        ZOrderMoveAdjacentToInstance(p, r) {
            const x = this._inst;
            let y = !1;
            const E = this._layer;
            if (p.GetUID() !== x.GetUID()) {
                var G = p.GetWorldInfo();
                if (!G) throw Error("expected world instance");
                G = G.GetLayer();
                E.GetIndex() !== G.GetIndex() && (E._RemoveInstance(x, !0), this._SetLayer(G), G._AddInstance(x, !0), y = !0);
                p = G.MoveInstanceAdjacent(x, p, !!r);
                (y || p) && this._runtime.UpdateRender()
            }
        }
        GetInstanceEffectList() {
            return this._instanceEffectList
        }
        _SetHasAnyActiveEffect(p) {
            this._SetFlag(64,
                p)
        }
        HasAnyActiveEffect() {
            return 0 !== (this._flags & 64)
        }
        _SaveToJson(p) {
            const r = {
                x: this.GetX(),
                y: this.GetY(),
                w: this.GetWidth(),
                h: this.GetHeight(),
                l: this.GetLayer().GetSID(),
                zi: this.GetZIndex()
            };
            0 !== this.GetZElevation() && (r.ze = this.GetZElevation());
            0 !== this.GetAngle() && (r.a = this.GetAngle());
            this.HasDefaultColor() || (r.c = this._color.toJSON());
            .5 !== this.GetOriginX() && (r.oX = this.GetOriginX());
            .5 !== this.GetOriginY() && (r.oY = this.GetOriginY());
            0 !== this.GetBlendMode() && (r.bm = this.GetBlendMode());
            this.IsVisible() ||
                (r.v = this.IsVisible());
            this.IsCollisionEnabled() || (r.ce = this.IsCollisionEnabled());
            this.IsBboxChangeEventEnabled() && (r.be = this.IsBboxChangeEventEnabled());
            this._instanceEffectList && (r.fx = this._instanceEffectList._SaveToJson());
            const x = 0 !== (this._flags & 32);
            x && (r.sfi = x);
            this._solidFilterTags && (r.sft = [...this._solidFilterTags].join(" "));
            this._sceneGraphInfo && "visual-state" !== p && (r.sgi = this._sceneGraphInfo._SaveToJson());
            this.HasMesh() && (r.mesh = this.GetSourceMesh().SaveToJson());
            return r
        }
        _OnBeforeLoad(p) {
            "visual-state" !==
            p && this._ResetAllSceneGraphState()
        }
        _LoadFromJson(p, r) {
            w = !1;
            this.SetX(p.x);
            this.SetY(p.y);
            this.SetWidth(p.w);
            this.SetHeight(p.h);
            this._SetZIndex(p.zi);
            this.SetZElevation(p.hasOwnProperty("ze") ? p.ze : 0);
            this.SetAngle(p.hasOwnProperty("a") ? p.a : 0);
            p.hasOwnProperty("c") ? c.setFromJSON(p.c) : p.hasOwnProperty("o") ? (c.copyRgb(this._color), c.a = p.o) : c.setRgba(1, 1, 1, 1);
            this._SetColor(c);
            this.SetOriginX(p.hasOwnProperty("oX") ? p.oX : .5);
            this.SetOriginY(p.hasOwnProperty("oY") ? p.oY : .5);
            this.SetBlendMode(p.hasOwnProperty("bm") ?
                p.bm : 0);
            this.SetVisible(p.hasOwnProperty("v") ? p.v : !0);
            this.SetCollisionEnabled(p.hasOwnProperty("ce") ? p.ce : !0);
            this.SetBboxChangeEventEnabled(p.hasOwnProperty("be") ? p.be : !1);
            this.SetSolidCollisionFilter(p.hasOwnProperty("sfi") ? p.sfi : !1, p.hasOwnProperty("sft") ? p.sft : "");
            this._instanceEffectList && p.hasOwnProperty("fx") && this._instanceEffectList._LoadFromJson(p.fx);
            if (p.hasOwnProperty("sgi") && "visual-state" !== r) {
                this._CreateSceneGraphInfo(null);
                const x = this._sceneGraphInfo,
                    y = p.sgi;
                x._LoadFromJson(y);
                const E = this.GetRuntime().Dispatcher(),
                    G = () => {
                        E.removeEventListener("afterload", G);
                        0 === (this._flags & 256) && x._OnAfterLoad(y)
                    };
                E.addEventListener("afterload", G)
            }
            p.hasOwnProperty("mesh") ? (p = p.mesh, this.CreateMesh(p.cols, p.rows), this.GetSourceMesh().LoadFromJson(p)) : this.ReleaseMesh();
            this.SetBboxChanged();
            w = !0;
            this._UpdateRendererStateGroup()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.BehaviorType = class extends e.DefendedBase {
        constructor(a, b) {
            super();
            const d = a.GetRuntime(),
                c = d.GetPluginManager(),
                f = d.GetObjectReference(b[1]);
            c.HasBehaviorByConstructorFunction(f) || c.CreateBehavior(b);
            this._runtime = d;
            this._objectClass = a;
            this._behavior = c.GetBehaviorByConstructorFunction(f);
            this._sdkType = null;
            this._instSdkCtor = f.Instance;
            this._sid = b[2];
            this._name = b[0];
            this._jsPropName = this._runtime.GetJsPropName(b[3]);
            this._sdkType = e.New(f.Type, this);
            this.OnCreate()
        }
        static Create(a,
            b) {
            return e.New(e.BehaviorType, a, b)
        }
        Release() {
            this._behavior = this._runtime = null;
            this._sdkType.Release();
            this._instSdkCtor = this._sdkType = null
        }
        GetSdkType() {
            return this._sdkType
        }
        OnCreate() {
            this._sdkType.OnCreate()
        }
        GetRuntime() {
            return this._runtime
        }
        GetObjectClass() {
            return this._objectClass
        }
        GetBehavior() {
            return this._behavior
        }
        GetInstanceSdkCtor() {
            return this._instSdkCtor
        }
        GetName() {
            return this._name
        }
        GetSID() {
            return this._sid
        }
        GetJsPropName() {
            return this._jsPropName
        }
    }
} {
    "use strict";
    const e = self.C3,
        a = self.IBehaviorInstance;
    e.BehaviorInstance = class extends e.DefendedBase {
        constructor(b) {
            super();
            this._runtime = b.runtime;
            this._behaviorType = b.behaviorType;
            this._behavior = this._behaviorType.GetBehavior();
            this._inst = b.instance;
            this._index = b.index;
            this._iScriptInterface = this._sdkInst = null;
            this._behavior._AddInstance(this._inst)
        }
        Release() {
            this._iScriptInterface && (this._iScriptInterface._Release(), this._iScriptInterface = null);
            this._behavior._RemoveInstance(this._inst);
            this._sdkInst.Release();
            this._inst = this._behavior = this._behaviorType = this._runtime = this._iScriptInterface = this._sdkInst = null
        }
        _CreateSdkInstance(b) {
            if (this._sdkInst) throw Error("already got sdk instance");
            this._sdkInst = e.New(this._behaviorType.GetInstanceSdkCtor(), this, b);
            this._InitScriptInterface()
        }
        GetSdkInstance() {
            return this._sdkInst
        }
        GetObjectInstance() {
            return this._inst
        }
        GetRuntime() {
            return this._runtime
        }
        GetBehaviorType() {
            return this._behaviorType
        }
        GetBehavior() {
            return this._behavior
        }
        _GetIndex() {
            return this._index
        }
        PostCreate() {
            this._sdkInst.PostCreate()
        }
        OnSpriteFrameChanged(b,
            d) {
            this._sdkInst.OnSpriteFrameChanged(b, d)
        }
        _GetDebuggerProperties() {
            return this._sdkInst.GetDebuggerProperties()
        }
        SaveToJson() {
            return this._sdkInst.SaveToJson()
        }
        LoadFromJson(b) {
            return this._sdkInst.LoadFromJson(b)
        }
        static SortByTickSequence(b, d) {
            var c = b.GetObjectInstance(),
                f = d.GetObjectInstance();
            const k = c.GetObjectClass().GetIndex(),
                h = f.GetObjectClass().GetIndex();
            if (k !== h) return k - h;
            c = c.GetPUID();
            f = f.GetPUID();
            return c !== f ? c - f : b.GetBehaviorInstance()._GetIndex() - d.GetBehaviorInstance()._GetIndex()
        }
        _InitScriptInterface() {
            const b =
                this._sdkInst.GetScriptInterfaceClass(),
                d = b || a;
            a._Init(this);
            this._iScriptInterface = new d;
            a._Init(null);
            if (b && !(this._iScriptInterface instanceof a)) throw new TypeError(`script interface class '${b.name}' does not extend the right base class '${a.name}'`);
        }
        GetScriptInterface() {
            return this._iScriptInterface
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.EffectList = class extends e.DefendedBase {
        constructor(a, b) {
            super();
            this._owner = a;
            this._allEffectTypes = [];
            this._activeEffectTypes = [];
            this._effectTypesByName = new Map;
            this._effectParams = [];
            this._preservesOpaqueness = !0;
            for (const d of b) a = e.New(e.EffectType, this, d, this._allEffectTypes.length), this._allEffectTypes.push(a), this._effectTypesByName.set(a.GetName().toLowerCase(), a), 3 <= d.length && this._effectParams.push(this._LoadSingleEffectParameters(d[2]));
            this.GetRuntime()._AddEffectList(this)
        }
        Release() {
            e.clearArray(this._allEffectTypes);
            e.clearArray(this._activeEffectTypes);
            this._effectTypesByName.clear();
            e.clearArray(this._effectParams);
            this._owner = null
        }
        PrependEffectTypes(a) {
            if (a.length) {
                this._allEffectTypes = a.concat(this._allEffectTypes);
                for (const b of a) this._effectTypesByName.set(b.GetName().toLowerCase(), b);
                for (let b = 0, d = this._allEffectTypes.length; b < d; ++b) this._allEffectTypes[b]._SetIndex(b)
            }
        }
        _LoadSingleEffectParameters(a) {
            a = a.slice(0);
            for (let b = 0, d = a.length; b < d; ++b) {
                const c = a[b];
                if (Array.isArray(c)) {
                    const f = e.New(e.Color);
                    f.setFromJSON(c);
                    a[b] = f
                }
            }
            return a
        }
        GetOwner() {
            return this._owner
        }
        GetRuntime() {
            return this._owner.GetRuntime()
        }
        UpdateActiveEffects() {
            e.clearArray(this._activeEffectTypes);
            let a = !0;
            for (const b of this._allEffectTypes) b.IsActive() && (this._activeEffectTypes.push(b), b.GetShaderProgram().PreservesOpaqueness() || (a = !1));
            this._preservesOpaqueness = a
        }
        GetAllEffectTypes() {
            return this._allEffectTypes
        }
        HasAnyEffectType() {
            return 0 < this._allEffectTypes.length
        }
        GetEffectTypeByName(a) {
            return this._effectTypesByName.get(a.toLowerCase()) ||
                null
        }
        GetEffectTypeByIndex(a) {
            a = Math.floor(+a);
            if (0 > a || a >= this._allEffectTypes.length) throw new RangeError("invalid effect type index");
            return this._allEffectTypes[a]
        }
        IsEffectIndexActive(a) {
            return this.GetEffectTypeByIndex(a).IsActive()
        }
        SetEffectIndexActive(a, b) {
            this.GetEffectTypeByIndex(a).SetActive(b)
        }
        GetActiveEffectTypes() {
            return this._activeEffectTypes
        }
        HasAnyActiveEffect() {
            return 0 < this._activeEffectTypes.length
        }
        PreservesOpaqueness() {
            return this._preservesOpaqueness
        }
        GetEffectParametersForIndex(a) {
            return this._effectParams[a]
        }
        static SaveFxParamToJson(a) {
            return a &&
                a instanceof e.Color ? {
                    t: "color",
                    v: a.toJSON()
                } : a
        }
        static LoadFxParamFromJson(a) {
            if ("object" === typeof a) {
                if ("color" === a.t) {
                    const b = e.New(e.Color);
                    b.setFromJSON(a.v);
                    return b
                }
                throw Error("invalid effect parameter type");
            }
            return a
        }
        static SaveFxParamsToJson(a) {
            return a.map(e.EffectList.SaveFxParamToJson)
        }
        static LoadFxParamsFromJson(a) {
            return a.map(e.EffectList.LoadFxParamFromJson)
        }
        SaveToJson() {
            return this._allEffectTypes.map(a => ({
                name: a.GetName(),
                active: a.IsActive(),
                params: e.EffectList.SaveFxParamsToJson(this._effectParams[a.GetIndex()])
            }))
        }
        LoadFromJson(a) {
            for (const b of a)
                if (a =
                    this.GetEffectTypeByName(b.name)) a.SetActive(b.active), this._effectParams[a.GetIndex()] = e.EffectList.LoadFxParamsFromJson(b.params);
            this.UpdateActiveEffects()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.EffectType = class extends e.DefendedBase {
        constructor(a, b, d) {
            super();
            this._effectList = a;
            this._id = b[0];
            this._name = b[1];
            this._index = d;
            this._shaderProgram = null;
            this._isActive = !0
        }
        Release() {
            this._shaderProgram = this._effectList = null
        }
        Clone(a) {
            a = e.New(e.EffectType, a, [this._id, this._name], -1);
            a._shaderProgram = this._shaderProgram;
            a._isActive = this._isActive;
            return a
        }
        _InitRenderer(a) {
            a = a.GetShaderProgramByName(this._id);
            if (!a) throw Error("failed to find shader program '" + this._id +
                "'");
            this._shaderProgram = a
        }
        GetEffectList() {
            return this._effectList
        }
        GetName() {
            return this._name
        }
        _SetIndex(a) {
            this._index = a
        }
        GetIndex() {
            return this._index
        }
        GetOwner() {
            return this._effectList.GetOwner()
        }
        GetRuntime() {
            return this._effectList.GetRuntime()
        }
        SetActive(a) {
            this._isActive = !!a
        }
        IsActive() {
            return this._isActive
        }
        GetShaderProgram() {
            return this._shaderProgram
        }
        GetDefaultParameterValues() {
            const a = [];
            for (let b = 0, d = this._shaderProgram.GetParameterCount(); b < d; ++b) {
                const c = this._shaderProgram.GetParameterType(b);
                if ("float" === c || "percent" === c) a.push(0);
                else if ("color" === c) a.push(e.New(e.Color, 1, 1, 1, 1));
                else throw new TypeError("unknown effect parameter type");
            }
            return a
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.InstanceEffectList = class extends e.DefendedBase {
        constructor(a, b) {
            super();
            this._inst = a;
            this._wi = b;
            this._effectList = a.GetObjectClass().GetEffectList();
            this._wasDefaultColor = this._needsRebuildSteps = !0;
            this._wasTexRotated = this._wasRotatedOrNegativeSize = this._was3D = !1;
            this._effectChain = e.New(e.Gfx.EffectChain, a.GetRuntime().GetCanvasManager().GetEffectChainManager(), {
                drawContent: (d, c) => {
                    c = c.GetContentObject();
                    const f = c.GetWorldInfo();
                    d.SetColor(f.GetPremultipliedColor());
                    d.SetCurrentZ(f.GetTotalZElevation());
                    c.Draw(d);
                    d.SetCurrentZ(0)
                },
                getSourceTextureInfo: d => {
                    const c = d.GetCurrentTexRect(),
                        [f, k] = d.GetCurrentSurfaceSize();
                    return {
                        srcTexRect: c,
                        srcWidth: f,
                        srcHeight: k
                    }
                },
                getShaderParameters: d => this.GetEffectParametersForIndex(d)
            });
            this._activeEffectFlags = [];
            this._activeEffectTypes = [];
            this._preservesOpaqueness = !0;
            this._effectParams = [];
            for (const d of this._effectList.GetAllEffectTypes()) this._activeEffectFlags.push(!0);
            this.UpdateActiveEffects()
        }
        Release() {
            this._effectChain.Release();
            this._effectChain = null;
            e.clearArray(this._activeEffectFlags);
            e.clearArray(this._activeEffectTypes);
            e.clearArray(this._effectParams);
            this._effectList = this._inst = null
        }
        _LoadEffectParameters(a) {
            for (const b of a) this._effectParams.push(this._LoadSingleEffectParameters(b))
        }
        _LoadSingleEffectParameters(a) {
            a = a.slice(0);
            for (let b = 0, d = a.length; b < d; ++b) {
                const c = a[b];
                if (Array.isArray(c)) {
                    const f = e.New(e.Color);
                    f.setFromJSON(c);
                    a[b] = f
                }
            }
            return a
        }
        LoadDefaultEffectParameters() {
            for (const a of this._effectList.GetAllEffectTypes()) this._effectParams.push(a.GetDefaultParameterValues())
        }
        GetOwner() {
            return this._owner
        }
        GetEffectList() {
            return this._effectList
        }
        GetEffectChain() {
            this._MaybeRebuildEffectChainSteps();
            return this._effectChain
        }
        GetRuntime() {
            return this._inst.GetRuntime()
        }
        UpdateActiveEffects() {
            e.clearArray(this._activeEffectTypes);
            const a = this._wi,
                b = this._effectList.GetAllEffectTypes(),
                d = this._activeEffectTypes,
                c = this._activeEffectFlags;
            let f = !0;
            for (let k = 0, h = b.length; k < h; ++k)
                if (c[k]) {
                    const l = b[k];
                    d.push(l);
                    l.GetShaderProgram().PreservesOpaqueness() || (f = !1)
                } this._preservesOpaqueness = f;
            a._SetHasAnyActiveEffect(!!d.length);
            this._needsRebuildSteps = !0
        }
        _MaybeRebuildEffectChainSteps() {
            const a = this._inst;
            var b = this._wi;
            const d = b.HasDefaultColor(),
                c = 0 < b.GetDepth();
            b = 0 !== b.GetAngle() || 0 > b.GetWidth() || 0 > b.GetHeight();
            const f = a.IsCurrentTexRotated();
            if (this._needsRebuildSteps || d !== this._wasDefaultColor || c !== this._was3D || b !== this._wasRotatedOrNegativeSize || f !== this._wasTexRotated) this._effectChain.BuildSteps(this._activeEffectTypes.map(k => k.GetShaderProgram()), {
                    indexMap: this._activeEffectTypes.map(k => k.GetIndex()),
                    forcePreDraw: !d || a.MustPreDraw(),
                    is3D: c,
                    isSourceTextureRotated: f,
                    isRotatedOrNegativeSizeInstance: b
                }),
                this._needsRebuildSteps = !1, this._wasDefaultColor = d, this._was3D = c, this._wasRotatedOrNegativeSize = b, this._wasTexRotated = f
        }
        GetActiveEffectTypes() {
            return this._activeEffectTypes
        }
        GetEffectParametersForIndex(a) {
            return this._effectParams[a]
        }
        PreservesOpaqueness() {
            return this._preservesOpaqueness
        }
        HasAnyActiveBackgroundBlendingEffect() {
            return this._activeEffectTypes.some(a => a.GetShaderProgram().BlendsBackground())
        }
        IsEffectIndexActive(a) {
            return this._activeEffectFlags[a]
        }
        SetEffectIndexActive(a, b) {
            this._activeEffectFlags[a] = !!b
        }
        GetAllEffectTypes() {
            return this._effectList.GetAllEffectTypes()
        }
        _SaveToJson() {
            return this._effectList.GetAllEffectTypes().map(a => ({
                name: a.GetName(),
                active: this._activeEffectFlags[a.GetIndex()],
                params: e.EffectList.SaveFxParamsToJson(this._effectParams[a.GetIndex()])
            }))
        }
        _LoadFromJson(a) {
            for (const b of a)
                if (a = this._effectList.GetEffectTypeByName(b.name)) this._activeEffectFlags[a.GetIndex()] = b.active, this._effectParams[a.GetIndex()] = e.EffectList.LoadFxParamsFromJson(b.params);
            this.UpdateActiveEffects()
        }
    }
} {
    "use strict";
    const e = self.C3,
        a = [],
        b = [],
        d = [],
        c = e.New(e.CollisionPoly),
        f = e.New(e.CollisionPoly),
        k = e.New(e.Quad),
        h = e.New(e.Rect),
        l = e.New(e.Rect);
    let n = null,
        u = null,
        w = null;
    e.CollisionEngine = class extends e.DefendedBase {
        constructor(q) {
            super();
            this._runtime = q;
            this._registeredCollisions = [];
            this._polyCheckSec = this._polyCheckCount = this._collisionCheckSec = this._collisionCheckCount = 0
        }
        Release() {
            this._runtime = null
        }
        _Update1sStats() {
            this._collisionCheckSec = this._collisionCheckCount;
            this._collisionCheckCount = 0;
            this._polyCheckSec =
                this._polyCheckCount;
            this._polyCheckCount = 0
        }
        Get1secCollisionChecks() {
            return this._collisionCheckSec
        }
        Get1secPolyChecks() {
            return this._polyCheckSec
        }
        RegisterCollision(q, t) {
            const p = q.GetWorldInfo(),
                r = t.GetWorldInfo();
            p && r && p.IsCollisionEnabled() && r.IsCollisionEnabled() && this._registeredCollisions.push([q, t])
        }
        AddRegisteredCollisionCandidates(q, t, p) {
            for (const [r, x] of this._registeredCollisions) {
                let y;
                if (q === r) y = x;
                else if (q === x) y = r;
                else continue;
                y.BelongsToObjectClass(t) && (p.includes(y) || p.push(y))
            }
        }
        CheckRegisteredCollision(q,
            t) {
            if (!this._registeredCollisions.length) return !1;
            for (const [p, r] of this._registeredCollisions)
                if (q === p && t === r || q === r && t === p) return !0;
            return !1
        }
        ClearRegisteredCollisions() {
            e.clearArray(this._registeredCollisions)
        }
        TestOverlap(q, t) {
            if (!q || !t || q === t) return !1;
            q = q.GetWorldInfo();
            t = t.GetWorldInfo();
            if (!q.IsCollisionEnabled() || !t.IsCollisionEnabled()) return !1;
            this._collisionCheckCount++;
            const p = q.GetLayer(),
                r = t.GetLayer();
            return p.IsTransformCompatibleWith(r) ? this._TestOverlap_SameLayers(q, t) : this._TestOverlap_DifferentLayers(q,
                t)
        }
        _TestOverlap_SameLayers(q, t) {
            if (!q.GetBoundingBox().intersectsRect(t.GetBoundingBox())) return !1;
            this._polyCheckCount++;
            if (!q.GetBoundingQuad().intersectsQuad(t.GetBoundingQuad()) || q.HasTilemap() && t.HasTilemap()) return !1;
            if (q.HasTilemap()) return this.TestTilemapOverlap(q, t);
            if (t.HasTilemap()) return this.TestTilemapOverlap(t, q);
            if (!q.HasOwnCollisionPoly() && !t.HasOwnCollisionPoly()) return !0;
            const p = q.GetTransformedCollisionPoly(),
                r = t.GetTransformedCollisionPoly();
            return p.intersectsPoly(r, t.GetX() -
                q.GetX(), t.GetY() - q.GetY())
        }
        _TestOverlap_DifferentLayers(q, t) {
            var p = q.HasTilemap(),
                r = t.HasTilemap();
            if (p && !r) return this.TestTilemapOverlapDifferentLayers(q, t);
            if (r && !p) return this.TestTilemapOverlapDifferentLayers(t, q);
            if (r || p) return !1;
            r = q.GetLayer();
            p = t.GetLayer();
            c.copy(q.GetTransformedCollisionPoly());
            f.copy(t.GetTransformedCollisionPoly());
            var x = c.pointsArr();
            for (let y = 0, E = x.length; y < E; y += 2) {
                const G = y + 1,
                    A = x[G],
                    [F, J] = r.LayerToCanvasCss(x[y] + q.GetX(), A + q.GetY());
                x[y] = F;
                x[G] = J
            }
            q = f.pointsArr();
            for (let y =
                    0, E = q.length; y < E; y += 2) {
                r = y + 1;
                x = q[r];
                const [G, A] = p.LayerToCanvasCss(q[y] + t.GetX(), x + t.GetY());
                q[y] = G;
                q[r] = A
            }
            c.setBboxChanged();
            f.setBboxChanged();
            this._polyCheckCount++;
            return c.intersectsPoly(f, 0, 0)
        }
        TestTilemapOverlapDifferentLayers(q, t) {
            var p = q.GetLayer(),
                r = t.GetLayer();
            n || (n = e.New(e.CollisionPoly));
            u || (u = e.New(e.Rect));
            w || (w = e.New(e.Quad));
            var x = t.GetX(),
                y = t.GetY();
            const [E, G] = r.LayerToCanvasCss(x, y), [A, F] = p.CanvasCssToLayer(E, G);
            p = A - x;
            y = F - y;
            u.copy(t.GetBoundingBox());
            u.offset(p, y);
            if (!q.GetBoundingBox().intersectsRect(u)) return !1;
            w.copy(t.GetBoundingQuad());
            w.offset(p, y);
            this._polyCheckCount++;
            if (!q.GetBoundingQuad().intersectsQuad(w)) return !1;
            n.copy(t.GetTransformedCollisionPoly());
            r = n.pointsArr();
            for (let J = 0, B = r.length; J < B; J += 2) x = J + 1, r[J] += p, r[x] += y;
            n.setBboxChanged();
            return this.TestTilemapOverlap(q, t, A, F, n, u, w)
        }
        TestTilemapOverlap(q, t, p, r, x, y, E) {
            y = void 0 !== y ? y : t.GetBoundingBox();
            const G = q.GetX(),
                A = q.GetY();
            var F = q.GetInstance().GetSdkInstance();
            p = void 0 !== p ? p : t.GetX();
            r = void 0 !== r ? r : t.GetY();
            q = t.HasOwnCollisionPoly();
            E =
                void 0 !== E ? E : t.GetBoundingQuad();
            F.GetCollisionRectCandidates(y, b);
            for (let I = 0, L = b.length; I < L; ++I) {
                var J = b[I];
                F = J.GetRect();
                this._collisionCheckCount++;
                if (y.intersectsRectOffset(F, G, A) && (k.setFromRect(F), k.offset(G, A), k.intersectsQuad(E)))
                    if (q) {
                        var B = void 0 !== x ? x : t.GetTransformedCollisionPoly();
                        if (J = J.GetPoly()) {
                            if (this._polyCheckCount++, J.intersectsPoly(B, p - (G + F.getLeft()), r - (A + F.getTop()))) return e.clearArray(b), !0
                        } else if (c.setFromQuad(k, 0, 0), c.intersectsPoly(B, p, r)) return e.clearArray(b), !0
                    } else if (B =
                    J.GetPoly()) {
                    if (c.setFromQuad(E, 0, 0), B.intersectsPoly(c, -(G + F.getLeft()), -(A + F.getTop()))) return e.clearArray(b), !0
                } else return e.clearArray(b), !0
            }
            e.clearArray(b);
            return !1
        }
        TestAndSelectCanvasPointOverlap(q, t, p, r) {
            const x = q.GetCurrentSol();
            var y = this._runtime.GetCurrentEvent();
            if (!y) throw Error("cannot call outside event");
            y = y.IsOrBlock();
            if (x.IsSelectAll()) {
                r || (x._SetSelectAll(!1), e.clearArray(x._GetOwnInstances()));
                for (var E of q.GetInstances()) {
                    var G = E.GetWorldInfo(),
                        A = G.GetLayer();
                    const [F, J] =
                    A.CanvasCssToLayer(t, p, G.GetTotalZElevation());
                    if (G.ContainsPoint(F, J)) {
                        if (r) return !1;
                        x._PushInstance(E)
                    } else y && x._PushElseInstance(E)
                }
            } else {
                G = !1;
                y ? this._runtime.IsCurrentConditionFirst() && !x._GetOwnElseInstances().length && x._GetOwnInstances().length ? E = x._GetOwnInstances() : (E = x._GetOwnElseInstances(), G = !0) : E = x._GetOwnInstances();
                A = 0;
                for (let F = 0, J = E.length; F < J; ++F) {
                    const B = E[F],
                        I = B.GetWorldInfo(),
                        L = I.GetLayer(),
                        [P, S] = L.CanvasCssToLayer(t, p, I.GetTotalZElevation());
                    if (I.ContainsPoint(P, S)) {
                        if (r) return !1;
                        G ? x._PushInstance(B) : E[A++] = B
                    } else G ? E[A++] = B : y && x._PushElseInstance(B)
                }
                r || (E.length = A)
            }
            q.ApplySolToContainer();
            return r ? !0 : x.HasAnyInstances()
        }
        GetCollisionCandidates(q, t, p, r) {
            q = q ? 1 !== q.GetParallaxX() || 1 !== q.GetParallaxY() : !1;
            if (t.IsFamily())
                for (const x of t.GetFamilyMembers()) q || x.IsAnyInstanceParallaxed() ? e.appendArray(r, x.GetInstances()) : (x._UpdateAllCollisionCells(), x._GetCollisionCellGrid().QueryRange(p, r));
            else q || t.IsAnyInstanceParallaxed() ? e.appendArray(r, t.GetInstances()) : (t._UpdateAllCollisionCells(),
                t._GetCollisionCellGrid().QueryRange(p, r))
        }
        GetObjectClassesCollisionCandidates(q, t, p, r) {
            for (const x of t) this.GetCollisionCandidates(q, x, p, r)
        }
        GetSolidCollisionCandidates(q, t, p) {
            const r = this._runtime.GetSolidBehavior();
            r && this.GetObjectClassesCollisionCandidates(q, r.GetObjectClasses(), t, p)
        }
        GetJumpthruCollisionCandidates(q, t, p) {
            const r = this._runtime.GetJumpthruBehavior();
            r && this.GetObjectClassesCollisionCandidates(q, r.GetObjectClasses(), t, p)
        }
        IsSolidCollisionAllowed(q, t) {
            return q._IsSolidEnabled() &&
                (!t || t.GetWorldInfo().IsSolidCollisionAllowed(q.GetSavedDataMap().get("solidTags")))
        }
        TestOverlapSolid(q) {
            const t = q.GetWorldInfo();
            this.GetSolidCollisionCandidates(t.GetLayer(), t.GetBoundingBox(), a);
            for (const p of a)
                if (this.IsSolidCollisionAllowed(p, q) && this.TestOverlap(q, p)) return e.clearArray(a), p;
            e.clearArray(a);
            return null
        }
        TestRectOverlapSolid(q, t) {
            this.GetSolidCollisionCandidates(null, q, a);
            for (const p of a)
                if (this.IsSolidCollisionAllowed(p, t) && this.TestRectOverlap(q, p)) return e.clearArray(a),
                    p;
            e.clearArray(a);
            return null
        }
        TestOverlapJumpthru(q, t) {
            let p = null;
            t && (p = d, e.clearArray(p));
            const r = q.GetWorldInfo();
            this.GetJumpthruCollisionCandidates(r.GetLayer(), r.GetBoundingBox(), a);
            for (const x of a)
                if (x._IsJumpthruEnabled() && this.TestOverlap(q, x))
                    if (t) p.push(x);
                    else return e.clearArray(a), x;
            e.clearArray(a);
            return p
        }
        PushOut(q, t, p, r, x) {
            r = r || 50;
            const y = q.GetWorldInfo(),
                E = y.GetX(),
                G = y.GetY();
            for (let A = 0; A < r; ++A)
                if (y.SetXY(E + t * A, G + p * A), y.SetBboxChanged(), !this.TestOverlap(q, x)) return !0;
            y.SetXY(E,
                G);
            y.SetBboxChanged();
            return !1
        }
        PushOutSolid(q, t, p, r, x, y) {
            r = r || 50;
            const E = q.GetWorldInfo(),
                G = E.GetX(),
                A = E.GetY();
            let F = null,
                J = null;
            for (let B = 0; B < r; ++B)
                if (E.SetXY(G + t * B, A + p * B), E.SetBboxChanged(), !this.TestOverlap(q, F))
                    if (F = this.TestOverlapSolid(q)) J = F;
                    else if (x && (F = y ? this.TestOverlap(q, y) ? y : null : this.TestOverlapJumpthru(q)) && (J = F), !F) return J && this.PushInFractional(q, t, p, J, 16, !0), !0;
            E.SetXY(G, A);
            E.SetBboxChanged();
            return !1
        }
        PushOutSolidAxis(q, t, p, r) {
            r = r || 50;
            const x = q.GetWorldInfo(),
                y = x.GetX(),
                E = x.GetY();
            let G = null,
                A = null;
            for (let F = 0; F < r; ++F)
                for (let J = 0; 2 > J; ++J) {
                    const B = 2 * J - 1;
                    x.SetXY(y + t * F * B, E + p * F * B);
                    x.SetBboxChanged();
                    if (!this.TestOverlap(q, G))
                        if (G = this.TestOverlapSolid(q)) A = G;
                        else return A && this.PushInFractional(q, t * B, p * B, A, 16, !0), !0
                }
            x.SetXY(y, E);
            x.SetBboxChanged();
            return !1
        }
        PushInFractional(q, t, p, r, x, y) {
            let E = 2,
                G = !1;
            var A = !1;
            const F = q.GetWorldInfo();
            let J = F.GetX(),
                B = F.GetY();
            for (; E <= x;) A = 1 / E, E *= 2, F.OffsetXY(t * A * (G ? 1 : -1), p * A * (G ? 1 : -1)), F.SetBboxChanged(), this.TestOverlap(q, r) || y && this.TestOverlapSolid(q) ?
                A = G = !0 : (A = G = !1, J = F.GetX(), B = F.GetY());
            A && (F.SetXY(J, B), F.SetBboxChanged())
        }
        PushOutSolidNearest(q, t = 100) {
            let p = 0;
            const r = q.GetWorldInfo(),
                x = r.GetX(),
                y = r.GetY();
            let E = 0,
                G = this.TestOverlapSolid(q);
            if (!G) return !0;
            for (; p <= t;) {
                let A = 0,
                    F = 0;
                switch (E) {
                    case 0:
                        A = 0;
                        F = -1;
                        p++;
                        break;
                    case 1:
                        A = 1;
                        F = -1;
                        break;
                    case 2:
                        A = 1;
                        F = 0;
                        break;
                    case 3:
                        F = A = 1;
                        break;
                    case 4:
                        A = 0;
                        F = 1;
                        break;
                    case 5:
                        A = -1;
                        F = 1;
                        break;
                    case 6:
                        A = -1;
                        F = 0;
                        break;
                    case 7:
                        F = A = -1
                }
                E = (E + 1) % 8;
                r.SetXY(Math.floor(x + A * p), Math.floor(y + F * p));
                r.SetBboxChanged();
                if (!this.TestOverlap(q,
                        G) && (G = this.TestOverlapSolid(q), !G)) return !0
            }
            r.SetXY(x, y);
            r.SetBboxChanged();
            return !1
        }
        CalculateBounceAngle(q, t, p, r) {
            const x = q.GetWorldInfo(),
                y = x.GetX(),
                E = x.GetY(),
                G = Math.max(10, e.distanceTo(t, p, y, E));
            var A = e.angleTo(t, p, y, E),
                F = r || this.TestOverlapSolid(q);
            if (!F) return e.clampAngle(A + Math.PI);
            let J = F;
            var B = 0,
                I = 0;
            const L = e.toRadians(5);
            let P;
            for (P = 1; 36 > P; ++P) {
                const S = A - P * L;
                x.SetXY(t + Math.cos(S) * G, p + Math.sin(S) * G);
                x.SetBboxChanged();
                if (!this.TestOverlap(q, J) && (J = r ? null : this.TestOverlapSolid(q), !J)) {
                    B =
                        S;
                    break
                }
            }
            36 === P && (B = e.clampAngle(A + Math.PI));
            J = F;
            for (P = 1; 36 > P; ++P)
                if (F = A + P * L, x.SetXY(t + Math.cos(F) * G, p + Math.sin(F) * G), x.SetBboxChanged(), !this.TestOverlap(q, J) && (J = r ? null : this.TestOverlapSolid(q), !J)) {
                    I = F;
                    break
                } 36 === P && (I = e.clampAngle(A + Math.PI));
            x.SetXY(y, E);
            x.SetBboxChanged();
            if (I === B) return I;
            q = e.angleDiff(I, B) / 2;
            q = e.angleClockwise(I, B) ? e.clampAngle(B + q + Math.PI) : e.clampAngle(I + q);
            B = Math.cos(A);
            A = Math.sin(A);
            I = Math.cos(q);
            q = Math.sin(q);
            t = B * I + A * q;
            return e.angleTo(0, 0, B - 2 * t * I, A - 2 * t * q)
        }
        TestSegmentOverlap(q,
            t, p, r, x) {
            if (!x) return !1;
            const y = x.GetWorldInfo();
            if (!y.IsCollisionEnabled()) return !1;
            this._collisionCheckCount++;
            h.set(Math.min(q, p), Math.min(t, r), Math.max(q, p), Math.max(t, r));
            if (!y.GetBoundingBox().intersectsRect(h)) return !1;
            if (x.HasTilemap()) return this._TestSegmentOverlapTilemap(q, t, p, r, x, y);
            this._polyCheckCount++;
            return y.GetBoundingQuad().intersectsSegment(q, t, p, r) ? y.HasOwnCollisionPoly() ? y.GetTransformedCollisionPoly().intersectsSegment(y.GetX(), y.GetY(), q, t, p, r) : !0 : !1
        }
        _TestSegmentOverlapTilemap(q,
            t, p, r, x, y) {
            const E = y.GetX();
            y = y.GetY();
            x = x.GetSdkInstance();
            l.set(q, t, p, r);
            l.normalize();
            x.GetCollisionRectCandidates(l, b);
            for (let A = 0, F = b.length; A < F; ++A) {
                var G = b[A];
                x = G.GetRect();
                this._collisionCheckCount++;
                if (h.intersectsRectOffset(x, E, y) && (k.setFromRect(x), k.offset(E, y), k.intersectsSegment(q, t, p, r)))
                    if (G = G.GetPoly()) {
                        if (this._polyCheckCount++, G.intersectsSegment(E + x.getLeft(), y + x.getTop(), q, t, p, r)) return e.clearArray(b), !0
                    } else return e.clearArray(b), !0
            }
            e.clearArray(b);
            return !1
        }
        TestRectOverlap(q,
            t) {
            if (!t) return !1;
            const p = t.GetWorldInfo();
            if (!p.IsCollisionEnabled()) return !1;
            this._collisionCheckCount++;
            if (!p.GetBoundingBox().intersectsRect(q)) return !1;
            if (t.HasTilemap()) return this._TestRectOverlapTilemap(q, t, p);
            this._polyCheckCount++;
            k.setFromRect(q);
            if (!p.GetBoundingQuad().intersectsQuad(k)) return !1;
            if (!p.HasOwnCollisionPoly()) return !0;
            c.setFromRect(q, p.GetX(), p.GetY());
            q = p.GetTransformedCollisionPoly();
            return c.intersectsPoly(q, 0, 0)
        }
        _TestRectOverlapTilemap(q, t, p) {
            const r = p.GetX();
            p = p.GetY();
            t.GetSdkInstance().GetCollisionRectCandidates(q, b);
            for (let y = 0, E = b.length; y < E; ++y) {
                var x = b[y];
                t = x.GetRect();
                this._collisionCheckCount++;
                if (q.intersectsRectOffset(t, r, p))
                    if (x = x.GetPoly()) {
                        if (this._polyCheckCount++, c.setFromRect(q, 0, 0), x.intersectsPoly(c, -(r + t.getLeft()), -(p + t.getTop()))) return e.clearArray(b), !0
                    } else return e.clearArray(b), !0
            }
            e.clearArray(b);
            return !1
        }
        TestRayIntersectsInstance(q, t) {
            if (q) {
                var p = q.GetWorldInfo();
                p.IsCollisionEnabled() && (this._collisionCheckCount++, p.GetBoundingBox().intersectsRect(t.rect) &&
                    (q.HasTilemap() ? this._TestRayIntersectsTilemap(q, p, t) : (this._polyCheckCount++, p.HasOwnCollisionPoly() ? t.TestInstancePoly(q, p.GetX(), p.GetY(), p.GetTransformedCollisionPoly()) : t.TestInstanceQuad(q, p.GetBoundingQuad()))))
            }
        }
        _TestRayIntersectsTilemap(q, t, p) {
            const r = t.GetX(),
                x = t.GetY();
            q.GetSdkInstance().GetCollisionRectCandidates(p.rect, b);
            for (let E = 0, G = b.length; E < G; E++) {
                var y = b[E];
                const A = y.GetRect();
                this._collisionCheckCount++;
                p.rect.intersectsRectOffset(A, r, x) && (y = y.GetPoly(), this._polyCheckCount++,
                    y ? p.TestInstancePoly(q, r + A.getLeft(), x + A.getTop(), y) : p.TestInstanceRect(q, t.GetX(), t.GetY(), A))
            }
            e.clearArray(b)
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.SparseGrid = class extends e.DefendedBase {
        constructor(a, b) {
            super();
            this._cellWidth = a;
            this._cellHeight = b;
            this._cells = e.New(e.PairMap)
        }
        Release() {
            this._cells.Release();
            this._cells = null
        }
        GetCell(a, b, d) {
            let c = this._cells.Get(a, b);
            return c ? c : d ? (c = e.New(e.GridCell, this, a, b), this._cells.Set(a, b, c), c) : null
        }
        XToCell(a) {
            a = Math.floor(a / this._cellWidth);
            return isFinite(a) ? a : 0
        }
        YToCell(a) {
            a = Math.floor(a / this._cellHeight);
            return isFinite(a) ? a : 0
        }
        Update(a, b, d) {
            if (b)
                for (let c = b.getLeft(),
                        f = b.getRight(); c <= f; ++c)
                    for (let k = b.getTop(), h = b.getBottom(); k <= h; ++k) {
                        if (d && d.containsPoint(c, k)) continue;
                        const l = this.GetCell(c, k, !1);
                        l && (l.Remove(a), l.IsEmpty() && this._cells.Delete(c, k))
                    }
            if (d)
                for (let c = d.getLeft(), f = d.getRight(); c <= f; ++c)
                    for (let k = d.getTop(), h = d.getBottom(); k <= h; ++k) b && b.containsPoint(c, k) || this.GetCell(c, k, !0).Insert(a)
        }
        QueryRange(a, b) {
            let d = this.XToCell(a.getLeft());
            const c = this.YToCell(a.getTop()),
                f = this.XToCell(a.getRight());
            a = this.YToCell(a.getBottom());
            if (isFinite(f) && isFinite(a))
                for (; d <=
                    f; ++d)
                    for (let k = c; k <= a; ++k) {
                        const h = this.GetCell(d, k, !1);
                        h && h.Dump(b)
                    }
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.GridCell = class extends e.DefendedBase {
        constructor(a, b, d) {
            super();
            this._grid = a;
            this._x = b;
            this._y = d;
            this._instances = e.New(e.ArraySet)
        }
        Release() {
            this._instances.Release();
            this._grid = this._instances = null
        }
        IsEmpty() {
            return this._instances.IsEmpty()
        }
        Insert(a) {
            this._instances.Add(a)
        }
        Remove(a) {
            this._instances.Delete(a)
        }
        Dump(a) {
            e.appendArray(a, this._instances.GetArray())
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Ray = class {
        constructor() {
            this.dy = this.dx = this.y2 = this.x2 = this.y1 = this.x1 = 0;
            this.rect = new e.Rect;
            this.hitFraction = 2;
            this.hitUid = null;
            this.distance = this.hitY = this.hitX = this.hitNormalDy = this.hitNormalDx = this.hitNormal = 0;
            this.normalX = 1;
            this.normalY = 0;
            this.reflectionX = 1;
            this.reflectionY = 0
        }
        DidCollide() {
            return 1.000001 > this.hitFraction
        }
        Set(a, b, d, c) {
            this.x1 = a;
            this.y1 = b;
            this.x2 = d;
            this.y2 = c;
            this.dx = d - a;
            this.dy = c - b;
            this.rect.set(a, b, d, c);
            this.rect.normalize();
            this.hitFraction =
                2;
            this.hitUid = null;
            this.distance = this.hitY = this.hitX = this.hitNormalDy = this.hitNormalDx = this.hitNormal = 0;
            this.normalX = 1;
            this.normalY = 0;
            this.reflectionX = 1;
            this.reflectionY = 0;
            return this
        }
        Complete() {
            if (!1 !== this.DidCollide()) {
                var a = this.dx * this.hitFraction,
                    b = this.dy * this.hitFraction,
                    d = Math.sqrt(a * a + b * b);
                a /= d;
                b /= d;
                this.distance = d - 1E-6;
                this.hitX = this.x1 + a * this.distance;
                this.hitY = this.y1 + b * this.distance;
                this.hitNormal = Math.atan2(this.hitNormalDy, this.hitNormalDx) + Math.PI / 2;
                this.normalX = Math.cos(this.hitNormal);
                this.normalY = Math.sin(this.hitNormal);
                d = a * this.normalX + b * this.normalY;
                this.reflectionX = a - 2 * this.normalX * d;
                this.reflectionY = b - 2 * this.normalY * d;
                0 < d && (this.hitNormal = e.clampAngle(this.hitNormal + Math.PI), this.normalX = -this.normalX, this.normalY = -this.normalY)
            }
        }
        TestInstanceSegment(a, b, d, c, f) {
            const k = e.rayIntersect(this.x1, this.y1, this.x2, this.y2, b, d, c, f);
            0 <= k && k < this.hitFraction && (this.hitFraction = k, this.hitUid = a.GetUID(), this.hitNormalDx = b - c, this.hitNormalDy = d - f)
        }
        TestInstanceRect(a, b, d, c) {
            const f = b + c.getLeft();
            b += c.getRight();
            const k = d + c.getTop();
            d += c.getBottom();
            this.TestInstanceSegment(a, f, k, b, k);
            this.TestInstanceSegment(a, b, k, b, d);
            this.TestInstanceSegment(a, b, d, f, d);
            this.TestInstanceSegment(a, f, d, f, k)
        }
        TestInstanceQuad(a, b) {
            const d = b.getTlx(),
                c = b.getTly(),
                f = b.getTrx(),
                k = b.getTry(),
                h = b.getBrx(),
                l = b.getBry(),
                n = b.getBlx();
            b = b.getBly();
            this.TestInstanceSegment(a, d, c, f, k);
            this.TestInstanceSegment(a, f, k, h, l);
            this.TestInstanceSegment(a, h, l, n, b);
            this.TestInstanceSegment(a, n, b, d, c)
        }
        TestInstancePoly(a, b, d, c) {
            c =
                c.pointsArr();
            for (let f = 0, k = c.length; f < k; f += 2) {
                const h = (f + 2) % k;
                this.TestInstanceSegment(a, c[f] + b, c[f + 1] + d, c[h] + b, c[h + 1] + d)
            }
        }
    }
} {
    "use strict";
    const e = self.C3,
        a = new Set("off crop scale-inner scale-outer letterbox-scale letterbox-integer-scale".split(" ")),
        b = new Set(["high", "low"]),
        d = self.glMatrix.mat4,
        c = d.create(),
        f = e.New(e.Quad),
        k = e.New(e.Rect);
    e.CanvasManager = class extends e.DefendedBase {
        constructor(h) {
            super();
            this._runtime = h;
            this._canvas = null;
            this._isWebGPUEnabled = !1;
            this._webgpuRenderer = this._webglRenderer = null;
            this._gpuPreference = "high-performance";
            this._canvasCssOffsetY = this._canvasCssOffsetX = this._canvasDeviceHeight =
                this._canvasDeviceWidth = this._canvasCssHeight = this._canvasCssWidth = this._windowInnerHeight = this._windowInnerWidth = 0;
            this._enableMipmaps = !0;
            this._drawHeight = this._drawWidth = this._textureAnisotropy = 0;
            this._documentFullscreenMode = this._fullscreenMode = "letterbox-scale";
            this._deviceTransformOffY = this._deviceTransformOffX = 0;
            this._defaultProjectionMatrix = d.create();
            this._fullscreenScalingQuality = this._wantFullscreenScalingQuality = "high";
            this._isDocumentFullscreen = !1;
            this._availableAdditionalRenderTargets = [];
            this._usedAdditionalRenderTargets = new Set;
            this._shaderData = self.C3_Shaders;
            this._effectChainManager = e.New(e.Gfx.EffectChainManager, {
                getDrawSize: () => [this.GetDrawWidth(), this.GetDrawHeight()],
                getRenderTarget: () => this.GetEffectCompositorRenderTarget(),
                releaseRenderTarget: l => this.ReleaseEffectCompositorRenderTarget(l),
                getTime: () => this.GetRuntime().GetGameTime(),
                redraw: () => this.GetRuntime().UpdateRender()
            });
            this._gpuTimeEndFrame = this._gpuTimeStartFrame = 0;
            this._gpuLastUtilisation = NaN;
            this._gpuFrameTimingsBuffer =
                null;
            this._layersGpuProfile = new Map;
            this._gpuCurUtilisation = NaN;
            this._webgpuFrameTimings = new Map;
            this._snapshotFormat = "";
            this._snapshotQuality = 1;
            this._snapshotArea = e.New(e.Rect);
            this._snapshotUrl = "";
            this._snapshotResolve = this._snapshotPromise = null;
            this._loaderStartTime = this._isPastingToDrawingCanvas = 0;
            this._rafId = -1;
            this._loadingProgress = 0;
            this._loadingprogress_handler = l => this._loadingProgress = l.progress;
            this._percentText = null;
            this._splashTextures = {
                logo: null,
                powered: null,
                website: null
            };
            this._splashFadeOutStartTime =
                this._splashFadeInFinishTime = this._splashFrameNumber = 0;
            this._splashState = "fade-in";
            this._splashDoneResolve = null;
            this._splashDonePromise = new Promise(l => this._splashDoneResolve = l)
        }
        _SetGPUPowerPreference(h) {
            this._gpuPreference = h
        }
        _SetWebGPUEnabled(h) {
            this._isWebGPUEnabled = !!h
        }
        async CreateCanvas(h) {
            this._canvas = h.canvas;
            this._runtime.AddDOMComponentMessageHandler("runtime", "window-resize", u => this._OnWindowResize(u));
            this._runtime.AddDOMComponentMessageHandler("runtime", "fullscreenchange", u => this._OnFullscreenChange(u));
            this._runtime.AddDOMComponentMessageHandler("runtime", "fullscreenerror", u => this._OnFullscreenError(u));
            this._canvas.addEventListener("webglcontextlost", u => this._OnWebGLContextLost(u));
            this._canvas.addEventListener("webglcontextrestored", u => this._OnWebGLContextRestored(u));
            this._isDocumentFullscreen = !!h.isFullscreen;
            var l = navigator.gpu && this._isWebGPUEnabled;
            let n = !1;
            if (l) try {
                await this._InitWebGPUContext(!0)
            } catch (u) {
                this._webgpuRenderer = null
            }
            if (!this.GetRenderer()) try {
                await this._InitWebGLContext(!0)
            } catch (u) {
                this._webglRenderer =
                    null
            }
            this.GetRenderer() || (n = !0);
            if (!this.GetRenderer() && l) try {
                await this._InitWebGPUContext(!1)
            } catch (u) {
                this._webgpuRenderer = null
            }
            if (!this.GetRenderer()) try {
                await this._InitWebGLContext(!1)
            } catch (u) {
                this._webglRenderer = null
            }
            l = this.GetRenderer();
            if (!l) throw Error("failed to acquire a renderer - check WebGL or WebGPU is supported");
            l.SetHasMajorPerformanceCaveat(n);
            this.SetSize(h.windowInnerWidth, h.windowInnerHeight, !0);
            this._webgpuRenderer ? await this._InitWebGPU() : this._webglRenderer && await this._InitWebGL();
            l.SetMipmapsEnabled(this._enableMipmaps);
            l.SupportsGPUProfiling() && (this._gpuLastUtilisation = 0);
            for (const u of this._runtime._GetAllEffectLists()) {
                for (const w of u.GetAllEffectTypes()) w._InitRenderer(l);
                u.UpdateActiveEffects()
            }
        }
        async _InitWebGPUContext(h) {
            h = {
                powerPreference: this._gpuPreference,
                depth: this._runtime.Uses3DFeatures(),
                failIfMajorPerformanceCaveat: h,
                canSampleBackbuffer: this._runtime.UsesAnyBackgroundBlending(),
                canSampleDepth: this._runtime.UsesAnyDepthSampling()
            };
            this._webgpuRenderer = e.New(e.Gfx.WebGPURenderer);
            await this._webgpuRenderer.Create(this._canvas, h)
        }
        async _InitWebGLContext(h) {
            h = {
                powerPreference: this._gpuPreference,
                enableGpuProfiling: !0,
                depth: this._runtime.Uses3DFeatures(),
                canSampleDepth: this._runtime.UsesAnyDepthSampling(),
                failIfMajorPerformanceCaveat: h
            };
            "Android" === e.Platform.OS && "Chromium" === e.Platform.BrowserEngine && 75 > e.Platform.BrowserVersionNumber && (console.warn("[Construct 3] Disabling WebGL 2 because this device appears to be affected by crbug.com/934823. Install software updates to avoid this."),
                h.maxWebGLVersion = 1);
            "standard" === this._runtime.GetCompositingMode() ? h.alpha = !0 : (h.alpha = !1, h.lowLatency = !0);
            this._webglRenderer = e.New(e.Gfx.WebGLRenderer, this._canvas, h);
            await this._webglRenderer.InitState()
        }
        async _InitWebGPU() {
            if (this._shaderData) {
                const h = [];
                for (const [l, n] of Object.entries(this._shaderData)) {
                    n.src = n.wgsl;
                    const u = e.Gfx.WebGPUShaderProgram.GetDefaultVertexShaderSource();
                    h.push(this._webgpuRenderer.CreateShaderProgram(n, u, l))
                }
                await Promise.all(h)
            }
        }
        async _InitWebGL() {
            if (this._shaderData) {
                const h = [];
                for (const [l, n] of Object.entries(this._shaderData)) {
                    n.src = n.glsl;
                    const u = e.Gfx.WebGLShaderProgram.GetDefaultVertexShaderSource();
                    h.push(this._webglRenderer.CreateShaderProgram(n, u, l))
                }
                await Promise.all(h);
                this._webglRenderer.ResetLastProgram();
                this._webglRenderer.SetTextureFillMode()
            }
            this._webglRenderer.SupportsGPUProfiling() && (this._gpuFrameTimingsBuffer = e.New(e.Gfx.WebGLQueryResultBuffer, this._webglRenderer))
        }
        Release() {
            this._canvas = this._webglRenderer = this._runtime = null
        }
        _OnWindowResize(h) {
            const l =
                this._runtime,
                n = h.devicePixelRatio;
            l.IsInWorker() && (self.devicePixelRatio = n);
            l._SetDevicePixelRatio(n);
            this._isDocumentFullscreen = !!h.isFullscreen;
            this.SetSize(h.innerWidth, h.innerHeight);
            l.UpdateRender();
            l.IsDebug() && (l.HitBreakpoint() || self.C3Debugger.IsDebuggerPaused()) && l.Render()
        }
        _OnFullscreenChange(h) {
            this._isDocumentFullscreen = !!h.isFullscreen;
            this.SetSize(h.innerWidth, h.innerHeight, !0);
            this._runtime.UpdateRender()
        }
        _OnFullscreenError(h) {
            this._isDocumentFullscreen = !!h.isFullscreen;
            this.SetSize(h.innerWidth,
                h.innerHeight, !0);
            this._runtime.UpdateRender()
        }
        SetSize(h, l, n = !1) {
            h = Math.floor(h);
            l = Math.floor(l);
            if (0 >= h || 0 >= l) throw Error("invalid size");
            if (this._windowInnerWidth !== h || this._windowInnerHeight !== l || n) {
                this._windowInnerWidth = h;
                this._windowInnerHeight = l;
                n = this.GetCurrentFullscreenMode();
                "letterbox-scale" === n ? this._CalculateLetterboxScale(h, l) : "letterbox-integer-scale" === n ? this._CalculateLetterboxIntegerScale(h, l) : "off" === n ? this._CalculateFixedSizeCanvas(h, l) : this._CalculateFullsizeCanvas(h, l);
                this._UpdateFullscreenScalingQuality(n);
                this._canvas.width = this._canvasDeviceWidth;
                this._canvas.height = this._canvasDeviceHeight;
                this._runtime.PostComponentMessageToDOM("canvas", "update-size", {
                    marginLeft: this._canvasCssOffsetX,
                    marginTop: this._canvasCssOffsetY,
                    styleWidth: this._canvasCssWidth,
                    styleHeight: this._canvasCssHeight
                });
                h = this.GetRenderer();
                h.SetSize(this._canvasDeviceWidth, this._canvasDeviceHeight, !0);
                for (var u of this._availableAdditionalRenderTargets) h.DeleteRenderTarget(u);
                e.clearArray(this._availableAdditionalRenderTargets);
                h.CalculatePerspectiveMatrix(this._defaultProjectionMatrix,
                    this.GetDrawWidth() / this.GetDrawHeight());
                u = this._runtime.GetLayoutManager();
                u.SetAllLayerProjectionChanged();
                u.SetAllLayerMVChanged()
            }
        }
        GetDefaultProjectionMatrix() {
            return this._defaultProjectionMatrix
        }
        _CalculateLetterboxScale(h, l) {
            const n = this._runtime.GetDevicePixelRatio(),
                u = this._runtime.GetOriginalViewportWidth(),
                w = this._runtime.GetOriginalViewportHeight(),
                q = u / w;
            h / l > q ? (this._canvasCssWidth = Math.round(l * q), this._canvasCssHeight = l, this._canvasCssOffsetX = Math.floor((h - this._canvasCssWidth) / 2), this._canvasCssOffsetY =
                0) : (this._canvasCssWidth = h, this._canvasCssHeight = Math.round(h / q), this._canvasCssOffsetX = 0, this._canvasCssOffsetY = Math.floor((l - this._canvasCssHeight) / 2));
            this._canvasDeviceWidth = Math.round(this._canvasCssWidth * n);
            this._canvasDeviceHeight = Math.round(this._canvasCssHeight * n);
            this._runtime.SetViewportSize(u, w)
        }
        _CalculateLetterboxIntegerScale(h, l) {
            const n = this._runtime.GetDevicePixelRatio();
            1 !== n && (h += 1, l += 1);
            const u = this._runtime.GetOriginalViewportWidth(),
                w = this._runtime.GetOriginalViewportHeight();
            var q = u / w;
            q = h / l > q ? l * q * n / u : h / q * n / w;
            1 < q ? q = Math.floor(q) : 1 > q && (q = 1 / Math.ceil(1 / q));
            this._canvasDeviceWidth = Math.round(u * q);
            this._canvasDeviceHeight = Math.round(w * q);
            this._canvasCssWidth = this._canvasDeviceWidth / n;
            this._canvasCssHeight = this._canvasDeviceHeight / n;
            this._canvasCssOffsetX = Math.max(Math.floor((h - this._canvasCssWidth) / 2), 0);
            this._canvasCssOffsetY = Math.max(Math.floor((l - this._canvasCssHeight) / 2), 0);
            this._runtime.SetViewportSize(u, w)
        }
        _CalculateFullsizeCanvas(h, l) {
            const n = this._runtime.GetDevicePixelRatio();
            this._canvasCssWidth = h;
            this._canvasCssHeight = l;
            this._canvasDeviceWidth = Math.round(this._canvasCssWidth * n);
            this._canvasDeviceHeight = Math.round(this._canvasCssHeight * n);
            this._canvasCssOffsetY = this._canvasCssOffsetX = 0;
            h = this.GetDisplayScale();
            this._runtime.SetViewportSize(this._canvasCssWidth / h, this._canvasCssHeight / h)
        }
        _CalculateFixedSizeCanvas(h, l) {
            const n = this._runtime.GetDevicePixelRatio();
            this._canvasCssWidth = this._runtime.GetViewportWidth();
            this._canvasCssHeight = this._runtime.GetViewportHeight();
            this._canvasDeviceWidth = Math.round(this._canvasCssWidth * n);
            this._canvasDeviceHeight = Math.round(this._canvasCssHeight * n);
            this.IsDocumentFullscreen() ? (this._canvasCssOffsetX = Math.floor((h - this._canvasCssWidth) / 2), this._canvasCssOffsetY = Math.floor((l - this._canvasCssHeight) / 2)) : this._canvasCssOffsetY = this._canvasCssOffsetX = 0;
            this._runtime.SetViewportSize(this._runtime.GetViewportWidth(), this._runtime.GetViewportHeight())
        }
        _UpdateFullscreenScalingQuality(h) {
            if ("high" === this._wantFullscreenScalingQuality) this._drawWidth =
                this._canvasDeviceWidth, this._drawHeight = this._canvasDeviceHeight, this._fullscreenScalingQuality = "high";
            else {
                let n;
                if ("off" === this.GetCurrentFullscreenMode()) {
                    var l = this._runtime.GetViewportWidth();
                    n = this._runtime.GetViewportHeight()
                } else l = this._runtime.GetOriginalViewportWidth(), n = this._runtime.GetOriginalViewportHeight();
                this._canvasDeviceWidth < l && this._canvasDeviceHeight < n ? (this._drawWidth = this._canvasDeviceWidth, this._drawHeight = this._canvasDeviceHeight, this._fullscreenScalingQuality = "high") :
                    (this._drawWidth = l, this._drawHeight = n, this._fullscreenScalingQuality = "low", "scale-inner" === h ? (h = l / n, l = this._windowInnerWidth / this._windowInnerHeight, l < h ? this._drawWidth = this._drawHeight * l : l > h && (this._drawHeight = this._drawWidth / l)) : "scale-outer" === h && (h = l / n, l = this._windowInnerWidth / this._windowInnerHeight, l > h ? this._drawWidth = this._drawHeight * l : l < h && (this._drawHeight = this._drawWidth / l)))
            }
        }
        GetRuntime() {
            return this._runtime
        }
        GetEffectChainManager() {
            return this._effectChainManager
        }
        IsDocumentFullscreen() {
            return this._isDocumentFullscreen
        }
        SetFullscreenMode(h) {
            if (!a.has(h)) throw Error("invalid fullscreen mode");
            this._fullscreenMode = h;
            h = this._runtime.GetLayoutManager();
            h.SetAllLayerProjectionChanged();
            h.SetAllLayerMVChanged()
        }
        GetFullscreenMode() {
            return this._fullscreenMode
        }
        SetDocumentFullscreenMode(h) {
            if (!a.has(h)) throw Error("invalid fullscreen mode");
            this._documentFullscreenMode = h;
            h = this._runtime.GetLayoutManager();
            h.SetAllLayerProjectionChanged();
            h.SetAllLayerMVChanged()
        }
        GetDocumentFullscreenMode() {
            return this._documentFullscreenMode
        }
        GetCurrentFullscreenMode() {
            return this.IsDocumentFullscreen() ? this.GetDocumentFullscreenMode() :
                this.GetFullscreenMode()
        }
        SetFullscreenScalingQuality(h) {
            if (!b.has(h)) throw Error("invalid fullscreen scaling quality");
            this._wantFullscreenScalingQuality = h;
            this._runtime.GetLayoutManager().SetAllLayerProjectionChanged()
        }
        GetSetFullscreenScalingQuality() {
            return this._wantFullscreenScalingQuality
        }
        GetCurrentFullscreenScalingQuality() {
            return this._fullscreenScalingQuality
        }
        static _FullscreenModeNumberToString(h) {
            switch (h) {
                case 0:
                    return "off";
                case 1:
                    return "crop";
                case 2:
                    return "scale-inner";
                case 3:
                    return "scale-outer";
                case 4:
                    return "letterbox-scale";
                case 5:
                    return "letterbox-integer-scale";
                default:
                    throw Error("invalid fullscreen mode");
            }
        }
        GetLastWidth() {
            return this._windowInnerWidth
        }
        GetLastHeight() {
            return this._windowInnerHeight
        }
        GetDrawWidth() {
            return this._drawWidth
        }
        GetDrawHeight() {
            return this._drawHeight
        }
        SetMipmapsEnabled(h) {
            this._enableMipmaps = !!h
        }
        _SetTextureAnisotropy(h) {
            this._textureAnisotropy = h
        }
        GetTextureAnisotropy() {
            return this._textureAnisotropy
        }
        IsRendererContextLost() {
            return this.GetRenderer().IsContextLost()
        }
        _OnWebGLContextLost(h) {
            console.log("[Construct 3] WebGL context lost");
            h.preventDefault();
            this._availableAdditionalRenderTargets = [];
            this._usedAdditionalRenderTargets.clear();
            this._webglRenderer.OnContextLost();
            this._runtime._OnWebGLContextLost()
        }
        async _OnWebGLContextRestored(h) {
            await this._webglRenderer.OnContextRestored();
            await this._LoadWebGLShaderPrograms();
            for (const l of this._runtime._GetAllEffectLists())
                for (const n of l.GetAllEffectTypes()) n._InitRenderer(this._webglRenderer);
            await this._runtime._OnWebGLContextRestored();
            console.log("[Construct 3] WebGL context restored")
        }
        GetWebGLRenderer() {
            return this._webglRenderer
        }
        GetWebGPURenderer() {
            return this._webgpuRenderer
        }
        GetRenderer() {
            return this._webgpuRenderer ||
                this._webglRenderer
        }
        GetRenderScale() {
            return "low" === this._fullscreenScalingQuality ? 1 / this._runtime.GetDevicePixelRatio() : this.GetDisplayScale()
        }
        GetDisplayScale() {
            const h = this.GetCurrentFullscreenMode();
            if ("off" === h || "crop" === h) return 1;
            const l = this._runtime.GetOriginalViewportWidth(),
                n = this._runtime.GetOriginalViewportHeight(),
                u = l / n,
                w = this._canvasDeviceWidth / this._canvasDeviceHeight;
            return "scale-inner" !== h && w > u || "scale-inner" === h && w < u ? this._canvasCssHeight / n : this._canvasCssWidth / l
        }
        GetEffectLayerScaleParam() {
            return "low" ===
                this.GetCurrentFullscreenScalingQuality() ? 1 : this.GetDisplayScale()
        }
        GetEffectDevicePixelRatioParam() {
            return "low" === this.GetCurrentFullscreenScalingQuality() ? 1 : this._runtime.GetDevicePixelRatio()
        }
        SetDeviceTransformOffset(h, l) {
            this._deviceTransformOffX = h;
            this._deviceTransformOffY = l
        }
        SetDeviceTransform(h, l, n, u = !0) {
            l = l || this._drawWidth;
            n = n || this._drawHeight;
            const w = l / 2 + this._deviceTransformOffX,
                q = n / 2 + this._deviceTransformOffY;
            if (u) {
                u = this.GetDefaultProjectionMatrix();
                if (l !== this._drawWidth || n !== this._drawHeight) h.CalculatePerspectiveMatrix(c,
                    l / n), u = c;
                h.SetProjectionMatrix(u)
            }
            l = h.CalculateLookAtModelView2(w, q, h.GetDefaultCameraZ() * this._runtime.GetDevicePixelRatio(), w, q, 0, n || this._drawHeight);
            h.SetModelViewMatrix(l)
        }
        SetCssTransform(h, l = !0) {
            const n = this._canvasCssWidth / 2,
                u = this._canvasCssHeight / 2;
            l && h.SetProjectionMatrix(this.GetDefaultProjectionMatrix());
            l = h.CalculateLookAtModelView2(n, u, h.GetDefaultCameraZ(), n, u, 0);
            h.SetModelViewMatrix(l)
        }
        GetDeviceWidth() {
            return this._canvasDeviceWidth
        }
        GetDeviceHeight() {
            return this._canvasDeviceHeight
        }
        GetCssWidth() {
            return this._canvasCssWidth
        }
        GetCssHeight() {
            return this._canvasCssHeight
        }
        GetCanvasClientX() {
            return this._canvasCssOffsetX
        }
        GetCanvasClientY() {
            return this._canvasCssOffsetY
        }
        GetAdditionalRenderTarget(h) {
            h.depth =
                this._runtime.Uses3DFeatures();
            const l = this._availableAdditionalRenderTargets,
                n = l.findIndex(w => w.IsCompatibleWithOptions(h));
            let u; - 1 !== n ? (u = l[n], l.splice(n, 1)) : u = this.GetRenderer().CreateRenderTarget(h);
            this._usedAdditionalRenderTargets.add(u);
            return u
        }
        ReleaseAdditionalRenderTarget(h) {
            if (!this._usedAdditionalRenderTargets.has(h)) throw Error("render target not in use");
            this._usedAdditionalRenderTargets.delete(h);
            this._availableAdditionalRenderTargets.push(h)
        }
        GetEffectCompositorRenderTarget() {
            const h = {
                sampling: this._runtime.GetSampling()
            };
            "low" === this.GetCurrentFullscreenScalingQuality() && (h.width = this.GetDrawWidth(), h.height = this.GetDrawHeight());
            return this.GetAdditionalRenderTarget(h)
        }
        ReleaseEffectCompositorRenderTarget(h) {
            this.ReleaseAdditionalRenderTarget(h)
        }* activeLayersGpuProfiles() {
            for (const h of this._runtime.GetLayoutManager().runningLayouts())
                for (const l of h.GetLayers()) {
                    const n = this._layersGpuProfile.get(l);
                    n && (yield n)
                }
        }
        GetLayerTimingsBuffer(h) {
            if (!this.GetRenderer().SupportsGPUProfiling()) return null;
            let l = this._layersGpuProfile.get(h);
            l || (l = {
                name: h.GetName(),
                timingsBuffer: e.New(e.Gfx.WebGLQueryResultBuffer, this._webglRenderer),
                curUtilisation: 0,
                lastUtilisation: 0
            }, this._layersGpuProfile.set(h, l));
            return l.timingsBuffer
        }
        _Update1sFrameRange() {
            const h = this.GetRenderer();
            if (h.SupportsGPUProfiling() && 0 === this._gpuTimeEndFrame) {
                this._gpuTimeEndFrame = h.GetFrameNumber();
                this._gpuCurUtilisation = NaN;
                for (const l of this.activeLayersGpuProfiles()) l.curUtilisation = NaN
            }
        }
        _UpdateTick() {
            this._webglRenderer && this._webglRenderer.SupportsGPUProfiling() &&
                this._UpdateTick_WebGL();
            this._webgpuRenderer && this._webgpuRenderer.SupportsGPUProfiling() && this._UpdateTick_WebGPU()
        }
        _UpdateTick_WebGL() {
            if (isNaN(this._gpuCurUtilisation) && (this._gpuCurUtilisation = this._gpuFrameTimingsBuffer.GetFrameRangeResultSum(this._gpuTimeStartFrame, this._gpuTimeEndFrame), !isNaN(this._gpuCurUtilisation))) {
                if (this._runtime.IsDebug())
                    for (const h of this.activeLayersGpuProfiles())
                        if (h.curUtilisation = h.timingsBuffer.GetFrameRangeResultSum(this._gpuTimeStartFrame, this._gpuTimeEndFrame),
                            isNaN(h.curUtilisation)) return;
                this._gpuFrameTimingsBuffer.DeleteAllBeforeFrameNumber(this._gpuTimeEndFrame);
                this._gpuLastUtilisation = Math.min(this._gpuCurUtilisation, 1);
                if (this._runtime.IsDebug()) {
                    for (const h of this.activeLayersGpuProfiles()) h.timingsBuffer.DeleteAllBeforeFrameNumber(this._gpuTimeEndFrame), h.lastUtilisation = Math.min(h.curUtilisation, 1);
                    self.C3Debugger.UpdateGPUProfile(this._gpuLastUtilisation, [...this.activeLayersGpuProfiles()])
                }
                this._gpuTimeStartFrame = this._gpuTimeEndFrame;
                this._gpuTimeEndFrame =
                    0
            }
        }
        GetGPUFrameTimingsBuffer() {
            return this._gpuFrameTimingsBuffer
        }
        _UpdateTick_WebGPU() {
            if (0 !== this._gpuTimeEndFrame) {
                for (var h = this._gpuTimeStartFrame; h < this._gpuTimeEndFrame; ++h) {
                    var l = this._webgpuFrameTimings.get(h);
                    if (l && !l.HasResult()) return
                }
                l = this._runtime.GetMainRunningLayout();
                h = e.MakeFilledArray(l.GetLayerCount() + 1, 0);
                for (var n = this._gpuTimeStartFrame; n < this._gpuTimeEndFrame; ++n) {
                    var u = this._webgpuFrameTimings.get(n);
                    if (u) {
                        u = u.GetResult();
                        for (let w = 0, q = Math.min(h.length, u.length / 2); w < q; ++w) {
                            const t =
                                u[2 * w],
                                p = u[2 * w + 1];
                            h[w] = 0 === Number(t) || 0 === Number(p) ? NaN : h[w] + Number(p - t) / 1E9
                        }
                    }
                }
                this._gpuLastUtilisation = e.clamp(h[0], 0, 1);
                if (this._runtime.IsDebug()) {
                    n = [];
                    l = l.GetLayers();
                    for (let w = 0, q = Math.min(l.length, h.length - 1); w < q; ++w) n.push({
                        name: l[w].GetName(),
                        lastUtilisation: e.clamp(h[w + 1], 0, 1)
                    });
                    self.C3Debugger.UpdateGPUProfile(this._gpuLastUtilisation, n)
                }
                for (h = this._gpuTimeStartFrame; h < this._gpuTimeEndFrame; ++h) this._webgpuFrameTimings.delete(h);
                this._gpuTimeStartFrame = this._gpuTimeEndFrame;
                this._gpuTimeEndFrame =
                    0
            }
        }
        _AddWebGPUFrameTiming(h) {
            this._webgpuFrameTimings.set(this._webgpuRenderer.GetFrameNumber(), h)
        }
        GetGPUUtilisation() {
            return this._gpuLastUtilisation
        }
        SnapshotCanvas(h, l, n, u, w, q) {
            this._snapshotFormat = h;
            this._snapshotQuality = l;
            this._snapshotArea.setWH(n, u, w, q);
            return this._snapshotPromise ? this._snapshotPromise : this._snapshotPromise = new Promise(t => {
                this._snapshotResolve = t
            })
        }
        _MaybeTakeSnapshot() {
            if (this._snapshotFormat) {
                var h = this._canvas,
                    l = this._snapshotArea,
                    n = e.clamp(Math.floor(l.getLeft()), 0, h.width),
                    u = e.clamp(Math.floor(l.getTop()), 0, h.height),
                    w = l.width();
                w = 0 === w ? h.width - n : e.clamp(Math.floor(w), 0, h.width - n);
                l = l.height();
                l = 0 === l ? h.height - u : e.clamp(Math.floor(l), 0, h.height - u);
                (0 !== n || 0 !== u || w !== h.width || l !== h.height) && 0 < w && 0 < l && (h = e.CreateCanvas(w, l), h.getContext("2d").drawImage(this._canvas, n, u, w, l, 0, 0, w, l));
                e.CanvasToBlob(h, this._snapshotFormat, this._snapshotQuality).then(q => {
                    this._snapshotUrl = URL.createObjectURL(q);
                    this._snapshotPromise = null;
                    this._snapshotResolve(this._snapshotUrl)
                });
                this._snapshotFormat =
                    "";
                this._snapshotQuality = 1
            }
        }
        GetCanvasSnapshotUrl() {
            return this._snapshotUrl
        }
        SetIsPastingToDrawingCanvas(h) {
            h ? this._isPastingToDrawingCanvas++ : this._isPastingToDrawingCanvas--
        }
        IsPastingToDrawingCanvas() {
            return 0 < this._isPastingToDrawingCanvas
        }
        InitLoadingScreen(h) {
            this._webglRenderer && (2 === h ? (this._percentText = e.New(e.Gfx.RendererText, this.GetRenderer()), this._percentText.SetIsAsync(!1), this._percentText.SetFontName("Arial"), this._percentText.SetFontSize(16), this._percentText.SetHorizontalAlignment("center"),
                this._percentText.SetVerticalAlignment("center"), this._percentText.SetSize(300, 200)) : 0 === h ? (h = this._runtime.GetLoadingLogoAsset()) && h.LoadStaticTexture(this._webglRenderer).catch(l => console.warn("[C3 runtime] Failed to create texture for loading logo: ", l)) : 4 === h && (this._LoadSvgSplashImage("splash-images/splash-logo.svg").then(l => {
                "done" === this._splashState ? this._webglRenderer.DeleteTexture(l) : this._splashTextures.logo = l
            }).catch(l => console.warn("Failed to load splash image: ", l)), this._LoadBitmapSplashImage("splash-images/splash-poweredby-512.png").then(l => {
                "done" === this._splashState ? this._webglRenderer.DeleteTexture(l) : this._splashTextures.powered = l
            }).catch(l => console.warn("Failed to load splash image: ", l)), this._LoadBitmapSplashImage("splash-images/splash-website-512.png").then(l => {
                "done" === this._splashState ? this._webglRenderer.DeleteTexture(l) : this._splashTextures.website = l
            }).catch(l => console.warn("Failed to load splash image: ", l))))
        }
        async _LoadSvgSplashImage(h) {
            h = (new URL(h, this._runtime.GetBaseURL())).toString();
            h = await e.FetchBlob(h);
            h = await this._runtime.RasterSvgImage(h,
                2048, 2048);
            return await this._webglRenderer.CreateStaticTextureAsync(h, {
                mipMapQuality: "high"
            })
        }
        async _LoadBitmapSplashImage(h) {
            h = (new URL(h, this._runtime.GetBaseURL())).toString();
            h = await e.FetchBlob(h);
            return await this._webglRenderer.CreateStaticTextureAsync(h, {
                mipMapQuality: "high"
            })
        }
        HideCordovaSplashScreen() {
            this._runtime.PostComponentMessageToDOM("runtime", "hide-cordova-splash")
        }
        StartLoadingScreen() {
            this._loaderStartTime = Date.now();
            this._runtime.Dispatcher().addEventListener("loadingprogress",
                this._loadingprogress_handler);
            this._rafId = requestAnimationFrame(() => this._DrawLoadingScreen());
            3 !== this._runtime.GetLoaderStyle() && this.HideCordovaSplashScreen()
        }
        async EndLoadingScreen() {
            if (this._webglRenderer) {
                this._loadingProgress = 1;
                var h = this._runtime.GetLoaderStyle();
                4 === h && await this._splashDonePromise;
                this._splashDonePromise = this._splashDoneResolve = null; - 1 !== this._rafId && (cancelAnimationFrame(this._rafId), this._rafId = -1);
                this._runtime.Dispatcher().removeEventListener("loadingprogress", this._loadingprogress_handler);
                this._loadingprogress_handler = null;
                this._percentText && (this._percentText.Release(), this._percentText = null);
                this._runtime.ReleaseLoadingLogoAsset();
                this._webglRenderer.Start();
                this._splashTextures.logo && (this._webglRenderer.DeleteTexture(this._splashTextures.logo), this._splashTextures.logo = null);
                this._splashTextures.powered && (this._webglRenderer.DeleteTexture(this._splashTextures.powered), this._splashTextures.powered = null);
                this._splashTextures.website && (this._webglRenderer.DeleteTexture(this._splashTextures.website),
                    this._splashTextures.website = null);
                this._webglRenderer.ClearRgba(0, 0, 0, 0);
                this._webglRenderer.Finish();
                this._splashState = "done";
                this._gpuTimeStartFrame = this._webglRenderer.GetFrameNumber();
                3 === h && this.HideCordovaSplashScreen()
            }
        }
        _DrawLoadingScreen() {
            if (-1 !== this._rafId) {
                var h = this._webglRenderer;
                if (h) {
                    h.Start();
                    this._rafId = -1;
                    var l = this._runtime.GetAssetManager().HasHadErrorLoading(),
                        n = this._runtime.GetLoaderStyle();
                    3 !== n && (this.SetCssTransform(h), h.ClearRgba(0, 0, 0, 0), h.ResetColor(), h.SetTextureFillMode(),
                        h.SetTexture(null));
                    if (0 === n) this._DrawProgressBarAndLogoLoadingScreen(l);
                    else if (1 === n) this._DrawProgressBarLoadingScreen(l, 120, 0);
                    else if (2 === n) this._DrawPercentTextLoadingScreen(l);
                    else if (3 === n) e.noop();
                    else if (4 === n) this._DrawSplashLoadingScreen(l);
                    else throw Error("invalid loader style");
                    h.Finish();
                    this._rafId = requestAnimationFrame(() => this._DrawLoadingScreen())
                }
            }
        }
        _DrawPercentTextLoadingScreen(h) {
            h ? this._percentText.SetColorRgb(1, 0, 0) : this._percentText.SetColorRgb(.6, .6, .6);
            this._percentText.SetText(Math.round(100 *
                this._loadingProgress) + "%");
            h = this._canvasCssWidth / 2;
            const l = this._canvasCssHeight / 2;
            f.setRect(h - 150, l - 100, h + 150, l + 100);
            this._webglRenderer.SetTexture(this._percentText.GetTexture());
            this._webglRenderer.Quad3(f, this._percentText.GetTexRect())
        }
        _DrawProgressBarLoadingScreen(h, l, n) {
            const u = this._webglRenderer;
            u.SetColorFillMode();
            h ? u.SetColorRgba(1, 0, 0, 1) : u.SetColorRgba(.118, .565, 1, 1);
            h = this._canvasCssWidth / 2;
            const w = this._canvasCssHeight / 2,
                q = l / 2;
            k.setWH(h - q, w - 4 + n, Math.floor(l * this._loadingProgress),
                8);
            u.Rect(k);
            k.setWH(h - q, w - 4 + n, l, 8);
            k.offset(-.5, -.5);
            k.inflate(.5, .5);
            u.SetColorRgba(0, 0, 0, 1);
            u.LineRect2(k);
            k.inflate(1, 1);
            u.SetColorRgba(1, 1, 1, 1);
            u.LineRect2(k)
        }
        _DrawProgressBarAndLogoLoadingScreen(h) {
            var l = this._runtime.GetLoadingLogoAsset();
            if (l)
                if (l = l.GetTexture()) {
                    var n = l.GetWidth(),
                        u = l.GetHeight(),
                        w = this._canvasCssWidth / 2,
                        q = this._canvasCssHeight / 2,
                        t = n / 2;
                    u /= 2;
                    f.setRect(w - t, q - u, w + t, q + u);
                    this._webglRenderer.SetTexture(l);
                    this._webglRenderer.Quad(f);
                    this._DrawProgressBarLoadingScreen(h, n, u + 16)
                } else this._DrawProgressBarLoadingScreen(h,
                    120, 0);
            else this._DrawProgressBarLoadingScreen(h, 120, 0)
        }
        _DrawSplashLoadingScreen(h) {
            const l = this._webglRenderer,
                n = this._splashTextures.logo,
                u = this._splashTextures.powered,
                w = this._splashTextures.website,
                q = Date.now();
            0 === this._splashFrameNumber && (this._loaderStartTime = q);
            const t = this._runtime.IsPreview() || this._runtime.IsFBInstantAvailable() && !this._runtime.IsCordova(),
                p = t ? 0 : 200,
                r = t ? 0 : 3E3;
            let x = 1;
            "fade-in" === this._splashState ? x = Math.min((q - this._loaderStartTime) / 300, 1) : "fade-out" === this._splashState &&
                (x = Math.max(1 - (q - this._splashFadeOutStartTime) / 300, 0));
            l.SetColorFillMode();
            l.SetColorRgba(.231 * x, .251 * x, .271 * x, x);
            k.set(0, 0, this._canvasCssWidth, this._canvasCssHeight);
            l.Rect(k);
            const y = Math.ceil(this._canvasCssWidth),
                E = Math.ceil(this._canvasCssHeight);
            let G;
            256 < this._canvasCssHeight ? (l.SetColorRgba(.302 * x, .334 * x, .365 * x, x), G = Math.max(.005 * E, 2), k.setWH(0, .8 * E - G / 2, y, G), l.Rect(k), h ? l.SetColorRgba(x, 0, 0, x) : l.SetColorRgba(.161 * x, .953 * x, .816 * x, x), h = y * this._loadingProgress, k.setWH(.5 * y - h / 2, .8 * E - G / 2, h, G),
                l.Rect(k), l.SetColorRgba(x, x, x, x), l.SetTextureFillMode(), u && (h = 1.5 * e.clamp(.22 * E, 105, .6 * y), G = h / 8, k.setWH(.5 * y - h / 2, .2 * E - G / 2, h, G), l.SetTexture(u), l.Rect(k)), n && (G = h = Math.min(.395 * E, .95 * y), k.setWH(.5 * y - h / 2, .485 * E - G / 2, h, G), l.SetTexture(n), l.Rect(k)), w && (h = 1.5 * e.clamp(.22 * E, 105, .6 * y), G = h / 8, k.setWH(.5 * y - h / 2, .868 * E - G / 2, h, G), l.SetTexture(w), l.Rect(k))) : (l.SetColorRgba(.302 * x, .334 * x, .365 * x, x), G = Math.max(.005 * E, 2), k.setWH(0, .85 * E - G / 2, y, G), l.Rect(k), h ? l.SetColorRgba(x, 0, 0, x) : l.SetColorRgba(.161 * x, .953 * x, .816 *
                x, x), h = y * this._loadingProgress, k.setWH(.5 * y - h / 2, .85 * E - G / 2, h, G), l.Rect(k), l.SetColorRgba(x, x, x, x), l.SetTextureFillMode(), n && (G = h = .55 * E, k.setWH(.5 * y - h / 2, .45 * E - G / 2, h, G), l.SetTexture(n), l.Rect(k)));
            this._splashFrameNumber++;
            "fade-in" === this._splashState && 300 <= q - this._loaderStartTime && 2 <= this._splashFrameNumber && (this._splashState = "wait", this._splashFadeInFinishTime = q);
            "wait" === this._splashState && q - this._splashFadeInFinishTime >= r && 1 <= this._loadingProgress && (this._splashState = "fade-out", this._splashFadeOutStartTime =
                q);
            ("fade-out" === this._splashState && q - this._splashFadeOutStartTime >= 300 + p || t && 1 <= this._loadingProgress && 500 > q - this._loaderStartTime) && this._splashDoneResolve()
        }
    }
} {
    "use strict";
    const e = self.C3,
        a = self.C3Debugger,
        b = {
            messagePort: null,
            baseUrl: "",
            headless: !1,
            hasDom: !0,
            isInWorker: !1,
            useAudio: !0,
            projectData: "",
            exportType: ""
        };
    let d = !0;
    e.Runtime = class extends e.DefendedBase {
        constructor(c) {
            c = Object.assign({}, b, c);
            super();
            this._messagePort = c.messagePort;
            this._baseUrl = c.baseUrl;
            this._isHeadless = !!c.headless;
            this._hasDom = !!c.hasDom;
            this._isInWorker = !!c.isInWorker;
            d = c.ife;
            this._useAudio = !!c.useAudio;
            this._exportType = c.exportType;
            this._isiOSCordova = !!c.isiOSCordova;
            this._isiOSWebView = !!c.isiOSWebView;
            this._isFBInstantAvailable = !!c.isFBInstantAvailable;
            this._opusWasmScriptUrl = c.opusWasmScriptUrl;
            this._opusWasmBinaryUrl = c.opusWasmBinaryUrl;
            this._isDebugging = this._breakpointsEnabled = this._isDebug = !("preview" !== this._exportType || !c.isDebug);
            this._debuggingDisabled = 0;
            this._additionalLoadPromises = [];
            this._additionalCreatePromises = [];
            this._isUsingCreatePromises = !1;
            this._appId = this._projectUniqueId = this._projectVersion = this._projectName = "";
            this._originalViewportHeight = this._originalViewportWidth =
                0;
            this._devicePixelRatio = self.devicePixelRatio;
            this._loaderStyle = this._viewportHeight = this._viewportWidth = this._parallaxYorigin = this._parallaxXorigin = 0;
            this._usesLoaderLayout = !1;
            this._isLoading = !0;
            this._usesAnyDepthSampling = this._usesAnyBackgroundBlending = !1;
            this._loadingLogoAsset = null;
            this._assetManager = e.New(e.AssetManager, this, c);
            this._layoutManager = e.New(e.LayoutManager, this);
            this._eventSheetManager = e.New(e.EventSheetManager, this);
            this._pluginManager = e.New(e.PluginManager, this);
            this._collisionEngine =
                e.New(e.CollisionEngine, this);
            this._timelineManager = e.New(e.TimelineManager, this);
            this._transitionManager = e.New(e.TransitionManager, this);
            this._allObjectClasses = [];
            this._objectClassesByName = new Map;
            this._objectClassesBySid = new Map;
            this._familyCount = 0;
            this._allContainers = [];
            this._allEffectLists = [];
            this._currentLayoutStack = [];
            this._instancesPendingCreate = [];
            this._instancesPendingDestroy = new Map;
            this._isFlushingPendingInstances = this._hasPendingInstances = !1;
            this._nextUid = this._objectCount = 0;
            this._instancesByUid =
                new Map;
            this._instancesToReleaseAtEndOfTick = new Set;
            this._instancesToReleaseAffectedObjectClasses = new Set;
            this._objectReferenceTable = [];
            this._jsPropNameTable = [];
            this._canvasManager = null;
            this._uses3dFeatures = !1;
            this._framerateMode = "vsync";
            this._compositingMode = "standard";
            this._sampling = "trilinear";
            this._isPixelRoundingEnabled = !1;
            this._needRender = !0;
            this._isPausedOnBlur = this._pauseOnBlur = !1;
            this._tickCallbacks = {
                normal: f => {
                    this._ruafId = this._rafId = -1;
                    this.Tick(f)
                },
                tickOnly: f => {
                    this._ruafId = -1;
                    this.Tick(f,
                        !1, "skip-render")
                },
                renderOnly: () => {
                    this._rafId = -1;
                    this.Render()
                }
            };
            this._ruafId = this._rafId = -1;
            this._execCount = this._tickCountNoSave = this._tickCount = 0;
            this._hasStartedTicking = this._isInTick = this._hasStarted = !1;
            this._isLayoutFirstTick = !0;
            this._suspendCount = 0;
            this._scheduleTriggersThrottle = new e.PromiseThrottle(1);
            this._randomNumberCallback = () => Math.random();
            this._dt = this._dt1 = this._lastTickTime = this._startTime = 0;
            this._timeScale = 1;
            this._minimumFramerate = 30;
            this._gameTime = e.New(e.KahanSum);
            this._gameTimeRaw =
                e.New(e.KahanSum);
            this._wallTime = e.New(e.KahanSum);
            this._fpsFrameCount = -1;
            this._mainThreadTime = this._mainThreadTimeCounter = this._fps = this._fpsLastTime = 0;
            this._isLoadingState = !1;
            this._loadFromSlotName = this._saveToSlotName = "";
            this._loadFromJson = null;
            this._lastSaveJson = "";
            this._savegamesStorage = this._projectStorage = null;
            this._dispatcher = e.New(e.Event.Dispatcher);
            this._domEventHandlers = new Map;
            this._pendingResponsePromises = new Map;
            this._nextDomResponseId = 0;
            this._isReadyToHandleEvents = this._didRequestDeviceMotionEvent =
                this._didRequestDeviceOrientationEvent = !1;
            this._waitingToHandleEvents = [];
            this._eventObjects = {
                pretick: e.New(e.Event, "pretick", !1),
                tick: e.New(e.Event, "tick", !1),
                tick2: e.New(e.Event, "tick2", !1),
                instancedestroy: e.New(e.Event, "instancedestroy", !1),
                beforelayoutchange: e.New(e.Event, "beforelayoutchange", !1),
                layoutchange: e.New(e.Event, "layoutchange", !1)
            };
            this._eventObjects.instancedestroy.instance = null;
            this._userScriptDispatcher = e.New(e.Event.Dispatcher);
            this._userScriptEventObjects = null;
            this._behInstsToTick =
                e.New(e.RedBlackSet, e.BehaviorInstance.SortByTickSequence);
            this._behInstsToPostTick = e.New(e.RedBlackSet, e.BehaviorInstance.SortByTickSequence);
            this._behInstsToTick2 = e.New(e.RedBlackSet, e.BehaviorInstance.SortByTickSequence);
            this._jobScheduler = e.New(e.JobSchedulerRuntime, this, c.jobScheduler);
            c.canvas && (this._canvasManager = e.New(e.CanvasManager, this));
            this._messagePort.onmessage = f => this._OnMessageFromDOM(f.data);
            this.AddDOMComponentMessageHandler("runtime", "visibilitychange", f => this._OnVisibilityChange(f));
            this.AddDOMComponentMessageHandler("runtime", "opus-decode", f => this._WasmDecodeWebMOpus(f.arrayBuffer));
            this.AddDOMComponentMessageHandler("runtime", "get-remote-preview-status-info", () => this._GetRemotePreviewStatusInfo());
            this.AddDOMComponentMessageHandler("runtime", "js-invoke-function", f => this._InvokeFunctionFromJS(f));
            this.AddDOMComponentMessageHandler("runtime", "go-to-last-error-script", self.goToLastErrorScript);
            this._dispatcher.addEventListener("window-blur", f => this._OnWindowBlur(f));
            this._dispatcher.addEventListener("window-focus",
                () => this._OnWindowFocus());
            this._timelineManager.AddRuntimeListeners();
            this._iRuntime = null;
            this._interfaceMap = new WeakMap;
            this._commonScriptInterfaces = {
                keyboard: null,
                mouse: null,
                touch: null
            }
        }
        static Create(c) {
            return e.New(e.Runtime, c)
        }
        Release() {
            e.clearArray(this._allObjectClasses);
            this._objectClassesByName.clear();
            this._objectClassesBySid.clear();
            this._layoutManager.Release();
            this._layoutManager = null;
            this._eventSheetManager.Release();
            this._eventSheetManager = null;
            this._pluginManager.Release();
            this._pluginManager =
                null;
            this._assetManager.Release();
            this._assetManager = null;
            this._collisionEngine.Release();
            this._collisionEngine = null;
            this._timelineManager.Release();
            this._timelineManager = null;
            this._transitionManager.Release();
            this._transitionManager = null;
            this._canvasManager && (this._canvasManager.Release(), this._canvasManager = null);
            this._dispatcher.Release();
            this._tickEvent = this._dispatcher = null
        } ["_OnMessageFromDOM"](c) {
            const f = c.type;
            if ("event" === f) this._OnEventFromDOM(c);
            else if ("result" === f) this._OnResultFromDOM(c);
            else throw Error(`unknown message '${f}'`);
        }
        _OnEventFromDOM(c) {
            if (this._isReadyToHandleEvents) {
                var f = c.component,
                    k = c.handler,
                    h = c.data,
                    l = c.dispatchOpts,
                    n = !(!l || !l.dispatchRuntimeEvent);
                l = !(!l || !l.dispatchUserScriptEvent);
                var u = c.responseId;
                if ("runtime" === f && (n && (c = new e.Event(k), c.data = h, this._dispatcher.dispatchEventAndWaitAsyncSequential(c)), l)) {
                    c = new e.Event(k, !0);
                    for (const [w, q] of Object.entries(h)) c[w] = q;
                    this.DispatchUserScriptEvent(c)
                }
                if (c = this._domEventHandlers.get(f))
                    if (c = c.get(k)) {
                        n = null;
                        try {
                            n = c(h)
                        } catch (w) {
                            console.error(`Exception in '${f}' handler '${k}':`, w);
                            null !== u && this._PostResultToDOM(u, !1, "" + w);
                            return
                        }
                        null !== u && (n && n.then ? n.then(w => this._PostResultToDOM(u, !0, w)).catch(w => {
                            console.error(`Rejection from '${f}' handler '${k}':`, w);
                            this._PostResultToDOM(u, !1, "" + w)
                        }) : this._PostResultToDOM(u, !0, n))
                    } else n || l || console.warn(`[Runtime] No DOM handler '${k}' for component '${f}'`);
                else n || l || console.warn(`[Runtime] No DOM event handlers for component '${f}'`)
            } else this._waitingToHandleEvents.push(c)
        }
        _PostResultToDOM(c,
            f, k) {
            this._messagePort.postMessage({
                type: "result",
                responseId: c,
                isOk: f,
                result: k
            })
        }
        _OnResultFromDOM(c) {
            const f = c.responseId,
                k = c.isOk;
            c = c.result;
            const h = this._pendingResponsePromises.get(f);
            k ? h.resolve(c) : h.reject(c);
            this._pendingResponsePromises.delete(f)
        }
        AddDOMComponentMessageHandler(c, f, k) {
            let h = this._domEventHandlers.get(c);
            h || (h = new Map, this._domEventHandlers.set(c, h));
            if (h.has(f)) throw Error(`[Runtime] Component '${c}' already has handler '${f}'`);
            h.set(f, k)
        }
        PostComponentMessageToDOM(c, f, k) {
            this._messagePort.postMessage({
                type: "event",
                component: c,
                handler: f,
                data: k,
                responseId: null
            })
        }
        PostComponentMessageToDOMAsync(c, f, k) {
            const h = this._nextDomResponseId++,
                l = new Promise((n, u) => {
                    this._pendingResponsePromises.set(h, {
                        resolve: n,
                        reject: u
                    })
                });
            this._messagePort.postMessage({
                type: "event",
                component: c,
                handler: f,
                data: k,
                responseId: h
            });
            return l
        }
        PostToDebugger(c) {
            if (!this.IsDebug()) throw Error("not in debug mode");
            this.PostComponentMessageToDOM("runtime", "post-to-debugger", c)
        }
        async Init(c) {
            this.IsDebug() ? await a.Init(this) : self.C3Debugger && self.C3Debugger.InitPreview(this);
            var [f] = await Promise.all([this._assetManager.FetchJson("data.json"), this._MaybeLoadOpusDecoder(), this._jobScheduler.Init()]);
            this._LoadDataJson(f);
            await this._InitialiseCanvas(c);
            this.IsPreview() || console.info("Made with Construct 3, the game and app creator :: https://www.construct.net");
            this.GetWebGLRenderer() ? (f = this.GetWebGLRenderer(), console.info(`[C3 runtime] Hosted in ${this.IsInWorker()?"worker":"DOM"}, rendering with WebGL ${f.GetWebGLVersionNumber()} [${f.GetUnmaskedRenderer()}] (${f.IsDesynchronized()?
"desynchronized":"standard"} compositing)`)) : this.GetWebGPURenderer() && console.info(`[C3 runtime] Hosted in ${this.IsInWorker()?"worker":"DOM"}, rendering with experimental WebGPU`);
            this.GetRenderer().HasMajorPerformanceCaveat() && console.warn("[C3 runtime] The renderer indicates a major performance caveat. Software rendering may be in use. This can result in significantly degraded performance.");
            this._isReadyToHandleEvents = !0;
            for (const k of this._waitingToHandleEvents) this._OnEventFromDOM(k);
            e.clearArray(this._waitingToHandleEvents);
            this._canvasManager && this._canvasManager.StartLoadingScreen();
            for (const k of c.runOnStartupFunctions) this._additionalLoadPromises.push(this._RunOnStartupFunction(k));
            await Promise.all([this._assetManager.WaitForAllToLoad(), ...this._additionalLoadPromises]);
            e.clearArray(this._additionalLoadPromises);
            if (this._assetManager.HasHadErrorLoading()) this._canvasManager && this._canvasManager.HideCordovaSplashScreen();
            else return this._canvasManager && await this._canvasManager.EndLoadingScreen(), await this._dispatcher.dispatchEventAndWaitAsync(new e.Event("beforeruntimestart")),
                await this.Start(), this._messagePort.postMessage({
                    type: "runtime-ready"
                }), this
        }
        async _RunOnStartupFunction(c) {
            try {
                await c(this._iRuntime)
            } catch (f) {
                console.error("[C3 runtime] Error in runOnStartup function: ", f)
            }
        }
        _LoadDataJson(c) {
            c = c.project;
            this._projectName = c[0];
            this._projectVersion = c[16];
            this._projectUniqueId = c[31];
            this._appId = c[38];
            const f = c[39] || "loading-logo.png";
            this._isPixelRoundingEnabled = !!c[9];
            this._originalViewportWidth = this._viewportWidth = c[10];
            this._originalViewportHeight = this._viewportHeight =
                c[11];
            this._parallaxXorigin = this._originalViewportWidth / 2;
            this._parallaxYorigin = this._originalViewportHeight / 2;
            this._compositingMode = c[36];
            this._framerateMode = c[37];
            "low-latency" === this._compositingMode && this.IsAndroidWebView() && 77 >= e.Platform.BrowserVersionNumber && (console.warn("[C3 runtime] Desynchronized (low-latency) compositing is enabled, but is disabled in the Android WebView <=77 due to crbug.com/1008842. Reverting to synchronized (standard) compositing."), this._compositingMode = "standard");
            this._uses3dFeatures = !!c[40];
            this._sampling = c[14];
            this._usesAnyBackgroundBlending = c[15];
            this._usesAnyDepthSampling = c[17];
            this._usesLoaderLayout = !!c[18];
            this._loaderStyle = c[19];
            this._nextUid = c[21];
            this._pauseOnBlur = c[22];
            const k = this._assetManager;
            k._SetAudioFiles(c[7], c[25]);
            k._SetMediaSubfolder(c[8]);
            k._SetFontsSubfolder(c[32]);
            k._SetIconsSubfolder(c[28]);
            k._SetWebFonts(c[29]);
            if (0 === this._loaderStyle) {
                let w = "";
                this.IsPreview() ? k._HasLocalUrlBlob(f) && (w = k.GetLocalUrlAsBlobUrl(f)) : w = k.GetIconsSubfolder() +
                    f;
                w && (this._loadingLogoAsset = k.LoadImage({
                    url: w
                }))
            }
            this._canvasManager && (this._canvasManager.SetFullscreenMode(e.CanvasManager._FullscreenModeNumberToString(c[12])), this._canvasManager.SetFullscreenScalingQuality(c[23] ? "high" : "low"), this._canvasManager.SetMipmapsEnabled(0 !== c[24]), this._canvasManager._SetGPUPowerPreference(c[34]), this._canvasManager._SetTextureAnisotropy(c[41]), this._canvasManager._SetWebGPUEnabled(c[13]));
            this._pluginManager.CreateSystemPlugin();
            this._objectReferenceTable = self.C3_GetObjectRefTable();
            for (var h of c[2]) this._pluginManager.CreatePlugin(h);
            this._objectReferenceTable = self.C3_GetObjectRefTable();
            this._LoadJsPropNameTable();
            for (var l of c[3]) h = e.ObjectClass.Create(this, this._allObjectClasses.length, l), this._allObjectClasses.push(h), this._objectClassesByName.set(h.GetName().toLowerCase(), h), this._objectClassesBySid.set(h.GetSID(), h);
            for (const w of c[4]) this._allObjectClasses[w[0]]._LoadFamily(w);
            for (var n of c[27]) l = n.map(w => this._allObjectClasses[w]), this._allContainers.push(e.New(e.Container,
                this, l));
            for (const w of this._allObjectClasses) w._OnAfterCreate();
            for (const w of c[5]) this._layoutManager.Create(w);
            (n = c[1]) && (n = this._layoutManager.GetLayoutByName(n)) && this._layoutManager.SetFirstLayout(n);
            for (var u of c[33]) this._timelineManager.Create(u);
            for (const w of c[35]) this._transitionManager.Create(w);
            this._InitScriptInterfaces();
            for (const w of c[6]) this._eventSheetManager.Create(w);
            this._eventSheetManager._PostInit();
            this._InitGlobalVariableScriptInterface();
            e.clearArray(this._objectReferenceTable);
            this.FlushPendingInstances();
            u = "any";
            c = c[20];
            1 === c ? u = "portrait" : 2 === c && (u = "landscape");
            this.PostComponentMessageToDOM("runtime", "set-target-orientation", {
                targetOrientation: u
            })
        }
        GetLoaderStyle() {
            return this._loaderStyle
        }
        IsFBInstantAvailable() {
            return this._isFBInstantAvailable
        }
        IsLoading() {
            return this._isLoading
        }
        AddLoadPromise(c) {
            this._additionalLoadPromises.push(c)
        }
        SetUsingCreatePromises(c) {
            this._isUsingCreatePromises = !!c
        }
        AddCreatePromise(c) {
            this._isUsingCreatePromises && this._additionalCreatePromises.push(c)
        }
        GetCreatePromises() {
            return this._additionalCreatePromises
        }
        _GetNextFamilyIndex() {
            return this._familyCount++
        }
        GetFamilyCount() {
            return this._familyCount
        }
        _AddEffectList(c) {
            this._allEffectLists.push(c)
        }
        _GetAllEffectLists() {
            return this._allEffectLists
        }
        async _InitialiseCanvas(c) {
            this._canvasManager &&
                (await this._canvasManager.CreateCanvas(c), this._canvasManager.InitLoadingScreen(this._loaderStyle))
        }
        async _MaybeLoadOpusDecoder() {
            if (!this._assetManager.IsAudioFormatSupported("audio/webm; codecs=opus")) {
                var c = null;
                try {
                    c = this.IsiOSCordova() && this._assetManager.IsFileProtocol() ? await this._assetManager.CordovaFetchLocalFileAsArrayBuffer(this._opusWasmBinaryUrl) : await this._assetManager.FetchArrayBuffer(this._opusWasmBinaryUrl)
                } catch (f) {
                    console.info("Failed to fetch Opus decoder WASM; assuming project has no Opus audio.",
                        f);
                    return
                }
                c ? this.AddJobWorkerBuffer(c, "opus-decoder-wasm") : this.AddJobWorkerBlob(null, "opus-decoder-wasm");
                await this.AddJobWorkerScripts([this._opusWasmScriptUrl])
            }
        }
        async _WasmDecodeWebMOpus(c) {
            return await this.AddJob("OpusDecode", {
                arrayBuffer: c
            }, [c])
        }
        async Start() {
            this._hasStarted = !0;
            this._startTime = Date.now();
            if (this._usesLoaderLayout) {
                for (var c of this._allObjectClasses) c.IsFamily() || c.IsOnLoaderLayout() || !c.IsWorldType() || c.OnCreate();
                this._assetManager.WaitForAllToLoad().then(() => {
                    this._isLoading = !1;
                    this._OnLoadFinished()
                })
            } else this._isLoading = !1;
            this._assetManager.SetInitialLoadFinished();
            this.IsDebug() && a.RuntimeInit(d);
            for (const f of this._layoutManager.GetAllLayouts()) f._CreateGlobalNonWorlds();
            c = this._layoutManager.GetFirstLayout();
            await c._Load(null, this.GetRenderer());
            await c._StartRunning(!0);
            this._fpsLastTime = performance.now();
            this._usesLoaderLayout || this._OnLoadFinished();
            (await this.PostComponentMessageToDOMAsync("runtime", "before-start-ticking")).isSuspended ? this._suspendCount++ :
                this.Tick()
        }
        _OnLoadFinished() {
            this.Trigger(e.Plugins.System.Cnds.OnLoadFinished, null, null);
            this.PostComponentMessageToDOM("runtime", "register-sw")
        }
        GetObjectReference(c) {
            c = Math.floor(c);
            const f = this._objectReferenceTable;
            if (0 > c || c >= f.length) throw Error("invalid object reference");
            return f[c]
        }
        _LoadJsPropNameTable() {
            for (const c of self.C3_JsPropNameTable) {
                const f = e.first(Object.keys(c));
                this._jsPropNameTable.push(f)
            }
        }
        GetJsPropName(c) {
            c = Math.floor(c);
            const f = this._jsPropNameTable;
            if (0 > c || c >= f.length) throw Error("invalid prop reference");
            return f[c]
        }
        HasDOM() {
            return this._hasDom
        }
        IsHeadless() {
            return this._isHeadless
        }
        IsInWorker() {
            return this._isInWorker
        }
        GetBaseURL() {
            return this._baseUrl
        }
        GetEventSheetManager() {
            return this._eventSheetManager
        }
        GetEventStack() {
            return this._eventSheetManager.GetEventStack()
        }
        GetCurrentEventStackFrame() {
            return this._eventSheetManager.GetCurrentEventStackFrame()
        }
        GetCurrentEvent() {
            return this._eventSheetManager.GetCurrentEvent()
        }
        GetCurrentCondition() {
            return this._eventSheetManager.GetCurrentCondition()
        }
        IsCurrentConditionFirst() {
            return 0 ===
                this.GetCurrentEventStackFrame().GetConditionIndex()
        }
        GetCurrentAction() {
            return this._eventSheetManager.GetCurrentAction()
        }
        GetPluginManager() {
            return this._pluginManager
        }
        GetSystemPlugin() {
            return this._pluginManager.GetSystemPlugin()
        }
        GetObjectClassByIndex(c) {
            c = Math.floor(c);
            if (0 > c || c >= this._allObjectClasses.length) throw new RangeError("invalid index");
            return this._allObjectClasses[c]
        }
        GetObjectClassByName(c) {
            return this._objectClassesByName.get(c.toLowerCase()) || null
        }
        GetObjectClassBySID(c) {
            return this._objectClassesBySid.get(c) ||
                null
        }
        GetSingleGlobalObjectClassByCtor(c) {
            return (c = this._pluginManager.GetPluginByConstructorFunction(c)) ? c.GetSingleGlobalObjectClass() : null
        }
        GetAllObjectClasses() {
            return this._allObjectClasses
        }* allInstances() {
            for (const c of this._allObjectClasses) c.IsFamily() || (yield* c.instances())
        }
        Dispatcher() {
            return this._dispatcher
        }
        UserScriptDispatcher() {
            return this._userScriptDispatcher
        }
        DispatchUserScriptEvent(c) {
            c.runtime = this.GetIRuntime();
            const f = this.IsDebug() && !this._eventSheetManager.IsInEventEngine();
            f &&
                a.StartMeasuringScriptTime();
            this._userScriptDispatcher.dispatchEvent(c);
            f && a.AddScriptTime()
        }
        DispatchUserScriptEventAsyncWait(c) {
            c.runtime = this.GetIRuntime();
            return this._userScriptDispatcher.dispatchEventAndWaitAsync(c)
        }
        GetOriginalViewportWidth() {
            return this._originalViewportWidth
        }
        GetOriginalViewportHeight() {
            return this._originalViewportHeight
        }
        SetOriginalViewportSize(c, f) {
            if (this._originalViewportWidth !== c || this._originalViewportHeight !== f) this._originalViewportWidth = c, this._originalViewportHeight =
                f, c = this.GetLayoutManager(), c.SetAllLayerProjectionChanged(), c.SetAllLayerMVChanged()
        }
        GetViewportWidth() {
            return this._viewportWidth
        }
        GetViewportHeight() {
            return this._viewportHeight
        }
        SetViewportSize(c, f) {
            if (this._viewportWidth !== c || this._viewportHeight !== f) this._viewportWidth = c, this._viewportHeight = f, c = this.GetLayoutManager(), c.SetAllLayerProjectionChanged(), c.SetAllLayerMVChanged()
        }
        _SetDevicePixelRatio(c) {
            this._devicePixelRatio = c
        }
        GetDevicePixelRatio() {
            return this._devicePixelRatio
        }
        GetParallaxXOrigin() {
            return this._parallaxXorigin
        }
        GetParallaxYOrigin() {
            return this._parallaxYorigin
        }
        GetCanvasManager() {
            return this._canvasManager
        }
        GetDrawWidth() {
            return this._canvasManager ?
                this._canvasManager.GetDrawWidth() : this._viewportWidth
        }
        GetDrawHeight() {
            return this._canvasManager ? this._canvasManager.GetDrawHeight() : this._viewportHeight
        }
        GetRenderScale() {
            return this._canvasManager ? this._canvasManager.GetRenderScale() : 1
        }
        GetDisplayScale() {
            return this._canvasManager ? this._canvasManager.GetDisplayScale() : 1
        }
        GetEffectLayerScaleParam() {
            return this._canvasManager ? this._canvasManager.GetEffectLayerScaleParam() : 1
        }
        GetEffectDevicePixelRatioParam() {
            return this._canvasManager ? this._canvasManager.GetEffectDevicePixelRatioParam() :
                1
        }
        GetCanvasClientX() {
            return this._canvasManager ? this._canvasManager.GetCanvasClientX() : 0
        }
        GetCanvasClientY() {
            return this._canvasManager ? this._canvasManager.GetCanvasClientY() : 0
        }
        GetCanvasCssWidth() {
            return this._canvasManager ? this._canvasManager.GetCssWidth() : 0
        }
        GetCanvasCssHeight() {
            return this._canvasManager ? this._canvasManager.GetCssHeight() : 0
        }
        GetFullscreenMode() {
            return this._canvasManager ? this._canvasManager.GetFullscreenMode() : "off"
        }
        GetAdditionalRenderTarget(c) {
            return this._canvasManager ? this._canvasManager.GetAdditionalRenderTarget(c) :
                null
        }
        ReleaseAdditionalRenderTarget(c) {
            this._canvasManager && this._canvasManager.ReleaseAdditionalRenderTarget(c)
        }
        UsesAnyBackgroundBlending() {
            return this._usesAnyBackgroundBlending
        }
        UsesAnyDepthSampling() {
            return this._usesAnyDepthSampling
        }
        GetGPUUtilisation() {
            return this._canvasManager ? this._canvasManager.GetGPUUtilisation() : NaN
        }
        IsLinearSampling() {
            return "nearest" !== this.GetSampling()
        }
        GetFramerateMode() {
            return this._framerateMode
        }
        GetCompositingMode() {
            return this._compositingMode
        }
        GetSampling() {
            return this._sampling
        }
        UsesLoaderLayout() {
            return this._usesLoaderLayout
        }
        GetLoadingLogoAsset() {
            return this._loadingLogoAsset
        }
        ReleaseLoadingLogoAsset() {
            this._loadingLogoAsset &&
                (this._loadingLogoAsset.Release(), this._loadingLogoAsset = null)
        }
        GetLayoutManager() {
            return this._layoutManager
        }
        GetMainRunningLayout() {
            return this._layoutManager.GetMainRunningLayout()
        }
        GetTimelineManager() {
            return this._timelineManager
        }
        GetTransitionManager() {
            return this._transitionManager
        }
        GetAssetManager() {
            return this._assetManager
        }
        LoadImage(c) {
            return this._assetManager.LoadImage(c)
        }
        CreateInstance(c, f, k, h, l) {
            return this.CreateInstanceFromData(c, f, !1, k, h, !1, l, void 0, l)
        }
        CreateInstanceFromData(c, f, k, h, l,
            n, u, w, q) {
            var t = null;
            let p = null;
            if (c instanceof e.ObjectClass) {
                p = c;
                if (p.IsFamily()) {
                    c = p.GetFamilyMembers();
                    var r = Math.floor(this.Random() * c.length);
                    p = c[r]
                }
                t = p.GetDefaultInstanceData()
            } else t = c, p = this.GetObjectClassByIndex(t[1]);
            var x = p.GetPlugin().IsWorldType();
            if (this._isLoading && x && !p.IsOnLoaderLayout()) return null;
            const y = f;
            x || (f = null);
            var E = k && !n && t && !this._instancesByUid.has(t[2]) ? t[2] : this._nextUid++;
            r = t ? t[0] : null;
            c = e.New(e.Instance, {
                runtime: this,
                objectType: p,
                layer: f,
                worldData: r,
                instVarData: t ?
                    t[3] : null,
                uid: E
            });
            this._instancesByUid.set(E, c);
            E = null;
            x && (E = c.GetWorldInfo(), "undefined" !== typeof h && "undefined" !== typeof l && (E.SetX(h), E.SetY(l)), p._SetAnyCollisionCellChanged(!0));
            f && (q || f._AddInstance(c, !0), 1 === f.GetParallaxX() && 1 === f.GetParallaxY() || p._SetAnyInstanceParallaxed(!0), f.GetLayout().MaybeLoadTexturesFor(p));
            this._objectCount++;
            let G = !0;
            if (w) {
                var A = w.GetObjectClass();
                A.IsInContainer() && p.IsInContainer() && (w = p.GetContainer(), A = A.GetContainer(), w === A && (G = !1))
            }
            if (p.IsInContainer() && !k &&
                !n && G) {
                for (var F of p.GetContainer().objectTypes()) F !== p && (w = this.CreateInstanceFromData(F, y, !1, E ? E.GetX() : h, E ? E.GetY() : l, !0, !1, void 0, q), c._AddSibling(w));
                for (var J of c.siblings()) {
                    J._AddSibling(c);
                    for (const B of c.siblings()) J !== B && J._AddSibling(B)
                }
            }
            x && !k && u && this._CreateChildInstancesFromData(c, r, E, f, h, l, q);
            if (p.IsInContainer() && !k && !n && u)
                for (const B of c.siblings())
                    if (k = B.GetWorldInfo()) F = B.GetPlugin(), J = B.GetObjectClass().GetDefaultInstanceData()[0], F.IsWorldType() ? this._CreateChildInstancesFromData(B,
                        J, k, f, k.GetX(), k.GetY(), q) : this._CreateChildInstancesFromData(B, J, k, f, void 0, void 0, q);
            !n && u && ("undefined" === typeof h && (h = r[0]), "undefined" === typeof l && (l = r[1]), f = E.GetTopParent(), h = h - E.GetX() + f.GetX(), l = l - E.GetY() + f.GetY(), f.SetXY(h, l));
            p._SetIIDsStale();
            l = t ? e.cloneArray(t[5]) : null;
            t = t ? t[4].map(B => e.cloneArray(B)) : null;
            (x = x && r && r[13]) && c._SetHasTilemap();
            c._CreateSdkInstance(l, t);
            x && (r = r[13], c.GetSdkInstance().LoadTilemapData(r[2], r[0], r[1]));
            this._instancesPendingCreate.push(c);
            this._hasPendingInstances = !0;
            this.IsDebug() && a.InstanceCreated(c);
            return c
        }
        _CreateChildInstancesFromData(c, f, k, h, l, n, u) {
            var w = k.GetSceneGraphZIndexExportData(),
                q = k.GetSceneGraphChildrenExportData();
            c.GetWorldInfo().SetSceneGraphZIndex(w);
            if (q) {
                "undefined" === typeof l && (l = f[0]);
                "undefined" === typeof n && (n = f[1]);
                w = new Set;
                k = f[0];
                f = f[1];
                for (const y of q) {
                    var t = y[1],
                        p = y[2];
                    q = y[3];
                    var r = !!y[4];
                    const E = y[5];
                    p = this._layoutManager.GetLayoutBySID(y[0]).GetLayer(t).GetInitialInstanceData(p);
                    t = this.GetObjectClassByIndex(p[1]);
                    var x = c.HasSibling(t);
                    const G = w.has(t);
                    x && !G && r ? (r = c.GetSibling(t), x = l + p[0][0] - k, p = n + p[0][1] - f, r.GetWorldInfo().SetXY(x, p), r.GetWorldInfo().SetSceneGraphZIndex(E), c.AddChild(r, {
                        transformX: !!(q >> 0 & 1),
                        transformY: !!(q >> 1 & 1),
                        transformWidth: !!(q >> 2 & 1),
                        transformHeight: !!(q >> 3 & 1),
                        transformAngle: !!(q >> 4 & 1),
                        destroyWithParent: !!(q >> 5 & 1),
                        transformZElevation: !!(q >> 6 & 1)
                    }), w.add(t)) : (t = this.CreateInstanceFromData(p, h, !1, l + p[0][0] - k, n + p[0][1] - f, !1, !0, c, u), t.GetWorldInfo().SetSceneGraphZIndex(E), c.AddChild(t, {
                        transformX: !!(q >> 0 & 1),
                        transformY: !!(q >>
                            1 & 1),
                        transformWidth: !!(q >> 2 & 1),
                        transformHeight: !!(q >> 3 & 1),
                        transformAngle: !!(q >> 4 & 1),
                        destroyWithParent: !!(q >> 5 & 1),
                        transformZElevation: !!(q >> 6 & 1)
                    }))
                }
            }
        }
        DestroyInstance(c) {
            if (!this._instancesToReleaseAtEndOfTick.has(c)) {
                var f = c.GetObjectClass(),
                    k = this._instancesPendingDestroy.get(f);
                if (k) {
                    if (k.has(c)) return;
                    k.add(c)
                } else k = new Set, k.add(c), this._instancesPendingDestroy.set(f, k);
                this.IsDebug() && a.InstanceDestroyed(c);
                c._MarkDestroyed();
                this._hasPendingInstances = !0;
                if (c.IsInContainer())
                    for (const h of c.siblings()) this.DestroyInstance(h);
                for (const h of c.children()) h.GetDestroyWithParent() && this.DestroyInstance(h);
                this._layoutManager.IsEndingLayout() || this._isLoadingState || (f = this.GetEventSheetManager(), f.BlockFlushingInstances(!0), c._TriggerOnDestroyed(), f.BlockFlushingInstances(!1));
                c._FireDestroyedScriptEvents(this._layoutManager.IsEndingLayout())
            }
        }
        FlushPendingInstances() {
            this._hasPendingInstances && (this._isFlushingPendingInstances = !0, this._FlushInstancesPendingCreate(), this._FlushInstancesPendingDestroy(), this._hasPendingInstances =
                this._isFlushingPendingInstances = !1, this.UpdateRender())
        }
        _FlushInstancesPendingCreate() {
            for (const c of this._instancesPendingCreate) {
                const f = c.GetObjectClass();
                f._AddInstance(c);
                for (const k of f.GetFamilies()) k._AddInstance(c), k._SetIIDsStale()
            }
            e.clearArray(this._instancesPendingCreate)
        }
        _FlushInstancesPendingDestroy() {
            this._dispatcher.SetDelayRemoveEventsEnabled(!0);
            for (const [c, f] of this._instancesPendingDestroy.entries()) this._FlushInstancesPendingDestroyForObjectClass(c, f), f.clear();
            this._instancesPendingDestroy.clear();
            this._dispatcher.SetDelayRemoveEventsEnabled(!1)
        }
        _FlushInstancesPendingDestroyForObjectClass(c, f) {
            for (const h of f) {
                var k = this._eventObjects.instancedestroy;
                k.instance = h;
                this._dispatcher.dispatchEvent(k);
                this._instancesByUid.delete(h.GetUID());
                if (k = h.GetWorldInfo()) k._RemoveFromCollisionCells(), k._RemoveFromRenderCells(), k._MarkDestroyed();
                this._instancesToReleaseAtEndOfTick.add(h);
                this._objectCount--
            }
            e.arrayRemoveAllInSet(c.GetInstances(), f);
            c._SetIIDsStale();
            this._instancesToReleaseAffectedObjectClasses.add(c);
            0 === c.GetInstances().length && c._SetAnyInstanceParallaxed(!1);
            for (const h of c.GetFamilies()) e.arrayRemoveAllInSet(h.GetInstances(), f), h._SetIIDsStale(), this._instancesToReleaseAffectedObjectClasses.add(h);
            if (c.GetPlugin().IsWorldType()) {
                c = new Set([...f].map(h => h.GetWorldInfo().GetLayer()));
                for (const h of c) h._RemoveAllInstancesInSet(f)
            }
        }
        _GetInstancesPendingCreate() {
            return this._instancesPendingCreate
        }* instancesPendingCreateForObjectClass(c) {
            for (const f of this._GetInstancesPendingCreate()) c.IsFamily() ?
                f.GetObjectClass().BelongsToFamily(c) && (yield f) : f.GetObjectClass() === c && (yield f)
        }
        _GetNewUID() {
            return this._nextUid++
        }
        _MapInstanceByUID(c, f) {
            this._instancesByUid.set(c, f)
        }
        _OnWebGLContextLost() {
            this._dispatcher.dispatchEvent(e.New(e.Event, "webglcontextlost"));
            this.SetSuspended(!0);
            for (var c of this._allObjectClasses) !c.IsFamily() && c.HasLoadedTextures() && c.ReleaseTextures();
            (c = this.GetMainRunningLayout()) && c._OnWebGLContextLost();
            e.ImageInfo.OnWebGLContextLost();
            e.ImageAsset.OnWebGLContextLost()
        }
        async _OnWebGLContextRestored() {
            await this.GetMainRunningLayout()._Load(null,
                this.GetWebGLRenderer());
            this._dispatcher.dispatchEvent(e.New(e.Event, "webglcontextrestored"));
            this.SetSuspended(!1);
            this.UpdateRender()
        }
        _OnVisibilityChange(c) {
            this.SetSuspended(c.hidden)
        }
        _OnWindowBlur(c) {
            this.IsPreview() && this._pauseOnBlur && !e.Platform.IsMobile && !c.data.parentHasFocus && (this.SetSuspended(!0), this._isPausedOnBlur = !0)
        }
        _OnWindowFocus() {
            this._isPausedOnBlur && (this.SetSuspended(!1), this._isPausedOnBlur = !1)
        }
        _RequestAnimationFrame() {
            const c = this._tickCallbacks;
            "vsync" === this._framerateMode ?
                -1 === this._rafId && (this._rafId = self.requestAnimationFrame(c.normal)) : "unlimited-tick" === this._framerateMode ? (-1 === this._ruafId && (this._ruafId = e.RequestUnlimitedAnimationFrame(c.tickOnly)), -1 === this._rafId && (this._rafId = self.requestAnimationFrame(c.renderOnly))) : -1 === this._ruafId && (this._ruafId = e.RequestUnlimitedAnimationFrame(c.normal))
        }
        _CancelAnimationFrame() {
            -1 !== this._rafId && (self.cancelAnimationFrame(this._rafId), this._rafId = -1); - 1 !== this._ruafId && (e.CancelUnlimitedAnimationFrame(this._ruafId),
                this._ruafId = -1)
        }
        IsSuspended() {
            return 0 < this._suspendCount
        }
        SetSuspended(c) {
            var f = this.IsSuspended();
            this._suspendCount += c ? 1 : -1;
            0 > this._suspendCount && (this._suspendCount = 0);
            c = this.IsSuspended();
            !f && c ? (console.log("[Construct 3] Suspending"), this._CancelAnimationFrame(), this._dispatcher.dispatchEvent(e.New(e.Event, "suspend")), this.Trigger(e.Plugins.System.Cnds.OnSuspend, null, null)) : f && !c && (console.log("[Construct 3] Resuming"), this._fpsLastTime = this._lastTickTime = f = performance.now(), this._mainThreadTimeCounter =
                this._mainThreadTime = this._fps = this._fpsFrameCount = 0, this._dispatcher.dispatchEvent(e.New(e.Event, "resume")), this.Trigger(e.Plugins.System.Cnds.OnResume, null, null), this.HitBreakpoint() || this.Tick(f))
        }
        _AddBehInstToTick(c) {
            this._behInstsToTick.Add(c)
        }
        _AddBehInstToPostTick(c) {
            this._behInstsToPostTick.Add(c)
        }
        _AddBehInstToTick2(c) {
            this._behInstsToTick2.Add(c)
        }
        _RemoveBehInstToTick(c) {
            this._behInstsToTick.Remove(c)
        }
        _RemoveBehInstToPostTick(c) {
            this._behInstsToPostTick.Remove(c)
        }
        _RemoveBehInstToTick2(c) {
            this._behInstsToTick2.Remove(c)
        }
        _BehaviorTick() {
            this._behInstsToTick.SetQueueingEnabled(!0);
            for (const c of this._behInstsToTick) c.Tick();
            this._behInstsToTick.SetQueueingEnabled(!1)
        }
        _BehaviorPostTick() {
            this._behInstsToPostTick.SetQueueingEnabled(!0);
            for (const c of this._behInstsToPostTick) c.PostTick();
            this._behInstsToPostTick.SetQueueingEnabled(!1)
        }
        _BehaviorTick2() {
            this._behInstsToTick2.SetQueueingEnabled(!0);
            for (const c of this._behInstsToTick2) c.Tick2();
            this._behInstsToTick2.SetQueueingEnabled(!1)
        }* _DebugBehaviorTick() {
            this._behInstsToTick.SetQueueingEnabled(!0);
            for (const c of this._behInstsToTick) {
                const f =
                    c.Tick();
                e.IsIterator(f) && (yield* f)
            }
            this._behInstsToTick.SetQueueingEnabled(!1)
        }* _DebugBehaviorPostTick() {
            this._behInstsToPostTick.SetQueueingEnabled(!0);
            for (const c of this._behInstsToPostTick) {
                const f = c.PostTick();
                e.IsIterator(f) && (yield* f)
            }
            this._behInstsToPostTick.SetQueueingEnabled(!1)
        }* _DebugBehaviorTick2() {
            this._behInstsToTick2.SetQueueingEnabled(!0);
            for (const c of this._behInstsToTick2) {
                const f = c.Tick2();
                e.IsIterator(f) && (yield* f)
            }
            this._behInstsToTick2.SetQueueingEnabled(!1)
        }
        async Tick(c, f,
            k) {
            this._hasStartedTicking = !0;
            const h = "background-wake" === k;
            k = "background-wake" !== k && "skip-render" !== k;
            this._hasStarted && (!this.IsSuspended() || f || h) && (f = performance.now(), this._isInTick = !0, this._MeasureDt(c || 0), c = this.Step_BeforePreTick(), this.IsDebugging() && await c, c = this._dispatcher.dispatchEventAndWait_AsyncOptional(this._eventObjects.pretick), c instanceof Promise && await c, c = this.Step_AfterPreTick(), this.IsDebugging() && await c, this._NeedsHandleSaveOrLoad() && await this._HandleSaveOrLoad(), this.GetLayoutManager().IsPendingChangeMainLayout() &&
                await this._MaybeChangeLayout(), c = this.Step_RunEventsEtc(), this.IsDebugging() && await c, k && this.Render(), this.IsSuspended() || h || this._RequestAnimationFrame(), this._tickCount++, this._tickCountNoSave++, this._execCount++, this._isInTick = !1, this._mainThreadTimeCounter += performance.now() - f)
        }
        async Step_BeforePreTick() {
            const c = this._eventSheetManager,
                f = this.IsDebug();
            this.FlushPendingInstances();
            c.BlockFlushingInstances(!0);
            this.PushCurrentLayout(this.GetMainRunningLayout());
            f && a.StartMeasuringTime();
            this.IsDebugging() ?
                await c.DebugRunScheduledWaits() : c.RunScheduledWaits();
            f && a.AddEventsTime();
            this.PopCurrentLayout();
            c.BlockFlushingInstances(!1);
            this.FlushPendingInstances();
            c.BlockFlushingInstances(!0)
        }
        async Step_AfterPreTick() {
            const c = this.IsDebug(),
                f = this.IsDebugging(),
                k = this._dispatcher,
                h = this._eventObjects,
                l = this._userScriptEventObjects;
            c && a.StartMeasuringTime();
            f ? await this.DebugIterateAndBreak(this._DebugBehaviorTick()) : this._BehaviorTick();
            f ? await this.DebugIterateAndBreak(this._DebugBehaviorPostTick()) :
                this._BehaviorPostTick();
            c && a.AddBehaviorTickTime();
            c && a.StartMeasuringTime();
            f ? await this.DebugFireGeneratorEventAndBreak(h.tick) : k.dispatchEvent(h.tick);
            c && a.AddPluginTickTime();
            this._eventSheetManager.BlockFlushingInstances(!1);
            this.DispatchUserScriptEvent(l.tick)
        }
        async Step_RunEventsEtc() {
            const c = this._eventSheetManager,
                f = this._dispatcher,
                k = this._eventObjects,
                h = this.IsDebug(),
                l = this.IsDebugging();
            h && a.StartMeasuringTime();
            l ? await c.DebugRunEvents(this._layoutManager) : c.RunEvents(this._layoutManager);
            h && a.AddEventsTime();
            this._collisionEngine.ClearRegisteredCollisions();
            this._ReleaseInstancesAtEndOfTick();
            this._isLayoutFirstTick = !1;
            c.BlockFlushingInstances(!0);
            h && a.StartMeasuringTime();
            l ? await this.DebugIterateAndBreak(this._DebugBehaviorTick2()) : this._BehaviorTick2();
            h && a.AddBehaviorTickTime();
            h && a.StartMeasuringTime();
            l ? await this.DebugFireGeneratorEventAndBreak(k.tick2) : f.dispatchEvent(k.tick2);
            h && a.AddPluginTickTime();
            c.BlockFlushingInstances(!1);
            l && await c.RunQueuedDebugTriggersAsync()
        }
        _ReleaseInstancesAtEndOfTick() {
            if (0 !==
                this._instancesToReleaseAtEndOfTick.size) {
                var c = this._dispatcher;
                c.SetDelayRemoveEventsEnabled(!0);
                for (const f of this._instancesToReleaseAffectedObjectClasses) f.GetSolStack().RemoveInstances(this._instancesToReleaseAtEndOfTick);
                this._instancesToReleaseAffectedObjectClasses.clear();
                this._eventSheetManager.RemoveInstancesFromScheduledWaits(this._instancesToReleaseAtEndOfTick);
                for (const f of this._instancesToReleaseAtEndOfTick) f.Release();
                this._instancesToReleaseAtEndOfTick.clear();
                c.SetDelayRemoveEventsEnabled(!1)
            }
        }
        async _MaybeChangeLayout() {
            const c =
                this.GetLayoutManager();
            let f = 0;
            for (; c.IsPendingChangeMainLayout() && 10 > f++;) await this._DoChangeLayout(c.GetPendingChangeMainLayout())
        }
        _MeasureDt(c) {
            let f = 0;
            0 !== this._lastTickTime && (f = Math.max(c - this._lastTickTime, 0) / 1E3, .5 < f && (f = 0), this._dt1 = Math.min(f, 1 / this._minimumFramerate));
            this._lastTickTime = c;
            this._dt = this._dt1 * this._timeScale;
            this._gameTime.Add(this._dt);
            this._gameTimeRaw.Add(f * this._timeScale);
            this._wallTime.Add(this._dt1);
            this._canvasManager && this._canvasManager._UpdateTick();
            1E3 <= c - this._fpsLastTime &&
                (this._fpsLastTime += 1E3, 1E3 <= c - this._fpsLastTime && (this._fpsLastTime = c), this._fps = this._fpsFrameCount, this._fpsFrameCount = 0, this._mainThreadTime = Math.min(this._mainThreadTimeCounter / 1E3, 1), this._mainThreadTimeCounter = 0, this._canvasManager && this._canvasManager._Update1sFrameRange(), this._collisionEngine._Update1sStats(), this.IsDebug() && a.Update1sPerfStats());
            this._fpsFrameCount++
        }
        async _DoChangeLayout(c) {
            const f = this._dispatcher,
                k = this.GetLayoutManager().GetMainRunningLayout();
            await k._StopRunning();
            k._Unload(c, this.GetRenderer());
            k === c && this._eventSheetManager.ClearAllScheduledWaits();
            this._collisionEngine.ClearRegisteredCollisions();
            this._ReleaseInstancesAtEndOfTick();
            f.dispatchEvent(this._eventObjects.beforelayoutchange);
            e.Asyncify.SetHighThroughputMode(!0);
            await c._Load(k, this.GetRenderer());
            e.Asyncify.SetHighThroughputMode(!1);
            await c._StartRunning(!1);
            f.dispatchEvent(this._eventObjects.layoutchange);
            this.UpdateRender();
            this._isLayoutFirstTick = !0;
            this.FlushPendingInstances()
        }
        UpdateRender() {
            this._needRender = !0
        }
        GetWebGLRenderer() {
            return this._canvasManager ? this._canvasManager.GetWebGLRenderer() : null
        }
        GetWebGPURenderer() {
            return this._canvasManager ? this._canvasManager.GetWebGPURenderer() : null
        }
        GetRenderer() {
            return this._canvasManager ? this._canvasManager.GetRenderer() : null
        }
        Render() {
            const c = this._canvasManager;
            if (c && !c.IsRendererContextLost()) {
                var f = this.GetRenderer(),
                    k = f.SupportsGPUProfiling(),
                    h = k && f.IsWebGL();
                k = k && f.IsWebGPU();
                h && f.CheckForQueryResults();
                if (this._needRender) {
                    var l = this._layoutManager.GetMainRunningLayout();
                    f.Start();
                    var n = this.IsDebug();
                    n && a.StartMeasuringTime();
                    this._needRender = !1;
                    var u = null;
                    h && (u = c.GetGPUFrameTimingsBuffer().AddTimeElapsedQuery(), f.StartQuery(u));
                    h = null;
                    k && (h = f.StartFrameTiming(2 * (1 + l.GetLayerCount())), f.WriteTimestamp(0));
                    this.Uses3DFeatures() && "low" === c.GetCurrentFullscreenScalingQuality() ? f.SetFixedSizeDepthBuffer(c.GetDrawWidth(), c.GetDrawHeight()) : f.SetAutoSizeDepthBuffer();
                    this._Render(this.GetRenderer(), l);
                    u && f.EndQuery(u);
                    k && (f.WriteTimestamp(1), this._canvasManager._AddWebGPUFrameTiming(h));
                    f.Finish();
                    n && (a.AddDrawCallsTime(), a.UpdateInspectHighlight());
                    c && c._MaybeTakeSnapshot()
                } else f.IncrementFrameNumber()
            }
        }
        _Render(c, f) {
            c.SetTextureFillMode();
            c.SetAlphaBlend();
            c.SetColorRgba(1, 1, 1, 1);
            c.SetRenderTarget(null);
            c.SetTexture(null);
            c.SetDepthEnabled(this.Uses3DFeatures());
            f.Draw(c)
        }
        Trigger(c, f, k) {
            if (!this._hasStarted) return !1;
            var h = !this._isInTick && !this._eventSheetManager.IsInTrigger();
            let l = 0;
            h && (l = performance.now());
            const n = this.IsDebug();
            n && this.SetDebuggingEnabled(!1);
            c = this._eventSheetManager._Trigger(this._layoutManager,
                c, f, k);
            h && (h = performance.now() - l, this._mainThreadTimeCounter += h, n && a.AddTriggersTime(h));
            n && this.SetDebuggingEnabled(!0);
            return c
        }
        DebugTrigger(c, f, k) {
            if (!this.IsDebug()) return this.Trigger(c, f, k);
            if (this.HitBreakpoint()) throw Error("called DebugTrigger() while stopped on breakpoint");
            if (!this._isInTick && !this._eventSheetManager.IsInTrigger()) throw Error("called DebugTrigger() outside of event code - use TriggerAsync() instead");
            return this._eventSheetManager._DebugTrigger(this._layoutManager, c, f,
                k)
        }
        async TriggerAsync(c, f, k) {
            if (!this.IsDebugging()) return this.Trigger(c, f, k);
            if (!this._hasStarted) return !1;
            if (this.HitBreakpoint()) return this._eventSheetManager.QueueDebugTrigger(c, f, k);
            if (!this.GetMainRunningLayout()) return this._eventSheetManager.QueueTrigger(c, f, k);
            const h = performance.now();
            c = this._eventSheetManager._DebugTrigger(this._layoutManager, c, f, k);
            for (f = c.next(); !f.done;) await this.DebugBreak(f.value), f = c.next();
            this.IsSuspended() || this._eventSheetManager.IsInTrigger() || (await this._eventSheetManager.RunQueuedDebugTriggersAsync(),
                this._hasStartedTicking && !this._isInTick && this._RequestAnimationFrame());
            this._mainThreadTimeCounter += performance.now() - h;
            return f.value
        }
        FastTrigger(c, f, k) {
            const h = this.IsDebug();
            h && this.SetDebuggingEnabled(!1);
            c = this._eventSheetManager._FastTrigger(this._layoutManager, c, f, k);
            h && this.SetDebuggingEnabled(!0);
            return c
        }
        DebugFastTrigger(c, f, k) {
            return this._eventSheetManager._DebugFastTrigger(this._layoutManager, c, f, k)
        }
        ScheduleTriggers(c) {
            return this._scheduleTriggersThrottle.Add(c)
        }
        PushCurrentLayout(c) {
            this._currentLayoutStack.push(c)
        }
        PopCurrentLayout() {
            if (!this._currentLayoutStack.length) throw Error("layout stack empty");
            this._currentLayoutStack.pop()
        }
        GetCurrentLayout() {
            return this._currentLayoutStack.length ? this._currentLayoutStack.at(-1) : this.GetMainRunningLayout()
        }
        GetDt(c) {
            return c && -1 !== c.GetTimeScale() ? this._dt1 * c.GetTimeScale() : this._dt
        }
        _GetDtFast() {
            return this._dt
        }
        GetDt1() {
            return this._dt1
        }
        GetTimeScale() {
            return this._timeScale
        }
        SetTimeScale(c) {
            if (isNaN(c) || 0 > c) c = 0;
            this._timeScale = c
        }
        SetMinimumFramerate(c) {
            this._minimumFramerate = e.clamp(c, 1, 120)
        }
        GetMinimumFramerate() {
            return this._minimumFramerate
        }
        GetFPS() {
            return this._fps
        }
        GetMainThreadTime() {
            return this._mainThreadTime
        }
        GetStartTime() {
            return this._startTime
        }
        GetGameTime() {
            return this._gameTime.Get()
        }
        GetGameTimeRaw() {
            return this._gameTimeRaw.Get()
        }
        GetWallTime() {
            return this._wallTime.Get()
        }
        GetTickCount() {
            return this._tickCount
        }
        GetTickCountNoSave() {
            return this._tickCountNoSave
        }
        IncrementExecCount() {
            ++this._execCount
        }
        GetExecCount() {
            return this._execCount
        }
        GetObjectCount() {
            return this._objectCount
        }
        GetProjectName() {
            return this._projectName
        }
        GetProjectVersion() {
            return this._projectVersion
        }
        GetProjectUniqueId() {
            return this._projectUniqueId
        }
        GetAppId() {
            return this._appId
        }
        GetInstanceByUID(c) {
            if (this._isLoadingState) throw Error("cannot call while loading state - wait until afterload event");
            return this._instancesByUid.get(c) || null
        }
        _RefreshUidMap() {
            this._instancesByUid.clear();
            for (const c of this._allObjectClasses)
                if (!c.IsFamily())
                    for (const f of c.GetInstances()) this._instancesByUid.set(f.GetUID(), f)
        }
        IsPreview() {
            return "preview" === this._exportType
        }
        IsDebug() {
            return this._isDebug
        }
        GetExportType() {
            return this._exportType
        }
        IsCordova() {
            return "cordova" === this._exportType
        }
        IsAndroidWebView() {
            return "Android" === e.Platform.OS && ("cordova" === this._exportType || "playable-ad" === this._exportType || "instant-games" ===
                this._exportType)
        }
        IsiOSCordova() {
            return this._isiOSCordova
        }
        IsiOSWebView() {
            return this._isiOSWebView
        }
        GetCollisionEngine() {
            return this._collisionEngine
        }
        GetSolidBehavior() {
            return this._pluginManager.GetSolidBehavior()
        }
        GetJumpthruBehavior() {
            return this._pluginManager.GetJumpthruBehavior()
        }
        Uses3DFeatures() {
            return this._uses3dFeatures
        }
        GetZScaleFactor() {
            const c = this.GetRenderer();
            return this.GetViewportHeight() / 2 / Math.tan(c.GetFovY() / 2) / c.GetDefaultCameraZ()
        }
        IsLayoutFirstTick() {
            return this._isLayoutFirstTick
        }
        SetPixelRoundingEnabled(c) {
            c = !!c;
            this._isPixelRoundingEnabled !== c && (this._isPixelRoundingEnabled = c, this.GetLayoutManager().SetAllLayerMVChanged(), this.UpdateRender())
        }
        IsPixelRoundingEnabled() {
            return this._isPixelRoundingEnabled
        }
        SaveToSlot(c) {
            this._saveToSlotName = c
        }
        LoadFromSlot(c) {
            this._loadFromSlotName = c
        }
        LoadFromJsonString(c) {
            this._loadFromJson = c
        }
        GetLastSaveJsonString() {
            return this._lastSaveJson
        }
        _NeedsHandleSaveOrLoad() {
            return !(!this._saveToSlotName && !this._loadFromSlotName && null === this._loadFromJson)
        }
        async _HandleSaveOrLoad() {
            this._saveToSlotName &&
                (this.FlushPendingInstances(), await this._DoSaveToSlot(this._saveToSlotName), this._ClearSaveOrLoad());
            this._loadFromSlotName && (await this._DoLoadFromSlot(this._loadFromSlotName), this._ClearSaveOrLoad(), this.IsDebug() && a.StepIfPausedInDebugger());
            if (null !== this._loadFromJson) {
                this.FlushPendingInstances();
                try {
                    await this._DoLoadFromJsonString(this._loadFromJson), this._lastSaveJson = this._loadFromJson, await this.TriggerAsync(e.Plugins.System.Cnds.OnLoadComplete, null), this._lastSaveJson = ""
                } catch (c) {
                    console.error("[Construct 3] Failed to load state from JSON string: ",
                        c), await this.TriggerAsync(e.Plugins.System.Cnds.OnLoadFailed, null)
                }
                this._ClearSaveOrLoad()
            }
        }
        _ClearSaveOrLoad() {
            this._loadFromSlotName = this._saveToSlotName = "";
            this._loadFromJson = null
        }
        _GetProjectStorage() {
            this._projectStorage || (this._projectStorage = localforage.createInstance({
                name: "c3-localstorage-" + this.GetProjectUniqueId(),
                description: this.GetProjectName()
            }));
            return this._projectStorage
        }
        _GetSavegamesStorage() {
            this._savegamesStorage || (this._savegamesStorage = localforage.createInstance({
                name: "c3-savegames-" +
                    this.GetProjectUniqueId(),
                description: this.GetProjectName()
            }));
            return this._savegamesStorage
        }
        async _DoSaveToSlot(c) {
            const f = await this._SaveToJsonString();
            try {
                await this._GetSavegamesStorage().setItem(c, f), console.log("[Construct 3] Saved state to storage (" + f.length + " chars)"), this._lastSaveJson = f, await this.TriggerAsync(e.Plugins.System.Cnds.OnSaveComplete, null), this._lastSaveJson = ""
            } catch (k) {
                console.error("[Construct 3] Failed to save state to storage: ", k), await this.TriggerAsync(e.Plugins.System.Cnds.OnSaveFailed,
                    null)
            }
        }
        async _DoLoadFromSlot(c) {
            try {
                const f = await this._GetSavegamesStorage().getItem(c);
                if (!f) throw Error("empty slot");
                console.log("[Construct 3] Loaded state from storage (" + f.length + " chars)");
                await this._DoLoadFromJsonString(f);
                this._lastSaveJson = f;
                await this.TriggerAsync(e.Plugins.System.Cnds.OnLoadComplete, null);
                this._lastSaveJson = ""
            } catch (f) {
                console.error("[Construct 3] Failed to load state from storage: ", f), await this.TriggerAsync(e.Plugins.System.Cnds.OnLoadFailed, null)
            }
        }
        async _SaveToJsonString() {
            const c = {
                c3save: !0,
                version: 1,
                rt: {
                    time: this.GetGameTime(),
                    timeRaw: this.GetGameTimeRaw(),
                    walltime: this.GetWallTime(),
                    timescale: this.GetTimeScale(),
                    tickcount: this.GetTickCount(),
                    execcount: this.GetExecCount(),
                    next_uid: this._nextUid,
                    running_layout: this.GetMainRunningLayout().GetSID(),
                    start_time_offset: Date.now() - this._startTime
                },
                types: {},
                layouts: {},
                events: this._eventSheetManager._SaveToJson(),
                timelines: this._timelineManager._SaveToJson(),
                user_script_data: null
            };
            for (var f of this._allObjectClasses) f.IsFamily() ||
                f.HasNoSaveBehavior() || (c.types[f.GetSID().toString()] = f._SaveToJson());
            for (const k of this._layoutManager.GetAllLayouts()) c.layouts[k.GetSID().toString()] = k._SaveToJson();
            f = this._CreateUserScriptEvent("save");
            f.saveData = null;
            await this.DispatchUserScriptEventAsyncWait(f);
            c.user_script_data = f.saveData;
            return JSON.stringify(c)
        }
        IsLoadingState() {
            return this._isLoadingState
        }
        async _DoLoadFromJsonString(c) {
            var f = this.GetLayoutManager();
            c = JSON.parse(c);
            if (c.c2save) throw Error("C2 saves are incompatible with C3 runtime");
            if (!c.c3save) throw Error("not valid C3 save data");
            if (1 < c.version) throw Error("C3 save data from future version");
            this._dispatcher.dispatchEvent(e.New(e.Event, "beforeload"));
            for (var k of this.allInstances()) k._OnBeforeLoad();
            this._isLoadingState = !0;
            k = c.rt;
            this._gameTime.Set(k.time);
            k.hasOwnProperty("timeRaw") && this._gameTimeRaw.Set(k.timeRaw);
            this._wallTime.Set(k.walltime);
            this._timeScale = k.timescale;
            this._tickCount = k.tickcount;
            this._execCount = k.execcount;
            this._startTime = Date.now() - k.start_time_offset;
            var h = k.running_layout;
            if (h !== this.GetMainRunningLayout().GetSID())
                if (h = f.GetLayoutBySID(h)) await this._DoChangeLayout(h);
                else return;
            for (const [l, n] of Object.entries(c.types)) h = parseInt(l, 10), h = this.GetObjectClassBySID(h), !h || h.IsFamily() || h.HasNoSaveBehavior() || h._LoadFromJson(n);
            this.FlushPendingInstances();
            this._RefreshUidMap();
            this._isLoadingState = !1;
            this._nextUid = k.next_uid;
            for (const [l, n] of Object.entries(c.layouts)) k = parseInt(l, 10), (k = f.GetLayoutBySID(k)) && k._LoadFromJson(n);
            this._eventSheetManager._LoadFromJson(c.events);
            for (const l of this._allObjectClasses)
                if (!l.IsFamily() && l.IsInContainer())
                    for (const n of l.GetInstances()) {
                        k = n.GetIID();
                        for (const u of l.GetContainer().objectTypes())
                            if (u !== l) {
                                h = u.GetInstances();
                                if (0 > k || k >= h.length) throw Error("missing sibling instance");
                                n._AddSibling(h[k])
                            }
                    }
            this._timelineManager._LoadFromJson(c.timelines);
            f.SetAllLayerProjectionChanged();
            f.SetAllLayerMVChanged();
            this._dispatcher.dispatchEvent(e.New(e.Event, "afterload"));
            f = this._CreateUserScriptEvent("load");
            f.saveData = c.user_script_data;
            await this.DispatchUserScriptEventAsyncWait(f);
            this.UpdateRender()
        }
        async AddJobWorkerScripts(c) {
            c = (await Promise.all(c.map(f => this._assetManager.FetchBlob(f)))).map(f => URL.createObjectURL(f));
            this._jobScheduler.ImportScriptsToJobWorkers(c)
        }
        AddJobWorkerBlob(c, f) {
            this._jobScheduler.SendBlobToJobWorkers(c, f)
        }
        AddJobWorkerBuffer(c, f) {
            this._jobScheduler.SendBufferToJobWorkers(c, f)
        }
        AddJob(c, f, k) {
            return this._jobScheduler.AddJob(c, f, k)
        }
        BroadcastJob(c, f, k) {
            return this._jobScheduler.BroadcastJob(c, f, k)
        }
        InvokeDownload(c,
            f) {
            this.PostComponentMessageToDOM("runtime", "invoke-download", {
                url: c,
                filename: f
            })
        }
        async RasterSvgImage(c, f, k, h, l, n) {
            h = h || f;
            l = l || k;
            if (this.IsInWorker()) return (await this.PostComponentMessageToDOMAsync("runtime", "raster-svg-image", {
                blob: c,
                imageWidth: f,
                imageHeight: k,
                surfaceWidth: h,
                surfaceHeight: l,
                imageBitmapOpts: n
            })).imageBitmap;
            c = await self.C3_RasterSvgImageBlob(c, f, k, h, l);
            return n ? await self.createImageBitmap(c, n) : c
        }
        async GetSvgImageSize(c) {
            return this.IsInWorker() ? await this.PostComponentMessageToDOMAsync("runtime",
                "get-svg-image-size", {
                    blob: c
                }) : await self.C3_GetSvgImageSize(c)
        }
        RequestDeviceOrientationEvent() {
            this._didRequestDeviceOrientationEvent || (this._didRequestDeviceOrientationEvent = !0, this.PostComponentMessageToDOM("runtime", "enable-device-orientation"))
        }
        RequestDeviceMotionEvent() {
            this._didRequestDeviceMotionEvent || (this._didRequestDeviceMotionEvent = !0, this.PostComponentMessageToDOM("runtime", "enable-device-motion"))
        }
        Random() {
            return this._randomNumberCallback()
        }
        SetRandomNumberGeneratorCallback(c) {
            this._randomNumberCallback =
                c
        }
        _GetRemotePreviewStatusInfo() {
            const c = this.GetWebGLRenderer();
            return {
                fps: this.GetFPS(),
                cpu: this.GetMainThreadTime(),
                gpu: this.GetGPUUtilisation(),
                layout: this.GetMainRunningLayout() ? this.GetMainRunningLayout().GetName() : "",
                renderer: c ? c.GetUnmaskedRenderer() : "<unavailable>"
            }
        }
        HitBreakpoint() {
            return this.IsDebug() ? a.HitBreakpoint() : !1
        }
        DebugBreak(c) {
            return this.IsDebugging() ? a.DebugBreak(c) : Promise.resolve()
        }
        DebugBreakNext() {
            return this.IsDebugging() ? a.BreakNext() : !1
        }
        SetDebugBreakpointsEnabled(c) {
            this._breakpointsEnabled = !!c;
            this._UpdateDebuggingFlag()
        }
        AreDebugBreakpointsEnabled() {
            return this._breakpointsEnabled
        }
        IsDebugging() {
            return this._isDebugging
        }
        SetDebuggingEnabled(c) {
            c ? this._debuggingDisabled-- : this._debuggingDisabled++;
            this._UpdateDebuggingFlag()
        }
        _UpdateDebuggingFlag() {
            this._isDebugging = this.IsDebug() && this._breakpointsEnabled && 0 === this._debuggingDisabled
        }
        IsCPUProfiling() {
            return this.IsDebug() && a.IsCPUProfiling()
        }
        IsGPUProfiling() {
            return this.IsDebug() && this.GetRenderer().SupportsGPUProfiling() && a.IsGPUProfiling()
        }
        async DebugIterateAndBreak(c) {
            if (c)
                for (const f of c) await this.DebugBreak(f)
        }
        DebugFireGeneratorEventAndBreak(c) {
            return this.DebugIterateAndBreak(this._dispatcher.dispatchGeneratorEvent(c))
        }
        _InvokeFunctionFromJS(c) {
            return this._eventSheetManager._InvokeFunctionFromJS(c.name,
                c.params)
        }
        GetIRuntime() {
            return this._iRuntime
        }
        _CreateUserScriptEvent(c) {
            c = e.New(e.Event, c, !1);
            c.runtime = this._iRuntime;
            return c
        }
        _InitScriptInterfaces() {
            var c = {};
            for (const f of this._allObjectClasses) c[f.GetJsPropName()] = {
                value: f.GetIObjectClass(),
                enumerable: !0,
                writable: !1
            };
            c = Object.create(Object.prototype, c);
            this._iRuntime = new self.IRuntime(this, c);
            this._userScriptEventObjects = {
                tick: this._CreateUserScriptEvent("tick")
            }
        }
        _InitGlobalVariableScriptInterface() {
            const c = {};
            for (const f of this.GetEventSheetManager().GetAllGlobalVariables()) c[f.GetJsPropName()] =
                f._GetScriptInterfaceDescriptor();
            this._iRuntime._InitGlobalVars(c)
        }
        _GetCommonScriptInterfaces() {
            return this._commonScriptInterfaces
        }
        _MapScriptInterface(c, f) {
            this._interfaceMap.set(c, f)
        }
        _UnwrapScriptInterface(c) {
            return this._interfaceMap.get(c)
        }
        _UnwrapIObjectClass(c) {
            if (!(c instanceof self.IObjectClass)) throw new TypeError("expected IObjectClass");
            c = this._UnwrapScriptInterface(c);
            if (!(c && c instanceof e.ObjectClass)) throw Error("invalid IObjectClass");
            return c
        }
        _UnwrapIWorldInstance(c) {
            if (!(c instanceof self.IWorldInstance)) throw new TypeError("expected IWorldInstance");
            c = this._UnwrapScriptInterface(c);
            if (!(c && c instanceof e.Instance)) throw Error("invalid IInstance");
            return c
        }
    };
    self.C3_CreateRuntime = e.Runtime.Create;
    self.C3_InitRuntime = (c, f) => c.Init(f)
} {
    "use strict";
    const e = self.C3;
    e.JobSchedulerRuntime = class extends e.DefendedBase {
        constructor(a, b) {
            super();
            this._runtime = a;
            this._jobPromises = new Map;
            this._nextJobId = 0;
            this._inputPort = b.inputPort;
            b.outputPort.onmessage = d => this._OnJobWorkerMessage(d);
            this._maxNumWorkers = b.maxNumWorkers;
            this._jobWorkerCount = 1;
            this._hadErrorCreatingWorker = this._isCreatingWorker = !1
        }
        async Init() {}
        ImportScriptsToJobWorkers(a) {
            this._inputPort.postMessage({
                type: "_import_scripts",
                scripts: a
            })
        }
        SendBlobToJobWorkers(a, b) {
            this._inputPort.postMessage({
                type: "_send_blob",
                blob: a,
                id: b
            })
        }
        SendBufferToJobWorkers(a, b) {
            this._inputPort.postMessage({
                type: "_send_buffer",
                buffer: a,
                id: b
            }, [a])
        }
        AddJob(a, b, d, c, f) {
            d || (d = []);
            const k = this._nextJobId++;
            a = {
                type: a,
                isBroadcast: !1,
                jobId: k,
                params: b,
                transferables: d
            };
            b = new Promise((h, l) => {
                this._jobPromises.set(k, {
                    resolve: h,
                    progress: c,
                    reject: l,
                    cancelled: !1
                })
            });
            f && f.SetAction(() => this._CancelJob(k));
            this._inputPort.postMessage(a, d);
            this._MaybeCreateExtraWorker();
            return b
        }
        BroadcastJob(a, b, d) {
            d || (d = []);
            const c = this._nextJobId++;
            this._inputPort.postMessage({
                type: a,
                isBroadcast: !0,
                jobId: c,
                params: b,
                transferables: d
            }, d)
        }
        _CancelJob(a) {
            const b = this._jobPromises.get(a);
            b && (b.cancelled = !0, b.resolve = null, b.progress = null, b.reject = null, this._inputPort.postMessage({
                type: "_cancel",
                jobId: a
            }))
        }
        _OnJobWorkerMessage(a) {
            a = a.data;
            const b = a.type,
                d = a.jobId;
            switch (b) {
                case "result":
                    this._OnJobResult(d, a.result);
                    break;
                case "progress":
                    this._OnJobProgress(d, a.progress);
                    break;
                case "error":
                    this._OnJobError(d, a.error);
                    break;
                case "ready":
                    this._OnJobWorkerReady();
                    break;
                default:
                    throw Error(`unknown message from worker '${b}'`);
            }
        }
        _OnJobResult(a, b) {
            const d = this._jobPromises.get(a);
            if (!d) throw Error("invalid job ID");
            d.cancelled || d.resolve(b);
            this._jobPromises.delete(a)
        }
        _OnJobProgress(a, b) {
            a = this._jobPromises.get(a);
            if (!a) throw Error("invalid job ID");
            !a.cancelled && a.progress && a.progress(b)
        }
        _OnJobError(a, b) {
            const d = this._jobPromises.get(a);
            if (!d) throw Error("invalid job ID");
            d.cancelled || d.reject(b);
            this._jobPromises.delete(a)
        }
        _OnJobWorkerReady() {
            this._isCreatingWorker && (this._isCreatingWorker = !1, this._jobWorkerCount++, this._jobWorkerCount <
                this._maxNumWorkers ? this._MaybeCreateExtraWorker() : this._inputPort.postMessage({
                    type: "_no_more_workers"
                }))
        }
        async _MaybeCreateExtraWorker() {
            if (!(this._jobWorkerCount >= this._maxNumWorkers || this._isCreatingWorker || this._hadErrorCreatingWorker || this._jobPromises.size <= this._jobWorkerCount)) try {
                this._isCreatingWorker = !0, (await this._runtime.PostComponentMessageToDOMAsync("runtime", "create-job-worker")).outputPort.onmessage = a => this._OnJobWorkerMessage(a)
            } catch (a) {
                this._hadErrorCreatingWorker = !0, this._isCreatingWorker = !1, console.error(`[Construct 3] Failed to create job worker; stopping creating any more (created ${this._jobWorkerCount} so far)`, a)
            }
        }
    }
}
self.C3_Shaders = {}; {
    "use strict";
    const e = self.C3;
    let a = null,
        b = "",
        d = "",
        c = [],
        f = "",
        k = "",
        h = "";
    const l = e.New(e.ArrayStack);

    function n(u, w) {
        u = u[1];
        w = w[1];
        if ("number" === typeof u && "number" === typeof w) return u - w;
        u = "" + u;
        w = "" + w;
        return u < w ? -1 : u > w ? 1 : 0
    }
    e.Plugins.System = class extends e.SDKPluginBase {
        constructor(u) {
            super(u);
            this._loopStack = this._runtime.GetEventSheetManager().GetLoopStack();
            this._eventStack = this._runtime.GetEventSheetManager().GetEventStack();
            this._imagesLoadingComplete = this._imagesLoadingTotal = 0;
            this._functionMaps =
                new Map
        }
        Release() {
            super.Release()
        }
        UpdateRender() {
            this._runtime.UpdateRender()
        }
        Trigger(u) {
            this._runtime.Trigger(u, null, null)
        }
        GetRegex(u, w) {
            a && u === b && w === d || (a = new RegExp(u, w), b = u, d = w);
            a.lastIndex = 0;
            return a
        }
        GetRegexMatches(u, w, q) {
            if (u === f && w === k && q === h) return c;
            const t = this.GetRegex(w, q);
            c = u.match(t);
            f = u;
            k = w;
            h = q;
            return c
        }
        async _LoadTexturesForObjectClasses(u, w) {
            if (w.length) {
                this._imagesLoadingTotal += w.length;
                var q = [];
                for (const t of w) q.push(u.MaybeLoadTexturesFor(t));
                await e.PromiseAllWithProgress(q,
                    () => {
                        this._imagesLoadingComplete++
                    });
                this._imagesLoadingComplete++;
                this._imagesLoadingComplete === this._imagesLoadingTotal && (this._runtime.Trigger(e.Plugins.System.Cnds.OnImageLoadingComplete, null, null), this._imagesLoadingTotal = this._imagesLoadingComplete = 0)
            }
        }
        _UnloadTexturesForObjectClasses(u, w) {
            for (const q of w) 0 === q.GetInstanceCount() && u.MaybeUnloadTexturesFor(q)
        }
        _GetForEachStack() {
            return l
        }
        _Repeat(u) {
            var w = this._runtime.GetEventSheetManager();
            const q = w.GetEventStack(),
                t = q.GetCurrentStackFrame(),
                p = t.GetCurrentEvent(),
                r = p.GetSolModifiers();
            var x = t.IsSolModifierAfterCnds();
            const y = q.Push(p),
                E = w.GetLoopStack(),
                G = E.Push();
            G.SetEnd(u);
            if (x)
                for (x = 0; x < u && !G.IsStopped(); ++x) w.PushCopySol(r), G.SetIndex(x), p.Retrigger(t, y), w.PopSol(r);
            else
                for (w = 0; w < u && !G.IsStopped(); ++w) G.SetIndex(w), p.Retrigger(t, y);
            q.Pop();
            E.Pop();
            return !1
        }* _DebugRepeat(u) {
            var w = this._runtime.GetEventSheetManager();
            const q = w.GetEventStack(),
                t = q.GetCurrentStackFrame(),
                p = t.GetCurrentEvent(),
                r = p.GetSolModifiers();
            var x = t.IsSolModifierAfterCnds();
            const y = q.Push(p),
                E = w.GetLoopStack(),
                G = E.Push();
            G.SetEnd(u);
            if (x)
                for (x = 0; x < u && !G.IsStopped(); ++x) w.PushCopySol(r), G.SetIndex(x), yield* p.DebugRetrigger(t, y), w.PopSol(r);
            else
                for (w = 0; w < u && !G.IsStopped(); ++w) G.SetIndex(w), yield* p.DebugRetrigger(t, y);
            q.Pop();
            E.Pop();
            return !1
        }
        _While() {
            var u = this._runtime.GetEventSheetManager();
            const w = u.GetEventStack(),
                q = w.GetCurrentStackFrame(),
                t = q.GetCurrentEvent(),
                p = t.GetSolModifiers();
            var r = q.IsSolModifierAfterCnds();
            const x = w.Push(t),
                y = u.GetLoopStack(),
                E = y.Push();
            if (r)
                for (r = 0; !E.IsStopped(); ++r) u.PushCopySol(p), E.SetIndex(r), t.Retrigger(q, x) || E.Stop(), u.PopSol(p);
            else
                for (u = 0; !E.IsStopped(); ++u) E.SetIndex(u), t.Retrigger(q, x) || E.Stop();
            w.Pop();
            y.Pop();
            return !1
        }* _DebugWhile() {
            var u = this._runtime.GetEventSheetManager();
            const w = u.GetEventStack(),
                q = w.GetCurrentStackFrame(),
                t = q.GetCurrentEvent(),
                p = t.GetSolModifiers();
            var r = q.IsSolModifierAfterCnds();
            const x = w.Push(t),
                y = u.GetLoopStack(),
                E = y.Push();
            if (r)
                for (r = 0; !E.IsStopped(); ++r) u.PushCopySol(p), E.SetIndex(r), (yield* t.DebugRetrigger(q,
                    x)) || E.Stop(), u.PopSol(p);
            else
                for (u = 0; !E.IsStopped(); ++u) E.SetIndex(u), (yield* t.DebugRetrigger(q, x)) || E.Stop();
            w.Pop();
            y.Pop();
            return !1
        }
        _For(u, w, q) {
            var t = this._runtime.GetEventSheetManager();
            const p = t.GetEventStack(),
                r = p.GetCurrentStackFrame(),
                x = r.GetCurrentEvent(),
                y = x.GetSolModifiers(),
                E = r.IsSolModifierAfterCnds(),
                G = p.Push(x),
                A = t.GetLoopStack(),
                F = A.Push();
            F.SetName(u);
            F.SetEnd(q);
            if (q < w)
                if (E)
                    for (u = w; u >= q && !F.IsStopped(); --u) t.PushCopySol(y), F.SetIndex(u), x.Retrigger(r, G), t.PopSol(y);
                else
                    for (t =
                        w; t >= q && !F.IsStopped(); --t) F.SetIndex(t), x.Retrigger(r, G);
            else if (E)
                for (u = w; u <= q && !F.IsStopped(); ++u) t.PushCopySol(y), F.SetIndex(u), x.Retrigger(r, G), t.PopSol(y);
            else
                for (t = w; t <= q && !F.IsStopped(); ++t) F.SetIndex(t), x.Retrigger(r, G);
            p.Pop();
            A.Pop();
            return !1
        }* _DebugFor(u, w, q) {
            var t = this._runtime.GetEventSheetManager();
            const p = t.GetEventStack(),
                r = p.GetCurrentStackFrame(),
                x = r.GetCurrentEvent(),
                y = x.GetSolModifiers(),
                E = r.IsSolModifierAfterCnds(),
                G = p.Push(x),
                A = t.GetLoopStack(),
                F = A.Push();
            F.SetName(u);
            F.SetEnd(q);
            if (q < w)
                if (E)
                    for (u = w; u >= q && !F.IsStopped(); --u) t.PushCopySol(y), F.SetIndex(u), yield* x.DebugRetrigger(r, G), t.PopSol(y);
                else
                    for (t = w; t >= q && !F.IsStopped(); --t) F.SetIndex(t), yield* x.DebugRetrigger(r, G);
            else if (E)
                for (u = w; u <= q && !F.IsStopped(); ++u) t.PushCopySol(y), F.SetIndex(u), yield* x.DebugRetrigger(r, G), t.PopSol(y);
            else
                for (t = w; t <= q && !F.IsStopped(); ++t) F.SetIndex(t), yield* x.DebugRetrigger(r, G);
            p.Pop();
            A.Pop();
            return !1
        }
        _ForEach(u) {
            var w = this._runtime.GetEventSheetManager();
            const q = w.GetEventStack(),
                t = q.GetCurrentStackFrame(),
                p = t.GetCurrentEvent(),
                r = p.GetSolModifiers();
            var x = t.IsSolModifierAfterCnds();
            const y = q.Push(p),
                E = w.GetLoopStack(),
                G = E.Push(),
                A = u.IsInContainer(),
                F = u.GetCurrentSol(),
                J = l.Push();
            e.shallowAssignArray(J, F.GetInstances());
            G.SetEnd(J.length);
            if (x)
                for (let B = 0, I = J.length; B < I && !G.IsStopped(); ++B) w.PushCopySol(r), x = J[B], u.GetCurrentSol().SetSinglePicked(x), A && x.SetSiblingsSinglePicked(), G.SetIndex(B), p.Retrigger(t, y), w.PopSol(r);
            else {
                F._SetSelectAll(!1);
                u = F._GetOwnInstances();
                e.clearArray(u);
                u.push(null);
                for (let B =
                        0, I = J.length; B < I && !G.IsStopped(); ++B) w = J[B], u[0] = w, A && w.SetSiblingsSinglePicked(), G.SetIndex(B), p.Retrigger(t, y)
            }
            q.Pop();
            E.Pop();
            e.clearArray(J);
            l.Pop();
            return !1
        }* _DebugForEach(u) {
            var w = this._runtime.GetEventSheetManager();
            const q = w.GetEventStack(),
                t = q.GetCurrentStackFrame(),
                p = t.GetCurrentEvent(),
                r = p.GetSolModifiers();
            var x = t.IsSolModifierAfterCnds();
            const y = q.Push(p),
                E = w.GetLoopStack(),
                G = E.Push(),
                A = u.IsInContainer(),
                F = u.GetCurrentSol(),
                J = l.Push();
            e.shallowAssignArray(J, F.GetInstances());
            G.SetEnd(J.length);
            if (x)
                for (let B = 0, I = J.length; B < I && !G.IsStopped(); ++B) w.PushCopySol(r), x = J[B], u.GetCurrentSol().SetSinglePicked(x), A && x.SetSiblingsSinglePicked(), G.SetIndex(B), yield* p.DebugRetrigger(t, y), w.PopSol(r);
            else {
                F._SetSelectAll(!1);
                u = F._GetOwnInstances();
                e.clearArray(u);
                u.push(null);
                for (let B = 0, I = J.length; B < I && !G.IsStopped(); ++B) w = J[B], u[0] = w, A && w.SetSiblingsSinglePicked(), G.SetIndex(B), yield* p.DebugRetrigger(t, y)
            }
            q.Pop();
            E.Pop();
            e.clearArray(J);
            l.Pop();
            return !1
        }
        _ForEachOrdered(u, w) {
            var q = this._runtime.GetEventSheetManager();
            const t = q.GetEventStack(),
                p = q.GetCurrentCondition(),
                r = t.GetCurrentStackFrame(),
                x = r.GetCurrentEvent(),
                y = x.GetSolModifiers(),
                E = r.IsSolModifierAfterCnds(),
                G = t.Push(x),
                A = q.GetLoopStack(),
                F = A.Push(),
                J = u.IsInContainer(),
                B = u.GetCurrentSol(),
                I = l.Push();
            e.clearArray(I);
            const L = B.GetInstances();
            F.SetEnd(L.length);
            for (let P = 0, S = L.length; P < S; ++P) I.push([L[P], p.ReevaluateParameter(1, P)]);
            I.sort(n);
            1 === w && I.reverse();
            if (E)
                for (let P = 0, S = I.length; P < S && !F.IsStopped(); ++P) q.PushCopySol(y), w = I[P][0], u.GetCurrentSol().SetSinglePicked(w),
                    J && w.SetSiblingsSinglePicked(), F.SetIndex(P), x.Retrigger(r, G), q.PopSol(y);
            else {
                B._SetSelectAll(!1);
                u = B._GetOwnInstances();
                e.clearArray(u);
                u.push(null);
                for (let P = 0, S = I.length; P < S && !F.IsStopped(); ++P) q = I[P][0], u[0] = q, J && q.SetSiblingsSinglePicked(), F.SetIndex(P), x.Retrigger(r, G)
            }
            t.Pop();
            A.Pop();
            e.clearArray(I);
            l.Pop();
            return !1
        }* _DebugForEachOrdered(u, w) {
            var q = this._runtime.GetEventSheetManager();
            const t = q.GetEventStack(),
                p = q.GetCurrentCondition(),
                r = t.GetCurrentStackFrame(),
                x = r.GetCurrentEvent(),
                y = x.GetSolModifiers(),
                E = r.IsSolModifierAfterCnds(),
                G = t.Push(x),
                A = q.GetLoopStack(),
                F = A.Push(),
                J = u.IsInContainer(),
                B = u.GetCurrentSol(),
                I = l.Push();
            e.clearArray(I);
            const L = B.GetInstances();
            F.SetEnd(L.length);
            for (let P = 0, S = L.length; P < S; ++P) I.push([L[P], p.ReevaluateParameter(1, P)]);
            I.sort(n);
            1 === w && I.reverse();
            if (E)
                for (let P = 0, S = I.length; P < S && !F.IsStopped(); ++P) q.PushCopySol(y), w = I[P][0], u.GetCurrentSol().SetSinglePicked(w), J && w.SetSiblingsSinglePicked(), F.SetIndex(P), yield* x.DebugRetrigger(r, G), q.PopSol(y);
            else {
                B._SetSelectAll(!1);
                u = B._GetOwnInstances();
                e.clearArray(u);
                u.push(null);
                for (let P = 0, S = I.length; P < S && !F.IsStopped(); ++P) q = I[P][0], u[0] = q, J && q.SetSiblingsSinglePicked(), F.SetIndex(P), yield* x.DebugRetrigger(r, G)
            }
            t.Pop();
            A.Pop();
            e.clearArray(I);
            l.Pop();
            return !1
        }
        _GetFunctionMap(u, w) {
            let q = this._functionMaps.get(u);
            if (q) return q;
            if (!w) return null;
            q = {
                defaultFunc: null,
                strMap: new Map
            };
            this._functionMaps.set(u, q);
            return q
        }
        _DoCallMappedFunction(u, w, q, t, p) {
            w.GetEventBlock().RunAsMappedFunctionCall(q);
            t && u.PopSol(p)
        }* _DebugDoCallMappedFunction(u,
            w, q, t, p) {
            yield* w.GetEventBlock().DebugRunAsMappedFunctionCall(q);
            t && u.PopSol(p)
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.System.Type = class extends e.DefendedBase {
        constructor(a) {
            super();
            this._objectClass = a;
            this._runtime = a.GetRuntime();
            this._plugin = a.GetPlugin()
        }
        OnCreate() {}
        Release() {
            this._plugin = this._runtime = this._objectClass = null
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.System.Instance = class extends e.DefendedBase {
        constructor(a, b) {
            super();
            this._inst = a;
            this._objectClass = this._inst.GetObjectClass();
            this._sdkType = this._objectClass.GetSdkType();
            this._runtime = this._inst.GetRuntime()
        }
        Release() {
            this._runtime = this._sdkType = this._objectClass = this._inst = null
        }
    }
} {
    "use strict";
    const e = self.C3,
        a = [];
    e.Plugins.System.Cnds = {
        EveryTick() {
            return !0
        },
        OnLayoutStart() {
            return !0
        },
        OnLayoutEnd() {
            return !0
        },
        OnSuspend() {
            return !0
        },
        OnResume() {
            return !0
        },
        IsSuspended() {
            return this._runtime.IsSuspended()
        },
        Else() {
            const b = this._runtime.GetCurrentEventStackFrame();
            return b.GetElseBranchRan() ? !1 : !b.GetLastEventTrue()
        },
        TriggerOnce() {
            const b = this._runtime.GetCurrentCondition().GetSavedDataMap();
            let d = b.get("TriggerOnce_lastTick");
            "undefined" === typeof d && (d = -1, b.set("TriggerOnce_lastTick",
                -1));
            const c = this._runtime.GetTickCount();
            b.set("TriggerOnce_lastTick", c);
            return this._runtime.IsLayoutFirstTick() || d !== c - 1
        },
        Every(b) {
            const d = this._runtime.GetCurrentCondition().GetSavedDataMap(),
                c = d.get("Every_lastTime") || 0,
                f = this._runtime.GetGameTime();
            d.has("Every_seconds") || d.set("Every_seconds", b);
            const k = d.get("Every_seconds");
            if (f >= c + k) return d.set("Every_lastTime", c + k), f >= d.get("Every_lastTime") + .04 && d.set("Every_lastTime", f), d.set("Every_seconds", b), !0;
            f < c - .1 && d.set("Every_lastTime", f);
            return !1
        },
        IsGroupActive(b) {
            return (b = this._runtime.GetEventSheetManager().GetEventGroupByName(b)) && b.IsGroupActive()
        },
        IsPreview() {
            return this._runtime.IsPreview()
        },
        IsMobile() {
            return e.Platform.IsMobile
        },
        OnLoadFinished() {
            return !0
        },
        OnCanvasSnapshot() {
            return !0
        },
        EffectsSupported() {
            return !0
        },
        OnSaveComplete() {
            return !0
        },
        OnSaveFailed() {
            return !0
        },
        OnLoadComplete() {
            return !0
        },
        OnLoadFailed() {
            return !0
        },
        ObjectUIDExists(b) {
            return !!this._runtime.GetInstanceByUID(b)
        },
        IsOnPlatform(b) {
            switch (b) {
                case 0:
                    return "browser" === e.Platform.Context;
                case 1:
                    return "iOS" === e.Platform.OS;
                case 2:
                    return "Android" === e.Platform.OS;
                case 8:
                    return "cordova" === e.Platform.Context;
                case 9:
                    return "scirra-arcade" === this._runtime.GetExportType();
                case 10:
                    return "nwjs" === e.Platform.Context;
                case 13:
                    return "windows-uwp" === this._runtime.GetExportType();
                default:
                    return !1
            }
        },
        RegexTest(b, d, c) {
            return this.GetRegex(d, c).test(b)
        },
        Compare(b, d, c) {
            return e.compare(b, d, c)
        },
        CompareBetween(b, d, c) {
            return b >= d && b <= c
        },
        CompareVar(b, d, c) {
            return e.compare(b.GetValue(), d, c)
        },
        CompareBoolVar(b) {
            return !!b.GetValue()
        },
        CompareTime(b, d) {
            const c = this._runtime.GetGameTime();
            return 0 === b ? (b = this._runtime.GetCurrentCondition().GetSavedDataMap(), !b.get("CompareTime_executed") && c >= d ? (b.set("CompareTime_executed", !0), !0) : !1) : e.compare(c, b, d)
        },
        IsNaN(b) {
            return isNaN(b)
        },
        AngleWithin(b, d, c) {
            return e.angleDiff(e.toRadians(b), e.toRadians(c)) <= e.toRadians(d)
        },
        IsClockwiseFrom(b, d) {
            return e.angleClockwise(e.toRadians(b), e.toRadians(d))
        },
        IsBetweenAngles(b, d, c) {
            b = e.toRadians(b);
            d = e.toRadians(d);
            c = e.toRadians(c);
            return e.angleClockwise(c,
                d) ? e.angleClockwise(b, d) && !e.angleClockwise(b, c) : !(!e.angleClockwise(b, d) && e.angleClockwise(b, c))
        },
        IsValueType(b, d) {
            return "number" === typeof b ? 0 === d : 1 === d
        },
        EvaluateExpression(b) {
            return !!b
        },
        PickByComparison(b, d, c, f) {
            if (!b) return !1;
            const k = this._GetForEachStack(),
                h = k.Push(),
                l = b.GetCurrentSol();
            e.shallowAssignArray(h, l.GetInstances());
            l.IsSelectAll() && e.clearArray(l._GetOwnElseInstances());
            const n = this._runtime.GetCurrentCondition();
            let u = 0;
            for (let w = 0, q = h.length; w < q; ++w) {
                const t = h[w];
                h[u] = t;
                d = n.ReevaluateParameter(1,
                    w);
                f = n.ReevaluateParameter(3, w);
                e.compare(d, c, f) ? ++u : l._PushElseInstance(t)
            }
            e.truncateArray(h, u);
            l.SetArrayPicked(h);
            d = !!h.length;
            e.clearArray(h);
            k.Pop();
            b.ApplySolToContainer();
            return d
        },
        PickByEvaluate(b, d) {
            if (!b) return !1;
            const c = this._GetForEachStack(),
                f = c.Push(),
                k = b.GetCurrentSol();
            e.shallowAssignArray(f, k.GetInstances());
            k.IsSelectAll() && e.clearArray(k._GetOwnElseInstances());
            const h = this._runtime.GetCurrentCondition();
            let l = 0;
            for (let n = 0, u = f.length; n < u; ++n) {
                const w = f[n];
                f[l] = w;
                (d = h.ReevaluateParameter(1,
                    n)) ? ++l: k._PushElseInstance(w)
            }
            e.truncateArray(f, l);
            k.SetArrayPicked(f);
            d = !!f.length;
            e.clearArray(f);
            c.Pop();
            b.ApplySolToContainer();
            return d
        },
        PickNth(b, d) {
            if (!b) return !1;
            const c = b.GetCurrentSol(),
                f = c.GetInstances();
            d = Math.floor(d);
            if (d >= f.length) return !1;
            c.PickOne(f[d]);
            b.ApplySolToContainer();
            return !0
        },
        PickRandom(b) {
            if (!b) return !1;
            const d = b.GetCurrentSol(),
                c = d.GetInstances(),
                f = Math.floor(this._runtime.Random() * c.length);
            if (f >= c.length) return !1;
            d.PickOne(c[f]);
            b.ApplySolToContainer();
            return !0
        },
        PickAll(b) {
            if (!b ||
                !b.GetInstanceCount()) return !1;
            b.GetCurrentSol()._SetSelectAll(!0);
            b.ApplySolToContainer();
            return !0
        },
        PickOverlappingPoint(b, d, c) {
            if (!b) return !1;
            const f = b.GetCurrentSol();
            var k = f.GetInstances();
            const h = this._runtime.GetCurrentEvent().IsOrBlock(),
                l = this._runtime.GetCurrentCondition().IsInverted();
            f.IsSelectAll() ? (e.shallowAssignArray(a, k), f.ClearArrays(), f._SetSelectAll(!1)) : h ? (e.shallowAssignArray(a, f._GetOwnElseInstances()), e.clearArray(f._GetOwnElseInstances())) : (e.shallowAssignArray(a, f._GetOwnInstances()),
                e.clearArray(f._GetOwnInstances()));
            for (let n = 0, u = a.length; n < u; ++n) k = a[n], e.xor(k.GetWorldInfo().ContainsPoint(d, c), l) ? f._PushInstance(k) : f._PushElseInstance(k);
            b.ApplySolToContainer();
            return e.xor(!!f._GetOwnInstances().length, l)
        },
        PickLastCreated(b) {
            if (!b) return !1;
            var d = b.IsFamily();
            let c = null;
            const f = this._runtime._GetInstancesPendingCreate();
            for (let k = f.length - 1; 0 <= k; --k) {
                const h = f[k];
                if (d) {
                    if (h.GetObjectClass().BelongsToFamily(b)) {
                        c = h;
                        break
                    }
                } else if (h.GetObjectClass() === b) {
                    c = h;
                    break
                }
            }
            c || (d = b.GetInstances(),
                d.length && (c = d.at(-1)));
            if (!c) return !1;
            b.GetCurrentSol().PickOne(c);
            b.ApplySolToContainer();
            return !0
        },
        Repeat(b) {
            return this._runtime.IsDebugging() ? this._DebugRepeat(b) : this._Repeat(b)
        },
        While() {
            return this._runtime.IsDebugging() ? this._DebugWhile() : this._While()
        },
        For(b, d, c) {
            return this._runtime.IsDebugging() ? this._DebugFor(b, d, c) : this._For(b, d, c)
        },
        ForEach(b) {
            return this._runtime.IsDebugging() ? this._DebugForEach(b) : this._ForEach(b)
        },
        ForEachOrdered(b, d, c) {
            return this._runtime.IsDebugging() ? this._DebugForEachOrdered(b,
                c) : this._ForEachOrdered(b, c)
        },
        LayerVisible(b) {
            return b ? b.IsVisible() : !1
        },
        LayerEmpty(b) {
            return b ? !b.GetInstanceCount() : !1
        },
        LayerCmpOpacity(b, d, c) {
            return b ? e.compare(100 * b.GetOpacity(), d, c) : !1
        },
        OnImageLoadingComplete() {
            return !0
        },
        IsLoadingImages() {
            return 0 < this._imagesLoadingTotal
        }
    }
} {
    "use strict";
    const e = self.C3;

    function a(h, l) {
        const n = h[0] - l[0];
        return 0 !== n ? n : h[1] - l[1]
    }

    function b(h, l) {
        return h[1] - l[1]
    }
    const d = [],
        c = [],
        f = e.New(e.Rect),
        k = e.New(e.Color);
    e.Plugins.System.Acts = {
        SetVar(h, l) {
            h.SetValue(l)
        },
        AddVar(h, l) {
            h.IsNumber() && "number" !== typeof l && (l = parseFloat(l));
            h.SetValue(h.GetValue() + l)
        },
        SubVar(h, l) {
            h.IsNumber() && h.SetValue(h.GetValue() - l)
        },
        SetBoolVar(h, l) {
            h.SetValue(!!l)
        },
        ToggleBoolVar(h) {
            h.SetValue(!h.GetValue())
        },
        ResetGlobals() {
            this._runtime.GetEventSheetManager().ResetAllGlobalsToInitialValue()
        },
        CreateObject(h, l, n, u, w) {
            h && l && (n = this._runtime.CreateInstance(h, l, n, u, w)) && (w && l.SortAndAddInstancesByZIndex(n), l = this._runtime.GetEventSheetManager(), l.BlockFlushingInstances(!0), n._TriggerOnCreatedOnSelfAndRelated(), l.BlockFlushingInstances(!1), h.GetCurrentSol().SetSinglePicked(n), n.IsInContainer() && n.SetSiblingsSinglePicked())
        },
        CreateObjectByName(h, l, n, u, w) {
            h && l && (h = this._runtime.GetObjectClassByName(h)) && e.Plugins.System.Acts.CreateObject.call(this, h, l, n, u, w)
        },
        RecreateInitialObjects(h, l, n, u, w,
            q, t, p, r, x) {
            if (h) {
                var y = this._runtime.GetCurrentLayout();
                if (q && (y = this._runtime.GetLayoutManager().GetLayoutByName(q), !y)) return;
                q = null;
                if ("number" !== typeof t || 0 <= t)
                    if (q = y.GetLayer(t), !q) return;
                f.set(l, n, u, w);
                l = y.RecreateInitialObjects(h, f, q, p, r, x);
                h.GetCurrentSol().SetArrayPicked(l);
                h.ApplySolToContainer()
            }
        },
        StopLoop() {
            const h = this._loopStack;
            h.IsInLoop() && h.GetCurrent().Stop()
        },
        SetGroupActive(h, l) {
            (h = this._runtime.GetEventSheetManager().GetEventGroupByName(h)) && (0 === l ? h.SetGroupActive(!1) : 1 === l ?
                h.SetGroupActive(!0) : h.SetGroupActive(!h.IsGroupActive()))
        },
        SetTimescale(h) {
            this._runtime.SetTimeScale(h)
        },
        SetObjectTimescale(h, l) {
            0 > l && (l = 0);
            if (h) {
                h = h.GetCurrentSol().GetInstances();
                for (const n of h) n.SetTimeScale(l)
            }
        },
        RestoreObjectTimescale(h) {
            if (h) {
                h = h.GetCurrentSol().GetInstances();
                for (const l of h) l.RestoreTimeScale()
            }
        },
        Wait(h) {
            if (!(0 > h)) return this._runtime.GetEventSheetManager().AddScheduledWait().InitTimer(h), !0
        },
        WaitForSignal(h) {
            this._runtime.GetEventSheetManager().AddScheduledWait().InitSignal(h);
            return !0
        },
        WaitForPreviousActions() {
            const h = this._runtime.GetEventSheetManager();
            h.AddScheduledWait().InitPromise(h.GetPromiseForAllAsyncActions());
            return !0
        },
        Signal(h) {
            h = h.toLowerCase();
            for (const l of this._runtime.GetEventSheetManager().scheduledWaits()) l.IsSignal() && l.GetSignalTag() === h && l.SetSignalled()
        },
        async SnapshotCanvas(h, l, n, u, w, q) {
            const t = this._runtime.GetCanvasManager();
            t && (this.UpdateRender(), await t.SnapshotCanvas(0 === h ? "image/png" : "image/jpeg", l / 100, n, u, w, q), await this._runtime.TriggerAsync(e.Plugins.System.Cnds.OnCanvasSnapshot,
                null))
        },
        SetCanvasSize(h, l) {
            if (!(0 >= h || 0 >= l)) {
                this._runtime.SetViewportSize(h, l);
                var n = this._runtime.GetCurrentLayout();
                n.BoundScrolling();
                for (const u of n.GetLayers()) u.UpdateViewport();
                if (n = this._runtime.GetCanvasManager()) "off" !== n.GetCurrentFullscreenMode() && this._runtime.SetOriginalViewportSize(h, l), n.SetSize(n.GetLastWidth(), n.GetLastHeight(), !0), this._runtime.UpdateRender()
            }
        },
        SetFullscreenQuality(h) {
            const l = this._runtime.GetCanvasManager();
            l && "off" !== l.GetCurrentFullscreenMode() && (l.SetFullscreenScalingQuality(0 !==
                h ? "high" : "low"), l.SetSize(l.GetLastWidth(), l.GetLastHeight(), !0))
        },
        SaveState(h) {
            this._runtime.SaveToSlot(h)
        },
        LoadState(h) {
            this._runtime.LoadFromSlot(h)
        },
        LoadStateJSON(h) {
            this._runtime.LoadFromJsonString(h)
        },
        SetHalfFramerateMode(h) {},
        ResetPersisted() {
            for (const h of this._runtime.GetLayoutManager().GetAllLayouts()) h.ResetPersistData()
        },
        SetPixelRounding(h) {
            this._runtime.SetPixelRoundingEnabled(0 !== h)
        },
        SetMinimumFramerate(h) {
            this._runtime.SetMinimumFramerate(h)
        },
        SortZOrderByInstVar(h, l) {
            if (h) {
                var n = h.GetCurrentSol().GetInstances(),
                    u = this._runtime.GetCurrentLayout(),
                    w = h.IsFamily();
                h = h.GetFamilyIndex();
                for (let t = 0, p = n.length; t < p; ++t) {
                    var q = n[t];
                    const r = q.GetWorldInfo();
                    if (!r) continue;
                    let x;
                    x = w ? q.GetInstanceVariableValue(l + q.GetObjectClass().GetFamilyInstanceVariableOffset(h)) : q.GetInstanceVariableValue(l);
                    d.push([r.GetLayer().GetIndex(), r.GetZIndex()]);
                    c.push([q, x])
                }
                if (d.length) {
                    d.sort(a);
                    c.sort(b);
                    l = !1;
                    for (let t = 0, p = d.length; t < p; ++t) n = c[t][0], w = u.GetLayerByIndex(d[t][0]), h = d[t][1], q = w._GetInstances(), q[h] !== n && (q[h] = n, n.GetWorldInfo()._SetLayer(w),
                        w.SetZIndicesChanged(), l = !0);
                    l && this._runtime.UpdateRender();
                    e.clearArray(d);
                    e.clearArray(c)
                }
            }
        },
        GoToLayout(h) {
            if (!this._runtime.IsLoading()) {
                var l = this._runtime.GetLayoutManager();
                l.IsPendingChangeMainLayout() || l.ChangeMainLayout(h)
            }
        },
        GoToLayoutByName(h) {
            if (!this._runtime.IsLoading()) {
                var l = this._runtime.GetLayoutManager();
                l.IsPendingChangeMainLayout() || (h = l.GetLayoutByName(h)) && l.ChangeMainLayout(h)
            }
        },
        NextPrevLayout(h) {
            if (!this._runtime.IsLoading()) {
                var l = this._runtime.GetLayoutManager();
                if (!l.IsPendingChangeMainLayout()) {
                    var n =
                        l.GetAllLayouts(),
                        u = n.indexOf(l.GetMainRunningLayout());
                    h && 0 === u || (h || u !== n.length - 1) && l.ChangeMainLayout(n[u + (h ? -1 : 1)])
                }
            }
        },
        RestartLayout() {
            if (!this._runtime.IsLoading()) {
                var h = this._runtime.GetLayoutManager();
                h.IsPendingChangeMainLayout() || (h.ChangeMainLayout(h.GetMainRunningLayout()), this._runtime.GetEventSheetManager().ResetAllGroupsInitialActivation())
            }
        },
        SetLayerVisible(h, l) {
            h && h.SetVisible(l)
        },
        SetLayerOpacity(h, l) {
            h && h.SetOpacity(l / 100)
        },
        SetLayerScale(h, l) {
            h && h.SetOwnScale(l)
        },
        SetLayerScaleRate(h,
            l) {
            h && h.SetScaleRate(l)
        },
        SetLayerAngle(h, l) {
            h && h.SetAngle(e.toRadians(+l))
        },
        SetLayerScroll(h, l, n) {
            h && (h.SetOwnScrollPositionEnabled(!0), h.SetScrollX(l), h.SetScrollY(n))
        },
        RestoreLayerScroll(h) {
            h && h.SetOwnScrollPositionEnabled(!1)
        },
        SetLayerParallax(h, l, n) {
            h && h.SetParallax(l / 100, n / 100)
        },
        SetLayerZElevation(h, l) {
            h && h.SetZElevation(+l)
        },
        SetLayerBackground(h, l) {
            h && (k.setFromRgbValue(l), k.clamp(), h = h.GetBackgroundColor(), h.equalsIgnoringAlpha(k) || (h.copyRgb(k), this.UpdateRender()))
        },
        SetLayerTransparent(h,
            l) {
            h && h.SetTransparent(l)
        },
        SetLayerBlendMode(h, l) {
            h && h.SetBlendMode(l)
        },
        SetLayerEffectEnabled(h, l, n) {
            h && (n = h.GetEffectList().GetEffectTypeByName(n)) && (l = 1 === l, n.IsActive() !== l && (n.SetActive(l), h.UpdateActiveEffects(), this._runtime.UpdateRender()))
        },
        SetLayerEffectParam(h, l, n, u) {
            if (h && (h = h.GetEffectList(), l = h.GetEffectTypeByName(l))) {
                var w = l.GetIndex();
                h = h.GetEffectParametersForIndex(w);
                n = Math.floor(n);
                if (!(0 > n || n >= h.length)) {
                    w = l.GetShaderProgram().GetParameterType(n);
                    if ("color" === w) {
                        k.setFromRgbValue(u);
                        n = h[n];
                        if (k.equalsIgnoringAlpha(n)) return;
                        n.copyRgb(k)
                    } else {
                        "percent" === w && (u /= 100);
                        if (h[n] === u) return;
                        h[n] = u
                    }
                    l.IsActive() && this._runtime.UpdateRender()
                }
            }
        },
        SetLayerForceOwnTexture(h, l) {
            h && h.SetForceOwnTexture(l)
        },
        SetLayoutScale(h) {
            this._runtime.GetCurrentLayout().SetScale(+h)
        },
        SetLayoutAngle(h) {
            this._runtime.GetCurrentLayout().SetAngle(e.toRadians(+h))
        },
        SetLayoutEffectEnabled(h, l) {
            const n = this._runtime.GetCurrentLayout();
            if (l = n.GetEffectList().GetEffectTypeByName(l)) h = 1 === h, l.IsActive() !== h && (l.SetActive(h),
                n.UpdateActiveEffects(), this._runtime.UpdateRender())
        },
        SetLayoutEffectParam(h, l, n) {
            var u = this._runtime.GetCurrentLayout().GetEffectList();
            if (h = u.GetEffectTypeByName(h)) {
                var w = h.GetIndex();
                u = u.GetEffectParametersForIndex(w);
                l = Math.floor(l);
                if (!(0 > l || l >= u.length)) {
                    w = h.GetShaderProgram().GetParameterType(l);
                    if ("color" === w) {
                        k.setFromRgbValue(n);
                        l = u[l];
                        if (k.equalsIgnoringAlpha(l)) return;
                        l.copyRgb(k)
                    } else {
                        "percent" === w && (n /= 100);
                        if (u[l] === n) return;
                        u[l] = n
                    }
                    h.IsActive() && this._runtime.UpdateRender()
                }
            }
        },
        SetLayoutVanishingPoint(h,
            l) {
            this._runtime.GetCurrentLayout().SetVanishingPointXY(h / 100, l / 100)
        },
        SetLayoutProjection(h) {
            const l = this._runtime.GetCurrentLayout();
            0 === h ? l.SetPerspectiveProjection() : l.SetOrthographicProjection()
        },
        ScrollX(h) {
            this._runtime.GetCurrentLayout().SetScrollX(h)
        },
        ScrollY(h) {
            this._runtime.GetCurrentLayout().SetScrollY(h)
        },
        Scroll(h, l) {
            const n = this._runtime.GetCurrentLayout();
            n.SetScrollX(h);
            n.SetScrollY(l)
        },
        ScrollToObject(h) {
            if (h && (h = h.GetFirstPicked()) && (h = h.GetWorldInfo())) {
                var l = this._runtime.GetCurrentLayout();
                l.SetScrollX(h.GetX());
                l.SetScrollY(h.GetY())
            }
        },
        async LoadObjectTextures(h) {
            const l = this._runtime.GetMainRunningLayout();
            l && h && !this._runtime.IsLoading() && (h = h.IsFamily() ? h.GetFamilyMembers() : [h], await this._LoadTexturesForObjectClasses(l, h))
        },
        async LoadObjectTexturesByName(h) {
            await e.Plugins.System.Acts.LoadObjectTextures.call(this, this._runtime.GetObjectClassByName(h))
        },
        UnloadObjectTextures(h) {
            const l = this._runtime.GetMainRunningLayout();
            l && h && (h = h.IsFamily() ? h.GetFamilyMembers() : [h], this._UnloadTexturesForObjectClasses(l,
                h))
        },
        UnloadObjectTexturesByName(h) {
            e.Plugins.System.Acts.UnloadObjectTextures.call(this, this._runtime.GetObjectClassByName(h))
        },
        UnloadUnusedTextures() {
            const h = this._runtime.GetMainRunningLayout();
            if (h) {
                var l = h._GetTextureLoadedObjectTypes();
                this._UnloadTexturesForObjectClasses(h, l)
            }
        },
        async LoadLayoutTextures(h) {
            const l = this._runtime.GetMainRunningLayout();
            h && l && !this._runtime.IsLoading() && await this._LoadTexturesForObjectClasses(l, h._GetInitialObjectClasses())
        },
        async LoadLayoutTexturesByName(h) {
            const l =
                this._runtime.GetMainRunningLayout();
            (h = this._runtime.GetLayoutManager().GetLayoutByName(h)) && l && !this._runtime.IsLoading() && await this._LoadTexturesForObjectClasses(l, h._GetInitialObjectClasses())
        },
        SetFunctionReturnValue(h) {
            const l = this._eventStack.GetCurrentExpFuncStackFrame();
            if (l) switch (l.GetFunctionReturnType()) {
                case 1:
                    "number" === typeof h && l.SetFunctionReturnValue(h);
                    break;
                case 2:
                    "string" === typeof h && l.SetFunctionReturnValue(h);
                    break;
                case 3:
                    l.SetFunctionReturnValue(h)
            }
        },
        MapFunction(h, l, n) {
            var u =
                this._GetFunctionMap(h.toLowerCase(), !0);
            const w = u.strMap,
                q = l.toLowerCase();
            w.has(q) && console.warn(`[Construct 3] Function map '${h}' string '${l}' already in map; overwriting entry`);
            if (u = e.first(w.values()) || u.defaultFunc) {
                u = 0 !== u.GetReturnType();
                const t = 0 !== n.GetReturnType();
                if (u !== t) {
                    console.error(`[Construct 3] Function map '${h}' string '${l}' function return type not compatible with other functions in the map; entry ignored`);
                    return
                }
            }
            w.set(q, n)
        },
        MapFunctionDefault(h, l) {
            const n = this._GetFunctionMap(h.toLowerCase(),
                !0);
            n.defaultFunc && console.warn(`[Construct 3] Function map '${h}' already has a default; overwriting entry`);
            var u = e.first(n.strMap.values()) || n.defaultFunc;
            if (u) {
                u = 0 !== u.GetReturnType();
                const w = 0 !== l.GetReturnType();
                if (u !== w) {
                    console.error(`[Construct 3] Function map '${h}' default: function return type not compatible with other functions in the map; entry ignored`);
                    return
                }
            }
            n.defaultFunc = l
        },
        CallMappedFunction(h, l, n) {
            n = Math.floor(n);
            var u = this._GetFunctionMap(h.toLowerCase(), !1);
            if (u) {
                var w = u.strMap.get(l.toLowerCase());
                if (!w)
                    if (u.defaultFunc) w = u.defaultFunc, n = 0;
                    else {
                        console.warn(`[Construct 3] Call mapped function: no function associated with map '${h}' string '${l}'; call ignored (consider setting a default)`);
                        return
                    } if (w.IsEnabled())
                    if (0 !== w.GetReturnType()) console.warn(`[Construct 3] Call mapped function: map '${h}' string '${l}' has a return type so cannot be called`);
                    else {
                        h = this._runtime;
                        l = h.GetEventSheetManager();
                        var q = l.GetCurrentEvent();
                        u = q.GetSolModifiersIncludingParents();
                        var t = 0 < u.length;
                        t && l.PushCleanSol(u);
                        var p = [];
                        if (q = l.FindFirstFunctionBlockParent(q)) {
                            q = q.GetFunctionParameters();
                            for (let r = n, x = q.length; r < x; ++r) p.push(q[r].GetValue())
                        }
                        n = w.GetFunctionParameters();
                        for (let r = p.length, x = n.length; r < x; ++r) p.push(n[r].GetInitialValue());
                        return h.IsDebugging() ? this._DebugDoCallMappedFunction(l, w, p, t, u) : this._DoCallMappedFunction(l, w, p, t, u)
                    }
            } else console.warn(`[Construct 3] Call mapped function: map name '${h}' not found; call ignored`)
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.System.Exps = {
        int: function (a) {
            "string" === typeof a && (a = parseInt(a, 10), isNaN(a) && (a = 0));
            return Math.floor(a)
        },
        float: function (a) {
            "string" === typeof a && (a = parseFloat(a), isNaN(a) && (a = 0));
            return a
        },
        str(a) {
            return a.toString()
        },
        len(a) {
            return "string" === typeof a ? a.length : 0
        },
        random(a, b) {
            return "undefined" === typeof b ? this._runtime.Random() * a : this._runtime.Random() * (b - a) + a
        },
        choose(...a) {
            const b = Math.floor(this._runtime.Random() * a.length);
            return a[b]
        },
        pi() {
            return Math.PI
        },
        infinity() {
            return Infinity
        },
        sqrt(a) {
            return Math.sqrt(a)
        },
        abs(a) {
            return Math.abs(a)
        },
        round(a) {
            return Math.round(a)
        },
        roundtodp(a, b) {
            b = Math.max(Math.floor(b), 0);
            b = Math.pow(10, b);
            return Math.round((a + Number.EPSILON) * b) / b
        },
        floor(a) {
            return Math.floor(a)
        },
        ceil(a) {
            return Math.ceil(a)
        },
        sign(a) {
            return Math.sign(a)
        },
        sin(a) {
            return Math.sin(e.toRadians(a))
        },
        cos(a) {
            return Math.cos(e.toRadians(a))
        },
        tan(a) {
            return Math.tan(e.toRadians(a))
        },
        asin(a) {
            return e.toDegrees(Math.asin(a))
        },
        acos(a) {
            return e.toDegrees(Math.acos(a))
        },
        atan(a) {
            return e.toDegrees(Math.atan(a))
        },
        exp(a) {
            return Math.exp(a)
        },
        ln(a) {
            return Math.log(a)
        },
        log10(a) {
            return Math.log(a) / Math.LN10
        },
        max(...a) {
            let b = a[0];
            "number" !== typeof b && (b = 0);
            for (let d = 1, c = a.length; d < c; ++d) {
                let f = a[d];
                "number" === typeof f && b < f && (b = f)
            }
            return b
        },
        min(...a) {
            let b = a[0];
            "number" !== typeof b && (b = 0);
            for (let d = 1, c = a.length; d < c; ++d) {
                let f = a[d];
                "number" === typeof f && b > f && (b = f)
            }
            return b
        },
        clamp(a, b, d) {
            return e.clamp(a, b, d)
        },
        distance(a, b, d, c) {
            return e.distanceTo(a, b, d, c)
        },
        angle(a, b, d, c) {
            return e.toDegrees(e.angleTo(a, b, d, c))
        },
        lerp(a,
            b, d) {
            return e.lerp(a, b, d)
        },
        unlerp(a, b, d) {
            return e.unlerp(a, b, d)
        },
        qarp(a, b, d, c) {
            return e.qarp(a, b, d, c)
        },
        cubic(a, b, d, c, f) {
            return e.cubic(a, b, d, c, f)
        },
        cosp(a, b, d) {
            return e.cosp(a, b, d)
        },
        anglediff(a, b) {
            return e.toDegrees(e.angleDiff(e.toRadians(a), e.toRadians(b)))
        },
        anglelerp(a, b, d) {
            return e.toDegrees(e.angleLerp(e.toRadians(a), e.toRadians(b), d))
        },
        anglerotate(a, b, d) {
            return e.toDegrees(e.angleRotate(e.toRadians(a), e.toRadians(b), e.toRadians(d)))
        },
        setbit(a, b, d) {
            b |= 0;
            return (a | 0) & ~(1 << b) | (0 !== d ? 1 : 0) << b
        },
        togglebit(a,
            b) {
            return (a | 0) ^ 1 << (b | 0)
        },
        getbit(a, b) {
            return (a | 0) & 1 << (b | 0) ? 1 : 0
        },
        newline() {
            return "\n"
        },
        uppercase(a) {
            return "string" === typeof a ? a.toUpperCase() : ""
        },
        lowercase(a) {
            return "string" === typeof a ? a.toLowerCase() : ""
        },
        left(a, b) {
            return "string" === typeof a ? a.substr(0, b) : ""
        },
        mid(a, b, d) {
            return "string" !== typeof a ? "" : 0 > d ? a.substr(b) : a.substr(b, d)
        },
        right(a, b) {
            return "string" === typeof a ? a.substr(Math.max(a.length - b, 0)) : ""
        },
        trim(a) {
            return "string" === typeof a ? a.trim() : ""
        },
        tokenat(a, b, d) {
            if ("string" !== typeof a || "string" !== typeof d) return "";
            a = a.split(d);
            b = Math.floor(b);
            return 0 > b || b >= a.length ? "" : a[b]
        },
        tokencount(a, b) {
            return "string" === typeof a && "string" === typeof b && a.length ? a.split(b).length : 0
        },
        find(a, b) {
            return "string" === typeof a && "string" === typeof b ? a.search(new RegExp(e.EscapeRegex(b), "i")) : -1
        },
        findcase(a, b) {
            return "string" === typeof a && "string" === typeof b ? a.search(new RegExp(e.EscapeRegex(b), "")) : -1
        },
        replace(a, b, d) {
            return "string" === typeof a && "string" === typeof b && "string" === typeof d ? a.replace(new RegExp(e.EscapeRegex(b), "gi"), d) : "string" ===
                typeof a ? a : ""
        },
        regexsearch(a, b, d) {
            b = this.GetRegex(b, d);
            return a ? a.search(b) : -1
        },
        regexreplace(a, b, d, c) {
            b = this.GetRegex(b, d);
            return a ? a.replace(b, c) : ""
        },
        regexmatchcount(a, b, d) {
            return (a = this.GetRegexMatches(a.toString(), b, d)) ? a.length : 0
        },
        regexmatchat(a, b, d, c) {
            c = Math.floor(c);
            a = this.GetRegexMatches(a.toString(), b, d);
            return !a || 0 > c || c >= a.length ? "" : a[c]
        },
        zeropad(a, b) {
            let d = 0 > a ? "-" : "";
            0 > a && (a = -a);
            d += "0".repeat(Math.max(b - a.toString().length, 0));
            return d + a.toString()
        },
        urlencode(a) {
            return encodeURIComponent(a)
        },
        urldecode(a) {
            return decodeURIComponent(a)
        },
        dt() {
            return this._runtime._GetDtFast()
        },
        timescale() {
            return this._runtime.GetTimeScale()
        },
        wallclocktime() {
            return (Date.now() - this._runtime.GetStartTime()) / 1E3
        },
        unixtime() {
            return Date.now()
        },
        time() {
            return this._runtime.GetGameTime()
        },
        tickcount() {
            return this._runtime.GetTickCount()
        },
        objectcount() {
            return this._runtime.GetObjectCount()
        },
        fps() {
            return this._runtime.GetFPS()
        },
        cpuutilisation() {
            return this._runtime.GetMainThreadTime()
        },
        gpuutilisation() {
            return this._runtime.GetGPUUtilisation()
        },
        windowwidth() {
            return this._runtime.GetCanvasManager().GetDeviceWidth()
        },
        windowheight() {
            return this._runtime.GetCanvasManager().GetDeviceHeight()
        },
        originalwindowwidth() {
            return this._runtime.GetOriginalViewportWidth()
        },
        originalwindowheight() {
            return this._runtime.GetOriginalViewportHeight()
        },
        originalviewportwidth() {
            return this._runtime.GetOriginalViewportWidth()
        },
        originalviewportheight() {
            return this._runtime.GetOriginalViewportHeight()
        },
        scrollx() {
            return this._runtime.GetCurrentLayout().GetScrollX()
        },
        scrolly() {
            return this._runtime.GetCurrentLayout().GetScrollY()
        },
        layoutname() {
            return this._runtime.GetCurrentLayout().GetName()
        },
        layoutscale() {
            return this._runtime.GetCurrentLayout().GetScale()
        },
        layoutangle() {
            return e.toDegrees(this._runtime.GetCurrentLayout().GetAngle())
        },
        layoutwidth() {
            return this._runtime.GetCurrentLayout().GetWidth()
        },
        layoutheight() {
            return this._runtime.GetCurrentLayout().GetHeight()
        },
        viewportleft(a) {
            return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.GetViewport3D().getLeft() :
                0
        },
        viewporttop(a) {
            return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.GetViewport3D().getTop() : 0
        },
        viewportright(a) {
            return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.GetViewport3D().getRight() : 0
        },
        viewportbottom(a) {
            return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.GetViewport3D().getBottom() : 0
        },
        viewportwidth(a) {
            return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.GetViewport3D().width() : 0
        },
        viewportheight(a) {
            return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.GetViewport3D().height() :
                0
        },
        canvastolayerx(a, b, d) {
            return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.CanvasCssToLayer(b, d)[0] : 0
        },
        canvastolayery(a, b, d) {
            return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.CanvasCssToLayer(b, d)[1] : 0
        },
        layertocanvasx(a, b, d) {
            return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.LayerToCanvasCss(b, d)[0] : 0
        },
        layertocanvasy(a, b, d) {
            return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.LayerToCanvasCss(b, d)[1] : 0
        },
        layerscale(a) {
            return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.GetOwnScale() :
                0
        },
        layerangle(a) {
            return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? e.toDegrees(a.GetOwnAngle()) : 0
        },
        layeropacity(a) {
            return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? 100 * a.GetOpacity() : 0
        },
        layerscalerate(a) {
            return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.GetScaleRate() : 0
        },
        layerscrollx(a) {
            return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.GetScrollX() : 0
        },
        layerscrolly(a) {
            return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.GetScrollY() : 0
        },
        layerparallaxx(a) {
            return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ?
                100 * a.GetParallaxX() : 0
        },
        layerparallaxy(a) {
            return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? 100 * a.GetParallaxY() : 0
        },
        layerzelevation(a) {
            return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.GetZElevation() : 0
        },
        layerindex(a) {
            return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.GetIndex() : -1
        },
        canvassnapshot() {
            const a = this._runtime.GetCanvasManager();
            return a ? a.GetCanvasSnapshotUrl() : ""
        },
        loopindex(a) {
            const b = this._loopStack;
            return b.IsInLoop() ? a ? (a = b.FindByName(a)) ? a.GetIndex() : 0 : b.GetCurrent().GetIndex() :
                0
        },
        savestatejson() {
            return this._runtime.GetLastSaveJsonString()
        },
        callmapped(a, b, ...d) {
            var c = this._GetFunctionMap(a.toLowerCase(), !1);
            if (!c) return console.warn(`[Construct 3] Call mapped function: map name '${a}' not found; returning 0`), 0;
            var f = c.strMap.get(b.toLowerCase());
            if (!f)
                if (c.defaultFunc) f = c.defaultFunc;
                else return console.warn(`[Construct 3] Call mapped function: no function associated with map '${a}' string '${b}'; returning 0 (consider setting a default)`), 0;
            c = f.GetReturnType();
            const k =
                f.GetDefaultReturnValue();
            if (0 === c) return console.warn(`[Construct 3] Call mapped function: map '${a}' string '${b}' has no return type so cannot be called from an expression; returning 0`), 0;
            if (!f.IsEnabled()) return k;
            a = this._runtime.GetEventSheetManager();
            b = a.GetCurrentEvent().GetSolModifiersIncludingParents();
            const h = 0 < b.length;
            h && a.PushCleanSol(b);
            const l = f.GetFunctionParameters();
            for (let n = d.length, u = l.length; n < u; ++n) d.push(l[n].GetInitialValue());
            f = f.GetEventBlock();
            d = f.RunAsExpressionFunctionCall(f.GetSolModifiersIncludingParents(),
                c, k, ...d);
            h && a.PopSol(b);
            return d
        },
        loadingprogress() {
            return this._runtime.GetAssetManager().GetLoadProgress()
        },
        imageloadingprogress() {
            return 0 === this._imagesLoadingTotal ? 1 : this._imagesLoadingComplete / this._imagesLoadingTotal
        },
        renderer() {
            return this._runtime.GetWebGPURenderer() ? "webgpu" : "webgl"
        },
        rendererdetail() {
            return this._runtime.GetWebGPURenderer() ? "<unavailable>" : this._runtime.GetWebGLRenderer().GetUnmaskedRenderer()
        },
        imagememoryusage() {
            let a = this._runtime.GetRenderer().GetEstimatedTextureMemoryUsage();
            return Math.round(100 * a / 1048576) / 100
        },
        rgb(a, b, d) {
            return e.PackRGB(a, b, d)
        },
        rgbex(a, b, d) {
            return e.PackRGBEx(a / 100, b / 100, d / 100)
        },
        rgba(a, b, d, c) {
            return e.PackRGBAEx(a / 100, b / 100, d / 100, c / 100)
        },
        rgbex255(a, b, d) {
            return e.PackRGBEx(a / 255, b / 255, d / 255)
        },
        rgba255(a, b, d, c) {
            return e.PackRGBAEx(a / 255, b / 255, d / 255, c / 255)
        },
        projectname() {
            return this._runtime.GetProjectName()
        },
        projectversion() {
            return this._runtime.GetProjectVersion()
        },
        currenteventsheetname() {
            return this._runtime.GetCurrentEvent().GetEventSheet().GetName()
        },
        currenteventnumber() {
            return this._runtime.GetCurrentEvent().GetDisplayNumber()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.Sprite = class extends e.SDKPluginBase {
        constructor(a) {
            super(a)
        }
        Release() {
            super.Release()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.Sprite.Type = class extends e.SDKTypeBase {
        constructor(a) {
            super(a);
            this._animations = a.GetAnimations()
        }
        Release() {
            e.clearArray(this._animations);
            super.Release()
        }
        OnCreate() {
            for (const a of this._animations) a.LoadAllAssets(this._runtime)
        }
        LoadTextures(a) {
            const b = {
                sampling: this._runtime.GetSampling()
            };
            return Promise.all(this._animations.map(d => d.LoadAllTextures(a, b)))
        }
        ReleaseTextures() {
            for (const a of this._animations) a.ReleaseAllTextures()
        }
        OnDynamicTextureLoadComplete() {
            this._UpdateAllCurrentTexture()
        }
        _UpdateAllCurrentTexture() {
            for (const a of this._objectClass.instancesIncludingPendingCreate()) a.GetSdkInstance()._UpdateCurrentTexture()
        }
        FinishCondition(a) {
            e.Plugins.Sprite.FinishCollisionCondition(this,
                a)
        }
    }
} {
    "use strict";
    const e = self.C3,
        a = self.C3X,
        b = e.New(e.Rect),
        d = e.New(e.Quad),
        c = e.New(e.Vector2);
    e.Plugins.Sprite.Instance = class extends e.SDKWorldInstanceBase {
        constructor(h, l) {
            super(h);
            let n = !0,
                u = "",
                w = 0,
                q = !0;
            l && (n = !!l[0], u = l[1], w = l[2], q = l[3]);
            this._currentAnimation = this._objectClass.GetAnimationByName(u) || this._objectClass.GetAnimations()[0];
            this._currentFrameIndex = e.clamp(w, 0, this._currentAnimation.GetFrameCount() - 1);
            this._currentAnimationFrame = this._currentAnimation.GetFrameAt(this._currentFrameIndex);
            l =
                this._currentAnimationFrame.GetImageInfo();
            this._currentTexture = l.GetTexture();
            this._currentRcTex = l.GetTexRect();
            this._currentQuadTex = l.GetTexQuad();
            this.HandleWebGLContextLoss();
            h.SetFlag(2, !0);
            h.SetFlag(1, 0 <= this._currentAnimation.GetSpeed());
            this._currentAnimationSpeed = Math.abs(this._currentAnimation.GetSpeed());
            this._currentAnimationRepeatTo = this._currentAnimation.GetRepeatTo();
            this._animationTimer = e.New(e.KahanSum);
            this._animationRepeats = this._frameStartTime = 0;
            this._animTriggerName = "";
            this._changeAnimFrameIndex = -1;
            this._changeAnimationName = "";
            this._changeAnimationFrom = 0;
            h = this.GetWorldInfo();
            this._bquadRef = h.GetBoundingQuad();
            h.SetVisible(n);
            h.SetCollisionEnabled(q);
            h.SetOriginX(this._currentAnimationFrame.GetOriginX());
            h.SetOriginY(this._currentAnimationFrame.GetOriginY());
            h.SetSourceCollisionPoly(this._currentAnimationFrame.GetCollisionPoly());
            h.SetBboxChanged();
            1 === this._objectClass.GetAnimationCount() && 1 === this._objectClass.GetAnimations()[0].GetFrameCount() || 0 === this._currentAnimationSpeed || this._StartTicking()
        }
        Release() {
            this._animationTimer =
                this._currentTexture = this._currentAnimationFrame = this._currentAnimation = null;
            super.Release()
        }
        GetCurrentImageInfo() {
            return this._currentAnimationFrame.GetImageInfo()
        }
        IsOriginalSizeKnown() {
            return !0
        }
        OnWebGLContextLost() {
            this._currentTexture = null
        }
        OnWebGLContextRestored() {
            this._UpdateCurrentTexture()
        }
        Draw(h) {
            var l = this._currentTexture;
            null !== l && (h.SetTexture(l), l = this.GetWorldInfo(), l.HasMesh() ? this._DrawMesh(l, h) : this._DrawStandard(l, h))
        }
        _DrawStandard(h, l) {
            let n = this._bquadRef;
            this._runtime.IsPixelRoundingEnabled() &&
                (n = h.PixelRoundQuad(n));
            l.Quad4(n, this._currentQuadTex)
        }
        _DrawMesh(h, l) {
            const n = h.GetTransformedMesh();
            if (h.IsMeshChanged()) {
                h.CalculateBbox(b, d, !1);
                let u = d;
                this._runtime.IsPixelRoundingEnabled() && (u = h.PixelRoundQuad(u));
                n.CalculateTransformedMesh(h.GetSourceMesh(), u, this._currentQuadTex);
                h.SetMeshChanged(!1)
            }
            n.Draw(l)
        }
        GetAnimationTime() {
            return this._animationTimer.Get()
        }
        IsAnimationPlaying() {
            return this._inst.GetFlag(2)
        }
        SetAnimationPlaying(h) {
            this._inst.SetFlag(2, h)
        }
        IsPlayingForwards() {
            return this._inst.GetFlag(1)
        }
        SetPlayingForwards(h) {
            this._inst.SetFlag(1,
                h)
        }
        IsInAnimationTrigger() {
            return this._inst.GetFlag(4)
        }
        SetInAnimationTrigger(h) {
            this._inst.SetFlag(4, h)
        }
        Tick() {
            this._changeAnimationName && this._DoChangeAnimation();
            0 <= this._changeAnimFrameIndex && this._DoChangeAnimFrame();
            const h = this._currentAnimationSpeed;
            if (this.IsAnimationPlaying() && 0 !== h) {
                var l = this._runtime.GetDt(this._inst);
                this._animationTimer.Add(l);
                l = this.GetAnimationTime();
                var n = this._currentAnimationFrame,
                    u = n.GetDuration() / h;
                if (!(l < this._frameStartTime + u)) {
                    var w = this._currentAnimation,
                        q = this._currentAnimationRepeatTo,
                        t = w.GetFrameCount(),
                        p = w.GetRepeatCount(),
                        r = w.IsLooping(),
                        x = w.IsPingPong();
                    this.IsPlayingForwards() ? this._currentFrameIndex++ : this._currentFrameIndex--;
                    this._frameStartTime += u;
                    this._currentFrameIndex >= t && (x ? (this.SetPlayingForwards(!1), this._currentFrameIndex = t - 2) : r ? this._currentFrameIndex = q : (this._animationRepeats++, this._animationRepeats >= p ? this._FinishAnimation(!1) : this._currentFrameIndex = q));
                    0 > this._currentFrameIndex && (x ? (this._currentFrameIndex = 1, this.SetPlayingForwards(!0),
                        r || (this._animationRepeats++, this._animationRepeats >= p && this._FinishAnimation(!0))) : r ? this._currentFrameIndex = q : (this._animationRepeats++, this._animationRepeats >= p ? this._FinishAnimation(!0) : this._currentFrameIndex = q));
                    this._currentFrameIndex = e.clamp(this._currentFrameIndex, 0, t - 1);
                    u = w.GetFrameAt(this._currentFrameIndex);
                    l > this._frameStartTime + u.GetDuration() / h && (this._frameStartTime = l);
                    this._OnFrameChanged(n, u)
                }
            } else this._StopTicking()
        }
        _FinishAnimation(h) {
            this._currentFrameIndex = h ? 0 : this._currentAnimation.GetFrameCount() -
                1;
            this.SetAnimationPlaying(!1);
            this._animTriggerName = this._currentAnimation.GetName();
            this.SetInAnimationTrigger(!0);
            this.DispatchScriptEvent("animationend", !1, {
                animationName: this._animTriggerName
            });
            this.Trigger(e.Plugins.Sprite.Cnds.OnAnyAnimFinished);
            this.Trigger(e.Plugins.Sprite.Cnds.OnAnimFinished);
            this.SetInAnimationTrigger(!1);
            this._animationRepeats = 0
        }
        _OnFrameChanged(h, l) {
            if (h !== l) {
                var n = this.GetWorldInfo(),
                    u = h.GetImageInfo(),
                    w = l.GetImageInfo(),
                    q = u.GetWidth();
                u = u.GetHeight();
                var t = w.GetWidth(),
                    p = w.GetHeight();
                q !== t && n.SetWidth(n.GetWidth() * (t / q));
                u !== p && n.SetHeight(n.GetHeight() * (p / u));
                n.SetOriginX(l.GetOriginX());
                n.SetOriginY(l.GetOriginY());
                n.SetSourceCollisionPoly(l.GetCollisionPoly());
                n.SetBboxChanged();
                this._currentAnimationFrame = l;
                this._currentTexture = w.GetTexture();
                this._currentRcTex = w.GetTexRect();
                this._currentQuadTex = w.GetTexQuad();
                n = this.GetInstance().GetBehaviorInstances();
                for (let r = 0, x = n.length; r < x; ++r) n[r].OnSpriteFrameChanged(h, l);
                this.DispatchScriptEvent("framechange", !1, {
                    animationName: this._currentAnimation.GetName(),
                    animationFrame: this._currentFrameIndex
                });
                this.Trigger(e.Plugins.Sprite.Cnds.OnFrameChanged);
                this._runtime.UpdateRender()
            }
        }
        _StartAnim(h) {
            this.SetAnimationPlaying(!0);
            this._frameStartTime = this.GetAnimationTime();
            1 === h && 0 !== this._currentFrameIndex && (this._changeAnimFrameIndex = 0, this.IsInAnimationTrigger() || this._DoChangeAnimFrame());
            this._StartTicking()
        }
        _SetAnim(h, l) {
            this._changeAnimationName = h;
            this._changeAnimationFrom = l;
            this._StartTicking();
            this.IsInAnimationTrigger() ||
                this._DoChangeAnimation()
        }
        _GetCurrentAnimationName() {
            return this._changeAnimationName ? this._changeAnimationName : this._currentAnimation.GetName()
        }
        _SetAnimFrame(h) {
            isFinite(h) && (this._changeAnimFrameIndex = h, this.IsInAnimationTrigger() || this._DoChangeAnimFrame())
        }
        _GetAnimFrame() {
            return this._currentFrameIndex
        }
        _SetAnimSpeed(h) {
            this._currentAnimationSpeed = Math.abs(h);
            this.SetPlayingForwards(0 <= h);
            0 < this._currentAnimationSpeed && this._StartTicking()
        }
        _GetAnimSpeed() {
            return this.IsPlayingForwards() ? this._currentAnimationSpeed :
                -this._currentAnimationSpeed
        }
        _SetAnimRepeatToFrame(h) {
            this._currentAnimationRepeatTo = h = e.clamp(Math.floor(h), 0, this._currentAnimation.GetFrameCount() - 1)
        }
        _GetAnimRepeatToFrame() {
            return this._currentAnimationRepeatTo
        }
        _DoChangeAnimation() {
            const h = this._currentAnimationFrame;
            var l = this._objectClass.GetAnimationByName(this._changeAnimationName);
            this._changeAnimationName = "";
            !l || l === this._currentAnimation && this.IsAnimationPlaying() || (this._currentAnimation = l, this.SetPlayingForwards(0 <= l.GetSpeed()), this._currentAnimationSpeed =
                Math.abs(l.GetSpeed()), this._currentAnimationRepeatTo = l.GetRepeatTo(), this._currentFrameIndex = e.clamp(this._currentFrameIndex, 0, this._currentAnimation.GetFrameCount() - 1), 1 === this._changeAnimationFrom && (this._currentFrameIndex = 0), this.SetAnimationPlaying(!0), this._frameStartTime = this.GetAnimationTime(), l = this._currentAnimation.GetFrameAt(this._currentFrameIndex), this._OnFrameChanged(h, l))
        }
        _DoChangeAnimFrame() {
            const h = this._currentAnimationFrame;
            var l = this._currentFrameIndex;
            this._currentFrameIndex =
                e.clamp(Math.floor(this._changeAnimFrameIndex), 0, this._currentAnimation.GetFrameCount() - 1);
            this._changeAnimFrameIndex = -1;
            l !== this._currentFrameIndex && (l = this._currentAnimation.GetFrameAt(this._currentFrameIndex), this._OnFrameChanged(h, l), this._frameStartTime = this.GetAnimationTime())
        }
        _UpdateCurrentTexture() {
            const h = this._currentAnimationFrame.GetImageInfo();
            this._currentTexture = h.GetTexture();
            this._currentRcTex = h.GetTexRect();
            this._currentQuadTex = h.GetTexQuad();
            this.GetWorldInfo().SetMeshChanged(!0)
        }
        GetTexture() {
            return this._currentTexture
        }
        GetTexRect() {
            return this._currentRcTex
        }
        GetTexQuad() {
            return this._currentQuadTex
        }
        GetImagePointCount() {
            return this._currentAnimationFrame.GetImagePointCount()
        }
        GetImagePoint(h) {
            const l =
                this._currentAnimationFrame,
                n = this.GetWorldInfo();
            if ("string" === typeof h) h = l.GetImagePointByName(h);
            else if ("number" === typeof h) h = l.GetImagePointByIndex(h - 1);
            else throw new TypeError("expected string or number");
            if (!h) return [n.GetX(), n.GetY()];
            c.copy(h.GetVec2());
            if (n.HasMesh()) {
                const [u, w] = n.GetSourceMesh().TransformPoint(c.getX(), c.getY());
                c.set(u, w)
            }
            c.offset(-l.GetOriginX(), -l.GetOriginY());
            c.scale(n.GetWidth(), n.GetHeight());
            c.rotate(n.GetAngle());
            c.offset(n.GetX(), n.GetY());
            return [c.getX(), c.getY()]
        }
        GetCollisionPolyPointCount() {
            return this.GetWorldInfo().GetTransformedCollisionPoly().pointCount()
        }
        GetCollisionPolyPoint(h) {
            h =
                Math.floor(h);
            const l = this.GetWorldInfo();
            var n = l.GetTransformedCollisionPoly();
            const u = n.pointCount();
            h === u && (h = 0);
            if (0 > h || h >= u) return [0, 0];
            n = n.pointsArr();
            return [n[2 * h] + l.GetX(), n[2 * h + 1] + l.GetY()]
        }
        GetDebuggerProperties() {
            const h = e.Plugins.Sprite.Acts;
            return [{
                title: "plugins.sprite.debugger.animation-properties.title",
                properties: [{
                    name: "plugins.sprite.debugger.animation-properties.current-animation",
                    value: this._currentAnimation.GetName(),
                    onedit: l => this.CallAction(h.SetAnim, l, 0)
                }, {
                    name: "plugins.sprite.debugger.animation-properties.current-frame",
                    value: this._currentFrameIndex,
                    onedit: l => this.CallAction(h.SetAnimFrame, l)
                }, {
                    name: "plugins.sprite.debugger.animation-properties.is-playing",
                    value: this.IsAnimationPlaying(),
                    onedit: l => l ? this.CallAction(h.StartAnim, 0) : this.CallAction(h.StopAnim)
                }, {
                    name: "plugins.sprite.debugger.animation-properties.speed",
                    value: this._currentAnimationSpeed,
                    onedit: l => this.CallAction(h.SetAnimSpeed, l)
                }, {
                    name: "plugins.sprite.debugger.animation-properties.repeats",
                    value: this._animationRepeats,
                    onedit: l => this._animationRepeats =
                        l
                }]
            }]
        }
        SaveToJson() {
            const h = {
                a: this._currentAnimation.GetSID()
            };
            0 !== this._frameStartTime && (h.fs = this._frameStartTime);
            var l = this.GetAnimationTime();
            0 !== l && (h.at = l);
            0 !== this._currentFrameIndex && (h.f = this._currentFrameIndex);
            0 !== this._currentAnimationSpeed && (h.cas = this._currentAnimationSpeed);
            1 !== this._animationRepeats && (h.ar = this._animationRepeats);
            0 !== this._currentAnimationRepeatTo && (h.rt = this._currentAnimationRepeatTo);
            this.IsAnimationPlaying() || (h.ap = this.IsAnimationPlaying());
            this.IsPlayingForwards() ||
                (h.af = this.IsPlayingForwards());
            l = this.GetWorldInfo();
            l.IsCollisionEnabled() && (h.ce = l.IsCollisionEnabled());
            return h
        }
        LoadFromJson(h) {
            var l = this.GetObjectClass().GetAnimationBySID(h.a);
            l && (this._currentAnimation = l);
            this._frameStartTime = h.hasOwnProperty("fs") ? h.fs : 0;
            this._animationTimer.Set(h.hasOwnProperty("at") ? h.at : 0);
            l = h.hasOwnProperty("f") ? h.f : 0;
            this._currentFrameIndex = e.clamp(l, 0, this._currentAnimation.GetFrameCount() - 1);
            this._currentAnimationSpeed = h.hasOwnProperty("cas") ? h.cas : 0;
            this._animationRepeats =
                h.hasOwnProperty("ar") ? h.ar : 1;
            l = h.hasOwnProperty("rt") ? h.rt : 0;
            this._currentAnimationRepeatTo = e.clamp(l, 0, this._currentAnimation.GetFrameCount() - 1);
            this.SetAnimationPlaying(h.hasOwnProperty("ap") ? !!h.ap : !0);
            this.SetPlayingForwards(h.hasOwnProperty("af") ? !!h.af : !0);
            this._currentAnimationFrame = l = this._currentAnimation.GetFrameAt(this._currentFrameIndex);
            this._UpdateCurrentTexture();
            const n = this.GetWorldInfo();
            n.SetOriginX(l.GetOriginX());
            n.SetOriginY(l.GetOriginY());
            n.SetSourceCollisionPoly(l.GetCollisionPoly());
            n.SetCollisionEnabled(!!h.ce)
        }
        GetPropertyValueByIndex(h) {
            const l = this.GetWorldInfo();
            switch (h) {
                case 3:
                    return l.IsCollisionEnabled();
                case 2:
                    return e.clamp(this._currentFrameIndex, 0, this._currentAnimation.GetFrameCount() - 1)
            }
        }
        SetPropertyValueByIndex(h, l) {
            var n = this.GetWorldInfo();
            switch (h) {
                case 3:
                    n.SetCollisionEnabled(!!l);
                    break;
                case 2:
                    this.SetAnimationPlaying(!1);
                    h = this._currentAnimation.GetFrameCount() - 1;
                    n = l = e.clamp(l, 0, h);
                    l = this._currentAnimation.GetFrameAt(this._currentFrameIndex);
                    const u = this._currentAnimation.GetFrameAt(n);
                    this._OnFrameChanged(l, u);
                    this._currentFrameIndex = e.clamp(n, 0, h)
            }
        }
        GetScriptInterfaceClass() {
            return self.ISpriteInstance
        }
    };
    const f = new WeakMap,
        k = new Map([
            ["current-frame", 0],
            ["beginning", 1]
        ]);
    self.ISpriteInstance = class extends self.IWorldInstance {
        constructor() {
            super();
            f.set(this, self.IInstance._GetInitInst().GetSdkInstance())
        }
        getImagePointCount() {
            return f.get(this).GetImagePointCount()
        }
        getImagePointX(h) {
            if ("string" !== typeof h && "number" !== typeof h) throw new TypeError("expected string or number");
            return f.get(this).GetImagePoint(h)[0]
        }
        getImagePointY(h) {
            if ("string" !==
                typeof h && "number" !== typeof h) throw new TypeError("expected string or number");
            return f.get(this).GetImagePoint(h)[1]
        }
        getImagePoint(h) {
            if ("string" !== typeof h && "number" !== typeof h) throw new TypeError("expected string or number");
            return f.get(this).GetImagePoint(h)
        }
        getPolyPointCount() {
            return f.get(this).GetCollisionPolyPointCount()
        }
        getPolyPointX(h) {
            a.RequireFiniteNumber(h);
            return f.get(this).GetCollisionPolyPoint(h)[0]
        }
        getPolyPointY(h) {
            a.RequireFiniteNumber(h);
            return f.get(this).GetCollisionPolyPoint(h)[1]
        }
        getPolyPoint(h) {
            a.RequireFiniteNumber(h);
            return f.get(this).GetCollisionPolyPoint(h)
        }
        stopAnimation() {
            f.get(this).SetAnimationPlaying(!1)
        }
        startAnimation(h = "current-frame") {
            a.RequireString(h);
            h = k.get(h);
            if ("undefined" === typeof h) throw Error("invalid mode");
            f.get(this)._StartAnim(h)
        }
        setAnimation(h, l = "beginning") {
            a.RequireString(h);
            a.RequireString(l);
            l = k.get(l);
            if ("undefined" === typeof l) throw Error("invalid mode");
            f.get(this)._SetAnim(h, l)
        }
        get animationName() {
            return f.get(this)._GetCurrentAnimationName()
        }
        set animationFrame(h) {
            a.RequireFiniteNumber(h);
            f.get(this)._SetAnimFrame(h)
        }
        get animationFrame() {
            return f.get(this)._GetAnimFrame()
        }
        set animationSpeed(h) {
            a.RequireFiniteNumber(h);
            f.get(this)._SetAnimSpeed(h)
        }
        get animationSpeed() {
            return f.get(this)._GetAnimSpeed()
        }
        set animationRepeatToFrame(h) {
            a.RequireFiniteNumber(h);
            f.get(this)._SetAnimRepeatToFrame(h)
        }
        get animationRepeatToFrame() {
            return f.get(this)._GetAnimRepeatToFrame()
        }
        get imageWidth() {
            return f.get(this).GetCurrentImageInfo().GetWidth()
        }
        get imageHeight() {
            return f.get(this).GetCurrentImageInfo().GetHeight()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.Sprite.Cnds = {
        IsAnimPlaying(a) {
            return e.equalsNoCase(this._GetCurrentAnimationName(), a)
        },
        CompareFrame(a, b) {
            return e.compare(this._currentFrameIndex, a, b)
        },
        CompareAnimSpeed(a, b) {
            return e.compare(this._GetAnimSpeed(), a, b)
        },
        OnAnimFinished(a) {
            return e.equalsNoCase(this._animTriggerName, a)
        },
        OnAnyAnimFinished() {
            return !0
        },
        OnFrameChanged() {
            return !0
        },
        IsMirrored() {
            return 0 > this.GetWorldInfo().GetWidth()
        },
        IsFlipped() {
            return 0 > this.GetWorldInfo().GetHeight()
        },
        OnURLLoaded() {
            return !0
        },
        OnURLFailed() {
            return !0
        },
        IsCollisionEnabled() {
            return this.GetWorldInfo().IsCollisionEnabled()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.Sprite.Acts = {
        Spawn(a, b, d, c) {
            if (a && b) {
                var [f, k] = this.GetImagePoint(d);
                if (d = this._runtime.CreateInstance(a, b, f, k, c)) {
                    c && b.SortAndAddInstancesByZIndex(d);
                    a.GetPlugin().IsRotatable() && (b = d.GetWorldInfo(), b.SetAngle(this.GetWorldInfo().GetAngle()), b.SetBboxChanged());
                    b = this._runtime.GetEventSheetManager();
                    b.BlockFlushingInstances(!0);
                    d._TriggerOnCreatedOnSelfAndRelated();
                    b.BlockFlushingInstances(!1);
                    c = this._runtime.GetCurrentAction().GetSavedDataMap();
                    b = !1;
                    if (!c.has("Spawn_LastExec") ||
                        c.get("Spawn_LastExec") < this._runtime.GetExecCount()) b = !0, c.set("Spawn_LastExec", this._runtime.GetExecCount());
                    if (a !== this.GetObjectClass() && (a = a.GetCurrentSol(), a._SetSelectAll(!1), a = a._GetOwnInstances(), b && e.clearArray(a), a.push(d), d.IsInContainer()))
                        for (const h of d.siblings()) d = h.GetObjectClass().GetCurrentSol(), b ? d.SetSinglePicked(h) : (d._SetSelectAll(!1), d._PushInstance(h))
                }
            }
        },
        StopAnim() {
            this.SetAnimationPlaying(!1)
        },
        StartAnim(a) {
            this._StartAnim(a)
        },
        SetAnim(a, b) {
            this._SetAnim(a, b)
        },
        SetAnimFrame(a) {
            this._SetAnimFrame(a)
        },
        SetAnimSpeed(a) {
            this._SetAnimSpeed(a)
        },
        SetAnimRepeatToFrame(a) {
            this._SetAnimRepeatToFrame(a)
        },
        SetMirrored(a) {
            const b = this.GetWorldInfo(),
                d = b.GetWidth();
            a = Math.abs(d) * (0 === a ? -1 : 1);
            d !== a && (b.SetWidth(a), b.SetBboxChanged())
        },
        SetFlipped(a) {
            const b = this.GetWorldInfo(),
                d = b.GetHeight();
            a = Math.abs(d) * (0 === a ? -1 : 1);
            d !== a && (b.SetHeight(a), b.SetBboxChanged())
        },
        SetScale(a) {
            const b = this._currentAnimationFrame.GetImageInfo(),
                d = this.GetWorldInfo();
            var c = 0 > d.GetWidth() ? -1 : 1;
            const f = 0 > d.GetHeight() ? -1 : 1;
            c *= b.GetWidth() *
                a;
            a = b.GetHeight() * a * f;
            if (d.GetWidth() !== c || d.GetHeight() !== a) d.SetSize(c, a), d.SetBboxChanged()
        },
        async LoadURL(a, b, d) {
            d = this._currentAnimationFrame.GetImageInfo();
            const c = this.GetWorldInfo(),
                f = this._runtime;
            if (d.GetURL() === a) 0 === b && (c.SetSize(d.GetWidth(), d.GetHeight()), c.SetBboxChanged()), this.Trigger(e.Plugins.Sprite.Cnds.OnURLLoaded);
            else {
                var k = e.New(e.ImageInfo);
                try {
                    await k.LoadDynamicAsset(f, a);
                    if (!k.IsLoaded()) throw Error("image failed to load");
                    await k.LoadStaticTexture(f.GetRenderer(), {
                        sampling: this._runtime.GetSampling()
                    })
                } catch (h) {
                    console.error("Load image from URL failed: ",
                        h);
                    this.Trigger(e.Plugins.Sprite.Cnds.OnURLFailed);
                    return
                }
                d.ReplaceWith(k);
                this._sdkType._UpdateAllCurrentTexture();
                this.WasReleased() || 0 !== b || (c.SetSize(d.GetWidth(), d.GetHeight()), c.SetBboxChanged());
                f.UpdateRender();
                this.WasReleased() || await this.TriggerAsync(e.Plugins.Sprite.Cnds.OnURLLoaded)
            }
        },
        SetCollisions(a) {
            this.GetWorldInfo().SetCollisionEnabled(a)
        },
        SetSolidCollisionFilter(a, b) {
            this.GetWorldInfo().SetSolidCollisionFilter(0 === a, b)
        },
        SetEffect(a) {
            this.GetWorldInfo().SetBlendMode(a);
            this._runtime.UpdateRender()
        }
    }
}
"use strict";
self.C3.Plugins.Sprite.Exps = {
    AnimationFrame() {
        return this._currentFrameIndex
    },
    AnimationFrameCount() {
        return this._currentAnimation.GetFrameCount()
    },
    AnimationName() {
        return this._currentAnimation.GetName()
    },
    AnimationSpeed() {
        return this._GetAnimSpeed()
    },
    OriginalAnimationSpeed() {
        return this._currentAnimation.GetSpeed()
    },
    ImagePointX(e) {
        return this.GetImagePoint(e)[0]
    },
    ImagePointY(e) {
        return this.GetImagePoint(e)[1]
    },
    ImagePointCount() {
        return this.GetImagePointCount()
    },
    ImageWidth() {
        return this.GetCurrentImageInfo().GetWidth()
    },
    ImageHeight() {
        return this.GetCurrentImageInfo().GetHeight()
    },
    PolyPointXAt(e) {
        return this.GetCollisionPolyPoint(e)[0]
    },
    PolyPointYAt(e) {
        return this.GetCollisionPolyPoint(e)[1]
    },
    PolyPointCount() {
        return this.GetCollisionPolyPointCount()
    }
}; {
    "use strict";
    const e = self.C3;
    e.Plugins.TextBox = class extends e.SDKDOMPluginBase {
        constructor(a) {
            super(a, "text-input");
            this.AddElementMessageHandler("click", (b, d) => b._OnClick(d));
            this.AddElementMessageHandler("dblclick", (b, d) => b._OnDoubleClick(d));
            this.AddElementMessageHandler("change", (b, d) => b._OnChange(d))
        }
        Release() {
            super.Release()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.TextBox.Type = class extends e.SDKTypeBase {
        constructor(a) {
            super(a)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
    }
} {
    "use strict";
    const e = self.C3,
        a = self.C3X,
        b = "text password email number tel url textarea search".split(" ");
    e.Plugins.TextBox.Instance = class extends e.SDKDOMInstanceBase {
        constructor(c, f) {
            super(c, "text-input");
            this._title = this._placeholder = this._text = "";
            this._isEnabled = !0;
            this._spellCheck = this._isReadOnly = !1;
            this._type = "text";
            this._autoFontSize = !0;
            this._maxLength = -1;
            this._id = "";
            f && (this._text = f[0], this._placeholder = f[1], this._title = f[2], this.GetWorldInfo().SetVisible(f[3]), this._isEnabled = f[4], this._isReadOnly =
                f[5], this._spellCheck = f[6], this._type = b[f[7]], this._autoFontSize = f[8], this._id = f[9]);
            this.CreateElement({
                type: this._type,
                id: this._id
            })
        }
        Release() {
            super.Release()
        }
        GetElementState() {
            return {
                text: this._text,
                placeholder: this._placeholder,
                title: this._title,
                isEnabled: this._isEnabled,
                isReadOnly: this._isReadOnly,
                spellCheck: this._spellCheck,
                maxLength: this._maxLength
            }
        }
        async _OnClick(c) {
            this.DispatchScriptEvent("click", !0);
            await this.TriggerAsync(e.Plugins.TextBox.Cnds.OnClicked)
        }
        async _OnDoubleClick(c) {
            this.DispatchScriptEvent("dblclick",
                !0);
            await this.TriggerAsync(e.Plugins.TextBox.Cnds.OnDoubleClicked)
        }
        async _OnChange(c) {
            this._text = c.text;
            this.DispatchScriptEvent("change", !0);
            await this.TriggerAsync(e.Plugins.TextBox.Cnds.OnTextChanged)
        }
        _SetText(c) {
            this._text !== c && (this._text = c, this.UpdateElementState())
        }
        _GetText() {
            return this._text
        }
        _SetPlaceholder(c) {
            this._placeholder !== c && (this._placeholder = c, this.UpdateElementState())
        }
        _GetPlaceholder() {
            return this._placeholder
        }
        _SetTooltip(c) {
            this._title !== c && (this._title = c, this.UpdateElementState())
        }
        _GetTooltip() {
            return this._title
        }
        _SetEnabled(c) {
            c = !!c;
            this._isEnabled !== c && (this._isEnabled = c, this.UpdateElementState())
        }
        _IsEnabled() {
            return this._isEnabled
        }
        _SetReadOnly(c) {
            c = !!c;
            this._isReadOnly !== c && (this._isReadOnly = c, this.UpdateElementState())
        }
        _IsReadOnly() {
            return this._isReadOnly
        }
        _SetMaxLength(c) {
            c = Math.max(+c, -1);
            this._maxLength !== c && (this._maxLength = c, this.UpdateElementState())
        }
        _GetMaxLength() {
            return this._maxLength
        }
        _ScrollToBottom() {
            Promise.resolve().then(() => this.PostToDOMElement("scroll-to-bottom"))
        }
        Draw(c) {}
        SaveToJson() {
            return {
                t: this._text,
                p: this._placeholder,
                ti: this._title,
                e: this._isEnabled,
                r: this._isReadOnly,
                sp: this._spellCheck,
                ml: this._maxLength,
                type: this._type,
                id: this._id
            }
        }
        LoadFromJson(c) {
            this._text = c.t;
            this._placeholder = c.p;
            this._title = c.ti;
            this._isEnabled = c.e;
            this._isReadOnly = c.r;
            this._spellCheck = c.sp;
            this._maxLength = c.hasOwnProperty("ml") ? c.ml : -1;
            this._type = c.type;
            this._id = c.id;
            this.UpdateElementState()
        }
        GetPropertyValueByIndex(c) {
            switch (c) {
                case 0:
                    return this._text;
                case 1:
                    return this._placeholder;
                case 2:
                    return this._title;
                case 4:
                    return this._isEnabled;
                case 5:
                    return this._isReadOnly;
                case 6:
                    return this._spellCheck;
                case 8:
                    return this._autoFontSize;
                case 9:
                    return this._id
            }
        }
        SetPropertyValueByIndex(c, f) {
            switch (c) {
                case 0:
                    if (this._text === f) break;
                    this._text = f;
                    this.UpdateElementState();
                    break;
                case 1:
                    if (this._placeholder === f) break;
                    this._placeholder = f;
                    this.UpdateElementState();
                    break;
                case 2:
                    if (this._title === f) break;
                    this._title = f;
                    this.UpdateElementState();
                    break;
                case 4:
                    if (this._isEnabled === !!f) break;
                    this._isEnabled = !!f;
                    this.UpdateElementState();
                    break;
                case 5:
                    if (this._isReadOnly ===
                        !!f) break;
                    this._isReadOnly = !!f;
                    this.UpdateElementState();
                    break;
                case 6:
                    if (this._spellCheck === !!f) break;
                    this._spellCheck = !!f;
                    this.UpdateElementState();
                    break;
                case 8:
                    this._autoFontSize = !!f;
                    break;
                case 9:
                    this._id !== f && (this._id = f, this.UpdateElementState())
            }
        }
        GetDebuggerProperties() {
            const c = e.Plugins.TextBox.Acts;
            return [{
                title: "plugins.textbox.name",
                properties: [{
                    name: "plugins.textbox.properties.text.name",
                    value: this._text,
                    onedit: f => this.CallAction(c.SetText, f)
                }, {
                    name: "plugins.textbox.properties.enabled.name",
                    value: this._isEnabled,
                    onedit: f => this.CallAction(c.SetEnabled, f)
                }, {
                    name: "plugins.textbox.properties.read-only.name",
                    value: this._isReadOnly,
                    onedit: f => this.CallAction(c.SetReadOnly, f)
                }]
            }]
        }
        GetScriptInterfaceClass() {
            return self.ITextInputInstance
        }
    };
    const d = new WeakMap;
    self.ITextInputInstance = class extends self.IDOMInstance {
        constructor() {
            super();
            d.set(this, self.IInstance._GetInitInst().GetSdkInstance())
        }
        set text(c) {
            a.RequireString(c);
            d.get(this)._SetText(c)
        }
        get text() {
            return d.get(this)._GetText()
        }
        set placeholder(c) {
            a.RequireString(c);
            d.get(this)._SetPlaceholder(c)
        }
        get placeholder() {
            return d.get(this)._GetPlaceholder()
        }
        set tooltip(c) {
            a.RequireString(c);
            d.get(this)._SetTooltip(c)
        }
        get tooltip() {
            return d.get(this)._GetTooltip()
        }
        set isEnabled(c) {
            d.get(this)._SetEnabled(c)
        }
        get isEnabled() {
            return d.get(this)._IsEnabled()
        }
        set isReadOnly(c) {
            d.get(this)._SetReadOnly(c)
        }
        get isReadOnly() {
            return d.get(this)._IsReadOnly()
        }
        set maxLength(c) {
            a.RequireFiniteNumber(c);
            d.get(this)._SetMaxLength(c)
        }
        get maxLength() {
            return d.get(this)._GetMaxLength()
        }
        scrollToBottom() {
            d.get(this)._ScrollToBottom()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.TextBox.Cnds = {
        CompareText(a, b) {
            return 0 === b ? e.equalsNoCase(this._text, a) : this._text === a
        },
        OnTextChanged() {
            return !0
        },
        OnClicked() {
            return !0
        },
        OnDoubleClicked() {
            return !0
        }
    }
}
"use strict";
self.C3.Plugins.TextBox.Acts = {
    SetText(e) {
        this._SetText(e.toString())
    },
    AppendText(e) {
        "" !== e && this._SetText(this._GetText() + e)
    },
    SetPlaceholder(e) {
        this._SetPlaceholder(e)
    },
    SetTooltip(e) {
        this._SetTooltip(e)
    },
    SetReadOnly(e) {
        this._SetReadOnly(0 === e)
    },
    ScrollToBottom() {
        this._ScrollToBottom()
    },
    SetMaxLength(e) {
        this._SetMaxLength(e)
    }
};
"use strict";
self.C3.Plugins.TextBox.Exps = {
    Text() {
        return this._GetText()
    },
    MaxLength() {
        return this._GetMaxLength()
    }
}; {
    "use strict";
    const e = self.C3;
    e.Plugins.Text = class extends e.SDKPluginBase {
        constructor(a) {
            super(a)
        }
        Release() {
            super.Release()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.Text.Type = class extends e.SDKTypeBase {
        constructor(a) {
            super(a)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
        LoadTextures(a) {}
        ReleaseTextures() {}
    }
} {
    "use strict";
    const e = self.C3,
        a = self.C3X,
        b = [0, 0, 0],
        d = ["left", "center", "right"],
        c = ["top", "center", "bottom"],
        f = new e.Rect,
        k = new e.Quad,
        h = new e.Color;
    e.Plugins.Text.Instance = class extends e.SDKWorldInstanceBase {
        constructor(q, t) {
            super(q);
            this._text = "";
            this._enableBBcode = !0;
            this._faceName = "Arial";
            this._ptSize = 12;
            this._lineHeightOffset = 0;
            this._isItalic = this._isBold = !1;
            this._color = e.New(e.Color);
            this._verticalAlign = this._horizontalAlign = 0;
            this._wrapByWord = !0;
            this._typewriterEndTime = this._typewriterStartTime = -1;
            this._typewriterLength = 0;
            this._rendererText = e.New(e.Gfx.RendererText, this._runtime.GetRenderer(), {
                timeout: 5
            });
            this._rendererText.ontextureupdate = () => this._runtime.UpdateRender();
            this._rendererText.SetIsAsync(!1);
            t && (this._text = t[0], this._enableBBcode = !!t[1], this._faceName = t[2], this._ptSize = t[3], this._lineHeightOffset = t[4], this._isBold = !!t[5], this._isItalic = !!t[6], this._horizontalAlign = t[8], this._verticalAlign = t[9], this._wrapByWord = 0 === t[10], q = t[7], this._color.setRgb(q[0], q[1], q[2]), this.GetWorldInfo().SetVisible(t[11]));
            this._UpdateTextSettings()
        }
        Release() {
            this._CancelTypewriter();
            this._rendererText.Release();
            this._rendererText = null;
            super.Release()
        }
        _UpdateTextSettings() {
            const q = this._rendererText;
            q.SetText(this._text);
            q.SetBBCodeEnabled(this._enableBBcode);
            q.SetFontName(this._faceName);
            q.SetLineHeight(this._lineHeightOffset);
            q.SetBold(this._isBold);
            q.SetItalic(this._isItalic);
            q.SetColor(this._color);
            q.SetHorizontalAlignment(d[this._horizontalAlign]);
            q.SetVerticalAlignment(c[this._verticalAlign]);
            q.SetWordWrapMode(this._wrapByWord ?
                "word" : "character")
        }
        _UpdateTextSize() {
            const q = this.GetWorldInfo();
            this._rendererText.SetFontSize(this._ptSize);
            this._rendererText.SetFontSizeScale(q.GetSceneGraphScale());
            var t = q.GetLayer();
            t = t.GetRenderScale() * t.Get2DScaleFactorToZ(q.GetTotalZElevation());
            this._rendererText.SetSize(q.GetWidth(), q.GetHeight(), t)
        }
        Draw(q) {
            var t = this.GetWorldInfo();
            this._UpdateTextSize();
            const p = this._rendererText.GetTexture();
            if (p) {
                var r = t.GetLayer();
                if (0 === t.GetAngle() && 0 === r.GetAngle() && 0 === t.GetTotalZElevation() &&
                    !t.HasMesh() && r.RendersIn2DMode()) {
                    t = t.GetBoundingQuad();
                    const [x, y] = r.LayerToDrawSurface(t.getTlx(), t.getTly()), [E, G] = r.LayerToDrawSurface(t.getBrx(), t.getBry());
                    t = x - Math.round(x);
                    const A = y - Math.round(y);
                    f.set(x, y, E, G);
                    f.offset(-t, -A);
                    k.setFromRect(f);
                    const [F, J] = q.GetRenderTargetSize(q.GetRenderTarget());
                    this._runtime.GetCanvasManager().SetDeviceTransform(q, F, J);
                    q.SetTexture(p);
                    q.Quad3(k, this._rendererText.GetTexRect());
                    r._SetTransform(q)
                } else q.SetTexture(p), t.HasMesh() ? this._DrawMesh(t, q) : this._DrawStandard(t,
                    q)
            }
        }
        _DrawStandard(q, t) {
            q = q.GetBoundingQuad();
            this._runtime.IsPixelRoundingEnabled() && (q = this._PixelRoundQuad(q));
            t.Quad3(q, this._rendererText.GetTexRect())
        }
        _DrawMesh(q, t) {
            const p = q.GetTransformedMesh();
            if (q.IsMeshChanged()) {
                q.CalculateBbox(f, k, !1);
                let r = k;
                this._runtime.IsPixelRoundingEnabled() && (r = this._PixelRoundQuad(r));
                p.CalculateTransformedMesh(q.GetSourceMesh(), r, this._rendererText.GetTexRect());
                q.SetMeshChanged(!1)
            }
            p.Draw(t)
        }
        _PixelRoundQuad(q) {
            const t = q.getTlx() - Math.round(q.getTlx()),
                p = q.getTly() -
                Math.round(q.getTly());
            if (0 === t && 0 === p) return q;
            k.copy(q);
            k.offset(-t, -p);
            return k
        }
        SaveToJson() {
            const q = {
                t: this._text,
                c: this._color.toJSON(),
                fn: this._faceName,
                ps: this._ptSize
            };
            this._enableBBcode && (q.bbc = this._enableBBcode);
            0 !== this._horizontalAlign && (q.ha = this._horizontalAlign);
            0 !== this._verticalAlign && (q.va = this._verticalAlign);
            this._wrapByWord || (q.wr = this._wrapByWord);
            0 !== this._lineHeightOffset && (q.lho = this._lineHeightOffset);
            this._isBold && (q.b = this._isBold);
            this._isItalic && (q.i = this._isItalic); -
            1 !== this._typewriterEndTime && (q.tw = {
                st: this._typewriterStartTime,
                en: this._typewriterEndTime,
                l: this._typewriterLength
            });
            return q
        }
        LoadFromJson(q) {
            this._CancelTypewriter();
            this._text = q.t;
            this._color.setFromJSON(q.c);
            this._faceName = q.fn;
            this._ptSize = q.ps;
            this._enableBBcode = q.hasOwnProperty("bbc") ? q.bbc : !1;
            this._horizontalAlign = q.hasOwnProperty("ha") ? q.ha : 0;
            this._verticalAlign = q.hasOwnProperty("va") ? q.va : 0;
            this._wrapByWord = q.hasOwnProperty("wr") ? q.wr : !0;
            this._lineHeightOffset = q.hasOwnProperty("lho") ?
                q.lho : 0;
            this._isBold = q.hasOwnProperty("b") ? q.b : !1;
            this._isItalic = q.hasOwnProperty("i") ? q.i : !1;
            q.hasOwnProperty("tw") && (q = q.tw, this._typewriterStartTime = q.st, this._typewriterEndTime = q.en, this._typewriterLength = q.l);
            this._UpdateTextSettings(); - 1 !== this._typewriterEndTime && this._StartTicking()
        }
        GetPropertyValueByIndex(q) {
            switch (q) {
                case 0:
                    return this._text;
                case 1:
                    return this._enableBBcode;
                case 2:
                    return this._faceName;
                case 3:
                    return this._ptSize;
                case 4:
                    return this._lineHeightOffset;
                case 5:
                    return this._isBold;
                case 6:
                    return this._isItalic;
                case 7:
                    return b[0] = this._color.getR(), b[1] = this._color.getG(), b[2] = this._color.getB(), b;
                case 8:
                    return this._horizontalAlign;
                case 9:
                    return this._verticalAlign;
                case 10:
                    return this._wrapByWord ? 1 : 0
            }
        }
        SetPropertyValueByIndex(q, t) {
            switch (q) {
                case 0:
                    if (this._text === t) break;
                    this._text = t;
                    this._UpdateTextSettings();
                    break;
                case 1:
                    if (this._enableBBcode === !!t) break;
                    this._enableBBcode = !!t;
                    this._UpdateTextSettings();
                    break;
                case 2:
                    if (this._faceName === t) break;
                    this._faceName = t;
                    this._UpdateTextSettings();
                    break;
                case 3:
                    if (this._ptSize === t) break;
                    this._ptSize = t;
                    this._UpdateTextSettings();
                    break;
                case 4:
                    if (this._lineHeightOffset === t) break;
                    this._lineHeightOffset = t;
                    this._UpdateTextSettings();
                    break;
                case 5:
                    if (this._isBold === !!t) break;
                    this._isBold = !!t;
                    this._UpdateTextSettings();
                    break;
                case 6:
                    if (this._isItalic === !!t) break;
                    this._isItalic = !!t;
                    this._UpdateTextSettings();
                    break;
                case 7:
                    q = this._color;
                    if (q.getR() === t[0] && q.getG() === t[1] && q.getB() === t[2]) break;
                    this._color.setRgb(t[0], t[1], t[2]);
                    this._UpdateTextSettings();
                    break;
                case 8:
                    if (this._horizontalAlign === t) break;
                    this._horizontalAlign = t;
                    this._UpdateTextSettings();
                    break;
                case 9:
                    if (this._verticalAlign === t) break;
                    this._verticalAlign = t;
                    this._UpdateTextSettings();
                    break;
                case 10:
                    this._wrapByWord !== (0 === t) && (this._wrapByWord = 0 === t, this._UpdateTextSettings())
            }
        }
        SetPropertyColorOffsetValueByIndex(q, t, p, r) {
            if (0 !== t || 0 !== p || 0 !== r) switch (q) {
                case 7:
                    this._color.addRgb(t, p, r), this._UpdateTextSettings()
            }
        }
        _SetText(q) {
            this._text !== q && (this._text = q, this._rendererText.SetText(q), this._runtime.UpdateRender())
        }
        GetText() {
            return this._text
        }
        _StartTypewriter(q,
            t) {
            this._SetText(q);
            this._typewriterStartTime = this._runtime.GetWallTime();
            this._typewriterEndTime = this._typewriterStartTime + t / this.GetInstance().GetActiveTimeScale();
            this._typewriterLength = e.BBString.StripAnyTags(q).length;
            this._rendererText.SetDrawMaxCharacterCount(0);
            this._StartTicking()
        }
        _CancelTypewriter() {
            this._typewriterEndTime = this._typewriterStartTime = -1;
            this._typewriterLength = 0;
            this._rendererText.SetDrawMaxCharacterCount(-1);
            this._StopTicking()
        }
        _FinishTypewriter() {
            -1 !== this._typewriterEndTime &&
                (this._CancelTypewriter(), this.Trigger(e.Plugins.Text.Cnds.OnTypewriterTextFinished), this._runtime.UpdateRender())
        }
        _SetFontFace(q) {
            this._faceName !== q && (this._faceName = q, this._rendererText.SetFontName(q), this._runtime.UpdateRender())
        }
        _GetFontFace() {
            return this._faceName
        }
        _SetBold(q) {
            q = !!q;
            this._isBold !== q && (this._isBold = q, this._rendererText.SetBold(q), this._runtime.UpdateRender())
        }
        _IsBold() {
            return this._isBold
        }
        _SetItalic(q) {
            q = !!q;
            this._isItalic !== q && (this._isItalic = q, this._rendererText.SetItalic(q),
                this._runtime.UpdateRender())
        }
        _IsItalic() {
            return this._isItalic
        }
        _SetFontSize(q) {
            this._ptSize !== q && (this._ptSize = q, this._runtime.UpdateRender())
        }
        _GetFontSize() {
            return this._ptSize
        }
        _SetFontColor(q) {
            this._color.equalsIgnoringAlpha(q) || (this._color.copyRgb(q), this._rendererText.SetColor(this._color), this._runtime.UpdateRender())
        }
        _GetFontColor() {
            return this._color
        }
        _SetLineHeight(q) {
            this._lineHeightOffset !== q && (this._lineHeightOffset = q, this._UpdateTextSettings(), this._runtime.UpdateRender())
        }
        _GetLineHeight() {
            return this._lineHeightOffset
        }
        _SetHAlign(q) {
            this._horizontalAlign !==
                q && (this._horizontalAlign = q, this._UpdateTextSettings(), this._runtime.UpdateRender())
        }
        _GetHAlign() {
            return this._horizontalAlign
        }
        _SetVAlign(q) {
            this._verticalAlign !== q && (this._verticalAlign = q, this._UpdateTextSettings(), this._runtime.UpdateRender())
        }
        _GetVAlign() {
            return this._verticalAlign
        }
        _SetWrapByWord(q) {
            q = !!q;
            this._wrapByWord !== q && (this._wrapByWord = q, this._UpdateTextSettings(), this._runtime.UpdateRender())
        }
        _IsWrapByWord() {
            return this._wrapByWord
        }
        _GetTextWidth() {
            this._UpdateTextSize();
            return this._rendererText.GetTextWidth()
        }
        _GetTextHeight() {
            this._UpdateTextSize();
            return this._rendererText.GetTextHeight()
        }
        Tick() {
            var q = this._runtime.GetWallTime();
            q >= this._typewriterEndTime ? (this._CancelTypewriter(), this.Trigger(e.Plugins.Text.Cnds.OnTypewriterTextFinished), this._runtime.UpdateRender()) : (q = e.relerp(this._typewriterStartTime, this._typewriterEndTime, q, 0, this._typewriterLength), q = Math.floor(q), q !== this._rendererText.GetDrawMaxCharacterCount() && (this._rendererText.SetDrawMaxCharacterCount(q), this._runtime.UpdateRender()))
        }
        GetDebuggerProperties() {
            return [{
                title: "plugins.text.name",
                properties: [{
                    name: "plugins.text.properties.text.name",
                    value: this._text,
                    onedit: q => this._SetText(q)
                }]
            }]
        }
        GetScriptInterfaceClass() {
            return self.ITextInstance
        }
    };
    const l = new WeakMap,
        n = new Map([
            ["left", 0],
            ["center", 1],
            ["right", 2]
        ]),
        u = new Map([
            ["top", 0],
            ["center", 1],
            ["bottom", 2]
        ]),
        w = new Map([
            ["word", !0],
            ["character", !1]
        ]);
    self.ITextInstance = class extends self.IWorldInstance {
        constructor() {
            super();
            l.set(this, self.IInstance._GetInitInst().GetSdkInstance())
        }
        get text() {
            return l.get(this).GetText()
        }
        set text(q) {
            a.RequireString(q);
            const t = l.get(this);
            t._CancelTypewriter();
            t._SetText(q)
        }
        typewriterText(q, t) {
            a.RequireString(q);
            a.RequireFiniteNumber(t);
            const p = l.get(this);
            p._CancelTypewriter();
            p._StartTypewriter(q, t)
        }
        typewriterFinish() {
            l.get(this)._FinishTypewriter()
        }
        set fontFace(q) {
            a.RequireString(q);
            l.get(this)._SetFontFace(q)
        }
        get fontFace() {
            return l.get(this)._GetFontFace()
        }
        set isBold(q) {
            l.get(this)._SetBold(q)
        }
        get isBold() {
            return l.get(this)._IsBold()
        }
        set isItalic(q) {
            l.get(this)._SetItalic(q)
        }
        get isItalic() {
            return l.get(this)._IsItalic()
        }
        set sizePt(q) {
            a.RequireFiniteNumber(q);
            l.get(this)._SetFontSize(q)
        }
        get sizePt() {
            return l.get(this)._GetFontSize()
        }
        set fontColor(q) {
            a.RequireArray(q);
            if (3 > q.length) throw Error("expected 3 elements");
            h.setRgb(q[0], q[1], q[2]);
            l.get(this)._SetFontColor(h)
        }
        get fontColor() {
            const q = l.get(this)._GetFontColor();
            return [q.getR(), q.getG(), q.getB()]
        }
        set lineHeight(q) {
            a.RequireFiniteNumber(q);
            l.get(this)._SetLineHeight(q)
        }
        get lineHeight() {
            return l.get(this)._GetLineHeight()
        }
        set horizontalAlign(q) {
            a.RequireString(q);
            q = n.get(q);
            if ("undefined" === typeof q) throw Error("invalid mode");
            l.get(this)._SetHAlign(q)
        }
        get horizontalAlign() {
            return d[l.get(this)._GetHAlign()]
        }
        set verticalAlign(q) {
            a.RequireString(q);
            q = u.get(q);
            if ("undefined" === typeof q) throw Error("invalid mode");
            l.get(this)._SetVAlign(q)
        }
        get verticalAlign() {
            return c[l.get(this)._GetVAlign()]
        }
        set wordWrapMode(q) {
            a.RequireString(q);
            q = w.get(q);
            if ("undefined" === typeof q) throw Error("invalid mode");
            l.get(this)._SetWrapByWord(q)
        }
        get wordWrapMode() {
            return l.get(this)._IsWrapByWord() ? "word" : "character"
        }
        get textWidth() {
            return l.get(this)._GetTextWidth()
        }
        get textHeight() {
            return l.get(this)._GetTextHeight()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.Text.Cnds = {
        CompareText(a, b) {
            return b ? this._text === a : e.equalsNoCase(this._text, a)
        },
        IsRunningTypewriterText() {
            return -1 !== this._typewriterEndTime
        },
        OnTypewriterTextFinished() {
            return !0
        }
    }
} {
    "use strict";
    const e = self.C3,
        a = e.New(e.Color);
    e.Plugins.Text.Acts = {
        SetText(b) {
            this._CancelTypewriter();
            "number" === typeof b && 1E9 > b && (b = Math.round(1E10 * b) / 1E10);
            this._SetText(b.toString())
        },
        AppendText(b) {
            this._CancelTypewriter();
            "number" === typeof b && 1E9 > b && (b = Math.round(1E10 * b) / 1E10);
            (b = b.toString()) && this._SetText(this._text + b)
        },
        TypewriterText(b, d) {
            this._CancelTypewriter();
            "number" === typeof b && 1E9 > b && (b = Math.round(1E10 * b) / 1E10);
            this._StartTypewriter(b.toString(), d)
        },
        SetFontFace(b, d) {
            let c = !1,
                f = !1;
            switch (d) {
                case 1:
                    c = !0;
                    break;
                case 2:
                    f = !0;
                    break;
                case 3:
                    f = c = !0
            }
            if (b !== this._faceName || c !== this._isBold || f !== this._isItalic) this._SetFontFace(b), this._SetBold(c), this._SetItalic(f)
        },
        SetFontSize(b) {
            this._SetFontSize(b)
        },
        SetFontColor(b) {
            a.setFromRgbValue(b);
            a.clamp();
            this._SetFontColor(a)
        },
        SetWebFont(b, d) {
            console.warn("[Text] 'Set web font' action is deprecated and no longer has any effect")
        },
        SetEffect(b) {
            this.GetWorldInfo().SetBlendMode(b);
            this._runtime.UpdateRender()
        },
        TypewriterFinish() {
            this._FinishTypewriter()
        },
        SetLineHeight(b) {
            this._SetLineHeight(b)
        },
        SetHAlign(b) {
            this._SetHAlign(b)
        },
        SetVAlign(b) {
            this._SetVAlign(b)
        },
        SetWrapping(b) {
            this._SetWrapByWord(0 === b)
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.Text.Exps = {
        Text() {
            return this._text
        },
        PlainText() {
            return this._enableBBcode ? e.BBString.StripAnyTags(this._text) : this._text
        },
        FaceName() {
            return this._faceName
        },
        FaceSize() {
            return this._ptSize
        },
        TextWidth() {
            return this._GetTextWidth()
        },
        TextHeight() {
            return this._GetTextHeight()
        },
        LineHeight() {
            return this._lineHeightOffset
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.Touch = class extends e.SDKPluginBase {
        constructor(a) {
            super(a)
        }
        Release() {
            super.Release()
        }
    }
} {
    "use strict";
    const e = self.C3,
        a = self.C3X;
    e.Plugins.Touch.Type = class extends e.SDKTypeBase {
        constructor(c) {
            super(c)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
        GetScriptInterfaceClass() {
            return self.ITouchObjectType
        }
    };
    let b = null;

    function d() {
        return b.GetSingleGlobalInstance().GetSdkInstance()
    }
    self.ITouchObjectType = class extends self.IObjectClass {
        constructor(c) {
            super(c);
            b = c;
            c.GetRuntime()._GetCommonScriptInterfaces().touch = this
        }
        requestPermission(c) {
            a.RequireString(c);
            const f = d();
            if ("orientation" === c) return f._RequestPermission(0);
            if ("motion" === c) return f._RequestPermission(1);
            throw Error("invalid type");
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.Touch.Instance = class extends e.SDKInstanceBase {
        constructor(a, b) {
            super(a, "touch");
            this._touches = new Map;
            this._isMouseDown = this._useMouseInput = !1;
            this._getTouchIndex = this._curTouchY = this._curTouchX = this._triggerPermission = this._triggerId = this._triggerIndex = this._accWithGZ = this._accWithGY = this._accWithGX = this._accZ = this._accY = this._accX = this._orientGamma = this._orientBeta = this._orientAlpha = this._orientCompassHeading = 0;
            this._permissionPromises = [];
            b && (this._useMouseInput =
                b[0]);
            this.AddDOMMessageHandler("permission-result", d => this._OnPermissionResult(d));
            a = this.GetRuntime().Dispatcher();
            this._disposables = new e.CompositeDisposable(e.Disposable.From(a, "pointerdown", d => this._OnPointerDown(d.data)), e.Disposable.From(a, "pointermove", d => this._OnPointerMove(d.data)), e.Disposable.From(a, "pointerup", d => this._OnPointerUp(d.data, !1)), e.Disposable.From(a, "pointercancel", d => this._OnPointerUp(d.data, !0)), e.Disposable.From(a, "deviceorientation", d => this._OnDeviceOrientation(d.data)),
                e.Disposable.From(a, "deviceorientationabsolute", d => this._OnDeviceOrientationAbsolute(d.data)), e.Disposable.From(a, "devicemotion", d => this._OnDeviceMotion(d.data)), e.Disposable.From(a, "tick2", d => this._OnTick2()))
        }
        Release() {
            this._touches.clear();
            super.Release()
        }
        _OnPointerDown(a) {
            if ("mouse" === a.pointerType)
                if (this._useMouseInput) this._isMouseDown = !0;
                else return;
            const b = a.pointerId;
            if (!this._touches.has(b)) {
                var d = a.pageX - this._runtime.GetCanvasClientX();
                a = a.pageY - this._runtime.GetCanvasClientY();
                var c =
                    performance.now(),
                    f = this._touches.size;
                this._triggerIndex = f;
                this._triggerId = b;
                var k = e.New(e.Plugins.Touch.TouchInfo);
                k.Init(c, d, a, b, f);
                this._touches.set(b, k);
                this.Trigger(e.Plugins.Touch.Cnds.OnNthTouchStart);
                this.Trigger(e.Plugins.Touch.Cnds.OnTouchStart);
                this._curTouchX = d;
                this._curTouchY = a;
                this.Trigger(e.Plugins.Touch.Cnds.OnTouchObject)
            }
        }
        _OnPointerMove(a) {
            if ("mouse" !== a.pointerType || this._isMouseDown) {
                var b = this._touches.get(a.pointerId);
                if (b) {
                    var d = performance.now();
                    if (!(2 > d - b.GetTime())) {
                        var c =
                            a.pageX - this._runtime.GetCanvasClientX(),
                            f = a.pageY - this._runtime.GetCanvasClientY();
                        b.Update(d, c, f, a.width, a.height, a.pressure)
                    }
                }
            }
        }
        _OnPointerUp(a, b) {
            if ("mouse" === a.pointerType)
                if (this._isMouseDown) this._isMouseDown = !1;
                else return;
            const d = performance.now();
            a = a.pointerId;
            const c = this._touches.get(a);
            c && (this._triggerIndex = c.GetStartIndex(), this._triggerId = c.GetId(), this.Trigger(e.Plugins.Touch.Cnds.OnNthTouchEnd), this.Trigger(e.Plugins.Touch.Cnds.OnTouchEnd), b || (b = c.ShouldTriggerTap(d), "single-tap" ===
                b ? (this.Trigger(e.Plugins.Touch.Cnds.OnTapGesture), this._curTouchX = c.GetX(), this._curTouchY = c.GetY(), this.Trigger(e.Plugins.Touch.Cnds.OnTapGestureObject)) : "double-tap" === b && (this.Trigger(e.Plugins.Touch.Cnds.OnDoubleTapGesture), this._curTouchX = c.GetX(), this._curTouchY = c.GetY(), this.Trigger(e.Plugins.Touch.Cnds.OnDoubleTapGestureObject))), c.Release(), this._touches.delete(a))
        }
        _RequestPermission(a) {
            this._PostToDOMMaybeSync("request-permission", {
                type: a
            });
            return new Promise((b, d) => {
                this._permissionPromises.push({
                    type: a,
                    resolve: b,
                    reject: d
                })
            })
        }
        _OnPermissionResult(a) {
            const b = a.result,
                d = a.type;
            this._triggerPermission = d;
            a = this._permissionPromises.filter(c => c.type === d);
            for (const c of a) c.resolve(b ? "granted" : "denied");
            this._permissionPromises = this._permissionPromises.filter(c => c.type !== d);
            b ? (this.Trigger(e.Plugins.Touch.Cnds.OnPermissionGranted), 0 === d ? this._runtime.RequestDeviceOrientationEvent() : this._runtime.RequestDeviceMotionEvent()) : this.Trigger(e.Plugins.Touch.Cnds.OnPermissionDenied)
        }
        _OnDeviceOrientation(a) {
            "number" ===
            typeof a.webkitCompassHeading ? this._orientCompassHeading = a.webkitCompassHeading : a.absolute && (this._orientCompassHeading = a.alpha);
            this._orientAlpha = a.alpha;
            this._orientBeta = a.beta;
            this._orientGamma = a.gamma
        }
        _OnDeviceOrientationAbsolute(a) {
            this._orientCompassHeading = a.alpha
        }
        _OnDeviceMotion(a) {
            const b = a.acceleration;
            b && (this._accX = b.x, this._accY = b.y, this._accZ = b.z);
            if (a = a.accelerationIncludingGravity) this._accWithGX = a.x, this._accWithGY = a.y, this._accWithGZ = a.z
        }
        _OnTick2() {
            const a = performance.now();
            let b =
                0;
            for (const d of this._touches.values()) d.GetTime() <= a - 50 && d._SetLastTime(a), d.ShouldTriggerHold(a) && (this._triggerIndex = d.GetStartIndex(), this._triggerId = d.GetId(), this._getTouchIndex = b, this.Trigger(e.Plugins.Touch.Cnds.OnHoldGesture), this._curTouchX = d.GetX(), this._curTouchY = d.GetY(), this.Trigger(e.Plugins.Touch.Cnds.OnHoldGestureObject), this._getTouchIndex = 0), ++b
        }
        _GetTouchByIndex(a) {
            a = Math.floor(a);
            for (const b of this._touches.values()) {
                if (0 === a) return b;
                --a
            }
            return null
        }
        _IsClientPosOnCanvas(a, b) {
            return 0 <=
                a && 0 <= b && a < this._runtime.GetCanvasCssWidth() && b < this._runtime.GetCanvasCssHeight()
        }
        GetDebuggerProperties() {
            return [{
                title: "plugins.touch.debugger.touches",
                properties: [...this._touches.values()].map(a => ({
                    name: "$" + a.GetId(),
                    value: a.GetX() + ", " + a.GetY()
                }))
            }]
        }
    }
} {
    "use strict";
    const e = self.C3,
        a = [];
    e.Plugins.Touch.Cnds = {
        OnTouchStart() {
            return !0
        },
        OnTouchEnd() {
            return !0
        },
        IsInTouch() {
            return 0 < this._touches.size
        },
        OnTouchObject(b) {
            return b && this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY) ? this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(b, this._curTouchX, this._curTouchY, !1) : !1
        },
        IsTouchingObject(b) {
            if (!b) return !1;
            const d = b.GetCurrentSol();
            var c = d.GetInstances();
            for (const f of c) {
                c = f.GetWorldInfo();
                const k = c.GetLayer();
                for (const h of this._touches.values()) {
                    if (!this._IsClientPosOnCanvas(h.GetX(),
                            h.GetY())) continue;
                    const [l, n] = k.CanvasCssToLayer(h.GetX(), h.GetY(), c.GetTotalZElevation());
                    if (c.ContainsPoint(l, n)) {
                        a.push(f);
                        break
                    }
                }
            }
            return a.length ? (d.SetArrayPicked(a), b.ApplySolToContainer(), e.clearArray(a), !0) : !1
        },
        CompareTouchSpeed(b, d, c) {
            return (b = this._GetTouchByIndex(b)) ? e.compare(b.GetSpeed(), d, c) : !1
        },
        OrientationSupported() {
            return !0
        },
        MotionSupported() {
            return !0
        },
        CompareOrientation(b, d, c) {
            this._runtime.RequestDeviceOrientationEvent();
            return e.compare(0 === b ? this._orientAlpha : 1 === b ? this._orientBeta :
                this._orientGamma, d, c)
        },
        CompareAcceleration(b, d, c) {
            this._runtime.RequestDeviceMotionEvent();
            return e.compare(0 === b ? this._accWithGX : 1 === b ? this._accWithGY : 2 === b ? this._accWithGZ : 3 === b ? this._accX : 4 === b ? this._accY : this._accZ, d, c)
        },
        OnNthTouchStart(b) {
            b = Math.floor(b);
            return b === this._triggerIndex
        },
        OnNthTouchEnd(b) {
            b = Math.floor(b);
            return b === this._triggerIndex
        },
        HasNthTouch(b) {
            b = Math.floor(b);
            return this._touches.size >= b + 1
        },
        OnHoldGesture() {
            return !0
        },
        OnTapGesture() {
            return !0
        },
        OnDoubleTapGesture() {
            return !0
        },
        OnHoldGestureObject(b) {
            return b && this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY) ? this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(b, this._curTouchX, this._curTouchY, !1) : !1
        },
        OnTapGestureObject(b) {
            return b && this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY) ? this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(b, this._curTouchX, this._curTouchY, !1) : !1
        },
        OnDoubleTapGestureObject(b) {
            return b && this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY) ? this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(b,
                this._curTouchX, this._curTouchY, !1) : !1
        },
        OnPermissionGranted(b) {
            return this._triggerPermission === b
        },
        OnPermissionDenied(b) {
            return this._triggerPermission === b
        }
    }
}
"use strict";
self.C3.Plugins.Touch.Acts = {
    RequestPermission(e) {
        this._RequestPermission(e)
    }
}; {
    "use strict";
    const e = self.C3;
    e.Plugins.Touch.Exps = {
        TouchCount() {
            return this._touches.size
        },
        X(a) {
            const b = this._GetTouchByIndex(this._getTouchIndex);
            return b ? b.GetPositionForLayer(this._runtime.GetCurrentLayout(), a, !0) : 0
        },
        Y(a) {
            const b = this._GetTouchByIndex(this._getTouchIndex);
            return b ? b.GetPositionForLayer(this._runtime.GetCurrentLayout(), a, !1) : 0
        },
        XAt(a, b) {
            return (a = this._GetTouchByIndex(a)) ? a.GetPositionForLayer(this._runtime.GetCurrentLayout(), b, !0) : 0
        },
        YAt(a, b) {
            return (a = this._GetTouchByIndex(a)) ?
                a.GetPositionForLayer(this._runtime.GetCurrentLayout(), b, !1) : 0
        },
        XForID(a, b) {
            return (a = this._touches.get(a)) ? a.GetPositionForLayer(this._runtime.GetCurrentLayout(), b, !0) : 0
        },
        YForID(a, b) {
            return (a = this._touches.get(a)) ? a.GetPositionForLayer(this._runtime.GetCurrentLayout(), b, !1) : 0
        },
        AbsoluteX() {
            const a = this._GetTouchByIndex(0);
            return a ? a.GetX() : 0
        },
        AbsoluteY() {
            const a = this._GetTouchByIndex(0);
            return a ? a.GetY() : 0
        },
        AbsoluteXAt(a) {
            return (a = this._GetTouchByIndex(a)) ? a.GetX() : 0
        },
        AbsoluteYAt(a) {
            return (a = this._GetTouchByIndex(a)) ?
                a.GetY() : 0
        },
        AbsoluteXForID(a) {
            return (a = this._touches.get(a)) ? a.GetX() : 0
        },
        AbsoluteYForID(a) {
            return (a = this._touches.get(a)) ? a.GetY() : 0
        },
        SpeedAt(a) {
            return (a = this._GetTouchByIndex(a)) ? a.GetSpeed() : 0
        },
        SpeedForID(a) {
            return (a = this._touches.get(a)) ? a.GetSpeed() : 0
        },
        AngleAt(a) {
            return (a = this._GetTouchByIndex(a)) ? e.toDegrees(a.GetAngle()) : 0
        },
        AngleForID(a) {
            return (a = this._touches.get(a)) ? e.toDegrees(a.GetAngle()) : 0
        },
        CompassHeading() {
            this._runtime.RequestDeviceOrientationEvent();
            return this._orientCompassHeading
        },
        Alpha() {
            this._runtime.RequestDeviceOrientationEvent();
            return this._orientAlpha
        },
        Beta() {
            this._runtime.RequestDeviceOrientationEvent();
            return this._orientBeta
        },
        Gamma() {
            this._runtime.RequestDeviceOrientationEvent();
            return this._orientGamma
        },
        AccelerationXWithG() {
            this._runtime.RequestDeviceMotionEvent();
            return this._accWithGX
        },
        AccelerationYWithG() {
            this._runtime.RequestDeviceMotionEvent();
            return this._accWithGY
        },
        AccelerationZWithG() {
            this._runtime.RequestDeviceMotionEvent();
            return this._accWithGZ
        },
        AccelerationX() {
            this._runtime.RequestDeviceMotionEvent();
            return this._accX
        },
        AccelerationY() {
            this._runtime.RequestDeviceMotionEvent();
            return this._accY
        },
        AccelerationZ() {
            this._runtime.RequestDeviceMotionEvent();
            return this._accZ
        },
        TouchIndex() {
            return this._triggerIndex
        },
        TouchID() {
            return this._triggerId
        },
        WidthForID(a) {
            return (a = this._touches.get(a)) ? a.GetWidth() : 0
        },
        HeightForID(a) {
            return (a = this._touches.get(a)) ? a.GetHeight() : 0
        },
        PressureForID(a) {
            return (a = this._touches.get(a)) ? a.GetPressure() : 0
        }
    }
} {
    "use strict";
    const e = self.C3;
    let a = -1E3,
        b = -1E3,
        d = -1E4;
    e.Plugins.Touch.TouchInfo = class extends e.DefendedBase {
        constructor() {
            super();
            this._pressure = this._height = this._width = this._lastY = this._lastX = this._y = this._x = this._startY = this._startX = this._lastTime = this._time = this._startTime = this._startIndex = this._pointerId = 0;
            this._isTooFarForHold = this._hasTriggeredHold = !1
        }
        Release() {}
        Init(c, f, k, h, l) {
            this._pointerId = h;
            this._startIndex = l;
            this._startTime = this._lastTime = this._time = c;
            this._startX = f;
            this._startY = k;
            this._x = f;
            this._y = k;
            this._lastX = f;
            this._lastY = k
        }
        Update(c, f, k, h, l, n) {
            this._lastTime = this._time;
            this._time = c;
            this._lastX = this._x;
            this._lastY = this._y;
            this._x = f;
            this._y = k;
            this._width = h;
            this._height = l;
            this._pressure = n;
            !this._isTooFarForHold && 15 <= e.distanceTo(this._startX, this._startY, this._x, this._y) && (this._isTooFarForHold = !0)
        }
        GetId() {
            return this._pointerId
        }
        GetStartIndex() {
            return this._startIndex
        }
        GetTime() {
            return this._time
        }
        _SetLastTime(c) {
            this._lastTime = c
        }
        GetX() {
            return this._x
        }
        GetY() {
            return this._y
        }
        GetSpeed() {
            const c =
                e.distanceTo(this._x, this._y, this._lastX, this._lastY),
                f = (this._time - this._lastTime) / 1E3;
            return 0 < f ? c / f : 0
        }
        GetAngle() {
            return e.angleTo(this._lastX, this._lastY, this._x, this._y)
        }
        GetWidth() {
            return this._width
        }
        GetHeight() {
            return this._height
        }
        GetPressure() {
            return this._pressure
        }
        ShouldTriggerHold(c) {
            return this._hasTriggeredHold ? !1 : 500 <= c - this._startTime && !this._isTooFarForHold && 15 > e.distanceTo(this._startX, this._startY, this._x, this._y) ? this._hasTriggeredHold = !0 : !1
        }
        ShouldTriggerTap(c) {
            if (this._hasTriggeredHold) return "";
            if (333 >= c - this._startTime && !this._isTooFarForHold && 15 > e.distanceTo(this._startX, this._startY, this._x, this._y)) {
                if (666 >= c - d && 25 > e.distanceTo(a, b, this._x, this._y)) return b = a = -1E3, d = -1E4, "double-tap";
                a = this._x;
                b = this._y;
                d = c;
                return "single-tap"
            }
            return ""
        }
        GetPositionForLayer(c, f, k) {
            return "undefined" === typeof f ? c.GetLayerByIndex(0).CanvasCssToLayer_DefaultTransform(this._x, this._y)[k ? 0 : 1] : (c = c.GetLayer(f)) ? c.CanvasCssToLayer(this._x, this._y)[k ? 0 : 1] : 0
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.Keyboard = class extends e.SDKPluginBase {
        constructor(a) {
            super(a)
        }
        Release() {
            super.Release()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.Keyboard.Type = class extends e.SDKTypeBase {
        constructor(d) {
            super(d)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
        GetScriptInterfaceClass() {
            return self.IKeyboardObjectType
        }
    };
    let a = null;

    function b() {
        return a.GetSingleGlobalInstance().GetSdkInstance()
    }
    self.IKeyboardObjectType = class extends self.IObjectClass {
        constructor(d) {
            super(d);
            a = d;
            d.GetRuntime()._GetCommonScriptInterfaces().keyboard = this
        }
        isKeyDown(d) {
            const c = b();
            if ("string" === typeof d) return c.IsKeyDown(d);
            if ("number" ===
                typeof d) return c.IsKeyCodeDown(d);
            throw new TypeError("expected string or number");
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.Keyboard.Instance = class extends e.SDKInstanceBase {
        constructor(a, b) {
            super(a);
            this._keysDownByString = new Set;
            this._keysDownByWhich = new Set;
            this._triggerWhich = 0;
            this._triggerTypedKey = this._triggerString = "";
            a = this.GetRuntime().Dispatcher();
            this._disposables = new e.CompositeDisposable(e.Disposable.From(a, "keydown", d => this._OnKeyDown(d.data)), e.Disposable.From(a, "keyup", d => this._OnKeyUp(d.data)), e.Disposable.From(a, "window-blur", () => this._OnWindowOrKeyboardBlur()),
                e.Disposable.From(a, "keyboard-blur", () => this._OnWindowOrKeyboardBlur()))
        }
        Release() {
            super.Release()
        }
        _OnKeyDown(a) {
            const b = a.which,
                d = a.code || b.toString();
            a = a.key;
            this._keysDownByString.has(d) || (this._keysDownByString.add(d), this._keysDownByWhich.add(b), this._triggerString = d, this._triggerWhich = b, this._triggerTypedKey = a, this.Trigger(e.Plugins.Keyboard.Cnds.OnAnyKey), this.Trigger(e.Plugins.Keyboard.Cnds.OnKey), this.Trigger(e.Plugins.Keyboard.Cnds.OnLeftRightKeyPressed), this.Trigger(e.Plugins.Keyboard.Cnds.OnKeyCode))
        }
        _OnKeyUp(a) {
            const b =
                a.which,
                d = a.code || b.toString();
            a = a.key;
            this._keysDownByString.delete(d);
            this._keysDownByWhich.delete(b);
            this._triggerString = d;
            this._triggerWhich = b;
            this._triggerTypedKey = a;
            this.Trigger(e.Plugins.Keyboard.Cnds.OnAnyKeyReleased);
            this.Trigger(e.Plugins.Keyboard.Cnds.OnKeyReleased);
            this.Trigger(e.Plugins.Keyboard.Cnds.OnLeftRightKeyReleased);
            this.Trigger(e.Plugins.Keyboard.Cnds.OnKeyCodeReleased)
        }
        _OnWindowOrKeyboardBlur() {
            for (const a of this._keysDownByWhich) this._keysDownByWhich.delete(a), this._triggerWhich =
                a, this.Trigger(e.Plugins.Keyboard.Cnds.OnAnyKeyReleased), this.Trigger(e.Plugins.Keyboard.Cnds.OnKeyReleased), this.Trigger(e.Plugins.Keyboard.Cnds.OnKeyCodeReleased);
            this._keysDownByString.clear()
        }
        IsKeyDown(a) {
            return this._keysDownByString.has(a)
        }
        IsKeyCodeDown(a) {
            return this._keysDownByWhich.has(a)
        }
        SaveToJson() {
            return {
                tk: this._triggerWhich,
                tkk: this._triggerTypedKey
            }
        }
        LoadFromJson(a) {
            this._triggerWhich = a.tk;
            a.hasOwnProperty("tkk") && (this._triggerTypedKey = a.tkk)
        }
        GetDebuggerProperties() {
            return [{
                title: "plugins.keyboard.name",
                properties: [{
                    name: "plugins.keyboard.debugger.last-key-code",
                    value: this._triggerWhich
                }, {
                    name: "plugins.keyboard.debugger.last-key-string",
                    value: e.Plugins.Keyboard.Exps.StringFromKeyCode(this._triggerWhich)
                }, {
                    name: "plugins.keyboard.debugger.last-typed-key",
                    value: this._triggerTypedKey
                }]
            }]
        }
    }
} {
    "use strict";
    const e = "ShiftLeft ShiftRight ControlLeft ControlRight AltLeft AltRight MetaLeft MetaRight".split(" ");
    self.C3.Plugins.Keyboard.Cnds = {
        IsKeyDown(a) {
            return this._keysDownByWhich.has(a)
        },
        OnKey(a) {
            return this._triggerWhich === a
        },
        OnAnyKey() {
            return !0
        },
        OnAnyKeyReleased() {
            return !0
        },
        OnKeyReleased(a) {
            return this._triggerWhich === a
        },
        IsKeyCodeDown(a) {
            a = Math.floor(a);
            return this._keysDownByWhich.has(a)
        },
        OnKeyCode(a) {
            return this._triggerWhich === a
        },
        OnKeyCodeReleased(a) {
            return this._triggerWhich === a
        },
        OnLeftRightKeyPressed(a) {
            return this._triggerString === e[a]
        },
        OnLeftRightKeyReleased(a) {
            return this._triggerString === e[a]
        },
        IsLeftRightKeyDown(a) {
            return this._keysDownByString.has(e[a])
        }
    }
}
"use strict";
self.C3.Plugins.Keyboard.Acts = {}; {
    "use strict";

    function e(a) {
        a = Math.floor(a);
        switch (a) {
            case 8:
                return "backspace";
            case 9:
                return "tab";
            case 13:
                return "enter";
            case 16:
                return "shift";
            case 17:
                return "control";
            case 18:
                return "alt";
            case 19:
                return "pause";
            case 20:
                return "capslock";
            case 27:
                return "esc";
            case 33:
                return "pageup";
            case 34:
                return "pagedown";
            case 35:
                return "end";
            case 36:
                return "home";
            case 37:
                return "\u2190";
            case 38:
                return "\u2191";
            case 39:
                return "\u2192";
            case 40:
                return "\u2193";
            case 45:
                return "insert";
            case 46:
                return "del";
            case 91:
                return "left window key";
            case 92:
                return "right window key";
            case 93:
                return "select";
            case 96:
                return "numpad 0";
            case 97:
                return "numpad 1";
            case 98:
                return "numpad 2";
            case 99:
                return "numpad 3";
            case 100:
                return "numpad 4";
            case 101:
                return "numpad 5";
            case 102:
                return "numpad 6";
            case 103:
                return "numpad 7";
            case 104:
                return "numpad 8";
            case 105:
                return "numpad 9";
            case 106:
                return "numpad *";
            case 107:
                return "numpad +";
            case 109:
                return "numpad -";
            case 110:
                return "numpad .";
            case 111:
                return "numpad /";
            case 112:
                return "F1";
            case 113:
                return "F2";
            case 114:
                return "F3";
            case 115:
                return "F4";
            case 116:
                return "F5";
            case 117:
                return "F6";
            case 118:
                return "F7";
            case 119:
                return "F8";
            case 120:
                return "F9";
            case 121:
                return "F10";
            case 122:
                return "F11";
            case 123:
                return "F12";
            case 144:
                return "numlock";
            case 145:
                return "scroll lock";
            case 186:
                return ";";
            case 187:
                return "=";
            case 188:
                return ",";
            case 189:
                return "-";
            case 190:
                return ".";
            case 191:
                return "/";
            case 192:
                return "'";
            case 219:
                return "[";
            case 220:
                return "\\";
            case 221:
                return "]";
            case 222:
                return "#";
            case 223:
                return "`";
            default:
                return String.fromCharCode(a)
        }
    }
    self.C3.Plugins.Keyboard.Exps = {
        LastKeyCode() {
            return this._triggerWhich
        },
        StringFromKeyCode(a) {
            return e(a)
        },
        TypedKey() {
            return this._triggerTypedKey
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.Mouse = class extends e.SDKPluginBase {
        constructor(a) {
            super(a)
        }
        Release() {
            super.Release()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.Mouse.Type = class extends e.SDKTypeBase {
        constructor(d) {
            super(d)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
        GetScriptInterfaceClass() {
            return self.IMouseObjectType
        }
    };
    let a = null;

    function b() {
        return a.GetSingleGlobalInstance().GetSdkInstance()
    }
    self.IMouseObjectType = class extends self.IObjectClass {
        constructor(d) {
            super(d);
            a = d;
            d.GetRuntime()._GetCommonScriptInterfaces().mouse = this
        }
        getMouseX(d) {
            return b().GetMousePositionForLayer(d)[0]
        }
        getMouseY(d) {
            return b().GetMousePositionForLayer(d)[1]
        }
        getMousePosition(d) {
            return b().GetMousePositionForLayer(d)
        }
        isMouseButtonDown(d) {
            return b().IsMouseButtonDown(d)
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.Mouse.Instance = class extends e.SDKInstanceBase {
        constructor(a, b) {
            super(a, "mouse");
            this._buttonMap = [!1, !1, !1];
            this._triggerDir = this._triggerType = this._triggerButton = this._mouseYcanvas = this._mouseXcanvas = 0;
            this._hasPointerLock = !1;
            this._movementY = this._movementX = 0;
            this.AddDOMMessageHandlers([
                ["pointer-lock-change", d => this._OnPointerLockChange(d)],
                ["pointer-lock-error", d => this._OnPointerLockError(d)]
            ]);
            a = this.GetRuntime().Dispatcher();
            this._disposables = new e.CompositeDisposable(e.Disposable.From(a,
                "pointermove", d => this._OnPointerMove(d.data)), e.Disposable.From(a, "pointerdown", d => this._OnPointerDown(d.data)), e.Disposable.From(a, "pointerup", d => this._OnPointerUp(d.data)), e.Disposable.From(a, "dblclick", d => this._OnDoubleClick(d.data)), e.Disposable.From(a, "wheel", d => this._OnMouseWheel(d.data)), e.Disposable.From(a, "window-blur", () => this._OnWindowBlur()))
        }
        Release() {
            super.Release()
        }
        _OnPointerDown(a) {
            "mouse" === a.pointerType && (this._mouseXcanvas = a.pageX - this._runtime.GetCanvasClientX(), this._mouseYcanvas =
                a.pageY - this._runtime.GetCanvasClientY(), this._CheckButtonChanges(a.lastButtons, a.buttons))
        }
        _OnPointerMove(a) {
            this._movementX = a.movementX;
            this._movementY = a.movementY;
            this.Trigger(e.Plugins.Mouse.Cnds.OnMovement);
            this._movementY = this._movementX = 0;
            "mouse" === a.pointerType && (this._mouseXcanvas = a.pageX - this._runtime.GetCanvasClientX(), this._mouseYcanvas = a.pageY - this._runtime.GetCanvasClientY(), this._CheckButtonChanges(a.lastButtons, a.buttons))
        }
        _OnPointerUp(a) {
            "mouse" === a.pointerType && this._CheckButtonChanges(a.lastButtons,
                a.buttons)
        }
        _CheckButtonChanges(a, b) {
            this._CheckButtonChange(a, b, 1, 0);
            this._CheckButtonChange(a, b, 4, 1);
            this._CheckButtonChange(a, b, 2, 2)
        }
        _CheckButtonChange(a, b, d, c) {
            !(a & d) && b & d ? this._OnMouseDown(c) : a & d && !(b & d) && this._OnMouseUp(c)
        }
        _OnMouseDown(a) {
            this._buttonMap[a] = !0;
            this.Trigger(e.Plugins.Mouse.Cnds.OnAnyClick);
            this._triggerButton = a;
            this._triggerType = 0;
            this.Trigger(e.Plugins.Mouse.Cnds.OnClick);
            this.Trigger(e.Plugins.Mouse.Cnds.OnObjectClicked)
        }
        _OnMouseUp(a) {
            this._buttonMap[a] && (this._buttonMap[a] = !1, this._triggerButton = a, this.Trigger(e.Plugins.Mouse.Cnds.OnRelease))
        }
        _OnDoubleClick(a) {
            this._triggerButton = a.button;
            this._triggerType = 1;
            this.Trigger(e.Plugins.Mouse.Cnds.OnClick);
            this.Trigger(e.Plugins.Mouse.Cnds.OnObjectClicked)
        }
        _OnMouseWheel(a) {
            this._triggerDir = 0 > a.deltaY ? 1 : 0;
            this.Trigger(e.Plugins.Mouse.Cnds.OnWheel)
        }
        _OnWindowBlur() {
            for (let a = 0, b = this._buttonMap.length; a < b && this._buttonMap[a]; ++a) this._buttonMap[a] = !1, this._triggerButton = a, this.Trigger(e.Plugins.Mouse.Cnds.OnRelease)
        }
        GetMousePositionForLayer(a) {
            const b =
                this._runtime.GetMainRunningLayout(),
                d = this._mouseXcanvas,
                c = this._mouseYcanvas;
            return "undefined" === typeof a ? b.GetLayerByIndex(0).CanvasCssToLayer_DefaultTransform(d, c) : (a = b.GetLayer(a)) ? a.CanvasCssToLayer(d, c) : [0, 0]
        }
        IsMouseButtonDown(a) {
            a = Math.floor(a);
            return !!this._buttonMap[a]
        }
        _IsMouseOverCanvas() {
            return 0 <= this._mouseXcanvas && 0 <= this._mouseYcanvas && this._mouseXcanvas < this._runtime.GetCanvasCssWidth() && this._mouseYcanvas < this._runtime.GetCanvasCssHeight()
        }
        _OnPointerLockChange(a) {
            this._UpdatePointerLockState(a["has-pointer-lock"])
        }
        _OnPointerLockError(a) {
            this._UpdatePointerLockState(a["has-pointer-lock"]);
            this.Trigger(e.Plugins.Mouse.Cnds.OnPointerLockError)
        }
        _UpdatePointerLockState(a) {
            this._hasPointerLock !== a && ((this._hasPointerLock = a) ? this.Trigger(e.Plugins.Mouse.Cnds.OnPointerLocked) : this.Trigger(e.Plugins.Mouse.Cnds.OnPointerUnlocked))
        }
        GetDebuggerProperties() {
            return [{
                title: "plugins.mouse.name",
                properties: [{
                    name: "plugins.mouse.debugger.absolute-position",
                    value: this._mouseXcanvas + "," + this._mouseYcanvas
                }, {
                    name: "plugins.mouse.debugger.left-button",
                    value: this._buttonMap[0]
                }, {
                    name: "plugins.mouse.debugger.middle-button",
                    value: this._buttonMap[1]
                }, {
                    name: "plugins.mouse.debugger.right-button",
                    value: this._buttonMap[2]
                }]
            }, {
                title: "plugins.mouse.debugger.position-on-each-layer",
                properties: this._runtime.GetMainRunningLayout().GetLayers().map(a => ({
                    name: "$" + a.GetName(),
                    value: a.CanvasCssToLayer(this._mouseXcanvas, this._mouseYcanvas).join(", ")
                }))
            }]
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.Mouse.Cnds = {
        OnClick(a, b) {
            return this._triggerButton === a && this._triggerType === b
        },
        OnAnyClick() {
            return !0
        },
        IsButtonDown(a) {
            return this._buttonMap[a]
        },
        OnRelease(a) {
            return this._triggerButton === a
        },
        IsOverObject(a) {
            if (!this._IsMouseOverCanvas()) return !1;
            const b = this._runtime.GetCurrentCondition().IsInverted(),
                d = this._mouseXcanvas,
                c = this._mouseYcanvas;
            return e.xor(this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(a, d, c, b), b)
        },
        OnObjectClicked(a, b, d) {
            if (a !==
                this._triggerButton || b !== this._triggerType || !this._IsMouseOverCanvas()) return !1;
            a = this._mouseXcanvas;
            b = this._mouseYcanvas;
            return this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(d, a, b, !1)
        },
        OnWheel(a) {
            return this._triggerDir === a
        },
        OnPointerLocked() {
            return !0
        },
        OnPointerUnlocked() {
            return !0
        },
        OnPointerLockError() {
            return !0
        },
        HasPointerLock() {
            return this._hasPointerLock
        },
        OnMovement() {
            return !0
        }
    }
} {
    "use strict";
    const e = self.C3;
    let a = null;
    const b = "auto pointer text crosshair move help wait none".split(" ");
    e.Plugins.Mouse.Acts = {
        SetCursor(d) {
            d = b[d];
            a !== d && (a = d, this.PostToDOM("cursor", d))
        },
        SetCursorSprite(d) {
            if (!e.Platform.IsMobile && d && (d = d.GetFirstPicked())) {
                var c = d.GetWorldInfo(),
                    f = d.GetCurrentImageInfo();
                c && f && a !== f && (a = f, f.ExtractImageToCanvas().then(k => e.CanvasToBlob(k)).then(k => {
                    k = `url(${URL.createObjectURL(k)}) ${Math.round(c.GetOriginX()*f.GetWidth())} ${Math.round(c.GetOriginY()*f.GetHeight())}, auto`;
                    this.PostToDOM("cursor", "");
                    this.PostToDOM("cursor", k)
                }))
            }
        },
        RequestPointerLock() {
            this._PostToDOMMaybeSync("request-pointer-lock")
        },
        ReleasePointerLock() {
            this.PostToDOM("release-pointer-lock")
        }
    }
}
"use strict";
self.C3.Plugins.Mouse.Exps = {
    X(e) {
        return this.GetMousePositionForLayer(e)[0]
    },
    Y(e) {
        return this.GetMousePositionForLayer(e)[1]
    },
    AbsoluteX() {
        return this._mouseXcanvas
    },
    AbsoluteY() {
        return this._mouseYcanvas
    },
    MovementX() {
        return this._movementX
    },
    MovementY() {
        return this._movementY
    }
}; {
    "use strict";
    const e = self.C3;
    e.Plugins.PlatformInfo = class extends e.SDKPluginBase {
        constructor(a) {
            super(a)
        }
        Release() {
            super.Release()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.PlatformInfo.Type = class extends e.SDKTypeBase {
        constructor(a) {
            super(a)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.PlatformInfo.Instance = class extends e.SDKInstanceBase {
        constructor(a, b) {
            super(a, "platform-info");
            this._windowOuterHeight = this._windowOuterWidth = this._screenHeight = this._screenWidth = 0;
            this._safeAreaInset = [0, 0, 0, 0];
            this._isWakeLockActive = this._supportsWakeLock = !1;
            this.AddDOMMessageHandlers([
                ["window-resize", d => this._OnWindowResize(d)],
                ["wake-lock-acquired", d => this._OnWakeLockAcquired(d)],
                ["wake-lock-error", d => this._OnWakeLockError(d)],
                ["wake-lock-released", d =>
                    this._OnWakeLockReleased(d)
                ]
            ]);
            navigator.connection && navigator.connection.addEventListener("change", () => this._OnNetworkChange());
            this._runtime.AddLoadPromise(this.PostToDOMAsync("get-initial-state").then(d => {
                this._screenWidth = d.screenWidth;
                this._screenHeight = d.screenHeight;
                this._windowOuterWidth = d.windowOuterWidth;
                this._windowOuterHeight = d.windowOuterHeight;
                this._safeAreaInset = d.safeAreaInset;
                this._supportsWakeLock = d.supportsWakeLock
            }))
        }
        Release() {
            super.Release()
        }
        _OnWindowResize(a) {
            this._windowOuterWidth =
                a.windowOuterWidth;
            this._windowOuterHeight = a.windowOuterHeight;
            this._safeAreaInset = a.safeAreaInset
        }
        async _OnNetworkChange() {
            await this.TriggerAsync(e.Plugins.PlatformInfo.Cnds.OnNetworkChange)
        }
        async _OnWakeLockAcquired() {
            this._isWakeLockActive = !0;
            await this.TriggerAsync(e.Plugins.PlatformInfo.Cnds.OnWakeLockAcquired)
        }
        async _OnWakeLockError() {
            this._isWakeLockActive = !1;
            await this.TriggerAsync(e.Plugins.PlatformInfo.Cnds.OnWakeLockError)
        }
        async _OnWakeLockReleased() {
            this._isWakeLockActive = !1;
            await this.TriggerAsync(e.Plugins.PlatformInfo.Cnds.OnWakeLockReleased)
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.PlatformInfo.Cnds = {
        IsOnMobile() {
            return e.Platform.IsMobile
        },
        IsOnWindows() {
            return "Windows" === e.Platform.OS
        },
        IsOnMacOS() {
            return "Mac OS X" === e.Platform.OS
        },
        IsOnLinux() {
            return "Linux" === e.Platform.OS
        },
        IsOnChromeOS() {
            return "Chrome OS" === e.Platform.OS
        },
        IsOnAndroid() {
            return "Android" === e.Platform.OS
        },
        IsOniOS() {
            return "iOS" === e.Platform.OS
        },
        IsWebExport() {
            const a = this._runtime.GetExportType();
            return "html5" === a || "scirra-arcade" === a || "preview" === a || "instant-games" === a
        },
        IsCordovaExport() {
            return this._runtime.IsCordova()
        },
        IsNWjsExport() {
            return "nwjs" === this._runtime.GetExportType()
        },
        IsWindowsUWPExport() {
            return "windows-uwp" === this._runtime.GetExportType()
        },
        IsWindowsWebView2Export() {
            return "windows-webview2" === this._runtime.GetExportType()
        },
        IsMacOSWKWebView2Export() {
            return "macos-wkwebview" === this._runtime.GetExportType()
        },
        OnNetworkChange() {
            return !0
        },
        OnWakeLockAcquired() {
            return !0
        },
        OnWakeLockError() {
            return !0
        },
        OnWakeLockReleased() {
            return !0
        },
        IsWakeLockActive() {
            return this._isWakeLockActive
        },
        IsWakeLockSupported() {
            return this._supportsWakeLock
        }
    }
}
"use strict";
self.C3.Plugins.PlatformInfo.Acts = {
    RequestWakeLock() {
        this._supportsWakeLock && this._PostToDOMMaybeSync("request-wake-lock")
    },
    ReleaseWakeLock() {
        this._supportsWakeLock && (this._isWakeLockActive = !1, this.PostToDOM("release-wake-lock"))
    }
};
"use strict";
self.C3.Plugins.PlatformInfo.Exps = {
    Renderer() {
        let e;
        e = this._runtime.GetWebGPURenderer() ? "webgpu" : "webgl" + this._runtime.GetWebGLRenderer().GetWebGLVersionNumber();
        this._runtime.GetRenderer().HasMajorPerformanceCaveat() && (e += "-software");
        return e
    },
    RendererDetail() {
        return this._runtime.GetWebGLRenderer().GetUnmaskedRenderer()
    },
    DevicePixelRatio() {
        return self.devicePixelRatio
    },
    ScreenWidth() {
        return this._screenWidth
    },
    ScreenHeight() {
        return this._screenHeight
    },
    WindowInnerWidth() {
        return this._runtime.GetCanvasManager().GetLastWidth()
    },
    WindowInnerHeight() {
        return this._runtime.GetCanvasManager().GetLastHeight()
    },
    WindowOuterWidth() {
        return this._windowOuterWidth
    },
    WindowOuterHeight() {
        return this._windowOuterHeight
    },
    CanvasCssWidth() {
        return this._runtime.GetCanvasManager().GetCssWidth()
    },
    CanvasCssHeight() {
        return this._runtime.GetCanvasManager().GetCssHeight()
    },
    CanvasDeviceWidth() {
        return this._runtime.GetCanvasManager().GetDeviceWidth()
    },
    CanvasDeviceHeight() {
        return this._runtime.GetCanvasManager().GetDeviceHeight()
    },
    Downlink() {
        return navigator.connection ?
            navigator.connection.downlink || 0 : 0
    },
    DownlinkMax() {
        return navigator.connection ? navigator.connection.downlinkMax || 0 : 0
    },
    ConnectionType() {
        return navigator.connection ? navigator.connection.type || "unknown" : "unknown"
    },
    ConnectionEffectiveType() {
        return navigator.connection ? navigator.connection.effectiveType || "unknown" : "unknown"
    },
    ConnectionRTT() {
        return navigator.connection ? navigator.connection.rtt || 0 : 0
    },
    HardwareConcurrency() {
        return navigator.hardwareConcurrency || 0
    },
    DeviceMemory() {
        return navigator.deviceMemory ||
            0
    },
    SafeAreaInsetTop() {
        return this._safeAreaInset[0]
    },
    SafeAreaInsetRight() {
        return this._safeAreaInset[1]
    },
    SafeAreaInsetBottom() {
        return this._safeAreaInset[2]
    },
    SafeAreaInsetLeft() {
        return this._safeAreaInset[3]
    }
}; {
    "use strict";
    const e = self.C3;
    e.Plugins.AJAX = class extends e.SDKPluginBase {
        constructor(a) {
            super(a)
        }
        Release() {
            super.Release()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.AJAX.Type = class extends e.SDKTypeBase {
        constructor(a) {
            super(a)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.AJAX.Instance = class extends e.SDKInstanceBase {
        constructor(a, b) {
            super(a);
            this._curTag = this._lastData = "";
            this._progress = 0;
            this._timeout = -1;
            this._nextRequestHeaders = new Map;
            this._nextReponseBinaryData = null;
            this._nextRequestOverrideMimeType = "";
            this._nwjsAppFolder = this._nwjsPath = this._nwjsFs = null;
            if (this._isNWjs = "nwjs" === this._runtime.GetExportType()) this._nwjsFs = require("fs"), this._nwjsPath = require("path"), this._nwjsAppFolder = this._nwjsPath.dirname((self.process ||
                nw.process).execPath) + "\\"
        }
        Release() {
            super.Release()
        }
        async _TriggerError(a, b, d) {
            console.error(`[Construct 3] AJAX request to '${b}' (tag '${a}') failed: `, d);
            this._curTag = a;
            await this.TriggerAsync(e.Plugins.AJAX.Cnds.OnAnyError);
            await this.TriggerAsync(e.Plugins.AJAX.Cnds.OnError)
        }
        async _TriggerComplete(a) {
            this._curTag = a;
            await this.TriggerAsync(e.Plugins.AJAX.Cnds.OnAnyComplete);
            await this.TriggerAsync(e.Plugins.AJAX.Cnds.OnComplete)
        }
        async _OnProgress(a, b) {
            b.lengthComputable && (this._progress = b.loaded /
                b.total, this._curTag = a, await this.TriggerAsync(e.Plugins.AJAX.Cnds.OnProgress))
        }
        _OnError(a, b, d) {
            if (this._isNWjs) {
                var c = this._nwjsFs,
                    f = this._nwjsAppFolder + b;
                c.existsSync(f) ? c.readFile(f, {
                    encoding: "utf8"
                }, (k, h) => {
                    k ? this._TriggerError(a, b, k) : (this._lastData = h.replace(/\r\n/g, "\n"), this._TriggerComplete(a))
                }) : this._TriggerError(a, b, d)
            } else this._TriggerError(a, b, d)
        }
        async _DoCordovaRequest(a, b) {
            const d = this._runtime.GetAssetManager(),
                c = this._nextReponseBinaryData;
            this._nextReponseBinaryData = null;
            try {
                if (c) {
                    const f =
                        await d.CordovaFetchLocalFileAsArrayBuffer(b);
                    c.SetArrayBufferTransfer(f);
                    this._lastData = ""
                } else this._lastData = (await d.CordovaFetchLocalFileAsText(b)).replace(/\r\n/g, "\n");
                this._TriggerComplete(a)
            } catch (f) {
                this._TriggerError(a, b, f)
            }
        }
        _DoRequest(a, b, d, c) {
            return new Promise(f => {
                const k = l => {
                        this._OnError(a, b, l);
                        f()
                    },
                    h = this._nextReponseBinaryData;
                this._nextReponseBinaryData = null;
                try {
                    const l = new XMLHttpRequest;
                    l.onreadystatechange = () => {
                        if (4 === l.readyState) {
                            this._lastData = h ? "" : (l.responseText || "").replace(/\r\n/g,
                                "\n");
                            if (400 <= l.status) this._TriggerError(a, b, l.status + l.statusText);
                            else {
                                const n = this._lastData.length || h && l.response instanceof ArrayBuffer;
                                this._isNWjs && !n || !this._isNWjs && 0 === l.status && !n || (h && h.SetArrayBufferTransfer(l.response), this._TriggerComplete(a))
                            }
                            f()
                        }
                    };
                    l.onerror = k;
                    l.ontimeout = k;
                    l.onabort = k;
                    l.onprogress = n => this._OnProgress(a, n);
                    l.open(d, b);
                    0 <= this._timeout && "undefined" !== typeof l.timeout && (l.timeout = this._timeout);
                    l.responseType = h ? "arraybuffer" : "text";
                    c && !this._nextRequestHeaders.has("Content-Type") &&
                        ("string" !== typeof c ? l.setRequestHeader("Content-Type", "application/octet-stream") : l.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"));
                    for (const [n, u] of this._nextRequestHeaders) try {
                        l.setRequestHeader(n, u)
                    } catch (w) {
                        console.error(`[Construct 3] AJAX: Failed to set header '${n}: ${u}': `, w)
                    }
                    this._nextRequestHeaders.clear();
                    if (this._nextRequestOverrideMimeType) {
                        try {
                            l.overrideMimeType(this._nextRequestOverrideMimeType)
                        } catch (n) {
                            console.error("[Construct 3] AJAX: failed to override MIME type: ",
                                n)
                        }
                        this._nextRequestOverrideMimeType = ""
                    }
                    c ? l.send(c) : l.send()
                } catch (l) {
                    k(l)
                }
            })
        }
        GetDebuggerProperties() {
            return [{
                title: "plugins.ajax.debugger.title",
                properties: [{
                    name: "plugins.ajax.debugger.last-data",
                    value: this._lastData
                }]
            }]
        }
        SaveToJson() {
            return {
                lastData: this._lastData
            }
        }
        LoadFromJson(a) {
            this._lastData = a.lastData;
            this._curTag = "";
            this._progress = 0
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.AJAX.Cnds = {
        OnComplete(a) {
            return e.equalsNoCase(this._curTag, a)
        },
        OnAnyComplete() {
            return !0
        },
        OnError(a) {
            return e.equalsNoCase(this._curTag, a)
        },
        OnAnyError() {
            return !0
        },
        OnProgress(a) {
            return e.equalsNoCase(this._curTag, a)
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Plugins.AJAX.Acts = {
        async Request(a, b) {
            this._runtime.IsCordova() && e.IsRelativeURL(b) && this._runtime.GetAssetManager().IsFileProtocol() ? await this._DoCordovaRequest(a, b) : this._runtime.IsPreview() && e.IsRelativeURL(b) ? (b = this._runtime.GetAssetManager().GetLocalUrlAsBlobUrl(b.toLowerCase()), await this._DoRequest(a, b, "GET", null)) : await this._DoRequest(a, b, "GET", null)
        },
        async RequestFile(a, b) {
            this._runtime.IsCordova() && this._runtime.GetAssetManager().IsFileProtocol() ? await this._DoCordovaRequest(a,
                b) : await this._DoRequest(a, this._runtime.GetAssetManager().GetLocalUrlAsBlobUrl(b), "GET", null)
        },
        async Post(a, b, d, c) {
            await this._DoRequest(a, b, c, d)
        },
        async PostBinary(a, b, d, c) {
            d && (d = d.GetFirstPicked(this._inst)) && (d = d.GetSdkInstance().GetArrayBufferReadOnly(), await this._DoRequest(a, b, c, d))
        },
        SetTimeout(a) {
            this._timeout = 1E3 * a
        },
        SetHeader(a, b) {
            this._nextRequestHeaders.set(a, b)
        },
        SetResponseBinary(a) {
            a && (a = a.GetFirstPicked(this._inst)) && (this._nextReponseBinaryData = a.GetSdkInstance())
        },
        OverrideMIMEType(a) {
            this._nextRequestOverrideMimeType =
                a
        }
    }
}
"use strict";
self.C3.Plugins.AJAX.Exps = {
    LastData() {
        return this._lastData
    },
    Progress() {
        return this._progress
    },
    Tag() {
        return this._curTag
    }
}; {
    "use strict";
    const e = self.C3;
    e.Behaviors.jumpthru = class extends e.SDKBehaviorBase {
        constructor(a) {
            super(a)
        }
        Release() {
            super.Release()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Behaviors.jumpthru.Type = class extends e.SDKBehaviorTypeBase {
        constructor(a) {
            super(a)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
    }
} {
    "use strict";
    const e = self.C3;
    e.Behaviors.jumpthru.Instance = class extends e.SDKBehaviorInstanceBase {
        constructor(a, b) {
            super(a);
            this.SetEnabled(!0);
            b && this.SetEnabled(b[0])
        }
        Release() {
            super.Release()
        }
        SetEnabled(a) {
            this._inst._SetJumpthruEnabled(!!a)
        }
        IsEnabled() {
            return this._inst._IsJumpthruEnabled()
        }
        SaveToJson() {
            return {
                e: this.IsEnabled()
            }
        }
        LoadFromJson(a) {
            this.SetEnabled(a.e)
        }
        GetPropertyValueByIndex(a) {
            switch (a) {
                case 0:
                    return this.IsEnabled()
            }
        }
        SetPropertyValueByIndex(a, b) {
            switch (a) {
                case 0:
                    this.SetEnabled(b)
            }
        }
        GetDebuggerProperties() {
            return [{
                title: "$" +
                    this.GetBehaviorType().GetName(),
                properties: [{
                    name: "behaviors.jumpthru.properties.enabled.name",
                    value: this.IsEnabled(),
                    onedit: a => this.SetEnabled(a)
                }]
            }]
        }
    }
}
"use strict";
self.C3.Behaviors.jumpthru.Cnds = {
    IsEnabled() {
        return this.IsEnabled()
    }
};
"use strict";
self.C3.Behaviors.jumpthru.Acts = {
    SetEnabled(e) {
        this.SetEnabled(e)
    }
};
"use strict";
self.C3.Behaviors.jumpthru.Exps = {}; {
    "use strict";
    const e = self.C3;
    e.Behaviors.Platform = class extends e.SDKBehaviorBase {
        constructor(a) {
            super(a)
        }
        Release() {
            super.Release()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Behaviors.Platform.Type = class extends e.SDKBehaviorTypeBase {
        constructor(a) {
            super(a)
        }
        Release() {
            super.Release()
        }
        OnCreate() {}
    }
} {
    "use strict";
    const e = self.C3,
        a = self.C3X,
        b = self.IBehaviorInstance;

    function d(k, h, l, n, u) {
        return e.clamp(k * u + .5 * n * u * u, h * u, l * u)
    }
    e.Behaviors.Platform.Instance = class extends e.SDKBehaviorInstanceBase {
        constructor(k, h) {
            super(k);
            this._keyboardDisposables = null;
            this._simJump = this._simRight = this._simLeft = this._ignoreInput = this._canDoubleJump = this._doubleJumped = this._jumped = this._jumpKey = this._rightKey = this._leftKey = !1;
            this._lastFloorObject = null;
            this._loadFloorUid = -1;
            this._lastFloorY = this._lastFloorX = 0;
            this._wasOnFloor =
                this._floorIsJumpthru = !1;
            this._wasOverJumpthru = !!this._runtime.GetCollisionEngine().TestOverlapJumpthru(this._inst);
            this._loadJumpthruUid = -1;
            this._animMode = "stopped";
            this._fallThrough = 0;
            this._isFirstTick = !0;
            this._rightY = this._rightX = this._downY = this._downX = this._dy = this._dx = 0;
            this._g1 = this._g = 1500;
            this._ga = e.toRadians(90);
            this._maxSpeed = 330;
            this._dec = this._acc = 1500;
            this._jumpStrength = 650;
            this._maxFall = 1E3;
            this._enableDoubleJump = !1;
            this._sustainTime = this._jumpSustain = 0;
            this._defaultControls = !0;
            this._ceilingCollisionMode =
                0;
            this._isEnabled = !0;
            h && (this._maxSpeed = h[0], this._acc = h[1], this._dec = h[2], this._jumpStrength = h[3], this._g = h[4], this._maxFall = h[5], this._enableDoubleJump = !!h[6], this._jumpSustain = h[7] / 1E3, this._defaultControls = !!h[8], this._isEnabled = !!h[9]);
            k = this._runtime.Dispatcher();
            this._disposables = new e.CompositeDisposable(e.Disposable.From(k, "instancedestroy", l => this._OnInstanceDestroyed(l.instance)), e.Disposable.From(k, "afterload", l => this._OnAfterLoad()));
            this._defaultControls && this._BindEvents();
            this._isEnabled &&
                this._StartPostTicking();
            this._UpdateGravity();
            this._inst.GetUnsavedDataMap().set("isPlatformBehavior", !0)
        }
        Release() {
            this._keyboardDisposables && (this._keyboardDisposables.Release(), this._keyboardDisposables = null);
            this._wasOverJumpthru = this._lastFloorObject = null;
            super.Release()
        }
        _BindEvents() {
            if (!this._keyboardDisposables) {
                var k = this._runtime.Dispatcher();
                this._keyboardDisposables = new e.CompositeDisposable(e.Disposable.From(k, "keydown", h => this._OnKeyDown(h.data)), e.Disposable.From(k, "keyup", h => this._OnKeyUp(h.data)),
                    e.Disposable.From(k, "window-blur", () => this._OnWindowOrKeyboardBlur()), e.Disposable.From(k, "keyboard-blur", () => this._OnWindowOrKeyboardBlur()))
            }
        }
        _UnBindEvents() {
            this._keyboardDisposables && (this._keyboardDisposables.Release(), this._keyboardDisposables = null)
        }
        _OnInstanceDestroyed(k) {
            this._lastFloorObject === k && (this._lastFloorObject = null);
            this._wasOverJumpthru === k && (this._wasOverJumpthru = null)
        }
        _OnKeyDown(k) {
            switch (k.key) {
                case "ArrowLeft":
                    this._leftKey = !0;
                    break;
                case "ArrowRight":
                    this._rightKey = !0;
                    break;
                case "ArrowUp":
                    this._jumpKey = !0
            }
        }
        _OnKeyUp(k) {
            switch (k.key) {
                case "ArrowLeft":
                    this._leftKey = !1;
                    break;
                case "ArrowRight":
                    this._rightKey = !1;
                    break;
                case "ArrowUp":
                    this._jumped = this._jumpKey = !1
            }
        }
        _OnWindowOrKeyboardBlur() {
            this._jumped = this._jumpKey = this._rightKey = this._leftKey = !1
        }
        SaveToJson() {
            return {
                ii: this._ignoreInput,
                lfx: this._lastFloorX,
                lfy: this._lastFloorY,
                lfo: this._lastFloorObject ? this._lastFloorObject.GetUID() : -1,
                am: this._animMode,
                en: this._isEnabled,
                fall: this._fallThrough,
                ft: this._isFirstTick,
                dx: this._dx,
                dy: this._dy,
                ms: this._maxSpeed,
                acc: this._acc,
                dec: this._dec,
                js: this._jumpStrength,
                g: this._g,
                g1: this._g1,
                mf: this._maxFall,
                wof: this._wasOnFloor,
                woj: this._wasOverJumpthru ? this._wasOverJumpthru.GetUID() : -1,
                ga: this._ga,
                edj: this._enableDoubleJump,
                cdj: this._canDoubleJump,
                dj: this._doubleJumped,
                sus: this._jumpSustain,
                dc: this._defaultControls,
                cc: this._ceilingCollisionMode
            }
        }
        LoadFromJson(k) {
            this._ignoreInput = k.ii;
            this._lastFloorX = k.lfx;
            this._lastFloorY = k.lfy;
            this._loadFloorUid = k.lfo;
            this._animMode = k.am;
            const h =
                k.en;
            this._fallThrough = k.fall;
            this._isFirstTick = k.ft;
            this._dx = k.dx;
            this._dy = k.dy;
            this._maxSpeed = k.ms;
            this._acc = k.acc;
            this._dec = k.dec;
            this._jumpStrength = k.js;
            this._g = k.g;
            this._g1 = k.g1;
            this._maxFall = k.mf;
            this._wasOnFloor = k.wof;
            this._loadJumpthruUid = k.woj;
            this._ga = k.ga;
            this._enableDoubleJump = k.edj;
            this._canDoubleJump = k.cdj;
            this._doubleJumped = k.dj;
            this._jumpSustain = k.sus;
            this._defaultControls = k.dc;
            this._ceilingCollisionMode = k.cc || 0;
            this._simJump = this._simRight = this._simLeft = this._jumped = this._jumpKey =
                this._rightKey = this._leftKey = !1;
            this._sustainTime = 0;
            this._defaultControls ? this._BindEvents() : this._UnBindEvents();
            this._SetEnabled(h);
            this._UpdateGravity()
        }
        _OnAfterLoad() {
            this._lastFloorObject = -1 === this._loadFloorUid ? null : this._runtime.GetInstanceByUID(this._loadFloorUid);
            this._wasOverJumpthru = -1 === this._loadJumpthruUid ? null : this._runtime.GetInstanceByUID(this._loadJumpthruUid)
        }
        _UpdateGravity() {
            this._downX = Math.cos(this._ga);
            this._downY = Math.sin(this._ga);
            this._rightX = Math.cos(this._ga - Math.PI / 2);
            this._rightY = Math.sin(this._ga - Math.PI / 2);
            this._downX = e.round6dp(this._downX);
            this._downY = e.round6dp(this._downY);
            this._rightX = e.round6dp(this._rightX);
            this._rightY = e.round6dp(this._rightY);
            this._g1 = this._g;
            0 > this._g && (this._downX *= -1, this._downY *= -1, this._g = Math.abs(this._g))
        }
        _GetGDir() {
            return 0 > this._g ? -1 : 1
        }
        _IsOnFloor() {
            var k = this._inst.GetWorldInfo();
            const h = this._runtime.GetCollisionEngine(),
                l = this._inst;
            var n = this._lastFloorObject;
            const u = k.GetX(),
                w = k.GetY();
            k.OffsetXY(this._downX, this._downY);
            k.SetBboxChanged();
            if (n && h.TestOverlap(l, n) && (!n.GetObjectClass().HasSolidBehavior() || h.IsSolidCollisionAllowed(n, l))) return k.SetXY(u, w), k.SetBboxChanged(), n; {
                let q = h.TestOverlapSolid(l);
                n = null;
                q || 0 !== this._fallThrough || (n = h.TestOverlapJumpthru(l, !0));
                k.SetXY(u, w);
                k.SetBboxChanged();
                if (q) {
                    if (h.TestOverlap(l, q)) return null;
                    this._floorIsJumpthru = !1;
                    return q
                }
                if (n && n.length) {
                    k = 0;
                    for (let t = 0, p = n.length; t < p; ++t) n[k] = n[t], h.TestOverlap(l, n[t]) || ++k;
                    if (1 <= k) return this._floorIsJumpthru = !0, n[0]
                }
                return null
            }
        }
        PostTick() {
            if (this._isEnabled) {
                var k =
                    this._runtime.GetDt(this._inst);
                this._jumpKey || this._simJump || (this._jumped = !1);
                var h = this._leftKey || this._simLeft,
                    l = this._rightKey || this._simRight,
                    n = this._jumpKey || this._simJump,
                    u = n && !this._jumped;
                this._simJump = this._simRight = this._simLeft = !1;
                this._ignoreInput && (u = n = l = h = !1);
                n || (this._sustainTime = 0);
                this._HandleFirstTick();
                var [w, , q] = this._TrackMovingPlatform(), t = this._IsOnFloor(), p = t && !this._wasOnFloor, r;
                [r, t] = this._MaybePushOutSolid(t);
                if (!r) {
                    this._TrackFloor(t, q, w, n);
                    u = this._HandleJump(t, u, n);
                    t || this._ApplyJumpGravity(u, n, k);
                    this._wasOnFloor = !!t;
                    h = this._ApplyHorizontalAcceleration(h, l, k);
                    l = !1;
                    n = 0;
                    0 !== this._dx && (l = this._HandleHorizontalMovement(k, h, t, u));
                    if (0 !== this._dy) {
                        const [x, y] = this._HandleVerticalMovement(k, t);
                        l = l || x;
                        n = y
                    }!l && p && 0 > this._dy && 0 < n && (this._dy = 0, l = !0);
                    this._HandleAnimationTriggers(t, l, u);
                    0 < this._fallThrough && this._fallThrough--;
                    this._wasOverJumpthru = this._runtime.GetCollisionEngine().TestOverlapJumpthru(this._inst)
                }
            }
        }
        _HandleFirstTick() {
            if (this._isFirstTick) {
                var k = this._inst,
                    h = this._runtime.GetCollisionEngine();
                (h.TestOverlapSolid(k) || h.TestOverlapJumpthru(k)) && h.PushOutSolid(k, -this._downX, -this._downY, 4, !0);
                this._isFirstTick = !1
            }
        }
        _TrackMovingPlatform() {
            var k = this._lastFloorObject,
                h = k ? k.GetWorldInfo() : null;
            let l = 0,
                n = 0;
            var u = !1;
            if (k && 0 === this._dy && (h.GetY() !== this._lastFloorY || h.GetX() !== this._lastFloorX)) {
                k = this._inst;
                u = k.GetWorldInfo();
                const w = this._runtime.GetCollisionEngine(),
                    q = h.GetX();
                h = h.GetY();
                l = q - this._lastFloorX;
                n = h - this._lastFloorY;
                u.OffsetXY(l, n);
                u.SetBboxChanged();
                this._lastFloorX = q;
                this._lastFloorY = h;
                u = !0;
                w.TestOverlapSolid(k) && w.PushOutSolid(k, -l, -n, 2.5 * Math.hypot(l, n))
            }
            return [l, n, u]
        }
        _MaybePushOutSolid(k) {
            let h = !1;
            var l = this._inst,
                n = l.GetWorldInfo();
            const u = this._runtime.GetCollisionEngine(),
                w = u.TestOverlapSolid(l);
            if (!w) return [!1, k];
            const q = Math.abs(n.GetWidth());
            n = Math.abs(n.GetHeight());
            l.GetSavedDataMap().get("inputPredicted") ? u.PushOutSolid(l, -this._downX, -this._downY, 10, !1) : u.PushOutSolidAxis(l, -this._downX, -this._downY, n / 8) ? (u.RegisterCollision(l,
                w), this._lastFloorObject = k = w, l = w.GetWorldInfo(), this._lastFloorX = l.GetX(), this._lastFloorY = l.GetY(), this._floorIsJumpthru = !1) : u.PushOutSolidAxis(l, this._rightX, this._rightY, q / 2) || u.PushOutSolidAxis(l, this._downX, this._downY, n / 2) || u.PushOutSolidNearest(l, Math.max(q, n) / 2) ? u.RegisterCollision(l, w) : h = !0;
            return [h, k]
        }
        _TrackFloor(k, h, l, n) {
            const u = this._inst,
                w = this._runtime.GetCollisionEngine();
            if (k) {
                n = this._downX;
                const q = this._downY,
                    t = this._rightX,
                    p = this._rightY;
                this._canDoubleJump = this._doubleJumped = !1;
                0 < this._dy && (this._wasOnFloor || (w.PushInFractional(u, -n, -q, k, 16), this._wasOnFloor = !0), this._dy = 0);
                this._lastFloorObject !== k ? (this._lastFloorObject = k, l = k.GetWorldInfo(), this._lastFloorX = l.GetX(), this._lastFloorY = l.GetY(), w.RegisterCollision(u, k)) : h && (k = w.TestOverlapSolid(u)) && (w.RegisterCollision(u, k), 0 !== l && (0 < l ? w.PushOutSolid(u, -t, -p) : w.PushOutSolid(u, t, p)), w.PushOutSolid(u, -n, -q))
            } else n || (this._canDoubleJump = !0)
        }
        _HandleJump(k, h, l) {
            if (k && h || !k && this._enableDoubleJump && l && this._canDoubleJump && !this._doubleJumped) {
                h =
                    this._inst;
                l = h.GetWorldInfo();
                const n = this._runtime.GetCollisionEngine(),
                    u = l.GetX(),
                    w = l.GetY();
                l.OffsetXY(-this._downX, -this._downY);
                l.SetBboxChanged();
                n.TestOverlapSolid(h) ? h = !1 : (this._sustainTime = this._jumpSustain, this.Trigger(e.Behaviors.Platform.Cnds.OnJump), this._animMode = "jumping", this._dy = -this._jumpStrength, h = !0, k ? this._jumped = !0 : this._doubleJumped = !0);
                l.SetXY(u, w);
                l.SetBboxChanged()
            }
            return h
        }
        _ApplyJumpGravity(k, h, l) {
            h && 0 < this._sustainTime ? (this._dy = -this._jumpStrength, this._sustainTime -=
                l) : (this._lastFloorObject = null, this._dy += this._g * l, this._dy > this._maxFall && (this._dy = this._maxFall));
            k && (this._jumped = !0)
        }
        _ApplyHorizontalAcceleration(k, h, l) {
            const n = this._acc,
                u = this._dec;
            k === h && (0 > this._dx ? (this._dx += u * l, 0 < this._dx && (this._dx = 0)) : 0 < this._dx && (this._dx -= u * l, 0 > this._dx && (this._dx = 0)));
            let w = 0;
            k && !h && (w = 0 < this._dx ? -(n + u) : -n);
            h && !k && (w = 0 > this._dx ? n + u : n);
            this._dx += w * l;
            this._dx = e.clamp(this._dx, -this._maxSpeed, this._maxSpeed);
            return w
        }
        _HandleHorizontalMovement(k, h, l, n) {
            const u = this._inst;
            var w = u.GetWorldInfo();
            const q = this._runtime.GetCollisionEngine(),
                t = this._downX,
                p = this._downY,
                r = this._rightX,
                x = this._rightY;
            var y = this._maxSpeed;
            let E = !1;
            var G = w.GetX();
            let A = w.GetY();
            var F = d(this._dx, -y, y, h, k) * r;
            const J = d(this._dx, -y, y, h, k) * x;
            w.OffsetXY(r * (1 < this._dx ? 1 : -1) - t, x * (1 < this._dx ? 1 : -1) - p);
            w.SetBboxChanged();
            h = !1;
            y = q.TestOverlapSolid(u);
            w.SetXY(G + F, A + J);
            w.SetBboxChanged();
            let B = q.TestOverlapSolid(u);
            !B && l && (B = q.TestOverlapJumpthru(u)) && (w.SetXY(G, A), w.SetBboxChanged(), q.TestOverlap(u, B) ?
                (B = null, h = !1) : h = !0, w.SetXY(G + F, A + J), w.SetBboxChanged());
            B ? (F = Math.abs(this._dx * k) + 2, y || !q.PushOutSolid(u, -t, -p, F, h, B)) ? (q.RegisterCollision(u, B), F = Math.max(Math.abs(this._dx * k * 2.5), 30), q.PushOutSolid(u, r * (0 > this._dx ? 1 : -1), x * (0 > this._dx ? 1 : -1), F, !1) ? !l || h || this._floorIsJumpthru || (G = w.GetX(), A = w.GetY(), w.OffsetXY(t, p), q.TestOverlapSolid(u) ? q.PushOutSolid(u, -t, -p, 3, !1) || (w.SetXY(G, A), w.SetBboxChanged()) : (w.SetXY(G, A), w.SetBboxChanged())) : (w.SetXY(G, A), w.SetBboxChanged()), h || (this._dx = 0)) : !y && !n && Math.abs(this._dy) <
                Math.abs(this._jumpStrength / 4) && (this._dy = 0, l || (E = !0)) : (G = this._IsOnFloor(), l && !G ? (k = Math.ceil(Math.abs(this._dx * k)) + 2, G = w.GetX(), A = w.GetY(), w.OffsetXY(t * k, p * k), w.SetBboxChanged(), q.TestOverlapSolid(u) || q.TestOverlapJumpthru(u) ? q.PushOutSolid(u, -t, -p, k + 2, !0) : (w.SetXY(G, A), w.SetBboxChanged())) : G && (!l && this._floorIsJumpthru && (this._lastFloorObject = G, w = G.GetWorldInfo(), this._lastFloorX = w.GetX(), this._lastFloorY = w.GetY(), this._dy = 0, E = !0), 0 === this._dy && q.PushInFractional(u, -t, -p, G, 16)));
            return E
        }
        _HandleVerticalMovement(k,
            h) {
            const l = this._inst,
                n = l.GetWorldInfo(),
                u = this._runtime.GetCollisionEngine(),
                w = this._downX,
                q = this._downY;
            let t = !1,
                p = n.GetX(),
                r = n.GetY();
            const x = d(this._dy, -Infinity, this._maxFall, this._g, k);
            n.OffsetXY(x * w, x * q);
            var y = n.GetX();
            const E = n.GetY();
            n.SetBboxChanged();
            let G = u.TestOverlapSolid(l);
            var A = !1;
            if (!G && 0 < this._dy && !h) {
                if ((A = 0 < this._fallThrough ? null : u.TestOverlapJumpthru(l, !0)) && A.length) {
                    if (this._wasOverJumpthru) {
                        n.SetXY(p, r);
                        n.SetBboxChanged();
                        h = 0;
                        for (let F = 0, J = A.length; F < J; ++F) A[h] = A[F], u.TestOverlap(l,
                            A[F]) || ++h;
                        e.truncateArray(A, h);
                        n.SetXY(y, E);
                        n.SetBboxChanged()
                    }
                    1 <= A.length && (G = A[0])
                }
                A = !!G
            }
            if (G)
                if (u.RegisterCollision(l, G), this._sustainTime = 0, y = 1.1, A && !this._wasOverJumpthru && (y = 2), u.PushOutSolid(l, w * (0 > this._dy ? 1 : -1), q * (0 > this._dy ? 1 : -1), Math.max(Math.abs(this._dy * k * y), 2), A, G)) {
                    this._lastFloorObject = G;
                    k = G.GetWorldInfo();
                    this._lastFloorX = k.GetX();
                    this._lastFloorY = k.GetY();
                    (this._floorIsJumpthru = A) && (t = !0);
                    if (0 < this._dy || 0 === this._ceilingCollisionMode) this._dy = 0;
                    0 > this._dy && 1 === this._ceilingCollisionMode &&
                        u.PushInFractional(l, w, q, G, 32)
                } else n.SetXY(p, r), n.SetBboxChanged(), this._wasOnFloor = !0, A || (this._dy = 0);
            return [t, x]
        }
        _HandleAnimationTriggers(k, h, l) {
            "falling" !== this._animMode && 0 < this._dy && !k && (this.Trigger(e.Behaviors.Platform.Cnds.OnFall), this._animMode = "falling");
            (k || h) && 0 <= this._dy && ("falling" === this._animMode || h || l && 0 === this._dy ? (this.Trigger(e.Behaviors.Platform.Cnds.OnLand), this._animMode = 0 === this._dx && 0 === this._dy ? "stopped" : "moving") : ("stopped" !== this._animMode && 0 === this._dx && 0 === this._dy &&
                (this.Trigger(e.Behaviors.Platform.Cnds.OnStop), this._animMode = "stopped"), "moving" === this._animMode || 0 === this._dx && 0 === this._dy || l || (this.Trigger(e.Behaviors.Platform.Cnds.OnMove), this._animMode = "moving")))
        }
        _IsMoving() {
            return 0 !== this._GetVectorX() || 0 !== this._GetVectorY()
        }
        _CheckIfStandingOnFloor() {
            if (0 !== this._dy) return !1;
            const k = this._inst;
            var h = this.GetWorldInfo();
            const l = this._runtime.GetCollisionEngine(),
                n = h.GetX(),
                u = h.GetY();
            h.OffsetXY(this._downX, this._downY);
            h.SetBboxChanged();
            const w = l.TestOverlapSolid(k);
            let q = null;
            w || 0 !== this._fallThrough || (q = l.TestOverlapJumpthru(k, !0));
            h.SetXY(n, u);
            h.SetBboxChanged();
            if (w) return !l.TestOverlap(k, w);
            if (q && q.length) {
                h = 0;
                for (let t = 0, p = q.length; t < p; ++t) q[h] = q[t], l.TestOverlap(k, q[t]) || h++;
                if (1 <= h) return !0
            }
            return !1
        }
        _IsByWall(k) {
            const h = this._inst,
                l = this.GetWorldInfo(),
                n = this._runtime.GetCollisionEngine(),
                u = l.GetX(),
                w = l.GetY();
            0 === k ? l.OffsetXY(2 * -this._rightX, 2 * -this._rightY) : l.OffsetXY(2 * this._rightX, 2 * this._rightY);
            l.SetBboxChanged();
            if (!n.TestOverlapSolid(h)) return l.SetXY(u,
                w), l.SetBboxChanged(), !1;
            l.OffsetXY(3 * -this._downX, 3 * -this._downY);
            l.SetBboxChanged();
            k = !!n.TestOverlapSolid(h);
            l.SetXY(u, w);
            l.SetBboxChanged();
            return k
        }
        _FallThroughJumpThru() {
            const k = this.GetWorldInfo(),
                h = k.GetX(),
                l = k.GetY();
            k.OffsetXY(this._downX, this._downY);
            k.SetBboxChanged();
            const n = this._runtime.GetCollisionEngine().TestOverlapJumpthru(this._inst, !1);
            k.SetXY(h, l);
            k.SetBboxChanged();
            n && (this._fallThrough = 3, this._lastFloorObject = null)
        }
        _ResetDoubleJump(k) {
            this._doubleJumped = !k
        }
        _GetSpeed() {
            return Math.hypot(this._dx,
                this._dy)
        }
        _GetMovingAngle() {
            return Math.atan2(this._dy, this._dx)
        }
        _IsJumping() {
            return 0 > this._dy
        }
        _IsFalling() {
            return 0 < this._dy
        }
        _SetMaxSpeed(k) {
            this._maxSpeed = Math.max(k, 0)
        }
        _GetMaxSpeed() {
            return this._maxSpeed
        }
        _SetAcceleration(k) {
            this._acc = Math.max(k, 0)
        }
        _GetAcceleration() {
            return this._acc
        }
        _SetDeceleration(k) {
            this._dec = Math.max(k, 0)
        }
        _GetDeceleration() {
            return this._dec
        }
        _SetJumpStrength(k) {
            this._jumpStrength = Math.max(k, 0)
        }
        _GetJumpStrength() {
            return this._jumpStrength
        }
        _SetMaxFallSpeed(k) {
            this._maxFall =
                Math.max(k, 0)
        }
        _GetMaxFallSpeed() {
            return this._maxFall
        }
        _SetGravity(k) {
            if (this._g1 !== k) {
                this._g = k;
                this._UpdateGravity();
                k = this._runtime.GetCollisionEngine();
                var h = this.GetWorldInfo();
                k.TestOverlapSolid(this._inst) && (k.PushOutSolid(this._inst, this._downX, this._downY, 10), h.OffsetXY(2 * this._downX, 2 * this._downY), h.SetBboxChanged());
                this._lastFloorObject = null
            }
        }
        _GetGravity() {
            return this._g
        }
        _SetGravityAngle(k) {
            k = e.clampAngle(k);
            this._ga !== k && (this._ga = k, this._UpdateGravity(), this._lastFloorObject = null)
        }
        _GetGravityAngle() {
            return this._ga
        }
        _SetDoubleJumpEnabled(k) {
            this._enableDoubleJump = !!k
        }
        _IsDoubleJumpEnabled() {
            return this._enableDoubleJump
        }
        _SetJumpSustain(k) {
            this._jumpSustain = k
        }
        _GetJumpSustain() {
            return this._jumpSustain
        }
        _SetCeilingCollisionMode(k) {
            this._ceilingCollisionMode = k
        }
        _GetCeilingCollisionMode() {
            return this._ceilingCollisionMode
        }
        _SetVectorX(k) {
            this._dx = k
        }
        _GetVectorX() {
            return this._dx
        }
        _SetVectorY(k) {
            this._dy = k
        }
        _GetVectorY() {
            return this._dy
        }
        _SimulateControl(k) {
            if (this._isEnabled) switch (k) {
                case 0:
                    this._simLeft = !0;
                    break;
                case 1:
                    this._simRight = !0;
                    break;
                case 2:
                    this._simJump = !0
            }
        }
        _SetDefaultControls(k) {
            k = !!k;
            this._defaultControls !== k && ((this._defaultControls = k) ? this._BindEvents() : (this._UnBindEvents(), this._OnWindowOrKeyboardBlur()))
        }
        _IsDefaultControls() {
            return this._defaultControls
        }
        _SetIgnoreInput(k) {
            this._ignoreInput = !!k
        }
        _IsIgnoreInput() {
            return this._ignoreInput
        }
        _SetEnabled(k) {
            k = !!k;
            this._isEnabled !== k && ((this._isEnabled = k) ? this._StartPostTicking() : (this._StopPostTicking(), this._lastFloorObject = null, this._simJump = this._simRight = this._simLeft = !1))
        }
        _IsEnabled() {
            return this._isEnabled
        }
        GetPropertyValueByIndex(k) {
            switch (k) {
                case 0:
                    return this._GetMaxSpeed();
                case 1:
                    return this._GetAcceleration();
                case 2:
                    return this._GetDeceleration();
                case 3:
                    return this._GetJumpStrength();
                case 4:
                    return this._GetGravity();
                case 5:
                    return this._GetMaxFallSpeed();
                case 6:
                    return this._IsDoubleJumpEnabled();
                case 7:
                    return 1E3 * this._GetJumpSustain();
                case 8:
                    return this._IsDefaultControls();
                case 9:
                    return this._IsEnabled()
            }
        }
        SetPropertyValueByIndex(k, h) {
            switch (k) {
                case 0:
                    this._SetMaxSpeed(h);
                    break;
                case 1:
                    this._SetAcceleration(h);
                    break;
                case 2:
                    this._SetDeceleration(h);
                    break;
                case 3:
                    this._SetJumpStrength(h);
                    break;
                case 4:
                    this._SetGravity(h);
                    break;
                case 5:
                    this._SetMaxFallSpeed(h);
                    break;
                case 6:
                    this._SetDoubleJumpEnabled(!!h);
                    break;
                case 7:
                    this._SetJumpSustain(h / 1E3);
                    break;
                case 8:
                    this._SetDefaultControls(!!h);
                    break;
                case 9:
                    this._SetEnabled(!!h)
            }
        }
        GetDebuggerProperties() {
            return [{
                title: "$" + this.GetBehaviorType().GetName(),
                properties: [{
                    name: "behaviors.platform.debugger.vector-x",
                    value: this._GetVectorX(),
                    onedit: k => this._SetVectorX(k)
                }, {
                    name: "behaviors.platform.debugger.vector-y",
                    value: this._GetVectorY(),
                    onedit: k =>
                        this._SetVectorY(k)
                }, {
                    name: "behaviors.platform.properties.max-speed.name",
                    value: this._GetMaxSpeed(),
                    onedit: k => this._SetMaxSpeed(k)
                }, {
                    name: "behaviors.platform.properties.acceleration.name",
                    value: this._GetAcceleration(),
                    onedit: k => this._SetAcceleration(k)
                }, {
                    name: "behaviors.platform.properties.deceleration.name",
                    value: this._GetDeceleration(),
                    onedit: k => this._SetDeceleration(k)
                }, {
                    name: "behaviors.platform.properties.jump-strength.name",
                    value: this._GetJumpStrength(),
                    onedit: k => this._SetJumpStrength(k)
                }, {
                    name: "behaviors.platform.properties.gravity.name",
                    value: this._GetGravity(),
                    onedit: k => this._SetGravity(k)
                }, {
                    name: "behaviors.platform.debugger.gravity-angle",
                    value: e.toDegrees(this._GetGravityAngle()),
                    onedit: k => this._SetGravityAngle(e.toRadians(k))
                }, {
                    name: "behaviors.platform.properties.max-fall-speed.name",
                    value: this._GetMaxFallSpeed(),
                    onedit: k => this._SetMaxFallSpeed(k)
                }, {
                    name: "behaviors.platform.debugger.animation-mode",
                    value: ["behaviors.platform.debugger.anim-" + this._animMode]
                }, {
                    name: "behaviors.platform.properties.enabled.name",
                    value: this._IsEnabled(),
                    onedit: k => this._SetEnabled(k)
                }]
            }]
        }
        GetScriptInterfaceClass() {
            return self.IPlatformBehaviorInstance
        }
    };
    const c = new WeakMap,
        f = new Map([
            ["left", 0],
            ["right", 1],
            ["jump", 2]
        ]);
    self.IPlatformBehaviorInstance = class extends b {
        constructor() {
            super();
            c.set(this, b._GetInitInst().GetSdkInstance())
        }
        fallThrough() {
            c.get(this)._FallThroughJumpThru()
        }
        resetDoubleJump(k) {
            c.get(this)._ResetDoubleJump(!!k)
        }
        simulateControl(k) {
            a.RequireString(k);
            k = f.get(k);
            if ("number" !== typeof k) throw Error("invalid control");
            c.get(this)._SimulateControl(k)
        }
        get speed() {
            return c.get(this)._GetSpeed()
        }
        get maxSpeed() {
            return c.get(this)._GetMaxSpeed()
        }
        set maxSpeed(k) {
            a.RequireFiniteNumber(k);
            c.get(this)._SetMaxSpeed(k)
        }
        get acceleration() {
            return c.get(this)._GetAcceleration()
        }
        set acceleration(k) {
            a.RequireFiniteNumber(k);
            c.get(this)._SetAcceleration(k)
        }
        get deceleration() {
            return c.get(this)._GetDeceleration()
        }
        set deceleration(k) {
            a.RequireFiniteNumber(k);
            c.get(this)._SetDeceleration(k)
        }
        get jumpStrength() {
            return c.get(this)._GetJumpStrength()
        }
        set jumpStrength(k) {
            a.RequireFiniteNumber(k);
            c.get(this)._SetJumpStrength(k)
        }
        get maxFallSpeed() {
            return c.get(this)._GetMaxFallSpeed()
        }
        set maxFallSpeed(k) {
            a.RequireFiniteNumber(k);
            c.get(this)._SetMaxFallSpeed(k)
        }
        get gravity() {
            return c.get(this)._GetGravity()
        }
        set gravity(k) {
            a.RequireFiniteNumber(k);
            c.get(this)._SetGravity(k)
        }
        get gravityAngle() {
            return c.get(this)._GetGravityAngle()
        }
        set gravityAngle(k) {
            a.RequireFiniteNumber(k);
            c.get(this)._SetGravityAngle(k)
        }
        get isDoubleJumpEnabled() {
            return c.get(this)._IsDoubleJumpEnabled()
        }
        set isDoubleJumpEnabled(k) {
            c.get(this)._SetDoubleJumpEnabled(!!k)
        }
        get jumpSustain() {
            return c.get(this)._GetJumpSustain()
        }
        set jumpSustain(k) {
            a.RequireFiniteNumber(k);
            c.get(this)._SetJumpSustain(k)
        }
        get ceilingCollisionMode() {
            return 0 === c.get(this)._GetCeilingCollisionMode() ? "stop" : "preserve-momentum"
        }
        set ceilingCollisionMode(k) {
            a.RequireString(k);
            const h = c.get(this);
            if ("stop" === k) h._SetCeilingCollisionMode(0);
            else if ("preserve-momentum" === k) h._SetCeilingCollisionMode(1);
            else throw Error("invalid mode");
        }
        get isOnFloor() {
            return c.get(this)._CheckIfStandingOnFloor()
        }
        isByWall(k) {
            a.RequireString(k);
            const h = c.get(this);
            if ("left" === k) return h._IsByWall(0);
            if ("right" ===
                k) return h._IsByWall(1);
            throw Error("invalid side");
        }
        get isMoving() {
            return c.get(this)._IsMoving()
        }
        get isJumping() {
            return c.get(this)._IsJumping()
        }
        get isFalling() {
            return c.get(this)._IsFalling()
        }
        get vectorX() {
            return c.get(this)._GetVectorX()
        }
        set vectorX(k) {
            a.RequireFiniteNumber(k);
            c.get(this)._SetVectorX(k)
        }
        get vectorY() {
            return c.get(this)._GetVectorY()
        }
        set vectorY(k) {
            a.RequireFiniteNumber(k);
            c.get(this)._SetVectorY(k)
        }
        get isDefaultControls() {
            return c.get(this)._IsDefaultControls()
        }
        set isDefaultControls(k) {
            c.get(this)._SetDefaultControls(!!k)
        }
        get isIgnoringInput() {
            return c.get(this)._IsIgnoreInput()
        }
        set isIgnoringInput(k) {
            c.get(this)._SetIgnoreInput(!!k)
        }
        get isEnabled() {
            return c.get(this)._IsEnabled()
        }
        set isEnabled(k) {
            c.get(this)._SetEnabled(!!k)
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Behaviors.Platform.Cnds = {
        IsMoving() {
            return this._IsMoving()
        },
        CompareSpeed(a, b) {
            return e.compare(this._GetSpeed(), a, b)
        },
        IsOnFloor() {
            return this._CheckIfStandingOnFloor()
        },
        IsByWall(a) {
            return this._IsByWall(a)
        },
        IsJumping() {
            return this._IsJumping()
        },
        IsFalling() {
            return this._IsFalling()
        },
        IsDoubleJumpEnabled() {
            return this._IsDoubleJumpEnabled()
        },
        OnJump() {
            return !0
        },
        OnFall() {
            return !0
        },
        OnStop() {
            return !0
        },
        OnMove() {
            return !0
        },
        OnLand() {
            return !0
        },
        IsEnabled() {
            return this._IsEnabled()
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Behaviors.Platform.Acts = {
        SetMaxSpeed(a) {
            this._SetMaxSpeed(a)
        },
        SetAcceleration(a) {
            this._SetAcceleration(a)
        },
        SetDeceleration(a) {
            this._SetDeceleration(a)
        },
        SetJumpStrength(a) {
            this._SetJumpStrength(a)
        },
        SetMaxFallSpeed(a) {
            this._SetMaxFallSpeed(a)
        },
        SetGravity(a) {
            this._SetGravity(a)
        },
        SimulateControl(a) {
            this._SimulateControl(a)
        },
        SetIgnoreInput(a) {
            this._SetIgnoreInput(!!a)
        },
        SetVectorX(a) {
            this._SetVectorX(a)
        },
        SetVectorY(a) {
            this._SetVectorY(a)
        },
        SetGravityAngle(a) {
            this._SetGravityAngle(e.toRadians(a))
        },
        SetEnabled(a) {
            this._SetEnabled(0 !== a)
        },
        FallThrough() {
            this._FallThroughJumpThru()
        },
        SetDoubleJumpEnabled(a) {
            this._SetDoubleJumpEnabled(0 !== a)
        },
        SetJumpSustain(a) {
            this._SetJumpSustain(a / 1E3)
        },
        SetCeilingCollision(a) {
            this._SetCeilingCollisionMode(a)
        },
        SetDefaultControls(a) {
            this._SetDefaultControls(a)
        },
        ResetDoubleJump(a) {
            this._ResetDoubleJump(a)
        }
    }
} {
    "use strict";
    const e = self.C3;
    e.Behaviors.Platform.Exps = {
        Speed() {
            return this._GetSpeed()
        },
        MaxSpeed() {
            return this._GetMaxSpeed()
        },
        Acceleration() {
            return this._GetAcceleration()
        },
        Deceleration() {
            return this._GetDeceleration()
        },
        JumpStrength() {
            return this._GetJumpStrength()
        },
        Gravity() {
            return this._GetGravity()
        },
        GravityAngle() {
            return e.toDegrees(this._GetGravityAngle())
        },
        MaxFallSpeed() {
            return this._GetMaxFallSpeed()
        },
        MovingAngle() {
            return e.toDegrees(this._GetMovingAngle())
        },
        VectorX() {
            return this._GetVectorX()
        },
        VectorY() {
            return this._GetVectorY()
        },
        JumpSustain() {
            return 1E3 * this._GetJumpSustain()
        }
    }
} {
    const e = self.C3;
    self.C3_GetObjectRefTable = function () {
        return [e.Plugins.Sprite, e.Plugins.TextBox, e.Plugins.Text, e.Behaviors.jumpthru, e.Behaviors.Platform, e.Plugins.Touch, e.Plugins.Keyboard, e.Plugins.Mouse, e.Plugins.PlatformInfo, e.Plugins.AJAX, e.Plugins.Sprite.Cnds.CompareY, e.Plugins.System.Acts.SetVar, e.Plugins.Sprite.Exps.Y, e.Plugins.System.Cnds.EveryTick, e.Plugins.System.Acts.Scroll, e.Plugins.System.Cnds.Compare, e.Plugins.System.Exps.scrolly, e.Plugins.System.Exps.viewportbottom, e.Plugins.System.Acts.CreateObject,
            e.Plugins.System.Exps.random, e.Plugins.System.Exps.layoutwidth, e.Plugins.System.Acts.AddVar, e.Plugins.Sprite.Acts.SetAnimFrame, e.Behaviors.Platform.Cnds.IsOnFloor, e.Behaviors.Platform.Acts.SimulateControl, e.Plugins.Keyboard.Cnds.IsKeyDown, e.Plugins.Touch.Cnds.IsTouchingObject, e.Plugins.Mouse.Cnds.IsButtonDown, e.Plugins.Mouse.Cnds.IsOverObject, e.Plugins.Sprite.Acts.Destroy, e.Plugins.Text.Acts.SetText, e.Plugins.System.Cnds.CompareVar, e.Plugins.Sprite.Cnds.IsOnScreen, e.Plugins.System.Acts.SetLayerVisible,
            e.Plugins.System.Acts.SetLayerScale, e.Plugins.Sprite.Cnds.CompareX, e.Plugins.Sprite.Acts.SetX, e.Plugins.System.Cnds.OnLayoutStart, e.Plugins.System.Cnds.Every, e.Plugins.System.Cnds.TriggerOnce, e.Behaviors.Platform.Cnds.IsFalling, e.Behaviors.Platform.Cnds.IsJumping, e.Plugins.Mouse.Cnds.OnObjectClicked, e.Plugins.Touch.Cnds.OnTapGestureObject, e.Plugins.System.Acts.ResetGlobals, e.Plugins.Text.Exps.Text, e.Plugins.System.Acts.RestartLayout, e.Plugins.System.Acts.GoToLayout, e.Plugins.Text.Acts.Destroy, e.Plugins.AJAX.Cnds.OnComplete,
            e.Plugins.TextBox.Exps.Text, e.Plugins.System.Cnds.OnLoadFinished, e.Plugins.Sprite.Acts.StartAnim, e.Plugins.Sprite.Cnds.OnAnyAnimFinished, e.Plugins.System.Acts.Wait
        ]
    };
    self.C3_JsPropNameTable = [{
            Sprite2: 0
        }, {
            InputName: 0
        }, {
            Name: 0
        }, {
            btnLeaderboardLogin: 0
        }, {
            btnLoginPlay: 0
        }, {
            Jumpthru: 0
        }, {
            Platform: 0
        }, {
            Player: 0
        }, {
            btnLeft: 0
        }, {
            btnRight: 0
        }, {
            Sprite3: 0
        }, {
            ResultName: 0
        }, {
            txtYourHighScore: 0
        }, {
            txtCurrentScore: 0
        }, {
            btnPlay: 0
        }, {
            btnLeaderboard: 0
        }, {
            btnExit: 0
        }, {
            intHighestScore: 0
        }, {
            intCurrentScore: 0
        }, {
            Sprite4: 0
        }, {
            btnExitLeaderboard: 0
        },
        {
            btnPlayLeaderboard: 0
        }, {
            txtLBName: 0
        }, {
            txtLBScore: 0
        }, {
            txtLBJohnDoe: 0
        }, {
            txtLBScore99: 0
        }, {
            Touch: 0
        }, {
            Keyboard: 0
        }, {
            txtYourScore: 0
        }, {
            StartText: 0
        }, {
            Mouse: 0
        }, {
            PlatformInfo: 0
        }, {
            intScore: 0
        }, {
            Background: 0
        }, {
            YourScore: 0
        }, {
            Sprite: 0
        }, {
            txtHow: 0
        }, {
            AJAX: 0
        }, {
            MinScroll: 0
        }, {
            JumpSpeed: 0
        }, {
            NextPlatform: 0
        }, {
            Score: 0
        }, {
            name: 0
        }
    ]
}
self.C3_ExpressionFuncs = [e => {
        const a = e._GetNode(0).GetVar();
        return () => a.GetValue()
    }, e => {
        const a = e._GetNode(0);
        return () => a.ExpObject()
    }, () => 160, e => {
        const a = e._GetNode(0).GetBoundMethod(),
            b = e._GetNode(1).GetBoundMethod();
        return () => a() + b("Game")
    }, () => "Game", e => {
        const a = e._GetNode(0).GetBoundMethod(),
            b = e._GetNode(1).GetBoundMethod();
        return () => a(10, b() - 50)
    }, () => -200, e => {
        const a = e._GetNode(0).GetBoundMethod();
        return () => a(0, 3)
    }, () => 1, e => {
        const a = e._GetNode(0).GetBoundMethod();
        return () => a("Game")
    }, () => 99999,
    () => 2, () => 3, () => -10, e => {
        const a = e._GetNode(0).GetBoundMethod();
        return () => a() + 9
    },
    e => {
        const a = e._GetNode(0).GetBoundMethod();
        return () => a() + 10
    }, () => -9, () => 0, () => 4, () => .5, () => 10, () => "reqLeaderboard"
];
var module$str$c3runtime = {};
var module$str$__c3root__ = {};